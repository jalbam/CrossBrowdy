<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"CrossBrowdy.js.html":{"id":"CrossBrowdy.js.html","title":"Source: CrossBrowdy.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBrowdy.js // CrossBrowdy by Joan Alba Maldonado (workindalian@gmail.com). /** * @file Main CrossBrowdy file. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; * @todo Clear all timeouts before creating them (just in case). */ //CrossBrowdy constants and variables: /** * Keeps the name of the script (the main script will use this name with the &quot;.js&quot; extension). Case sensitive. * @constant * @type {string} * @default */ var CB_NAME = &quot;CrossBrowdy&quot;; /** * CrossBrowdy version. * @constant * @type {string} */ var CB_VERSION = &quot;0.99.95.2&quot;; /** * Keeps the CrossBrowdy &quot;this&quot; context. * @constant * @type {Object} */ var CB_this = this; /** * Two-dimensional object defined by the user with the desired options for CrossBrowdy and its modules. The options supported are the ones used by the {@link CB_Configuration} object. &lt;br&gt; First-level indexes should belong to the module name (or to &quot;CrossBrowdy&quot;, for general options) and second-level indexes should belong to the option name. &lt;br&gt; Example: &lt;br&gt; { CrossBrowdy: { CB_console_ALLOW_ALERTS: false }, CrossBase: { SLCANVAS_LOAD : true, FLASHCANVAS_LOAD : true } } * @constant CB_OPTIONS * @type {Object} * @default undefined */ /** * Static class to manage the configuration. It will be overwritten with the values defined in {@link CB_OPTIONS} (if any). &lt;br&gt; First-level indexes should belong to the module name and second-level indexes should belong to the option name. &lt;br&gt; Follows the same format as {@link CB_OPTIONS}. * @namespace */ var CB_Configuration = {}; /** Property that contains an object with the options for the main script. * @namespace CB_Configuration.CrossBrowdy */ CB_Configuration[CB_NAME] = { /** * Default path of the script (path can be changed when {@link CB_init} is called) * @memberof CB_Configuration.CrossBrowdy * @constant * @type {string} * @default {@link CB_NAME} + &quot;/&quot; */ SCRIPT_PATH_DEFAULT: &quot;../&quot; + CB_NAME + &quot;/&quot;, /** * Defines whether to show the splash screen in the beginning by default or not. * @memberof CB_Configuration.CrossBrowdy * @constant * @type {boolean} * @default */ SHOW_SPLASH_SCREEN_DEFAULT: true, /** * Defines whether to register statistics or not. If it is enabled, the URL defined in {@link CB_Configuration.CrossBrowdy.STATS_URL} will be called (by including it as a JavaScript file) as soon as CrossBrowdy gets called (might not be ready yet). * This parameter do not do anything else, just includes your desired URL (defined in {@link CB_Configuration.CrossBrowdy.STATS_URL}) as a JavaScript file when CrossBrowdy is called. * @memberof CB_Configuration.CrossBrowdy * @constant * @type {boolean} * @default */ STATS: false, /** * URL to register the statistics if {@link CB_Configuration.CrossBrowdy.STATS} is enabled. When {@link CB_Configuration.CrossBrowdy.STATS} is enabled, this URL will be included as a JavaScript file as soon as CrossBrowdy gets called (might not be ready yet). * The URL will be called (included in the document as a JavaScript file) adding three parameters: &quot;cb&quot; parameter with the CrossBrowdy version as the value, &quot;time&quot; with a timestamp which belongs to the current time of the client and &quot;url&quot; parameter with the current URL visited by the user as the value. * @memberof CB_Configuration.CrossBrowdy * @constant * @type {string} * @default */ STATS_URL: &quot;https://crossbrowdy.com/_stats/CB_stats.php&quot;, /** * Defines whether to allow the use of alert()'s as a fallback when using {@link CB_console} and neither the [console]{@link https://developer.mozilla.org/en-US/docs/Web/API/Console} object nor a DOM element with &quot;CB_console&quot; ID are found. * @memberof CB_Configuration.CrossBrowdy * @constant * @type {boolean} * @default */ CB_console_ALLOW_ALERTS: true, /** * Default milliseconds before firing the timeout callback for the {@link CB_includeJSFile} function. * @memberof CB_Configuration.CrossBrowdy * @constant * @type {int} * @default */ CB_includeJSFile_TIMEOUT_MS_DEFAULT: 90000 }; /** * It will contain the CrossBrowdy path when it finally loads. * @var * @readonly * @type {string} * @default {@link CB_scriptPathCalculate}(); */ var CB_scriptPath = CB_scriptPathCalculate(); //Can be modified later. //Applies the options set by the user (if any): CB_applyOptions(CB_NAME, CB_this); //Needed modules: /** * Static class that contains all the modules and the tools to manage them. * @namespace */ var CB_Modules = {}; CB_Modules.modules = {}; /** * Enum which defines possible module statuses. * @memberof CB_Modules * @readonly * @enum {integer} CB_Modules.STATUSES */ CB_Modules.STATUSES = { /** The module has failed to load. */ FAILED: -1, /** The module has an unkwnown status. */ UNKNOWN : 0, /** The module is not loaded yet. Default status. */ UNLOADED : 1, /** The module is being loading. */ LOADING : 2, /** The module has loaded successfully (coudl be not ready yet). */ LOADED : 3, /** The module has loaded successfully and it is ready to be used. */ READY : 4 }; /** * Callback that is called before loading a file and should return true if we want to load the file or false otherwise. * @memberof CB_Modules * @callback CB_Modules.neededFile_LOAD_CHECKER * @param {string} filepath - Filepath of the needed file (including the filename). * @param {CB_Modules.NEEDED_FILE} neededFile - Object that contains the needed file. * @returns {boolean} - Returns true if we want to load the file or false otherwise. */ /** * Object that contains a needed file for a module. * @memberof CB_Modules * @typedef {Object} CB_Modules.NEEDED_FILE * @property {boolean} [load=false] - Defines whether to load the file or not. * @property {boolean} [mandatory=false] - Defines whether the file is mandatory. If the file is not mandatory, its module could be declared as loaded successfully before the file is loaded (and maybe never will). * @property {boolean} [absolutePath=false] - Defines whether the path of the file is relative to the path of the main script or absolute. * @property {CB_Modules.neededFile_LOAD_CHECKER} [loadChecker] - Callback that will be called when the file tries to be loaded and should return true if the file needs to be loaded. * @property {string} [id] - Desired string to identify the file. * @property {array} [requires] - Array of strings with the IDs of the files that must be loaded before loading this file. The file will not be loaded until the required files are loaded first. */ /** * Object that contains the needed files for a module. Each property will represent a needed file. * @memberof CB_Modules * @typedef {Object} CB_Modules.NEEDED_FILES * @property {CB_Modules.NEEDED_FILE} path_to_the_file - Object that contains a needed file for a module. The property name must be either the path to the file or a variable containing it. Tto use a variable, the name of the property must start with &quot;VALUEOF_&quot; and continue with the name of the variable. In the case that the variable is an object, each property must be separated by a dot (&quot;.&quot;). */ /** * Object that contains a needed module for a parent module. * @memberof CB_Modules * @typedef {Object} CB_Modules.NEEDED_MODULE * @property {string} name - Name of the module. * @property {CB_Modules.NEEDED_FILES} neededFiles - Object containing the needed files. */ /** * Callback for the different events of a module. * @memberof CB_Modules * @callback CB_Modules.CALLBACK * @param {string} scriptPath - The value for the &quot;scriptPath&quot; parameter used by {@link CB_init} when it was called. */ /** * Object that contains a module. * @memberof CB_Modules * @typedef {Object} CB_Modules.MODULE * @property {string} name - Name of the module. * @property {CB_Modules.STATUSES} status - Module status. * @property {CB_Modules.CALLBACK} onCall - Callback for when the module is called to be loaded. Being &quot;this&quot; the {@link CB_Modules.MODULE} object itself. * @property {CB_Modules.CALLBACK} onLoad - Callback for when the module loads successfully. Being &quot;this&quot; the {@link CB_Modules.MODULE} object itself. * @property {CB_Modules.CALLBACK} onReady - Callback for when the module is totally ready. Being &quot;this&quot; the {@link CB_Modules.MODULE} object itself. * @property {CB_Modules.CALLBACK} onFail - Callback for when the module fails to load. Being &quot;this&quot; the {@link CB_Modules.MODULE} object itself. NOT IMPLEMENTED YET. * @property {CB_Modules.NEEDED_FILES} neededFiles - Object containing the needed files. * @property {array} neededModules - Array of {@link CB_Modules.NEEDED_MODULE} objects, containing the needed modules. * @property {string} credits - Credits of the module. */ //Main module basic configuration: /** * Contains all the modules, one per property. * @var CB_Modules.modules * @type {Object} * @property {CB_Modules.MODULE} name_of_the_module - Object that contains the module data. The property name must be the name of the module. */ CB_Modules.modules[CB_NAME] = { //Name of the module: &quot;name&quot; : CB_NAME, //Status (UNKNOWN, UNLOADED, LOADING, LOADED, READY or FAILED): &quot;status&quot; : CB_Modules.STATUSES.UNLOADED, //Function to call as soon as the module is called (before loading its scripts): &quot;onCall&quot; : function(scriptPathGiven) { if (CB_Configuration[CB_NAME].STATS) { CB_sendStats(); } //If we want, includes the file for statistics purposes. CB_Modules.setStatus(CB_NAME, CB_Modules.STATUSES.LOADED); }, //Callback function to call when the module has been loaded successfully: &quot;onLoad&quot; : function(scriptPathGiven) { CB_Modules.setStatus(CB_NAME, CB_Modules.STATUSES.READY); }, //Callback function to call when the module is ready: &quot;onReady&quot; : function(scriptPathGiven) { CB_scriptPath = scriptPathGiven; //The path given was correct so we set it. CB_ready = true; //Set as it's ready. }, //Callback function to call when module has not been loaded successfully: //&quot;onFail&quot; =&gt; null, //Needed files: &quot;neededFiles&quot; : null, //Format: &quot;needed_file&quot; : { load: needs_to_be_loaded, [mandatory: needed_to_begin_CrossBrowdy], [absolutePath: relative_to_CrossBrowdy_path_or_absolute], [loadChecker: function that will be called and return true if the file needs to be loaded], [id: file_identifier_string], [requires: array_with_required_ids_of_files_required] } //Needed modules: &quot;neededModules&quot; : [ { &quot;name&quot; : &quot;CrossBase&quot;, //Format: &quot;needed_file&quot; : { load: needs_to_be_loaded, [mandatory: needed_to_begin_CrossBrowdy], [absolutePath: relative_to_CrossBrowdy_path_or_absolute], [loadChecker: function that will be called and return true if the file needs to be loaded], [id: file_identifier_string], [requires: array_with_required_ids_of_files_required] } &quot;neededFiles&quot; : { &quot;CrossBase/CrossBase.js&quot; : { load: true, mandatory: true } } } ], //Credits: &quot;credits&quot; : &quot;[CB] &quot; + CB_NAME + &quot; &quot; + CB_VERSION + &quot; by Joan Alba Maldonado&lt;br /&gt;&quot; }; //Sets default credits: /** * Default credits. * @var * @readonly * @type {string} * @default */ var CB_CREDITS_DEFAULT = &quot;&quot;; CB_addCredits(CB_Modules.modules[CB_NAME][&quot;credits&quot;]); //If now() static function not available, uses getTime() method: if (!Date.now) { Date.now = function() { return new Date().getTime(); }; } /** * Attaches the given credits to the default ones (to {@link CB_CREDITS_DEFAULT}). * @function * @param {string} credits - Path to the JS file. * @returns {string} Returns the default credits after attaching the given ones. */ function CB_addCredits(credits) { return CB_CREDITS_DEFAULT += credits; } /** * Alias for the &quot;console&quot; function which fallbacks to a DOM element with &quot;CB_console&quot; id (its CSS &quot;style&quot; attribute will be modified if needed, which means that its &quot;display&quot; property will be set to &quot;block&quot; if it is &quot;none&quot; and its &quot;visibility&quot; property to &quot;visible&quot; regardless its previous value) or even to an alert when it is not available (&quot;alert&quot; will only be used as a fallback in the case that the {@link CB_console_ALLOW_ALERTS} parameter is set to true). * @function * @param {string} message - Message to display * @todo When &quot;console&quot; is not available and it gets polyfilled, allow more parameters (use &quot;arguments&quot;). */ var CB_console; if (typeof(console) !== &quot;undefined&quot; &amp;&amp; typeof(console.log) !== &quot;undefined&quot;) { if (typeof(console.log.apply) !== &quot;undefined&quot;) { CB_console = function() { console.log.apply(console, arguments); }; } else { CB_console = console.log; } } else { CB_console = function(message) //TODO: allow more parameters (use &quot;arguments&quot;). { message += &quot;&quot;; var CB_consoleElement = document.getElementById(&quot;CB_console&quot;); if (CB_consoleElement !== null) { CB_consoleElement.style.visibility = &quot;visible&quot;; if (CB_consoleElement.style.display === &quot;none&quot;) { CB_consoleElement.style.display = &quot;block&quot;; } CB_consoleElement.innerHTML += message.replace(/\\n/gi, &quot;&lt;br /&gt;&quot;) + &quot;&lt;br /&gt;&quot;; CB_consoleElement.scrollTop = CB_consoleElement.scrollHeight; } else if (CB_Configuration[CB_NAME].CB_console_ALLOW_ALERTS) { alert(message); } }; console = { log : CB_console }; } var CB_filesRequested = {}; var CB_filesLoaded = []; var CB_filesLoadedIds = {}; /** * Callback for when the file is included successfully or fails to load. * @callback CB_includeJSFile_CALLBACK * @param {string} filepath - The 'filepath' parameter when {@link CB_includeJSFile} was called (if any). * @param {CB_includeJSFile_CALLBACK} callbackOk - The 'callbackOk' parameter when {@link CB_includeJSFile} was called (if any). * @param {CB_includeJSFile_CALLBACK} callbackError - The 'callbackError' parameter when {@link CB_includeJSFile} was called (if any). * @param {integer} timeoutMs - The 'timeoutMs' parameter when {@link CB_includeJSFile} was called (if any). * @param {boolean} asynchronously - The 'asynchronously' parameter when {@link CB_includeJSFile} was called (if any). */ /** * Includes a JavaScript file to the current document. * @function * @param {string} filepath - Path to the JS file. * @param {CB_includeJSFile_CALLBACK} [callbackOk] - Callback for when the file is included successfully. * @param {CB_includeJSFile_CALLBACK} [callbackError] - Callback for when there is any error including the file or it cannot be included after the defined timeout. * @param {integer} [timeoutMs={@link CB_Configuration.CrossBrowdy.CB_includeJSFile_TIMEOUT_MS_DEFAULT}] - Timeout in milliseconds to consider that the inclusion of the file has failed. * @param {boolean} [asynchronously=true] - Defines whether to load the file asynchronously or not. * @param {string} [fileId] - Internal usage recommended only. * @param {array} [fileRequires] - Internal usage recommended only. * @param {boolean} [notMandatory=false] - Internal usage recommended only. * @returns {Object|null|false} Returns null when the script file cannot be loaded yet as some required file has still not been loaded. Returns false when neither the 'HEAD' tag nor the document body can be found. Otherwise, returns an object whose two properties are 'scriptElement' (with the [SCRIPT]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script} element just created) and 'timeoutFailure' (with the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} ID created to check whether the file cannot be loaded after the given time). */ function CB_includeJSFile(filepath, callbackOk, callbackError, timeoutMs, asynchronously, fileId, fileRequires, notMandatory) { //If the file requires another one and it has still not loaded, calls the function again after a while: if (fileRequires &amp;&amp; typeof(fileRequires.length) !== &quot;undefined&quot; &amp;&amp; fileRequires.length &gt; 0) { for (var x = 0; x &lt; fileRequires.length; x++) { if (!CB_filesLoadedIds[fileRequires[x]]) { setTimeout(function() { CB_includeJSFile(filepath, callbackOk, callbackError, timeoutMs, asynchronously, fileId, fileRequires, notMandatory); }, 10); return null; } } } //If not given, uses the default timeout: timeoutMs = timeoutMs || CB_Configuration[CB_NAME].CB_includeJSFile_TIMEOUT_MS_DEFAULT //If not given, uses the default value for the 'asynchronously' parameter: if (asynchronously !== false) { asynchronously = true; } //Stores the file as not loaded in the array: if (!notMandatory) { CB_filesRequested[filepath] = true; } //var parentElement = document.getElementsByTagName(&quot;head&quot;) || document.head || document.getElementsByTagName(&quot;body&quot;) || document.body || document.documentElement; var parentElement = CB_getElementsByTagName(&quot;head&quot;); if (parentElement.length === 0) { parentElement = document.head || CB_getElementsByTagName(&quot;body&quot;); } if (parentElement.length === 0) { parentElement = document.body || document.documentElement || null; } if (parentElement &amp;&amp; typeof(parentElement[0]) === &quot;undefined&quot;) { parentElement = [parentElement]; } if (typeof(parentElement) === &quot;undefined&quot; || parentElement === null || typeof(parentElement[0]) === &quot;undefined&quot; || parentElement[0] === null) { CB_console(&quot;[ERROR] Neither &lt;HEAD&gt; tag nor document body could be found! (CB_includeJSFile)&quot;); if (typeof(callbackError) === &quot;function&quot;) { callbackError(filepath, callbackOk, callbackError, timeoutMs, asynchronously); } return false; } parentElement = parentElement[0]; var scriptTag = document.createElement(&quot;script&quot;); scriptTag.src = filepath; scriptTag.language = &quot;javascript&quot;; scriptTag.type = &quot;text/javascript&quot;; scriptTag.async = asynchronously; parentElement.appendChild(scriptTag); var onLoadExecuted = false; var onLoad = function() { this.onreadystatechange = this.onload = null; setTimeout ( function() { if (onErrorExecuted || onLoadExecuted) { return; } //Exists if the timeout has already been executed. onLoadExecuted = true; //Stores the file as already loaded in the array: CB_filesRequested[filepath] = false; CB_filesLoaded[CB_filesLoaded.length] = filepath; if (fileId) { CB_filesLoadedIds[fileId] = true; } //If defined, calls the OK function: if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(filepath, callbackOk, callbackError, timeoutMs, asynchronously); } }, 10 ); }; if (scriptTag.readyState) { scriptTag.onreadystatechange = function() { if (this.readyState === &quot;loaded&quot; || this.readyState === &quot;complete&quot;) { onLoad(); } }; } else { scriptTag.onload = onLoad; } var onErrorExecuted = false; var onError = function() { if (onErrorExecuted || onLoadExecuted) { return; } //Exists if the onLoad has been already executed. onErrorExecuted = true; //Stores the file as failed to load in the array: CB_filesRequested[filepath] = null; if (typeof(callbackError) === &quot;function&quot;) { callbackError(filepath, callbackOk, callbackError, timeoutMs, asynchronously); } }; scriptTag.onerror = onError; //Starts counting for the timeout: var callbackErrorTimeout = setTimeout(onError, timeoutMs); return { scriptElement: scriptTag, timeoutFailure: callbackErrorTimeout }; } /** * Callback for when the script is loaded successfully. Without parameters. * @callback CB_includeRequiredFileErrorCallback * @param {string} filepath - The 'filepath' parameter when {@link CB_includeJSFile} was called internally (if any). * @param {CB_includeJSFile_CALLBACK} callbackOk - The 'callbackOk' parameter when {@link CB_includeJSFile} was called internally (if any). * @param {CB_includeJSFile_CALLBACK} callbackError - The 'callbackError' parameter when {@link CB_includeJSFile} was called internally (if any). * @param {integer} timeoutMs - The 'timeoutMs' parameter when {@link CB_includeJSFile} was called internally (if any). * @param {boolean} asynchronously - The 'asynchronously' parameter when {@link CB_includeJSFile} was called (if any). * @param {object} filesRequested - Object whose indexes are all the filepaths of the script files requested so far and the value is true when the file is still loading (or to be loaded in the future), false if it was loaded successfully (the most likely) or null if it failed to load. * @param {array} filesLoaded - Numeric array whose values are the filepaths of the script files loaded successfully so far. */ //Function executed when a required file cannot be loaded (because of an error or timeout): CB_Modules._includeRequiredFileError = function(filepath, callbackOk, callbackError, timeoutMs, asynchronously) { CB_console(&quot;[CB] [ERROR] Script file failed to load: &quot; + filepath); if (typeof(CB_initOnErrorLoadingFile) === &quot;function&quot;) { CB_initOnErrorLoadingFile(filepath, callbackOk, callbackError, timeoutMs, asynchronously, CB_filesRequested, CB_filesLoaded); } } //Function that includes all required files: CB_Modules._includeAllRequiredFiles = function(CB_scriptPathGiven, neededFiles, callbackOk) { //Parses the neededFiles object to turn variable keys into the real value of those variables: var currentValue = null; var allIndexes = null; var allIndexesLength = 0; var x = 0; for (var currentFile in neededFiles) { if (currentFile.substring(0, 8) === &quot;VALUEOF_&quot;) { allIndexes = currentFile.substring(8).split(&quot;.&quot;); allIndexesLength = allIndexes.length; currentValue = CB_this;//window; for (var x = 0; x &lt; allIndexesLength; x++) { if (typeof(currentValue[allIndexes[x]]) !== &quot;undefined&quot; &amp;&amp; currentValue[allIndexes[x]] !== null) { currentValue = currentValue[allIndexes[x]]; } else { break; } } if (typeof(currentValue) !== &quot;string&quot; &amp;&amp; !(currentValue instanceof String)) { currentValue = &quot;&quot;; } if (currentValue !== &quot;&quot;) { neededFiles[currentValue] = { load: neededFiles[currentFile].load, loadChecker: neededFiles[currentFile].loadChecker, mandatory: neededFiles[currentFile].mandatory, id: neededFiles[currentFile].id, requires: neededFiles[currentFile].requires }; } neededFiles[currentFile].load = false; //It contains the key without parsing, so we set as we don't need it to load it to ignore it. neededFiles[currentFile].disabled = true; //Disables it. } } //Includes all files needed: var neededFilesPending = 0; for (currentFile in neededFiles) { if (neededFiles[currentFile].disabled) { continue; } //Performs the load checker that can change the load property (if any): if (typeof(neededFiles[currentFile].loadChecker) === &quot;function&quot; &amp;&amp; neededFiles[currentFile].load) { neededFiles[currentFile].load = neededFiles[currentFile].loadChecker(currentFile, neededFiles[currentFile]); } //If the file needs to be loaded, we load it: if (neededFiles[currentFile].load) { new function(currentFile) //Creates a new scope because we are in a loop. { var functionWhenLoad = null; if (neededFiles[currentFile].mandatory) //Only increases and decreases counter for mandatory files. { neededFilesPending++; functionWhenLoad = function(filepath, callbackOk, callbackError, timeoutMs) { neededFilesPending--; if (typeof(neededFiles) !== &quot;undefined&quot; &amp;&amp; neededFiles !== null &amp;&amp; typeof(neededFiles[currentFile]) !== &quot;undefined&quot; &amp;&amp; neededFiles[currentFile] !== null) { neededFiles[currentFile].load = false; //We have loaded it and don't need to load it more. } }; } var scriptPath = CB_scriptPathGiven; if (neededFiles[currentFile].absolutePath) { scriptPath = &quot;&quot;; } CB_includeJSFile(scriptPath + currentFile, functionWhenLoad, CB_Modules._includeRequiredFileError, undefined, undefined, neededFiles[currentFile].id, neededFiles[currentFile].requires); }(currentFile); } } //Interval that will check when all the modules has been loaded: var allRequiredFilesLoaded = function() { if (neededFilesPending &lt;= 0 &amp;&amp; typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } else if (typeof(callbackOk) === &quot;function&quot;) { setTimeout(allRequiredFilesLoaded, 1); } }; allRequiredFilesLoaded(); } //Function that includes all required modules: CB_Modules._includeAllRequiredModules = function(CB_scriptPathGiven, modules, callbackOk) { if (typeof(modules) === &quot;undefined&quot; || modules === null) { return; } var modulesLength = modules.length; var neededModulesPending = 0; for (var x = 0; x &lt; modulesLength; x++) { if (typeof(modules[x].name) !== &quot;undefined&quot; &amp;&amp; typeof(modules[x].neededFiles) !== &quot;undefined&quot; &amp;&amp; modules[x].neededFiles) { neededModulesPending++; new function(moduleName) //Closure to keep moduleName value for every loop. { CB_Modules._includeAllRequiredFiles ( CB_scriptPathGiven, modules[x][&quot;neededFiles&quot;], function() { setTimeout ( function() { CB_Modules._initializeModule(CB_scriptPathGiven, moduleName); neededModulesPending--; }, 10 ); } ); }(modules[x].name); } } //Interval that will check when all the modules has been loaded: var allRequiredModulesLoaded = function() { if (neededModulesPending &lt;= 0 &amp;&amp; typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } else if (typeof(callbackOk) === &quot;function&quot;) { setTimeout(allRequiredModulesLoaded, 1); } }; allRequiredModulesLoaded(); } //Tells the number of required files loaded: CB_Modules._numberFilesLoaded = function(neededFiles, onlyMandatory) { //Checks all files needed: var numberNeededFilesLoaded = 0; for (var currentFile in neededFiles) { //Checks whether the needed file has been loaded: if (neededFiles[currentFile].load) { if (!onlyMandatory || neededFiles[currentFile].mandatory) { numberNeededFilesLoaded++; } } } return numberNeededFilesLoaded; } //Checks whether all required files have been loaded: CB_Modules._allFilesLoaded = function(neededFiles, onlyMandatory) { //Checks all files needed: var allFilesNeededIncluded = true; for (var currentFile in neededFiles) { //If the file has not been included yet, exits the bucle: if (neededFiles[currentFile].load) { if (!onlyMandatory || neededFiles[currentFile].mandatory) { allFilesNeededIncluded = false; break; } } } return allFilesNeededIncluded; } //Checks whether all required modules have been loaded: CB_Modules._allModulesLoaded = function(neededModules, onlyMandatory) { if (typeof(neededModules) === &quot;undefined&quot; || neededModules === null) { return true; } var allModulesNeededIncluded = true; var neededModulesLength = neededModules.length; for (var x = 0; x &lt; neededModulesLength; x++) { if (typeof(neededModules[x].name) !== &quot;undefined&quot; &amp;&amp; typeof(neededModules[x].neededFiles) !== &quot;undefined&quot; &amp;&amp; neededModules[x].neededFiles) { if (!CB_Modules._allFilesLoaded(neededModules[x].neededFiles, onlyMandatory)) { allModulesNeededIncluded = false; break; } } } return allModulesNeededIncluded; } //Checks whether a given module is ready or not: CB_Modules._moduleReady = function(moduleName) { return (CB_Modules._getModuleStatus(moduleName) === CB_Modules.STATUSES.READY); } //Checks whether all required modules are ready: CB_Modules._allModulesReady = function(neededModules) { if (typeof(neededModules) === &quot;undefined&quot; || neededModules === null) { return true; } var allModulesNeededReady = true; var neededModulesLength = neededModules.length; for (var x = 0; x &lt; neededModulesLength; x++) { if (typeof(neededModules[x].name) !== &quot;undefined&quot; &amp;&amp; typeof(neededModules[x].neededFiles) !== &quot;undefined&quot; &amp;&amp; neededModules[x].neededFiles) { if (!CB_Modules._moduleReady(neededModules[x].name)) { allModulesNeededReady = false; break; } } } return allModulesNeededReady; } //Returns the status of a given module: CB_Modules._getModuleStatus = function(moduleName) { if (typeof(CB_Modules.modules[moduleName]) !== &quot;undefined&quot; &amp;&amp; typeof(CB_Modules.modules[moduleName].status) !== &quot;undefined&quot;) { return CB_Modules.modules[moduleName].status; } else { return CB_Modules.STATUSES.UNKNOWN; } } /** * Sets a status for a given module. * @memberof CB_Modules * @function * @param {string} moduleName - Name of the module. * @param {integer} status - The desired status. Must be a value that exists in the {@link CB_Modules.STATUSES} enum. * @returns {boolean} It will return true if succeeded or false otherwise. */ CB_Modules.setStatus = function(moduleName, status) { if (typeof(CB_Modules.modules[moduleName]) !== &quot;undefined&quot;) { CB_Modules.modules[moduleName].status = status; } } //Function that initializes a module: //var CB_allFilesLoadedInterval; //Interval that checks if CrossBrowdy is ready or not. CB_Modules._initializeModule = function(CB_scriptPathGiven, moduleName) { //It the module still does not exist (status is unknown), tries to load it again after some time: if (CB_Modules._getModuleStatus(moduleName) === CB_Modules.STATUSES.UNKNOWN) { setTimeout(function() { CB_Modules._initializeModule(CB_scriptPathGiven, moduleName); }, 1); return; } CB_Modules.setStatus(moduleName, CB_Modules.STATUSES.LOADING); if (typeof(CB_Modules.modules[moduleName][&quot;onCall&quot;]) === &quot;function&quot;) { CB_Modules.modules[moduleName][&quot;onCall&quot;].call(CB_Modules.modules[moduleName], CB_scriptPathGiven); } //Applies default path if it was not sent: if (typeof(CB_scriptPathGiven) === &quot;undefined&quot; || CB_scriptPathGiven === null) { CB_scriptPathGiven = CB_scriptPathCalculate(); } //Includes required files: CB_Modules._includeAllRequiredFiles(CB_scriptPathGiven, CB_Modules.modules[moduleName][&quot;neededFiles&quot;]); //Includes required modules: CB_Modules._includeAllRequiredModules(CB_scriptPathGiven, CB_Modules.modules[moduleName][&quot;neededModules&quot;]); //Show credits in console: CB_console(CB_credits(CB_Modules.modules[moduleName][&quot;credits&quot;], false)); //Interval that checks if CrossBrowdy is ready (and initializes the static objects): var onLoadProcessed = false; var onReadyProcessed = false; var CB_allFilesLoadedCheck = function() { var loopAgain = true; //If all files needed are loaded (mandatory files only): if (CB_Modules._allFilesLoaded(CB_Modules.modules[moduleName][&quot;neededFiles&quot;], true)) { //If all needed modules are loaded (mandatory module files only): if (CB_Modules._allModulesLoaded(CB_Modules.modules[moduleName][&quot;neededModules&quot;], true)) { //If defined, executes the onLoad function of the module: if (!onLoadProcessed &amp;&amp; typeof(CB_Modules.modules[moduleName][&quot;onLoad&quot;]) === &quot;function&quot;) { onLoadProcessed = true; CB_Modules.modules[moduleName][&quot;onLoad&quot;].call(CB_Modules.modules[moduleName], CB_scriptPathGiven); } //If all needed modules are ready: if (CB_Modules._allModulesReady(CB_Modules.modules[moduleName][&quot;neededModules&quot;])) { //If the module itself is ready: if (CB_Modules._moduleReady(moduleName)) { //If defined, executes the onReady function of the module: if (!onReadyProcessed &amp;&amp; typeof(CB_Modules.modules[moduleName][&quot;onReady&quot;]) === &quot;function&quot;) { onReadyProcessed = true; CB_Modules.modules[moduleName][&quot;onReady&quot;].call(CB_Modules.modules[moduleName], CB_scriptPathGiven); } loopAgain = false; } } } } if (loopAgain) { setTimeout(CB_allFilesLoadedCheck, 1); } }; CB_allFilesLoadedCheck(); } /** * Returns a {@link CB_Modules.MODULE} object for module management. * @memberof CB_Modules * @function * @param {string} moduleName - Name of the desired module. * @returns {CB_Modules.MODULE|null} If found, it will return the {@link CB_Modules.MODULE} object desired. Otherwise, it will return null. */ CB_Modules.get = function(moduleName) { if (typeof(CB_Modules.modules[moduleName]) !== &quot;undefined&quot;) { return CB_Modules.modules[moduleName]; } return null; } /** * Gets the value of a desired module property (or returns null). * @memberof CB_Modules * @function * @param {string} moduleName - Name of the desired module. * @param {string} property - Name of the desired property. * @returns {*|null} If found, it will return the value of the desired module property. Otherwise, it will return null. */ CB_Modules.getProperty = function(moduleName, property) { var module = CB_Modules.get(moduleName); if (module !== null &amp;&amp; typeof(module[property]) !== &quot;undefined&quot;) { return module[property]; } return null; } /** * Modifies a desired property of a given module. * @memberof CB_Modules * @function * @param {string} moduleName - Name of the module which contains the property to modify. * @param {string} property - Name of the property to modify. * @param {*} value - Value desired for the property. * @param {('array'|'object'|'scalar')} [type='scalar'] Type that the property uses. If it is &quot;array&quot;, the given &quot;value&quot; will be attached at the end of the array (all in a new single index if the &quot;iterateArray&quot; parameter is set to false, or each value in a new index otherwise). If it is &quot;object&quot;, the given &quot;value&quot; and the given &quot;property&quot; to modify will be treated as objects and the members of the &quot;value&quot; will be copied one by one (overwriting previous members in the case they existed). If it is &quot;scalar&quot; or any other, the given &quot;property&quot; value will be replaced with the given &quot;value&quot;. * @param {boolean} [iterateArray=false] - If is set to true and the given &quot;type&quot; is &quot;array&quot;, the given &quot;value&quot; will be considered an array and will be iterated to copy each of its values to a new index in the destiny. Otherwise, if it is set to false and the given &quot;type&quot; is &quot;array&quot;, the given &quot;value&quot; will be attached at the end of the array in a new single index. * @returns {boolean} It will return true if succeeded or false otherwise. */ CB_Modules.editProperty = function(moduleName, property, value, type, iterateArray) { if (typeof(moduleName) === &quot;undefined&quot; || moduleName === null || moduleName === &quot;&quot;) { return false; } if (typeof(property) === &quot;undefined&quot; || property === null || property === &quot;&quot;) { return false; } if (typeof(type) === &quot;undefined&quot; || type === null) { type = &quot;scalar&quot;; } type += &quot;&quot;; type = type.toLowerCase(); var modified = false; var module = CB_Modules.get(moduleName); if (module !== null) { var propertyValue = CB_Modules.getProperty(moduleName, property); if (type === &quot;array&quot;) { if (propertyValue === null) { module[property] = []; } if (!iterateArray) { module[property][module[property].length] = value; modified = true; } else { var valueLength = value.length; for (var x = 0; x &lt; valueLength; x++) { module[property][module[property].length] = value[x]; } if (x &gt; 0) { modified = true; } } } else if (type === &quot;object&quot;) { if (propertyValue === null) { module[property] = {}; } for (var propertyName in value) { module[property][propertyName] = value[propertyName]; modified = true; } } else { if (propertyValue === null) { module[property] = null; } module[property] = value; modified = true; } } return modified; } /** * Attaches one module to another one. * @memberof CB_Modules * @function * @param {string} moduleNameParent - Name of the parent module where the new child module will be attached to. * @param {string} moduleName - Name of the new child module which will be attached to the given parent. * @param {CB_Modules.NEEDED_FILES} neededFiles - The &quot;neededFiles&quot; parameter for the new child module. * @returns {boolean} It will return true if succeeded or false otherwise. */ CB_Modules.addNeededModule = function(moduleNameParent, moduleName, neededFiles) { return CB_Modules.editProperty(moduleNameParent, &quot;neededModules&quot;, { &quot;name&quot; : moduleName, &quot;neededFiles&quot; : neededFiles }, &quot;array&quot;); } /** * Attaches files to a module. * @memberof CB_Modules * @function * @param {string} moduleName - Name of the module which will contain the new files. * @param {CB_Modules.NEEDED_FILES} neededFiles - The &quot;neededFiles&quot; parameter for the module. * @returns {boolean} It will return true if succeeded or false otherwise. */ CB_Modules.addNeededFiles = function(moduleName, neededFiles) { return CB_Modules.editProperty(moduleName, &quot;neededFiles&quot;, neededFiles, &quot;object&quot;); } function CB_getElementsByTagName(tagName) { if (!tagName) { return []; } var elementsFound = []; if (typeof(document.getElementsByTagName) !== &quot;undefined&quot; &amp;&amp; document.getElementsByTagName !== null) { elementsFound = document.getElementsByTagName(tagName); } else if (document.querySelectorAll) { elementsFound = document.querySelectorAll(tagName); } else if (document.querySelectorAll) { elementsFound = document.querySelectorAll(tagName); } else if (typeof(document.all) !== &quot;undefined&quot; &amp;&amp; document.all !== null) { elementsFound = document.all.tags(tagName); } else if (document.layers) { var allElements = document.layers; //Obtains all elements with the given tag name: var allElementsLength = allElements.length; var elementCurrent; for (var x = 0; x &lt; allElementsLength; x++) { elementCurrent = allElements[x]; if (elementCurrent !== null &amp;&amp; typeof(elementCurrent.tagName) !== &quot;undefined&quot;) { if (CB_trim(elementCurrent.tagName).toLowerCase() === tagName) { elementsFound.push(elementCurrent); } } } //elementsFound = document.layers[tagName]; } return elementsFound; } var CB_scriptPathCalculateLastReturn = CB_this.CB_scriptPathCalculateLastReturn || null; /** * Tries to calculate and returns the path where the script is located. * @function * @returns {string} If it cannot be calculated, it will returns the value of {@link CB_Configuration[CB_NAME].SCRIPT_PATH_DEFAULT}. */ function CB_scriptPathCalculate() { if (typeof(CB_scriptPathCalculateLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_scriptPathCalculateLastReturn !== null) { return CB_scriptPathCalculateLastReturn; } //Gets the &quot;SCRIPT&quot; DOM elements: var scriptElements = CB_getElementsByTagName(&quot;script&quot;); var scriptFileName = CB_NAME + &quot;.js&quot;; for (var x = 0, scriptElementsLength = scriptElements.length; x &lt; scriptElementsLength; x++) { if (scriptElements[x].src &amp;&amp; scriptElements[x].src.length) { var src = scriptElements[x].src; if (src === scriptFileName || src.substring(src.length - scriptFileName.length - 1, src.length + 1) === &quot;/&quot; + scriptFileName) { CB_scriptPathCalculateLastReturn = src.substring(0, src.length - scriptFileName.length); return CB_scriptPathCalculateLastReturn; } } } return CB_Configuration[CB_NAME].SCRIPT_PATH_DEFAULT; } var CB_ready = false; //Defines weather CrossBrowdy is ready or not. var CB_initWait = true; var CB_initWaitMs = 50; var CB_readyInterval; //Interval that will execute the main function when CrossBrowdy is ready. var CB_deviceReady = false; var CB_initOnErrorLoadingFile; //Function to call if any required file fails to load. /** * Callback for when the script is loaded successfully. Without parameters. * @callback CB_init_CALLBACK */ /** * Starts CrossBrowdy. * @function * @param {CB_init_CALLBACK} [mainFunction] - Callback for when CrossBrowdy is loaded successfully. Recommended. * @param {string} [scriptPath={@link CB_scriptPathCalculate}()] - Path where the main script is located. If not provided (it is undefined or null), it will try to calculate it calling the {@link CB_scriptPathCalculate} function internally. * @param {CB_includeRequiredFileErrorCallback} [onErrorLoadingFile] - Function to call when any of the required files fails to load (because of an error or because its timeout was fired). It could be called more than once, for each file which failed loading. If a function is provided, it will be stored in the global 'CB_initOnErrorLoadingFile' variable. * @param {boolean} [showSplashScreen={@link CB_Configuration.CrossBrowdy.SHOW_SPLASH_SCREEN_DEFAULT}] - Defines whether to show the splash screen or not. */ function CB_init(mainFunction, scriptPath, onErrorLoadingFile, showSplashScreen) { //If Cordova is detected, exits this function and it will be called again when the device is ready: if ((typeof(window.cordova) !== &quot;undefined&quot;) &amp;&amp; !CB_deviceReady &amp;&amp; document.addEventListener) { document.addEventListener(&quot;deviceready&quot;, function() { CB_deviceReady = true; CB_init(mainFunction, scriptPath, onErrorLoadingFile, showSplashScreen) }, false); return; } //Applies the options set by the user (if any): CB_applyOptions(CB_NAME, CB_this); if (typeof(showSplashScreen) === &quot;undefined&quot; || showSplashScreen === null) { showSplashScreen = CB_Configuration[CB_NAME].SHOW_SPLASH_SCREEN_DEFAULT; } //If defined, shows splash screen: if (showSplashScreen) { CB_showSplashScreen(); } //Executes this same function only after some milliseconds (avoids problems with Internet Explorer and excanvas): if (CB_initWait) { setTimeout(function() { CB_initWait = false; CB_init(mainFunction, scriptPath, onErrorLoadingFile, showSplashScreen); }, CB_initWaitMs); return; } //Applies default path if it was not sent: if (typeof(scriptPath) === &quot;undefined&quot; || scriptPath === null) { scriptPath = CB_scriptPathCalculate(); //scriptPath = CB_Configuration[CB_NAME].SCRIPT_PATH_DEFAULT; } //If given, sets the callback when a required file fails to load: if (typeof(onErrorLoadingFile) === &quot;function&quot;) { CB_initOnErrorLoadingFile = onErrorLoadingFile; } //Initializes the main module: CB_Modules._initializeModule(scriptPath, CB_NAME); //If defined, the main function will be executed when CrossBrowdy is ready: if (typeof(mainFunction) === &quot;function&quot;) { var CB_readyExecute = function() { var loopAgain = true; if (CB_ready) { setTimeout(mainFunction, 1); //Calls the function given. if (showSplashScreen) { CB_hideSplashScreen = true; } //If showing, hides splash screen. loopAgain = false; } if (loopAgain) { setTimeout(CB_readyExecute, 1); } }; CB_readyExecute(); } } //Function that applies the given options: function CB_applyOptions(moduleName)//, containerObject) { if (typeof(CB_OPTIONS) !== &quot;undefined&quot; &amp;&amp; typeof(CB_OPTIONS[moduleName]) !== &quot;undefined&quot;) { for (var option in CB_OPTIONS[moduleName]) { CB_Configuration[moduleName][option] = CB_OPTIONS[moduleName][option]; } } } /** * Returns the credits with the desired format. * @function * @param {string} [credits={@link CB_CREDITS_DEFAULT}] - Desired credits to be shown. * @param {boolean} [html=true] - Strips all HTML tags (if any) when it is false. * @param {boolean} [showPrefix=true] - Defines whether to show the &quot;[CB]&quot; prefix for every line or not (it will remove all &quot;[CB]&quot; occurrences if it is false). * @returns {string} */ function CB_credits(credits, html, showPrefix) { if (typeof(html) === &quot;undefined&quot; || html === null) { html = true; } if (typeof(showPrefix) === &quot;undefined&quot; || showPrefix === null) { showPrefix = true; } if (typeof(credits) === &quot;undefined&quot; || credits === null || credits === &quot;&quot;) { credits = CB_CREDITS_DEFAULT; } if (!html) { if (typeof(CB_br2nl) !== &quot;undefined&quot;) { credits = CB_br2nl(credits); } else { credits = credits.replace(/&lt;br \\/&gt;/gi, &quot;\\n&quot;); } credits = credits.replace(/&lt;[^&gt;]*&gt;?/gm, ''); } if (!showPrefix) { credits = credits.replace(/\\[CB\\]/gi, &quot;&quot;); } return credits; } //Show a splash screen: var CB_showSplashScreenInterval; //Checks when the body is ready to show the splash screen. var CB_hideSplashScreen = false; var CB_showSplashScreenExecuted = false; function CB_showSplashScreen() { if (CB_showSplashScreenExecuted) { return; } CB_showSplashScreenExecuted = true; var CB_showSplashScreenShow = function() { var loopAgain = true; //var bodyTag = document.getElementsByTagName(&quot;body&quot;); var bodyTag = CB_getElementsByTagName(&quot;body&quot;); if (typeof(bodyTag) !== &quot;undefined&quot; &amp;&amp; bodyTag !== null &amp;&amp; typeof(bodyTag[0]) !== &quot;undefined&quot; &amp;&amp; bodyTag[0] !== null) { bodyTag = bodyTag[0]; if (!CB_hideSplashScreen &amp;&amp; document.getElementById(&quot;CB_splashScreenDiv&quot;) === null) { var splashScreenDivPosition = &quot;fixed&quot;; var additionalCSS = &quot;&quot;; //if (window.navigator.appName === &quot;Microsoft Internet Explorer&quot;) if (navigator.userAgent.indexOf(&quot;MSIE&quot;) !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 7&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 8&quot;) !== -1)) { /* if (typeof(document.compatMode) !== &quot;undefined&quot; &amp;&amp; document.compatMode === &quot;BackCompat&quot; || typeof(document.documentMode) !== &quot;undefined&quot; &amp;&amp; document.documentMode == 5) { additionalCSS = &quot; _position:absolute; _top:expression(eval(document.body.scrollTop));&quot;; } else if (navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1) { splashScreenDivPosition = &quot;absolute&quot;; } */ //If it is not IE8 (but IE5, IE6 or IE7) or it is in quirks mode (&quot;fixed&quot; property is not supported in IE8 when it is in quirks mode): if (navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 || typeof(document.compatMode) !== &quot;undefined&quot; &amp;&amp; document.compatMode === &quot;BackCompat&quot; || typeof(document.documentMode) !== &quot;undefined&quot; &amp;&amp; document.documentMode == 5) { splashScreenDivPosition = &quot;absolute&quot;; //additionalCSS = &quot; _position:absolute; _top: expression(eval(document.compatMode &amp;&amp; document.compatMode=='CSS1Compat') ? documentElement.scrollTop +(documentElement.clientHeight-this.clientHeight) : document.body.scrollTop +(document.body.clientHeight-this.clientHeight));&quot;; additionalCSS = &quot; _position:absolute; _top: expression(eval(document.compatMode &amp;&amp; document.compatMode=='CSS1Compat') ? documentElement.scrollTop : document.body.scrollTop);&quot;; additionalCSS += &quot; _left: expression(eval(document.compatMode &amp;&amp; document.compatMode=='CSS1Compat') ? documentElement.scrollLeft : document.body.scrollLeft);&quot;; } bodyTag.style.width = bodyTag.style.height = &quot;100%&quot;; } var splashScreenDiv = '\\ &lt;div id=&quot;CB_splashScreenDiv&quot; onmousedown=&quot;return false;&quot; style=&quot;position:' + splashScreenDivPosition + '; top:0px; left:0px; width:100%; height:100%; background-color:#cccccc; z-index:999; opacity:0.95; transition:opacity 1000ms; -moz-transition:opacity 1000ms; -webkit-transition:opacity 1000ms; -o-transition:opacity 1000ms; -khtml-transition:opacity 1000ms; -ms-transition:opacity 1000ms;' + additionalCSS + '&quot;&gt;\\ &lt;table style=&quot;padding:0px; border:#ffffff solid 10px; width:100%; height:100%;&quot;&gt;\\ &lt;tr&gt;\\ &lt;td align=&quot;center&quot; style=&quot;text-align:center; font-size:13px; font-family:terminal; color:#ffffff;&quot;&gt;\\ &lt;table style=&quot;width:100%; height:30px; background:#aa0000; margin:0px; padding:0px; width:100%; height:30px; line-height:30px; border:0px;&quot;&gt;\\ &lt;tr&gt;\\ &lt;td align=&quot;center&quot; valign=&quot;middle&quot; style=&quot;text-align:center; font-size:25px; font-family:terminal; color:#ffffff;&quot;&gt;\\ CrossBrowdy&lt;span style=&quot;font-size:10px;&quot;&gt;' + CB_VERSION + '&lt;/span&gt;\\ &lt;/td&gt;\\ &lt;/tr&gt;\\ &lt;/table&gt;\\ &lt;div style=&quot;font-family:arial; font-size:9px; line-height:10px; color:#696969; text-align:center;&quot;&gt;\\ &lt;div style=&quot;display:block; width:55%; text-align:left; margin:0px auto 0px auto;&quot;&gt;\\ &lt;div style=&quot;font-family:verdana; text-align:center;&quot; id=&quot;CB_splashScreenDivCredits&quot;&gt;' + CB_credits(CB_Modules.modules[CB_NAME][&quot;credits&quot;], true, false).replace(/&lt;br \\/&gt;/i, &quot;&quot;).replace(/&lt;br \\/&gt;/gi, &quot;. &quot;).replace(/- /i, &quot;&lt;/div&gt;&quot;).replace(/- /gi, &quot;&quot;) + '&lt;/div&gt;\\ &lt;/div&gt;\\ * &lt;span id=&quot;CB_splashScreenDivLoadingBlink&quot; style=&quot;color:#000000;&quot;&gt;Loading...&lt;/span&gt; *\\ &lt;br /&gt;\\ &lt;div id=&quot;CB_splashScreenDivLoader&quot; style=&quot;color:#ffffff; text-align:center;&quot;&gt;&lt;/div&gt;\\ &lt;/td&gt;\\ &lt;/tr&gt;\\ &lt;/table&gt;\\ &lt;/div&gt;\\ '; bodyTag.innerHTML += splashScreenDiv; } else if (CB_hideSplashScreen &amp;&amp; document.getElementById(&quot;CB_splashScreenDiv&quot;) !== null) { var CB_splashScreenDiv = document.getElementById(&quot;CB_splashScreenDiv&quot;); CB_splashScreenDiv.style.opacity = 0; setTimeout(function() { CB_splashScreenDiv.style.visibility = &quot;hidden&quot;; }, 1000); loopAgain = false; } if (document.getElementById(&quot;CB_splashScreenDivLoadingBlink&quot;) !== null) { document.getElementById(&quot;CB_splashScreenDivLoadingBlink&quot;).style.visibility = (document.getElementById(&quot;CB_splashScreenDivLoadingBlink&quot;).style.visibility === &quot;visible&quot;) ? &quot;hidden&quot; : &quot;visible&quot;; } if (document.getElementById(&quot;CB_splashScreenDivLoader&quot;) !== null) { var loader = &quot;&quot;; for (var file in CB_filesRequested) { if (CB_filesRequested[file]) { loader += '&lt;span style=&quot;color:#aa00aa;&quot;&gt;Loading&lt;/span&gt; ' + file; } else if (CB_filesRequested[file] === null) { loader += '&lt;span style=&quot;color:#aa0000; font-weight:bold;&quot;&gt;ERROR LOADING&lt;/span&gt; ' + file; } //else { loader += file + ' &lt;span style=&quot;color:#0000aa;&quot;&gt;Loaded!&lt;/span&gt;'; } loader += &quot;&lt;br /&gt;&quot;; } //if (typeof(CB_filesLoaded[CB_filesLoaded.length - 1]) !== &quot;undefined&quot;) { loader += CB_filesLoaded[CB_filesLoaded.length - 1] + ' &lt;span style=&quot;color:#aa0000;&quot;&gt;Loaded&lt;/span&gt;'; } document.getElementById(&quot;CB_splashScreenDivLoader&quot;).innerHTML = loader; } } if (loopAgain) { setTimeout(CB_showSplashScreenShow, 1); } }; CB_showSplashScreenShow(); } //Sends the statistics: var CB_statsStored = false; function CB_sendStats() { //Gets the information: //var OS = &quot;&quot;; var version = CB_VERSION; var url = typeof(window.location) !== &quot;undefined&quot; ? window.location : &quot;&quot;; var time = Date.now(); if (typeof(encodeURIComponent) !== &quot;undefined&quot;) { version = encodeURIComponent(version); url = encodeURIComponent(url); time = encodeURIComponent(time); } else if (typeof(escape) !== &quot;undefined&quot;) { version = escape(version); url = escape(url); time = escape(time); } /* txt = &quot;&lt;p&gt;Browser CodeName: &quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Browser Name: &quot; + navigator.appName + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Browser Version: &quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Cookies Enabled: &quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Browser Language: &quot; + navigator.language + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Browser Online: &quot; + navigator.onLine + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;Platform: &quot; + navigator.platform + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;User-agent header: &quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;; txt+= &quot;&lt;p&gt;User-agent language: &quot; + navigator.systemLanguage + &quot;&lt;/p&gt;&quot;; */ //Sends the information by including the statistics file: CB_includeJSFile(CB_Configuration[CB_NAME].STATS_URL + &quot;?cb=&quot; + version + &quot;&amp;time=&quot; + time + &quot;&amp;url=&quot; + url, undefined, undefined, undefined, true, undefined, undefined, true); } × Search results Close "},"CrossBase_general_CB_Arrays.js.html":{"id":"CrossBase_general_CB_Arrays.js.html","title":"Source: CrossBase/general/CB_Arrays.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_Arrays.js /** * @file Arrays management. Contains the {@link CB_Arrays} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage arrays. It will return itself if it is tried to be instantiated. * @namespace * @borrows CB_lastIndexOf as lastIndexOf * @borrows CB_indexOf as indexOf * @borrows CB_forEach as forEach * @borrows CB_isArray as isArray * @borrows CB_sizeOf as sizeOf * @borrows CB_replaceAll as replaceAll * @borrows CB_trim as trim * @borrows CB_rtrim as rtrim * @borrows CB_ltrim as ltrim * @borrows CB_combineArraysOrObjects as combine */ var CB_Arrays = function() { return CB_Arrays; }; { CB_Arrays.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Arrays.init = function() { if (CB_Arrays.initialized) { return CB_Arrays; } //The object has been initialized: CB_Arrays.initialized = true; //TODO. return CB_Arrays; } CB_Arrays.lastIndexOf = function(array, searchElement, fromIndex) { return CB_lastIndexOf(array, searchElement, fromIndex, false); } //Returns the first index of a given element in an array (starting from an index if desired): CB_Arrays.indexOf = function(array, searchElement, fromIndex) { return CB_indexOf(array, searchElement, fromIndex, false); } //Tells whether an variable given is an array or not: CB_Arrays.isArray = function(variable) { return CB_isArray(variable, false); } /** * Alias for {@link CB_Arrays.sizeOf}. * @function CB_Arrays.sizeof * @see {@link CB_Arrays.sizeOf} */ /** * Alias for {@link CB_Arrays.sizeOf}. * @function CB_Arrays.count * @see {@link CB_Arrays.sizeOf} */ //Returns the size of an object given (does not need to be an array!): CB_Arrays.sizeOf = CB_Arrays.sizeof = CB_Arrays.count = function(object, onlyOwn) { return CB_sizeof(object, onlyOwn); } //Returns the given array of strings with the desired occurrences replaced. Calls itself recursively and calls the CB_replaceAll function internally. CB_Arrays.replaceAll = function(stringOrArray, stringOrArrayFind, stringReplace, caseInsensitive) //Either &quot;stringOrArray&quot; or &quot;stringOrArrayFind&quot; can also be an array of arrays of strings (as many levels as you wish). { return CB_replaceAll(stringOrArray, stringOrArrayFind, stringReplace, caseInsensitive); } //Trims all the strings that contains a given array (undesired strings can be set or otherwise will be spaces, etc.): CB_Arrays.trim = function(array, undesiredStrings) { return CB_trim(array, undesiredStrings); } //Trims all the strings from the right side that contains a given array (undesired strings can be set or otherwise will be spaces, etc.): CB_Arrays.rtrim = function(array, undesiredStrings) { return CB_rtrim(array, undesiredStrings); } //Trims all the strings from the left side that contains a given array (undesired strings can be set or otherwise will be spaces, etc.): CB_Arrays.ltrim = function(array, undesiredStrings) { return CB_ltrim(array, undesiredStrings); } //Returns a combined array or object from two arrays or objects: CB_Arrays.combine = function(arrayOrObjectA, arrayOrObjectB, avoidDuplicatedValuesInArray) { return CB_combineArraysOrObjects(arrayOrObjectA, arrayOrObjectB, avoidDuplicatedValuesInArray); } //Performs a desired function for each element of a given array (changing the value of &quot;this&quot; if desired): CB_Arrays.forEach = function(array, fun, thisObject) { return CB_forEach(array, fun, thisObject, false); } /** * Callback that is used for each iteration when looping the array. Being &quot;this&quot; the value itself. * @memberof CB_Arrays * @callback CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK * @param {*} item - Element (item) which belongs to the index which is being checked in the current iteration of the given array. * @param {integer} index - Index which is being checked in the current iteration. * @param {array} array - Whole array which is being looped. * @param {integer} delay - The &quot;delayBetweenEach&quot; used for this loop. * @returns {number} When used as a function to calculate the delay, it should return the delay desired as a number. */ /** * Callback that is used when finishes all iterations after looping the array. Being &quot;this&quot; the array itself. * @memberof CB_Arrays * @callback CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK * @param {array} array - Whole array which was being looped. * @param {integer} itemsAffected - The number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null). * @param {integer} delayMaximum - The maximum &quot;delay&quot; used. */ /** * Object used by the {@link CB_Arrays#executeFunctionAll} method when the &quot;returnSetTimeoutsArray&quot; parameter is set to true. * @memberof CB_Arrays * @typedef {Object} CB_Arrays.executeFunctionAll_OBJECT * @property {*} item - The element affected. * @property {integer} setTimeoutReturningValue - The returning value of calling the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} internally or null if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. * @property {number} setTimeoutDelay - The value used as the second parameter when calling the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} internally or zero if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. */ /** * Alias for {@link CB_Arrays#executeFunctionAll}. * @function CB_Arrays#executeAll * @see {@link CB_Arrays#executeFunctionAll} */ /** * Alias for {@link CB_Arrays#executeFunctionAll}. * @function CB_Arrays#forEachDelay * @see {@link CB_Arrays#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing elements of a given array. Elements which are undefined or null will be skipped without calling the &quot;functionEach&quot; function. * @function * @param {array} array - A numeric array containing the elements that we want to loop. * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Function that will be called for each element of the given array. As the first parameter it receives the element of the &quot;array&quot; provided being looped, as the second parameter the position of this element in the &quot;array&quot; provided, the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the element itself. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each item). * @param {boolean} [returnSetTimeoutsArray=false] - Defines whether we want the method to return an integer or a numeric array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call. Returning an array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call is only useful when the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). * @param {boolean} [delayBetweenEachAffectsFirst=false] - If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the elements given in the &quot;array&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_Arrays.executeFunctionAll_OBJECT} object for each element given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. */ CB_Arrays.executeFunctionAll = CB_Arrays.executeAll = CB_Arrays.forEachDelay = function(array, functionEach, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { if (typeof(functionEach) !== &quot;function&quot; || !CB_isArray(array)) { if (typeof(functionFinish) === &quot;function&quot;) { functionFinish.call(array, array, 0, 0); } return returnSetTimeoutsArray ? [] : 0; } if (typeof(delayBetweenEach) !== &quot;function&quot; &amp;&amp; (typeof(delayBetweenEach) === &quot;undefined&quot; || delayBetweenEach === null || isNaN(delayBetweenEach) || delayBetweenEach &lt; 0)) { delayBetweenEach = 0; } var setTimeoutsInformation = []; var arrayLength = array.length; var y = 0; var setTimeoutReturningValue = null; var setTimeoutDelay = 0; var delay; var setTimeoutDelayMax = 0; for (var x = 0; x &lt; arrayLength; x++) { //If the object exists: if (typeof(array[x]) !== &quot;undefined&quot; &amp;&amp; array[x] !== null) { delay = typeof(delayBetweenEach) === &quot;function&quot; ? delayBetweenEach() : delayBetweenEach; delay = parseInt(delay) || 0; //Executes the given function (&quot;this&quot; parameters will point to the current object): if (delay === 0) { functionEach.call(array[x], array[x], x, array, delay); //&quot;x&quot; is the position of the object in the array. } else { new function(x, delay) //Closure to get unique value of &quot;x&quot; variable for each loop. { setTimeoutDelay = delayBetweenEachAffectsFirst ? delay * (y + 1) : delay * y; setTimeoutReturningValue = setTimeout ( function() { functionEach.call(array[x], array[x], x, array, delay); //&quot;x&quot; is the position of the object in the array. }, setTimeoutDelay ); setTimeoutDelayMax = setTimeoutDelay &gt; setTimeoutDelayMax ? setTimeoutDelay : setTimeoutDelayMax; }(x, delay); } setTimeoutsInformation[setTimeoutsInformation.length] = { &quot;item&quot; : array[x], &quot;setTimeoutReturningValue&quot; : setTimeoutReturningValue, &quot;setTimeoutDelay&quot; : setTimeoutDelay }; y++; } } if (typeof(functionFinish) === &quot;function&quot;) { if (setTimeoutDelayMax === 0) { functionFinish.call(array, array, y, setTimeoutDelayMax); } else { setTimeout(function() { functionFinish.call(array, array, y, setTimeoutDelayMax); }, setTimeoutDelayMax + 1); } } if (returnSetTimeoutsArray) { return setTimeoutsInformation; } else { return y; } } /** * Returns an array copied from the given one. It will also make a copy of the arrays found in the values (if any), calling itself recursively. * @function * @param {array} array - The array whose values we want to copy. * @returns {object} Returns an array copied from the given one. Returns an empty array if the given &quot;array&quot; was not an array. */ CB_Arrays.copy = function(array) { if (!CB_isArray(array)) { return []; } //Removes possible duplicated values or not desired: var newArray = []; for (var x = array.length - 1; x &gt;= 0; x--) { newArray[x] = CB_isArray(array[x]) ? CB_Arrays.copy(array[x]) : array[x]; } return newArray; } /** * Alias for {@link CB_Arrays.insertElement}. * @function CB_Arrays.insert * @see {@link CB_Arrays.insertElement} */ /** * Alias for {@link CB_Arrays.insertElement}. * @function CB_Arrays.insertElementByPosition * @see {@link CB_Arrays.insertElement} */ /** * Inserts an element in the desired position of a given an array. Elements which are placed after it will be moved a position to the right (increasing their index). * @function * @param {array} array - The array whose element we want to delete. * @param {integer} [index=0] - Position of the element in the given array that we want to remove. * @param {*} item - Element (item) which belongs to the index which is being checked in the current iteration of the given array. * @param {CB_Arrays.removeDuplicated_PURGE_FUNCTION} [onInsert] - Function to call if the element is inserted, after inserting it. * @returns {array} Returns the new array (with the element inserted if it was possible). If no valid array is given, it will return an empty array. */ CB_Arrays.insertElement = CB_Arrays.insertElementByPosition = CB_Arrays.insert = function(array, index, element, onInsert) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (!CB_isArray(array)) { return []; } if (index &lt; 0) { index *= -1; } //It must be a positive integer. if (index &gt; array.length) { index = array.length; } array.splice(index, 0, element); if (typeof(onInsert) === &quot;function&quot;) { onInsert.call(element, element, index, array); } return array; } /** * Callback that is used as the &quot;purgeFunction&quot; parameter of the {@link CB_Arrays.removeDuplicated} function. Being &quot;this&quot; the current element (item). It should return false when we want to keep the value or true otherwise. * @memberof CB_Arrays * @callback CB_Arrays.removeDuplicated_PURGE_FUNCTION * @param {*} item - Element (item) which belongs to the index which is being checked in the current iteration used in {@link CB_Arrays.removeDuplicated}. * @param {integer} index - Index which is being checked in the current iteration used in {@link CB_Arrays.removeDuplicated}. * @param {array} array - Whole array which is being checked. * @returns {boolean} It should return false when we want to keep the value or true otherwise. */ /** * Deletes duplicated and/or not desired values (with a checking function to purge) from a numeric array. Values can be of any type. Internally, loops through the given array backwards (from the last index to the first one). * @function * @param {array} array - The array whose values we want to purge. * @param {CB_Arrays.removeDuplicated_PURGE_FUNCTION} [purgeFunction] - Callback that will be called for each item, being &quot;this&quot; the current item. It should return false when we want to keep the value or true otherwise. If the &quot;ignoreDuplicated&quot; parameter is set to true, all duplicated elements will be removed regardless of the returning value of the &quot;purgeFunction&quot; function. * @param {boolean} [ignoreDuplicated=false] - If it is set to true, it will keep duplicated values (unless the given &quot;purgeFunction&quot; purge them). * @returns {array} Returns the array purged. If no valid array is given, it will return an empty array. */ CB_Arrays.removeDuplicated = function(array, purgeFunction, ignoreDuplicated) { if (!CB_isArray(array)) { return []; } //Removes possible duplicated values or not desired: var keysDuplicatedChecker = []; for (var x = array.length - 1; x &gt;= 0; x--) { //if (typeof(purgeFunction) === &quot;function&quot; &amp;&amp; purgeFunction(array[x]) || (typeof(purgeFunction) !== &quot;function&quot; || !ignoreDuplicated) &amp;&amp; CB_indexOf(keysDuplicatedChecker, array[x]) !== -1) if (typeof(purgeFunction) === &quot;function&quot; &amp;&amp; purgeFunction.call(array[x], array[x], x, array) || !ignoreDuplicated &amp;&amp; CB_indexOf(keysDuplicatedChecker, array[x]) !== -1) { array[x] = undefined; array.splice(x, 1); continue; } keysDuplicatedChecker[keysDuplicatedChecker.length] = array[x]; } return array; } /** * Alias for {@link CB_Arrays.removeElementByPosition}. * @function CB_Arrays.removeElementByIndex * @see {@link CB_Arrays.removeElementByPosition} */ /** * Deletes an element from an array which is placed in the desired position. Elements which were after it will be moved a position to the left (decreasing their index). * @function * @param {array} array - The array whose element we want to delete. * @param {integer} [index=0] - Position of the element in the given array that we want to remove. * @param {CB_Arrays.removeDuplicated_PURGE_FUNCTION} [onRemove] - Function to call if the element is removed, before removing it. * @returns {array} Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. */ CB_Arrays.removeElementByPosition = CB_Arrays.removeElementByIndex = function(array, index, onRemove) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (index &lt; 0) { index *= -1; } //It must be a positive integer. return CB_Arrays.removeDuplicated(array, function(value, position, array) { if (position === index) { if (typeof(onRemove) === &quot;function&quot;) { onRemove.call(value, value, position, array); } return true; } return false; }, true); } /** * Deletes a given element from an array. All occurrences will be deleted. Elements which were after a removed element will be moved a position to the left (decreasing their index). * @function * @param {array} array - The array whose element we want to delete. * @param {*} [element=undefined] - The element we want to remove. All occurrences will be deleted. Note that it is type sensitive. * @param {CB_Arrays.removeDuplicated_PURGE_FUNCTION} [onRemove] - Function to call if the element is removed, before removing it. * @returns {array} Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. */ CB_Arrays.removeElement = function(array, element) { return CB_Arrays.removeDuplicated(array, function(value, position, array) { if (value === element) { if (typeof(onRemove) === &quot;function&quot;) { onRemove.call(value, value, position, array); } return true; } return false; }, true); } /** * Deletes the given elements from an array. All occurrences will be deleted. Elements which were after a removed element will be moved a position to the left (decreasing their index). * @function * @param {array} array - The array whose element we want to delete. * @param {array} elements - An array with the elements we want to remove. All occurrences will be deleted. Note that it is type sensitive. * @returns {array} Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. */ CB_Arrays.removeElements = function(array, elements) { if (!CB_isArray(elements)) { elements = []; } return CB_Arrays.removeDuplicated(array, function(value, position, array) { return CB_Arrays.lastIndexOf(elements, value, position) !== -1; }, true); } /** * Sorts the values of an array (using the native [Array.sort]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort} method). * @function * @param {array} array - The array whose elements we want to sort. * @param {boolean} [reversed=false] - Defines whether to sort in the reverse order or not. Only applies when comparingFunction is not provided. * @param {function} [comparingFunction] - Comparing function with the same rules as the native [Array.sort]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort} method. If provided, the &quot;reversed&quot; parameter will be ignored. * @returns {array} Returns the array ordered. If another value which is not an array is given, it will be returned again. */ CB_Arrays.sort = function(array, reversed, comparingFunction) { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } if (typeof(comparingFunction) !== &quot;function&quot;) { if (reversed) { comparingFunction = function(a, b) { return b-a; }; } else { comparingFunction = function(a, b) { return a-b; }; } } return array.sort(comparingFunction); } /** * Sorts an array using the [bubble sort (sinking sort) method]{@link https://en.wikipedia.org/wiki/Bubble_sort}. Internally, it uses the &quot;&gt;&quot; operator for comparing values as they will be treated as numbers. * @function * @param {array} array - The array whose elements we want to sort. * @param {boolean} [reversed=false] - Defines whether to sort in the reverse order or not. * @todo Think about accepting a comparing function (as the &quot;sort&quot; method). * @returns {array} Returns the array ordered. If another value which is not an array is given, it will be returned again. */ CB_Arrays.bsort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } var arrayLength = array.length; for (var x = 1; x &lt; arrayLength; x++) { for (var y = 0; y &lt; arrayLength-x; y++) { if (!reversed &amp;&amp; array[y] &gt; array[y+1] || reversed &amp;&amp; array[y] &lt; array[y+1]) { var aux = array[y]; array[y] = array[y+1]; array[y+1] = aux; } } } return array; } //Sorts an array using merge sort method: CB_Arrays.msort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } //TODO. array = CB_Arrays.sort(array, reversed, comparingFunction); //DELETE THIS! return array; } //Sorts an array using quick sort method: CB_Arrays.qsort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } //TODO. array = CB_Arrays.sort(array, reversed, comparingFunction); //DELETE THIS! return array; } //Sorts an array using selection sort method: CB_Arrays.ssort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } //TODO. array = CB_Arrays.sort(array, reversed, comparingFunction); //DELETE THIS! return array; } //Sorts an array using insertion sort method: CB_Arrays.isort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } //TODO. array = CB_Arrays.sort(array, reversed, comparingFunction); //DELETE THIS! return array; } //Sorts an array using cocktail sort (bidirectional bubble) method: CB_Arrays.csort = function(array, reversed, comparingFunction) //NOTE: think about accepting a comparing function. { if (typeof(array) === &quot;undefined&quot; || array === null || !CB_Arrays.isArray(array)) { return array; } //TODO. array = CB_Arrays.sort(array, reversed, comparingFunction); //DELETE THIS! return array; } } × Search results Close "},"CrossBase_general_CB_data.js.html":{"id":"CrossBase_general_CB_data.js.html","title":"Source: CrossBase/general/CB_data.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_data.js /** * @file Data and related management. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; * @todo A function equivalent to htmlentities/htmlspecialchars (as in PHP). */ //If we want to extend the DOM, we do it: if (CB_Configuration[CB_BASE_NAME].EXTEND_DOM) { try { if (!Array.prototype.indexOf) { Array.prototype.indexOf = function(searchElement, fromIndex) { CB_indexOf(this, searchElement, fromIndex, true); } } if (!Array.prototype.lastIndexOf) { Array.prototype.lastIndexOf = function(searchElement, fromIndex) { CB_lastIndexOf(this, searchElement, fromIndex, true); } } if (!Array.isArray) { Array.isArray = function() { return CB_isArray(this, true); } } //isArray is a method which is not in the prototype. //if (!Array.prototype.isArray) { Array.prototype.isArray = function() { return CB_isArray(this, true); } } if (!Array.prototype.forEach) { Array.prototype.forEach = function(callback, thisArg) { CB_forEach(this, callback, thisArg, true); } } if (!NodeList.prototype.forEach) { NodeList.prototype.forEach = Array.prototype.forEach; } if (!HTMLCollection.prototype.forEach) { HTMLCollection.prototype.forEach = Array.prototype.forEach; } } catch(E) {} } /** * Implementation of [Array.lastIndexOf]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf} method for browsers that do not support it natively. &lt;br&gt; Returns the last index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. * @function * @param {array} array - Desired array. * @param {*} searchElement - Element we want to search. Note that it is type sensitive. * @param {integer} [fromIndex=array.length - 1] - First index of the given array where the search will start. * @param {boolean} [extendedDOM=false] - Defines whether the function is being called by a native function which was extended. Internal usage recommended only. * @returns {integer} * @todo Implement the &quot;fromIndex&quot; in the polyfill. */ //* Polyfill source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf function CB_lastIndexOf(array, searchElement, fromIndex, extendedDOM) { 'use strict'; if (!extendedDOM) { if (array &amp;&amp; array.lastIndexOf) { return array.lastIndexOf.call(array, searchElement, fromIndex || array.length); } //It can be a string. if (Array.prototype.lastIndexOf) { return Array.prototype.lastIndexOf.call(array, searchElement, fromIndex || array.length); } } if (typeof(array) === &quot;undefined&quot; || array === null) { throw new TypeError(); } var n, k, t = Object(array), len = t.length &gt;&gt;&gt; 0; if (len === 0) { return -1; } n = len - 1; if (arguments.length &gt; 2 &amp;&amp; typeof(arguments[2]) !== &quot;undefined&quot; &amp;&amp; arguments[2] !== null &amp;&amp; !isNaN(arguments[2])) { n = Number(arguments[2]); if (n != n) { n = 0; } //if (n != n) { n = len - 1; } else if (n != 0 &amp;&amp; n != (1 / 0) &amp;&amp; n != -(1 / 0)) { n = (n &gt; 0 || -1) * Math.floor(Math.abs(n)); } } for (k = n &gt;= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k &gt;= 0; k--) { if (k in t &amp;&amp; t[k] === searchElement) { return k; } } return -1; } /** * Implementation of [Array.indexOf]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf} method for arrays in browsers that do not support it natively. &lt;br&gt; Returns the first index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. * @function * @param {array} array - Desired array. * @param {*} searchElement - Element we want to search. Note that it is type sensitive. * @param {integer} [fromIndex=0] - First index of the given array where the search will start. * @param {boolean} [extendedDOM=false] - Defines whether the function is being called by a native function which was extended. Internal usage recommended only. * @returns {integer} */ //* Polyfill source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf function CB_indexOf(array, searchElement, fromIndex, extendedDOM) { if (!extendedDOM) { if (array &amp;&amp; array.indexOf) { return array.indexOf.call(array, searchElement, fromIndex); } //It can be a string. if (Array.prototype.indexOf) { return Array.prototype.indexOf.call(array, searchElement, fromIndex); } } if (typeof(array) === &quot;undefined&quot; || array === null) { throw new TypeError( '&quot;array&quot; is null or not defined' ); } var length = array.length &gt;&gt;&gt; 0; // Hack to convert object.length to a UInt32 fromIndex = +fromIndex || 0; if (Math.abs(fromIndex) === Infinity) { fromIndex = 0; } if (fromIndex &lt; 0) { fromIndex += length; if (fromIndex &lt; 0) { fromIndex = 0; } } for (;fromIndex &lt; length; fromIndex++) { if (array[fromIndex] === searchElement) { return fromIndex; } } return -1; } /** * Implementation of the [Array.forEach]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach} method for browsers that do not support it natively. &lt;br&gt; Executes a function for each element of a given array. * @function * @param {array} array - Desired array. * @param {function} callback - Function that will be executed for each element of the given array. Following the same rules as the native [Array.forEach]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach} method, it will receive three arguments: currentValue, currentIndex and the array given. * @param {*} [thisArg] - Value that will be passed as &quot;this&quot; every time the function is called. * @param {boolean} [extendedDOM=false] - Defines whether the function is being called by a native function which was extended. Internal usage recommended only. * @returns {array|undefined} If the &quot;extendedDOM&quot; parameter is set to false, returns the given &quot;array&quot; again. Otherwise, returns undefined. */ //* Polyfill source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach function CB_forEach(array, callback, thisArg, extendedDOM) { &quot;use strict&quot;; if (!extendedDOM) { if (array.forEach) { array.forEach.call(array, callback, thisArg); return array; } else if (Array.prototype.forEach) { Array.prototype.forEach.call(array, callback, thisArg); return array; } } if (array === void 0 || array === null) { throw new TypeError(); } if (typeof callback !== &quot;function&quot;) { throw new TypeError(); } var t = Object(array); var len = t.length &gt;&gt;&gt; 0; //thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) { if (i in t) { callback.call(thisArg, t[i], i, t); } } return extendedDOM ? undefined : array; } /** * Implementation of [Array.isArray]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray} method for browsers that do not support it natively. &lt;br&gt; Returns whether a given element is an array or not. * @function * @param {*} element - The element we want to check. * @param {boolean} [extendedDOM=false] - Defines whether the function is being called by a native function which was extended. Internal usage recommended only. * @returns {boolean} * @todo Think about a parameter to check whether the given array is a typed array (for example, 'Uint8Array') or not. */ function CB_isArray(element, extendedDOM) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } var isArray = false; if (Array) { if (Array.isArray &amp;&amp; !extendedDOM) { isArray = Array.isArray(element); } else { isArray = element instanceof Array; if (!isArray) //It could still be an Array from another frame. { isArray = (Object.prototype.toString.call(element) === '[object Array]'); } } } return isArray; } /** * Alias for {@link CB_sizeOf}. * @function CB_sizeof * @see {@link CB_sizeOf} */ /** * Returns the size of an object or array. * @function * @param {Object|array} element - The element whose size we want to know. It should be an object or an array. * @param {boolean} [onlyOwn=false] - If the &quot;element&quot; given is not an object, this parameter will be ignored. Otherwise, if it is set to true, it will only have into account the properties which the object has as their own property and have not been inherited (using the [Object.hasOwnProperty]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty} method). * @returns {integer} If an object is provided, the size will be the number of its properties. Otherwise, if an array is given, the size will be the numbers of its indexes ([Array.length]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length} property). */ function CB_sizeOf(object, onlyOwn) { var size = 0; if (CB_isArray(object) &amp;&amp; typeof(object.length) !== &quot;undefined&quot; &amp;&amp; object.length !== null &amp;&amp; !isNaN(object.length) &amp;&amp; object.length &gt; 0) { return object.length; } for (var key in object) { if (!onlyOwn || object.hasOwnProperty(key)) { size++; } } return size; } var CB_sizeof = CB_sizeOf; //Alias for the function. /** * Returns whether a given element is a string or not. * @function * @param {*} element - The element we want to check. * @returns {boolean} */ function CB_isString(element) { return (typeof(element) === &quot;string&quot; || element instanceof String); } /** * Returns back the given element if it is a string or an empty string otherwise. * @function * @param {*} element - The element that will be checked. * @returns {string} */ function CB_forceString(element) { if (!CB_isString(element)) { return &quot;&quot;; } else { return element; } } /** * Returns back the given element as a string if it could be parsed or an empty string otherwise. * @function * @param {*} element - The element that will be checked. * @returns {string} */ function CB_parseString(element) { if (typeof(element) === &quot;undefined&quot; || element === null || element === true || element === false || !CB_isString(element) &amp;&amp; isNaN(element)) { return &quot;&quot;; } else { return element + &quot;&quot;; } } /** * Trims a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. * @function * @param {string|array} element - The element that will be trimmed. It should be either a string or an array of strings. * @param {string|array} [undesiredStrings=[ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ]] - String or an array with the strings that we want to trim off the given element. * @returns {string|array} Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. * @todo Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). * @todo Consider accepting objects instead of arrays in the &quot;element&quot; parameter. */ function CB_trim(element, undesiredStrings) { if (CB_isArray(element)) { for (var x = 0, elementLength = element.length; x &lt; elementLength; x++) { element[x] = CB_trim(element[x], undesiredStrings); } return element; } //else if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null &amp;&amp; !isNaN(element)) { return element; } else if (typeof(element) === &quot;undefined&quot; || element === null) { return &quot;&quot;; } else if (element === true || element === false) { return &quot;&quot;; } else if (!isNaN(element)) { element = element + &quot;&quot;; } else if (!CB_isString(element)) { return &quot;&quot;; } else if (typeof(element.trim) === &quot;function&quot;) { //Only calls the native function when the &quot;undesiredStringFound&quot; parameter is the default one (it will not just trim blank spaces but also &quot;\\r&quot;, &quot;\\n&quot;...): if (!CB_isArray(undesiredStrings) &amp;&amp; !CB_isString(undesiredStrings)) { return element.trim(); } } //return element.replace(/^\\s+|\\s+$/g, &quot;&quot;); element = CB_rtrim(element, undesiredStrings); element = CB_ltrim(element, undesiredStrings); return element; } /** * Trims the right side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. * @function * @param {string|array} element - The element that will be trimmed. It should be either a string or an array of strings. * @param {string|array} [undesiredStrings=[ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ]] - String or an array with the strings that we want to trim off the given element. * @returns {string|array} Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. * @todo Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). * @todo Consider accepting objects instead of arrays in the &quot;element&quot; parameter. * @todo Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). */ function CB_rtrim(element, undesiredStrings) { if (CB_isArray(element)) { for (var x = 0, elementLength = element.length; x &lt; elementLength; x++) { element[x] = CB_rtrim(element[x], undesiredStrings); } return element; } //else if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null &amp;&amp; !isNaN(element)) { return element; } else if (typeof(element) === &quot;undefined&quot; || element === null) { return &quot;&quot;; } else if (element === true || element === false) { return &quot;&quot;; } else if (!isNaN(element)) { element = element + &quot;&quot;; } else if (!CB_isString(element)) { return &quot;&quot;; } if (CB_isString(undesiredStrings)) { undesiredStrings = [ undesiredStrings ]; } else if (!CB_isArray(undesiredStrings)) { undesiredStrings = [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ]; //Only calls the native function when the &quot;undesiredStringFound&quot; parameter is the default one (it will not just trim blank spaces but also &quot;\\r&quot;, &quot;\\n&quot;...): if (typeof(element.trimEnd) === &quot;function&quot;) { return element.trimEnd(); } } //Loops through the undesired strings: var undesiredStringsLength = undesiredStrings.length; var undesiredStringFound = false; for (var x = 0; x &lt; undesiredStringsLength; x++) { //Trims undesired string at the end: while (element.substring(element.length - undesiredStrings[x].length, element.length) === undesiredStrings[x]) { element = element.substring(0, element.length - undesiredStrings[x].length); undesiredStringFound = true; } //If an undesired string has been found, we are looking for more than one undesired strings and the loop is at the end, starts the loop again: if (undesiredStringFound &amp;&amp; undesiredStringsLength &gt; 1 &amp;&amp; x + 1 === undesiredStringsLength) { undesiredStringFound = false; x = -1; } } return element; } /** * Trims the left side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. * @function * @param {string|array} element - The element that will be trimmed. It should be either a string or an array of strings. * @param {string|array} [undesiredStrings=[ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ]] - String or an array with the strings that we want to trim off the given element. * @returns {string|array} Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. * @todo Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). * @todo Consider accepting objects instead of arrays in the &quot;element&quot; parameter. * @todo Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). */ function CB_ltrim(element, undesiredStrings) { if (CB_isArray(element)) { for (var x = 0, elementLength = element.length; x &lt; elementLength; x++) { element[x] = CB_ltrim(element[x], undesiredStrings); } return element; } //else if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null &amp;&amp; !isNaN(element)) { return element; } else if (typeof(element) === &quot;undefined&quot; || element === null) { return &quot;&quot;; } else if (element === true || element === false) { return &quot;&quot;; } else if (!isNaN(element)) { element = element + &quot;&quot;; } else if (!CB_isString(element)) { return &quot;&quot;; } if (CB_isString(undesiredStrings)) { undesiredStrings = [ undesiredStrings ]; } else if (!CB_isArray(undesiredStrings)) { undesiredStrings = [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ]; //Only calls the native function when the &quot;undesiredStringFound&quot; parameter is the default one (it will not just trim blank spaces but also &quot;\\r&quot;, &quot;\\n&quot;...): if (typeof(element.trimStart) === &quot;function&quot;) { return element.trimStart(); } } //Loops through the undesired strings: var undesiredStringsLength = undesiredStrings.length; var undesiredStringFound = false; for (var x = 0; x &lt; undesiredStringsLength; x++) { //Trims undesired string at the beginning: while (element.substring(0, undesiredStrings[x].length) === undesiredStrings[x]) { element = element.substring(undesiredStrings[x].length, element.length); undesiredStringFound = true; } //If an undesired string has been found, we are looking for more than one undesired strings and the loop is at the end, starts the loop again: if (undesiredStringFound &amp;&amp; undesiredStringsLength &gt; 1 &amp;&amp; x + 1 === undesiredStringsLength) { undesiredStringFound = false; x = -1; } } return element; } /** * Alias for {@link CB_nl2br}. * @function CB_nlToBr * @see {@link CB_nl2br} */ /** * Changes new lines (\\n) for &amp;lt;br /&amp;gt;'s in a given string. * @function * @param {string} string - The string we want to modify. * @returns {string} Returns the string with all the occurrences replaced or an empty string if the element given was not a string. */ function CB_nl2br(string) { //If it is not a string, uses an empty string instead: if (!CB_isString(string)) { string = &quot;&quot;; } //Parses the variable to string type: string = string.toString(); string = string.replace(/\\n/gi, &quot;&lt;br /&gt;&quot;); return string; } var CB_nlToBr = CB_nl2br; //Alias for the function. /** * Alias for {@link CB_br2nl}. * @function CB_brToNl * @see {@link CB_br2nl} */ /** * Changes &amp;lt;br /&amp;gt;'s, &amp;lt;br/&amp;gt;'s and &amp;lt;br&amp;gt;'s for new lines (\\n) in a given string. * @function * @param {string} string - The string we want to modify. * @returns {string} Returns the string with all the occurrences replaced or an empty string if the element given was not a string. */ function CB_br2nl(string) { //If it is not a string, uses an empty string instead: if (!CB_isString(string)) { string = &quot;&quot;; } //Parses the variable to string type: string = string.toString(); string = string.replace(/&lt;br \\/&gt;/gi, &quot;\\n&quot;); string = string.replace(/&lt;br\\/&gt;/gi, &quot;\\n&quot;); string = string.replace(/&lt;br&gt;/gi, &quot;\\n&quot;); return string; } var CB_brToNl = CB_br2nl; //Alias for the function. /** * Tries to guess whether a given file path (absolute or relative) is a local address or not. It will be assumed as local if the path uses the &quot;file:&quot; protocol or the current script is running locally and the path does not use the &quot;http:&quot;, &quot;https:&quot; or &quot;ftp:&quot; protocols. * @function * @param {string} filePath - The file path we want to check. * @returns {boolean} Returns whether the given file path is a local address or not. */ function CB_isFileLocal(filePath) { var isFileLocal = false; filePath = CB_trim(filePath); if (filePath !== &quot;&quot;) { if (filePath.substring(0, 5) === &quot;file:&quot; || CB_Client.isRunningLocally() &amp;&amp; filePath.substring(0, 5) !== &quot;http:&quot; &amp;&amp; filePath.substring(0, 6) !== &quot;https:&quot; &amp;&amp; filePath.substring(0, 4) !== &quot;ftp:&quot;) { isFileLocal = true; } } return isFileLocal; } /** * Processes a given string as a template and returns it rendered (if possible) with the values of the given JSON object. Tries to use [Handlebars]{@link https://handlebarsjs.com/} as the first choice but if is is not available it will just replace all occurrences with vanilla JavaScript. * @function * @param {string} str - The string we want to render. * @param {Object} [JSONObject=CB_JSONData] - The JSON object which contains the values. If not provided, it will try to use the global CB_JSONData object in the case it exists. * @param {boolean} [forceVanilla=false] - Forces vanilla JavaScript rendering instead of using [Handlebars]{@link https://handlebarsjs.com/}. * @param {integer} [depthLevelMax=10] - Maximum depth level allowed to read the object to render the string. Only applies when it is rendered by vanilla JavaScript. For performance purposes. * @returns {str} */ function CB_renderString(string, JSONObject, forceVanilla, depthLevelMax) { string = CB_trim(string); //If a JSON object is not given, uses the default one (if any): if (typeof(JSONObject) === &quot;undefined&quot; || JSONObject === null) { if (typeof(CB_JSONData) !== &quot;undefined&quot; &amp;&amp; CB_JSONData !== null) { JSONObject = CB_JSONData; } } //If we do not want vanilla JavaScript rendering and Handlebars is present, uses it: if (!forceVanilla &amp;&amp; typeof(Handlebars) !== &quot;undefined&quot; &amp;&amp; Handlebars !== null &amp;&amp; typeof(Handlebars.compile) === &quot;function&quot;) { //Returns the template rendered: return Handlebars.compile(string)(JSONObject); //Using Handlebars. } //...otherwise, just replaces all occurrences in the given string: else { return CB_renderStringRecursively(string, JSONObject, false, depthLevelMax); } } //Renders a given string recursively with the given object and the given max level: function CB_renderStringRecursively(string, desiredObject, avoidRecursive, depthLevelMax, levelCurrent, pathCurrent) { if (typeof(desiredObject) === &quot;undefined&quot; || desiredObject === null) { return string; } if (typeof(depthLevelMax) === &quot;undefined&quot; || depthLevelMax === null || isNaN(depthLevelMax)) { depthLevelMax = 10; } if (typeof(levelCurrent) === &quot;undefined&quot; || levelCurrent === null || isNaN(levelCurrent)) { levelCurrent = 0; } if (typeof(pathCurrent) === &quot;undefined&quot; || pathCurrent === null) { pathCurrent = &quot;&quot;; } if (pathCurrent.substring(0, 1) === &quot;.&quot;) { pathCurrent = pathCurrent.substring(1); } for (var property in desiredObject) { if (CB_sizeof(desiredObject[property]) === 0 || CB_isString(desiredObject[property])) { string = string.replace(CB_regularExpressionString(&quot;{{&quot; + pathCurrent + (pathCurrent === &quot;&quot; ? &quot;&quot; : &quot;.&quot;) + property + &quot;}}&quot;, true, false), desiredObject[property]); } else if (!avoidRecursive &amp;&amp; levelCurrent &lt; depthLevelMax) { string = CB_renderStringRecursively(string, desiredObject[property], avoidRecursive, depthLevelMax, ++levelCurrent, pathCurrent + &quot;.&quot; + property); string = string.replace(CB_regularExpressionString(&quot;{{&quot; + pathCurrent + (pathCurrent === &quot;&quot; ? &quot;&quot; : &quot;.&quot;) + property + &quot;}}&quot;, true, false), &quot;&quot;); //In the case is has not been found, clears it. } } return string; } /** * Tells whether a given email is valid or not. Not really precise. * @function * @param {string} email - Possible email that we want to validate. * @returns {boolean} */ //* Source: steve @ http://stackoverflow.com/questions/46155/validate-email-address-in-javascript function CB_isEmail(email) { return (CB_isString(email) &amp;&amp; email.indexOf(&quot;..&quot;) === -1 &amp;&amp; /^((([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(email)); } /** * Returns the given number with the desired decimals and make it a string if we want to (so it will be able to have trailing zeros). Uses decimal numeral system only. It will perform ceiling round automatically if needed. * @function * @param {integer|float|string} number - The number that we want to format. It can be a string. * @param {integer} [decimals=2] - The number of decimals we want to allow. * @param {boolean} [stringify=false] - Set to true if we want it to return a string (filled with trailing zeros to reach the desired number of decimals). * @returns {integer|float|string} Returns zero in the case a non-valid number has been provided. * @todo Allow to define a minimum length for the integer part of the &quot;number&quot; parameter, so it will fill with leading zeros if needed (when &quot;stringify&quot; is set to true). Think about allowing to define a maximum too. */ function CB_numberFormat(number, decimals, stringify) { number = parseFloat(number); if (isNaN(number)) { return 0; } decimals = parseInt(decimals); if (isNaN(decimals) || decimals &lt; 0) { decimals = 2; } number *= Math.pow(10, decimals); number = parseInt(number + 0.5); //Ceil round. number /= Math.pow(10, decimals); if (stringify) { number = number + &quot;&quot;; //if (number.indexOf(&quot;.&quot;) === -1) { number += &quot;.00&quot;; } //else if (number.substring(number.indexOf(&quot;.&quot;) + 1).length === 1) { number += &quot;0&quot;; } if (decimals &gt;= 1 &amp;&amp; number.indexOf(&quot;.&quot;) === -1) { number += &quot;.&quot;; } while (number.substring(number.indexOf(&quot;.&quot;) + 1).length &lt; decimals) { number += &quot;0&quot;; } } return number; } /** * Alias for {@link CB_countDecimalPart}. * @function CB_countDecimals * @see {@link CB_countDecimalPart} */ /** * Alias for {@link CB_countDecimalPart}. * @function CB_countDecimalDigits * @see {@link CB_countDecimalPart} */ /** * Alias for {@link CB_countDecimalPart}. * @function CB_numberOfDecimals * @see {@link CB_countDecimalPart} */ /** * Alias for {@link CB_countDecimalPart}. * @function CB_numberOfDecimalDigits * @see {@link CB_countDecimalPart} */ /** * Returns the number of decimals of the given number. It also works with numbers in exponential notation (as for example '1e-13' which would be 0.0000000000001). * @function * @param {integer|float|string} number - The number whose decimals we want to count. It can be a string. * @returns {integer} Returns zero in the case a non-valid number has been provided. Otherwise, it returns the number of decimals counted. */ var CB_countDecimalPart = CB_countDecimalDigits = CB_countDecimals = CB_numberOfDecimals = CB_numberOfDecimalDigits = function(number) { number = parseFloat(number); if (isNaN(number)) { return 0; } number = Math.abs(number); if (number % 1 === 0) { return 0; } //First it tries &quot;fastest&quot; way (it does not work for numbers in exponential notation): var decimals = (number + &quot;&quot;).split(&quot;.&quot;); decimals = (typeof(decimals[1]) !== &quot;undefined&quot;) ? decimals[1].length : 0; if (decimals &gt; 0) { return decimals; } //For float numbers that are represented in exponential notation (like '1e-13', for example): decimals = 0; var numberMultiplied = 0; while ((numberMultiplied = number * Math.pow(10, ++decimals)) % 1 !== 0); return decimals; } /** * Alias for {@link CB_countIntegerPart}. * @function CB_numberOfIntegerDigits * @see {@link CB_countIntegerPart} */ /** * Alias for {@link CB_countIntegerPart}. * @function CB_countIntegerDigits * @see {@link CB_countIntegerPart} */ /** * Returns the number of integer digits (the number of digits that belong to the integer part) of the given number. It also works with numbers in exponential notation (as for example '1e-13' which would be 0.0000000000001). * @function * @param {integer|float|string} number - The number whose integer digits (the digits that belong to the integer part) we want to count. It can be a string. * @returns {integer} Returns zero in the case a non-valid number has been provided. Otherwise, it returns the number of integer digits (the number of digits that belong to the integer part) counted. */ var CB_countIntegerPart = CB_countIntegerDigits = CB_numberOfIntegerDigits = function(number) { number = parseFloat(number); if (isNaN(number)) { return 0; } number = Math.abs(number); if (number &lt; 1) { return 0; } //First it tries &quot;fastest&quot; way (it does not work for numbers in exponential notation): var integers = (number + &quot;&quot;).split(&quot;.&quot;); integers = (typeof(integers[1]) !== &quot;undefined&quot;) ? integers[0].length : 0; if (integers &gt; 0) { return integers; } //For float numbers that are represented in exponential notation (like '1e-13', for example): integers = 0; var numberMultiplied = 0; while ((numberMultiplied = number / Math.pow(10, ++integers)) &gt; 1); return integers; } /** * Returns the value of a desired path in an object or an empty string if it cannot be found. * @function * @param {Object} object - The object where we want to find the path. * @param {string} path - The path that will be search in the given object to retrieve the value. It should use the string defined in the &quot;splitString&quot; parameter to separate items. If it is empty or not provided, it will just return the given &quot;object&quot; again. * @param {string} [splitString=&quot;.&quot;] - The string that will be used to separate one item from another one. By default, it will be a dot (&quot;.&quot;) so, for example, a given &quot;path&quot; with a value of &quot;hello.world&quot; will indicate the &quot;object.hello.world&quot; path. * @returns {*} Returns the value of a desired path in an object or an empty string if it cannot be found. If the &quot;path&quot; parameter is empty or not provided, it will just return the given &quot;object&quot; again. */ function CB_getValuePath(object, path, splitString) { if (CB_sizeof(object) === 0 || CB_isString(object)) { return &quot;&quot;; } path = CB_trim(path); if (path === &quot;&quot;) { return object; } if (!CB_isString(splitString) || splitString.length &lt; 1) { splitString = &quot;.&quot;; } var indexes = path.split(splitString); var indexesLength = indexes.length; var index; var value = object; for (var x = 0; x &lt; indexesLength; x++) { index = CB_trim(indexes[x]); value = CB_getValueIndex(value, index, &quot;&quot;); if (CB_sizeof(value) === 0 || CB_isString(value)) { break; } } return (x + 1 === indexesLength) ? value : &quot;&quot;; } var CB_setDatumDateObject = new Date(); /** * Stores a value using [Web Storage API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API} ([localStorage]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}). It can use [localStorage]{@link https://github.com/mortzdk/localStorage} as a fallback or cookies instead. * @function * @param {string|number} index - The index where the value given will be stored. * @param {string|number} value - The value we want to store. It should be a string or a number. * @param {integer} [days] - The number of days after which the cookie will expire (in the case that cookies are used). It belongs to the &quot;expires=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. * @param {string} [path] - The path where the cookie will be stored (in the case that cookies are used). It belongs to the &quot;path=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. * @param {boolean} [forceCookie=false] - Forces to use cookies instead of [Web Storage API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API} ([localStorage]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}). * @returns {boolean} Returns true if the value has been stored successfully (not totally reliable, it should be checked with {@link CB_getDatum} after a while). */ function CB_setDatum(index, value, days, path, forceCookie) { index += &quot;&quot;; value += &quot;&quot;; if (!forceCookie &amp;&amp; window.localStorage &amp;&amp; window.localStorage.setItem) { try { localStorage.setItem(index, value); return true; } catch(E) { } } if (typeof(document.cookie) !== &quot;undefined&quot; &amp;&amp; document.cookie !== null) { try { path = CB_trim(path); if (path !== &quot;&quot;) { path = &quot;;path=&quot; + escape(path); } var expires = &quot;&quot;; if (typeof(days) !== &quot;undefined&quot; &amp;&amp; days !== null &amp;&amp; !isNaN(days) &amp;&amp; days &gt;= 0 &amp;&amp; days &lt;= 365) { CB_setDatumDateObject.setTime(CB_setDatumDateObject.getTime() + (days * 24 * 60 * 60 * 1000)); expires = &quot;;expires=&quot; + CB_setDatumDateObject.toUTCString(); } document.cookie = escape(index) + &quot;=&quot; + escape(value) + expires + path; return true; } catch(E) { } } return false; } /** * Stores a cookie. * @function * @param {string|number} index - The index where the value given will be stored. * @param {string|number} value - The value we want to store. It should be a string or a number. * @param {integer} [days] - The number of days after which the cookie will expire. It belongs to the &quot;expires=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. * @param {string} [path] - The path where the cookie will be stored. It belongs to the &quot;path=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. * @returns {boolean} Returns true if the value has been stored successfully (not totally reliable, it should be checked with {@link CB_getCookie} after a while). */ function CB_setCookie(index, value, days, path) { return CB_setDatum(index, value, days, path, true); } /** * Gets, from its index, a previous value stored. It will try to get it using [Web Storage API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API} ([localStorage]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}). It can use [localStorage]{@link https://github.com/mortzdk/localStorage} as a fallback or cookies instead. * @function * @param {string} index - The index whose value we want to retrieve. * @param {boolean} [forceCookie=false] - Forces to use cookies instead of [Web Storage API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API} ([localStorage]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage}). * @param {boolean} [unescapeIndex=false] - Applies the unescape function to the value before returning it. Only applies when cookies are used. * @returns {string|null} Returns null when the value cannot be found. */ function CB_getDatum(index, forceCookie, unescapeIndex) { var itemFound = null; if (window.localStorage &amp;&amp; window.localStorage.getItem &amp;&amp; !forceCookie) { itemFound = localStorage.getItem(index); } if (itemFound === null &amp;&amp; typeof(document.cookie) !== &quot;undefined&quot; &amp;&amp; document.cookie !== null) { index += &quot;=&quot;; if (unescapeIndex) { index = unescape(index); } var cookies = document.cookie.split(&quot;;&quot;); var cookies_length = cookies.length; for (var x = 0; x &lt; cookies_length; x++) { if (cookies[x].indexOf(index) !== -1) { return unescape(cookies[x].substring(cookies[x].indexOf(index) + index.length, cookies[x].length)); } } } return itemFound; } /** * Returns, from its index, a previous stored cookie. * @function * @param {string} index - The index whose value we want to retrieve. * @returns {string|null} Returns null when the value cannot be found. */ function CB_getCookie(index) { return CB_getDatum(index, true); } /** * Gets the value from a given object which belongs to the desired index or returns the value of &quot;returnValueOnFail&quot; if it cannot be found. * @function * @param {Object} object - The object from which we want to get the value. * @param {string} index - The index whose value we want to retrieve. * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that the property cannot be found. If not provided, undefined will be returned. * @returns {*} Returns the value from a given object which belongs to the desired index or the value of &quot;returnValueOnFail&quot; otherwise if it cannot be found. */ function CB_getValueIndex(object, index, returnValueOnFail) { if (typeof(object) !== &quot;undefined&quot; &amp;&amp; object !== null &amp;&amp; typeof(object[index]) !== &quot;undefined&quot; &amp;&amp; object[index] !== null) { return object[index]; } else { return returnValueOnFail; } } /** * Returns an object copied from the given one. * @function * @param {object} element - The element whose properties and values we want to copy. It should be an object. * @param {boolean} [onlyOwn=false] - If the &quot;element&quot; given is not an object, this parameter will be ignored. Otherwise, if it is set to true, it will only have into account the properties which the object has as their own property and have not been inherited (using the [Object.hasOwnProperty]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty} method). * @returns {object} Returns an object copied from the given one. Returns an empty object if the given &quot;element&quot; was not an object. */ function CB_copyObject(object, onlyOwn) { if (typeof(object) !== &quot;object&quot; || object === null) { return {}; } var newObject = {}; for (var key in object) { if (!onlyOwn || object.hasOwnProperty(key)) { newObject[key] = object[key]; } } return newObject; } /** * Gets the value of a desired property of a given JSON object. Uses the {@link CB_getValueIndex} function internally. * @function * @param {Object|string} JSONObject - The JSON object from which we want to get the value. If it is a string, it will try to parse it to create a real object from it. Used as the &quot;object&quot; parameter when calling the {@link CB_getValueIndex} function internally. * @param {string} property - The property whose value we want to retrieve. If not provided, the given object will be returned again. Used as the &quot;index&quot; parameter when calling the {@link CB_getValueIndex} function internally. * @param {*} [returnValueOnFail] - The value we want it to return in the case it cannot be parsed. If not provided, undefined will be returned. Used as the &quot;returnValueOnFail&quot; parameter when calling the {@link CB_getValueIndex} function internally. * @returns {*} Returns the given &quot;JSONObject&quot; again (after trying to parse it if it was a string, if possible) if the &quot;property&quot; value was not given. Returns the value from the given object which belongs to the desired property or the value of &quot;returnValueOnFail&quot; otherwise if it cannot be found. */ function CB_getJSONPropertyValue(JSONObject, property, returnValueOnFail) { if (CB_isString(JSONObject)) { JSONObject = CB_parseJSON(JSONObject, undefined, null); } //If a string is received, tries to parse it as a JSON object. if (typeof(property) === &quot;undefined&quot; || property === null) { return JSONObject; } return CB_getValueIndex(JSONObject, property, returnValueOnFail); /* if (typeof(JSONObject) === &quot;undefined&quot; || JSONObject === null) { //if (!property || returnObjectOnFail) { return JSONObject; } return returnValueOnFail; } //else if (property &amp;&amp; typeof(JSONObject[property]) !== &quot;undefined&quot; &amp;&amp; JSONObject[property] !== null) { return JSONObject[property]; } //else if (!property || returnObjectOnFail) { return JSONObject; } else if (typeof(JSONObject[property]) !== &quot;undefined&quot; &amp;&amp; JSONObject[property] !== null) { return JSONObject[property]; } else { return returnValueOnFail; } */ } /** * Tries to parse a given string to convert it into a JSON object. Internally it will use the native [JSON.parse]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse} method or otherwise use [JSON 3]{@link https://bestiejs.github.io/json3/} instead. * @function * @param {string} objectString - The JSON object we want to parse, in string format. First parameter when calling the [JSON.parse]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse} method (or equivalent) * @param {function} [reviver] - Second parameter when calling the [JSON.parse]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse} method (or equivalent). * @param {*} [returnValueOnFail] - The value we want it to return in the case it cannot be parsed. If not provided, undefined will be returned. * @param {boolean} [acceptUndefinedOrNull=false] - If it is set to true and the given objectString is undefined or null, an empty object ({}) will be used as the objectString. * @param {function} [onError] - Callback which will be called if it failed to be parsed (it will receive the &quot;objectString&quot; as the unique parameter). * @returns {*} Returns the object parsed from the given string or the value of &quot;returnValueOnFail&quot; otherwise (which will be undefined if not provided). */ function CB_parseJSON(objectString, reviver, returnValueOnFail, acceptUndefinedOrNull, onError) { if (typeof(objectString) === &quot;undefined&quot; || objectString === null) { if (acceptUndefinedOrNull) { objectString = '{}'; } } objectString = objectString + &quot;&quot;; try { return JSON.parse(objectString, reviver); } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError(objectString); } return returnValueOnFail; } } /** * Tries to create a JSON valid string from a given JSON object or value. Internally it will use the native [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} method or otherwise use [JSON 3]{@link https://bestiejs.github.io/json3/} instead. * @function * @param {*} objectOrValue - The object or value that we want to stringify. First parameter when calling the [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} method (or equivalent). * @param {function} [replacer] - Second parameter when calling the [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} method (or equivalent). * @param {string|integer} [space] - Third parameter when calling the [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} method (or equivalent). * @param {*} [returnValueOnFail] - The value we want it to return in the case it cannot be stringify. If not provided, undefined will be returned. * @param {boolean} [failIfUndefinedOrNull=false] - If it is set to true and the returning value is undefined or null, the value of &quot;returnValueOnFail&quot; will be returned. * @param {function} [onError] - Callback which will be called if it failed to be stringified (it will receive the &quot;objectOrValue&quot; as the unique parameter). * @returns {string} Returns the object stringified from the given object or value if possible or the value of &quot;returnValueOnFail&quot; otherwise (which will be undefined if not provided). Avoids returning undefined or null if &quot;failIfUndefinedOrNull&quot; is set to true, returning the value of &quot;returnValueOnFail&quot; instead. */ function CB_stringifyJSON(objectOrValue, replacer, space, returnValueOnFail, failIfUndefinedOrNull, onError) { try { var valueReturned = JSON.stringify(objectOrValue, replacer, space); if (failIfUndefinedOrNull &amp;&amp; (typeof(valueReturned) === &quot;undefined&quot; || valueReturned === null || valueReturned === &quot;null&quot;)) { return returnValueOnFail; } return valueReturned; } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError(objectOrValue); } return returnValueOnFail; } } /** * Tries to combine two given values guessing the best way to do it and returns their combination. Using the following rules: &lt;br /&gt; If both values are either undefined or null, returns null. &lt;br /&gt; Otherwise, if both values are boolean, returns the AND operation for the two of them (a &amp;&amp; b). &lt;br /&gt; Otherwise, if either of the two is a string (not empty) and is not JSON valid, combines them as URL (GET) parameters using {@link CB_combineURIParameters}. &lt;br /&gt; Otherwise, if either of them is JSON valid, combines them as JSON using {@link CB_combineJSON} (passing the received avoidDuplicatedValuesInArray value as a parameter). &lt;br /&gt; Otherwise, combines them as arrays or objects using {@link CB_combineArraysOrObjects} (passing the received &quot;avoidDuplicatedValuesInArray&quot; value as a parameter). * @function * @param {*} [a=null|[]|{}] - First value. It can be optional if &quot;b&quot; is a valid value, defined and not null. * @param {*} [b=null|[]|{}] - Second value. It can be optional if &quot;a&quot; is a valid value, defined and not null. * @param {boolean} [avoidDuplicatedValuesInArray=false] - Parameter that will be used in the case that {@link CB_combineJSON} or {@link CB_combineArraysOrObjects} is called. * @param {boolean} [modifyArrayOrObjectA=false] - Parameter that will be used in the case that {@link CB_combineJSON} or {@link CB_combineArraysOrObjects} is called. If set to true, it will modify the original &quot;a&quot; array or object. * @returns {*} */ function CB_combineAutomatically(a, b, avoidDuplicatedValuesInArray, modifyArrayOrObjectA) { if ((typeof(a) === &quot;undefined&quot; || a === null) &amp;&amp; (typeof(b) === &quot;undefined&quot; || b === null)) { return null; } else if ((a === true || a === false) &amp;&amp; (b === true || b === false)) { return a &amp;&amp; b; } var aJSON = CB_parseJSON(a, undefined, null); var bJSON = CB_parseJSON(b, undefined, null); //If either of the two is a string (not empty) and is not JSON valid, combines them as URL (GET) parameters: if (CB_isString(a) &amp;&amp; CB_trim(a) !== &quot;&quot; &amp;&amp; aJSON === null || CB_isString(b) &amp;&amp; CB_trim(b) !== &quot;&quot; &amp;&amp; bJSON === null) { return CB_combineURIParameters(a, b); } //...otherwise, if either of them is JSON valid, combines them as JSON: else if (typeof(aJSON) !== &quot;undefined&quot; &amp;&amp; aJSON !== null &amp;&amp; aJSON !== true &amp;&amp; aJSON !== false || typeof(bJSON) !== &quot;undefined&quot; &amp;&amp; bJSON !== null &amp;&amp; bJSON !== true &amp;&amp; bJSON !== false) { return CB_combineJSON(a, b, avoidDuplicatedValuesInArray, modifyArrayOrObjectA); } //...otherwise, combines them as associative arrays or objects: else { return CB_combineArraysOrObjects(a, b, avoidDuplicatedValuesInArray, modifyArrayOrObjectA); } } /** * Alias for {@link CB_combineURIParameters}. * @function CB_combineURLParameters * @see {@link CB_combineURIParameters} */ /** * Combines two strings as URL (GET) parameters. If either &quot;parametersA&quot; or &quot;parametersB&quot; is not a string, internally it will use the native [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} method if available or otherwise it will use [JSON 3]{@link https://bestiejs.github.io/json3/} instead. * @function * @param {string} parametersA - String with the desired parameter or parameters. It can be optional if &quot;parametersB&quot; is a valid string. It will trim any &quot;&amp;&quot; and &quot;?&quot; character at the beginning and at the end, and finally use &quot;&amp;&quot; to concatenate the two strings (if needed). * @param {string} parametersB - String with the desired parameter or parameters. It can be optional if &quot;parametersA&quot; is a valid string. It will trim any &quot;&amp;&quot; and &quot;?&quot; character at the beginning and at the end, and finally use &quot;&amp;&quot; to concatenate the two strings (if needed). * @returns {string} For example, if parametersA is &quot;parameter1=value1&amp;amp;parameter2=value2&quot; and parametersB is &quot;parameter3=value3&amp;amp;what=ever&quot; then it will return &quot;parameter1=value1&amp;amp;parameter2=value2&amp;amp;parameter3=value3&amp;amp;what=ever&quot;. */ function CB_combineURIParameters(parametersA, parametersB) { if (typeof(parametersA) === &quot;undefined&quot; || parametersA === null) { parametersA = &quot;&quot;; } if (typeof(parametersB) === &quot;undefined&quot; || parametersB === null) { parametersB = &quot;&quot;; } if (!CB_isString(parametersA)) { parametersA = JSON.stringify(parametersA); if (!CB_isString(parametersA)) { parametersA = &quot;&quot;; } } if (!CB_isString(parametersB)) { parametersB = JSON.stringify(parametersB); if (!CB_isString(parametersB)) { parametersB = &quot;&quot;; } } if (parametersA !== &quot;&quot;) { parametersA = CB_trim(CB_trim(parametersA), [&quot;&amp;&quot;, &quot;?&quot;]); } if (parametersB !== &quot;&quot;) { parametersB = CB_trim(CB_trim(parametersB), [&quot;&amp;&quot;, &quot;?&quot;]); } return CB_trim(parametersA + &quot;&amp;&quot; + parametersB, &quot;&amp;&quot;); } var CB_combineURLParameters = CB_combineURIParameters; //Alias for the function. /** * Returns a combined array or object from two arrays or objects. Using the following rules: &lt;br /&gt; If they both are arrays (numeric indexes), it will keep all elements (attaching the elements of the second array after the elements of the first one). &lt;br /&gt; Otherwise, if either of them is not an array (it should be an associative array which is an object in JavaScript), it will merge the elements (overwritting those whose index is the same and keeping the ones from the second array/object): * @function * @param {array|Object|string|null|undefined} [arrayOrObjectA=[]|{}] - One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectB&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectB&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectB&quot; is an array or it will be an empty object otherwise. * @param {array|Object|string|null|undefined} [arrayOrObjectB=[]|{}] - One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectA&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectA&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectA&quot; is an array or it will be an empty object otherwise. * @param {boolean} avoidDuplicatedValuesInArray - Tells whether to avoid or allow items with duplicated values in the returned array or not. Only applies when both arrays to combine are numeric arrays. * @param {boolean} [modifyArrayOrObjectA=false] - Parameter that will be used in the case that {@link CB_combineJSON} or {@link CB_combineArraysOrObjects} is called. If set to true, it will modify the original &quot;arrayOrObjectA&quot; array or object. * @returns {array|Object} */ function CB_combineArraysOrObjects(arrayOrObjectA, arrayOrObjectB, avoidDuplicatedValuesInArray, modifyArrayOrObjectA) { if (typeof(arrayOrObjectA) === &quot;undefined&quot; || arrayOrObjectA === null || arrayOrObjectA === true || arrayOrObjectA === false) { arrayOrObjectA = CB_isArray(arrayOrObjectB) ? [] : {}; } if (typeof(arrayOrObjectB) === &quot;undefined&quot; || arrayOrObjectB === null || arrayOrObjectB === true || arrayOrObjectB === false) { arrayOrObjectB = CB_isArray(arrayOrObjectA) ? [] : {}; } if (CB_isString(arrayOrObjectA)) { arrayOrObjectA = CB_parseJSON(arrayOrObjectA, undefined, null); if (arrayOrObjectA === null) { arrayOrObjectA = CB_isArray(arrayOrObjectB) ? [] : {}; } } if (CB_isString(arrayOrObjectB)) { arrayOrObjectB = CB_parseJSON(arrayOrObjectB, undefined, null); if (arrayOrObjectB === null) { arrayOrObjectB = CB_isArray(arrayOrObjectA) ? [] : {}; } } var mergedObjectOrArray; //If they both are arrays, it will keep all elements (attaching the elements of the second array after the elements of the first one): if (CB_isArray(arrayOrObjectA) &amp;&amp; CB_isArray(arrayOrObjectB)) { if (modifyArrayOrObjectA) { mergedObjectOrArray = arrayOrObjectA; if (!avoidDuplicatedValuesInArray) { mergedObjectOrArray = CB_Arrays.removeDuplicated(mergedObjectOrArray, undefined, false); } } else { mergedObjectOrArray = []; var arrayOrObjectALength = arrayOrObjectA.length; for (var x = 0; x &lt; arrayOrObjectALength; x++) { if (!avoidDuplicatedValuesInArray || CB_indexOf(mergedObjectOrArray, arrayOrObjectA[x]) === -1) { mergedObjectOrArray[x] = arrayOrObjectA[x]; } } } var arrayOrObjectBLength = arrayOrObjectB.length; for (var x = 0; x &lt; arrayOrObjectBLength; x++) { if (!avoidDuplicatedValuesInArray || CB_indexOf(mergedObjectOrArray, arrayOrObjectB[x]) === -1) { mergedObjectOrArray[mergedObjectOrArray.length] = arrayOrObjectB[x]; } } } //...otherwise, if either of them is not an array, it will merge the elements (overwritting those whose index is the same and keeping the ones from the second object/array): else { if (modifyArrayOrObjectA) { mergedObjectOrArray = arrayOrObjectA; if (!avoidDuplicatedValuesInArray &amp;&amp; CB_isArray(arrayOrObjectA)) { mergedObjectOrArray = CB_Arrays.removeDuplicated(arrayOrObjectA, undefined, false); } } else { mergedObjectOrArray = {}; for (var propertyName in arrayOrObjectA) { mergedObjectOrArray[propertyName] = arrayOrObjectA[propertyName]; } } for (var propertyName in arrayOrObjectB) { mergedObjectOrArray[propertyName] = arrayOrObjectB[propertyName]; } } return mergedObjectOrArray; } /** * Alias for {@link CB_combineArraysOrObjects}. * @function CB_combineJSON * @see {@link CB_combineArraysOrObjects} */ var CB_combineJSON = CB_combineArraysOrObjects; /* function CB_combineJSON(JSONObjectA, JSONObjectB, avoidDuplicatedValuesInArray, modifyArrayOrObjectA) { return CB_combineArraysOrObjects(JSONObjectA, JSONObjectB, avoidDuplicatedValuesInArray, modifyArrayOrObjectA); } */ /** Object that contains different properties and methods that can be used as the &quot;baseSymbols&quot; parameter for the {@link CB_intToBase} and {@link CB_baseToInt} functions. Each property is a numeric array of characters. * @namespace * @type {Object} */ var CB_baseSymbols = { &quot;_getCache&quot; : { &quot;max&quot; : [] }, /** * Function that will return a numeric array of characters containing as many items as the desired base. Uses a cache internally. * @function * @param {integer} [base=256] - The desired base (number of items, each with a character, that the returning array will contain). Minimum value is 1. The maximum can differ one client to another but it is not recommended to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). All arrays of bases lower than 87 use the symbols included also in base 87. * @returns {array} Returns a numeric array of characters containing as many items as the desired base. All arrays of bases lower than 87 use the symbols included also in base 87. When the base is greater than 87 and it is not not created by default (88 and 128), each item of the returning array will be the result of calling the [String.fromCharCode]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode} function from 0 to one number less than the desired base number. */ &quot;get&quot; : function(base) { if (typeof(base) === &quot;undefined&quot; || base === null || isNaN(base) || base &lt; 1) { base = 256; } if (CB_isArray(CB_baseSymbols[base]) &amp;&amp; CB_baseSymbols[base].length === base) { return CB_baseSymbols[base]; } else if (CB_isArray(CB_baseSymbols._getCache[base]) &amp;&amp; CB_baseSymbols._getCache[base].length === base) { return CB_baseSymbols._getCache[base]; } var baseSymbols = []; var _getCacheLength = CB_baseSymbols._getCache.max.length; //if (_getCacheLength === base) { return CB_baseSymbols._getCache.max; } for (var x = 0; x &lt; base &amp;&amp; x &lt; _getCacheLength; x++) { baseSymbols[x] = CB_baseSymbols._getCache.max[x]; } for (; x &lt; base; x++) { CB_baseSymbols._getCache.max[x] = baseSymbols[x] = String.fromCharCode(x); } CB_baseSymbols._getCache[base] = baseSymbols; return baseSymbols; }, /** * Alias for {@link CB_baseSymbols.128}. * @var CB_baseSymbols._128 * @see {@link CB_baseSymbols.128} */ &quot;_128&quot; : [], /** * Numeric array of characters with 128 symbols. These symbols (and also the ones from other bases with higher number) will be encoded by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function and also by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function and they will need to be encoded in HTML (not recommended for URI components or JavaScript strings or HTML code). * @type {array} * @default An array with each item being the result of calling the [String.fromCharCode]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode} function from 0 to 127 as its unique parameter. */ &quot;128&quot; : [], /** * Alias for {@link CB_baseSymbols.88}. * @var CB_baseSymbols._88 * @see {@link CB_baseSymbols.88} */ /** * Numeric array of characters with 88 symbols. These symbols will be encoded by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function and also by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function, but they will not need to be encoded in HTML (not recommended for URI components or JavaScript strings, but useful for HTML code). * @type {array} * @default */ &quot;88&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;.&quot;, &quot;~&quot;, &quot;!&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;, &quot;*&quot;, &quot;-&quot;, &quot;_&quot;, &quot;@&quot;, &quot;\\\\&quot;, &quot;/&quot;, &quot;|&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, &quot;$&quot;, &quot;%&quot;, &quot;=&quot;, &quot;?&quot;, &quot;^&quot;, &quot;:&quot;, &quot;;&quot;, &quot;,&quot;, &quot;+&quot; ], /** * Alias for {@link CB_baseSymbols.87}. * @var CB_baseSymbols._87 * @see {@link CB_baseSymbols.87} */ /** * Numeric array of characters with 87 symbols. These symbols will be encoded by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function and also by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function but they will not need to be encoded neither in JavaScript strings nor in HTML (not recommended for URI components, but useful for JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;87&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;.&quot;, &quot;*&quot;, &quot;-&quot;, &quot;_&quot;, &quot;~&quot;, &quot;!&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;, &quot;@&quot;, &quot;/&quot;, &quot;|&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, &quot;$&quot;, &quot;%&quot;, &quot;=&quot;, &quot;?&quot;, &quot;^&quot;, &quot;:&quot;, &quot;;&quot;, &quot;,&quot;, &quot;+&quot; ], /** * Alias for {@link CB_baseSymbols.71}. * @var CB_baseSymbols._71 * @see {@link CB_baseSymbols.71} */ /** * Numeric array of characters with 71 symbols. These symbols will be encoded by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function but not by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (not recommended for URI components in old clients, but useful for URI components in new clients with [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function support, for JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;71&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;.&quot;, &quot;*&quot;, &quot;-&quot;, &quot;_&quot;, &quot;~&quot;, &quot;!&quot;, &quot;'&quot;, &quot;(&quot;, &quot;)&quot;], /** * Alias for {@link CB_baseSymbols.66}. * @var CB_baseSymbols._66 * @see {@link CB_baseSymbols.66} */ /** * Numeric array of characters with 66 symbols. These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code). Includes Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;66&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;.&quot;, &quot;*&quot;, &quot;-&quot;, &quot;_&quot; ], /** * Alias for {@link CB_baseSymbols.64}. * @var CB_baseSymbols._64 * @see {@link CB_baseSymbols.64} */ /** * Numeric array of characters with 64 symbols (using 0 to 9, A to Z, a to z, &quot;.&quot; and &quot;*&quot;). These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code in the case that we do not want to use base 66 from the {@link CB_baseSymbols.66} property). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;64&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;.&quot;, &quot;*&quot; ], /** * Alias for {@link CB_baseSymbols.16}. * @var CB_baseSymbols._16 * @see {@link CB_baseSymbols.16} */ /** * Numeric array of characters with 16 symbols (using 0 to 9, A to F), hexadecimal system. These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;16&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; ], /** * Alias for {@link CB_baseSymbols.10}. * @var CB_baseSymbols._10 * @see {@link CB_baseSymbols.10} */ /** * Numeric array of characters with 10 symbols (using 0 to 9), decimal system. These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;10&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot; ], /** * Alias for {@link CB_baseSymbols.8}. * @var CB_baseSymbols._8 * @see {@link CB_baseSymbols.8} */ /** * Numeric array of characters with 8 symbols (using 0 to 7), octal system. These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). * @type {array} * @default */ &quot;8&quot; : [ &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot; ], /** * Alias for {@link CB_baseSymbols.2}. * @var CB_baseSymbols._8 * @see {@link CB_baseSymbols.2} */ /** * Numeric array of characters with 2 symbols (using 0 and 1), binary system. These symbols will not be encoded neither by the [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function nor by the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function (recommended for URI components for any client, JavaScript strings or HTML code). * @type {array} * @default */ &quot;2&quot; : [ &quot;0&quot;, &quot;1&quot; ] }; CB_baseSymbols._128 = CB_baseSymbols[&quot;128&quot;] = CB_baseSymbols.get(128); CB_baseSymbols._88 = CB_baseSymbols[&quot;88&quot;]; CB_baseSymbols._87 = CB_baseSymbols[&quot;87&quot;]; CB_baseSymbols._71 = CB_baseSymbols[&quot;71&quot;]; CB_baseSymbols._66 = CB_baseSymbols[&quot;66&quot;]; CB_baseSymbols._64 = CB_baseSymbols[&quot;64&quot;]; CB_baseSymbols._16 = CB_baseSymbols[&quot;16&quot;]; CB_baseSymbols._10 = CB_baseSymbols[&quot;10&quot;]; CB_baseSymbols._8 = CB_baseSymbols[&quot;8&quot;]; CB_baseSymbols._2 = CB_baseSymbols[&quot;2&quot;]; for (CB_baseSymbols._x = 3; CB_baseSymbols._x &lt; 87; CB_baseSymbols._x++) { if (typeof(CB_baseSymbols[CB_baseSymbols._x]) !== &quot;undefined&quot;) { continue; } CB_baseSymbols[&quot;_&quot; + CB_baseSymbols._x] = CB_baseSymbols[CB_baseSymbols._x] = CB_baseSymbols._87.slice(0, CB_baseSymbols._x); } /** * Converts a given integer into a desired base. * @function * @param {integer|string} number - The integer that we want to convert to the desired base. For bigger numbers (up to 999999999999999934464 or even lower, depending on the client and the &quot;baseSymbols&quot; used), it is recommended to use a string which will allow to accept a slightly bigger number (up to 999999999999999999999999 or lower, depending on the client and the &quot;baseSymbols&quot; used). Really big numbers will not be codified properly even when passed as a string due to the limitations of JavaScript engines and maximum number allowed to be stored in a variable. * @param {array|integer} [baseSymbols={@link CB_baseSymbols.66}] - Array with the desired symbols, using only one per index (their value will correspond to their index). The base (radix) will be the total number of indexes. If an integer greater or equal than 2 is provided, it will try to use it as an index of the {@link CB_baseSymbols} object and use it if found or use it as a parameter to call the {@link CB_baseSymbols.get} function otherwise. If not provided or the integer is lower than 2, it will use base 66 (defined in the {@link CB_baseSymbols._66} property of the {@link CB_baseSymbols} object). It is recommended not to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). The properties of the {@link CB_baseSymbols} object or the {@link CB_baseSymbols.get} function can be used for this parameter. * @param {boolean} [unsigned=false] - Determines whether to treat the input and output numbers as unsigned or not. * @param {string} [minusSymbol='-'|'0'] - Determines the minus symbol or string for the output, to mark negative numbers. If not provided, it will be '-' for bases equal or lower than 16 (hexadecimal) or '0' (zero character) otherwise. This parameter is ignored if the &quot;unsigned&quot; parameter is set to true. * @param {prefix} [prefix='0'|'0x'|''] - Determines the prefix for the output. If not provided, it will be '0' (zero character) for base 8 (octal), '0x' for base 16 (hexadecimal) or nothing (empty string) for all the others. Use an empty string to avoid using anything. * @returns {string} Returns an empty string in the case that the given number cannot be parsed as an integer. Otherwise, returns the given number in the desired base as a string. * @todo Think about allowing the &quot;number&quot; parameter to be a very long string, for bigger numbers (to exceed the limit for integers). Internally, it would need to perform operations comparisons, divisions, remainder calculation with strings, etc. * @todo Think about allowing to specify the base for the integer (now it is 16 if it begins with &quot;0x&quot;, 8 if it begins with &quot;0&quot; and it is not a string or 10 otherwise, and newer clients can support '0b' for binaries, '0o' for octals, ). * @todo Think about accepting a decimal symbol to separate decimals and support float numbers. */ function CB_intToBase(number, baseSymbols, unsigned, minusSymbol, prefix) { number = parseInt(number); if (isNaN(number)) { return &quot;&quot;; } var isNegative = false; if (!unsigned &amp;&amp; number &lt; 0) { isNegative = true; } if (!CB_isArray(baseSymbols)) { if (typeof(baseSymbols) !== &quot;undefined&quot; &amp;&amp; baseSymbols !== null &amp;&amp; !isNaN(baseSymbols) &amp;&amp; baseSymbols &gt;= 2) { if (CB_isArray(CB_baseSymbols[baseSymbols])) { baseSymbols = CB_baseSymbols[baseSymbols]; } else { baseSymbols = CB_baseSymbols.get(baseSymbols); } } else { baseSymbols = CB_baseSymbols._66; } } baseRadix = baseSymbols.length; if (!unsigned &amp;&amp; isNegative &amp;&amp; (typeof(minusSymbol) === &quot;undefined&quot; || minusSymbol === null)) { minusSymbol = baseRadix &lt;= 16 ? &quot;-&quot; : &quot;0&quot;; } var total = &quot;&quot;; number = Math.abs(number); if (number &gt;= baseRadix) { total = CB_intToBase(number / baseRadix, baseSymbols, true, &quot;&quot;, &quot;&quot;); number = parseInt(number % baseRadix); } total += baseSymbols[number]; if (typeof(prefix) === &quot;undefined&quot; || prefix === null) { if (baseRadix === 8) { prefix = &quot;0&quot;; } else if (baseRadix === 16) { prefix = &quot;0x&quot;; } else { prefix = null; } } if (prefix !== null) { total = prefix + total; } if (!unsigned &amp;&amp; isNegative) { total = minusSymbol + total; } return total; } /** * Converts a given number which is already in a desired base into an integer (decimal base). &lt;br /&gt; Note: It can return wrong values when the value exceeds the maximum allowed by a number in the client's JavaScript engine. It can also depend on the &quot;baseSymbols&quot; used. * @function * @param {string} number - A string containing the number which is already in the desired base and that we want to convert to an integer. * @param {array|integer} [baseSymbols={@link CB_baseSymbols.66}] - Array with the desired symbols, using only one per index (their value will correspond to their index). The base (radix) will be the total number of indexes. It should be the base which is already being used by the given number. If an integer greater or equal than 2 is provided, it will try to use it as an index of the {@link CB_baseSymbols} object and use it if found or use it as a parameter to call the {@link CB_baseSymbols.get} function otherwise. If not provided or the integer is lower than 2, it will use base 66 (defined in the {@link CB_baseSymbols._66} property of the {@link CB_baseSymbols} object). It is recommended not to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). The properties of the {@link CB_baseSymbols} object or the {@link CB_baseSymbols.get} function can be used for this parameter. * @param {boolean} [unsigned=false] - Determines whether to treat the input and output numbers as unsigned or not. * @param {string} [minusSymbol='-'|'0'] - Determines the minus symbol or string for the input, to mark negative numbers. If not provided, it will be '-' for bases equal or lower than 16 (hexadecimal) or '0' (zero character) otherwise. This parameter is ignored if the &quot;unsigned&quot; parameter is set to true. * @param {prefix} [prefix='0'|'0x'|''] - Determines the prefix for the input. If not provided, it will be '0' (zero character) for base 8 (octal), '0x' for base 16 (hexadecimal) or nothing (empty string) for all the others. Use an empty string to avoid using anything. * @returns {integer} Returns the integer number in decimal base. * @todo Think about allowing to return a string, for bigger numbers (to exceed the limit for integers). Internally, it would need to perform operations comparisons, multiplications with strings, etc. * @todo Think about allowing to specify the base for the integer. * @todo Think about accepting a decimal symbol to separate decimals and support float numbers. */ function CB_baseToInt(number, baseSymbols, unsigned, minusSymbol, prefix) { number = &quot;&quot; + number; if (!CB_isArray(baseSymbols)) { if (typeof(baseSymbols) !== &quot;undefined&quot; &amp;&amp; baseSymbols !== null &amp;&amp; !isNaN(baseSymbols) &amp;&amp; baseSymbols &gt;= 2) { if (CB_isArray(CB_baseSymbols[baseSymbols])) { baseSymbols = CB_baseSymbols[baseSymbols]; } else { baseSymbols = CB_baseSymbols.get(baseSymbols); } } else { baseSymbols = CB_baseSymbols._66; } } var value = CB_indexOf(baseSymbols, number.substring(number.length-1)); if (value === -1) { return 0; } baseRadix = baseSymbols.length; var isNegative = false; if (!unsigned) { if (typeof(minusSymbol) === &quot;undefined&quot; || minusSymbol === null) { minusSymbol = baseRadix &lt;= 16 ? &quot;-&quot; : &quot;0&quot;; } else { minusSymbol = minusSymbol + &quot;&quot;; } if (number.substring(0, minusSymbol.length) === minusSymbol) { number = number.substring(minusSymbol.length); isNegative = true; } } if (typeof(prefix) === &quot;undefined&quot; || prefix === null) { if (baseRadix === 8) { prefix = &quot;0&quot;; } else if (baseRadix === 16) { prefix = &quot;0x&quot;; } else { prefix = null; } } if (prefix !== null &amp;&amp; prefix.length &amp;&amp; number.substring(0, prefix.length) === prefix) { number = number.substring(prefix.length); } number = number.substring(0, number.length - 1); if (number !== &quot;&quot;) { value += CB_baseToInt(number, baseSymbols, true, &quot;&quot;, &quot;&quot;) * baseRadix; } if (isNegative &amp;&amp; value &gt; 0) { value *= -1; } return value; } /** * Converts a given number which is already in a desired base into another chosen base. &lt;br /&gt; Note: Uses {@link CB_baseToInt} and {@link CB_intToBase} internally. * @function * @param {string} number - A string containing the number which is already in the desired base and that we want to convert into the another chosen base. Used as the &quot;number&quot; parameter for calling both {@link CB_intToBase} and {@link CB_baseToInt} functions internally. * @param {array|integer} [baseSymbolsOrigin={@link CB_baseSymbols.66}] - Used as the &quot;baseSymbols&quot; parameter when calling the {@link CB_baseToInt} function internally. * @param {array|integer} [baseSymbolsDestiny={@link CB_baseSymbols.66}] - Used as the &quot;baseSymbols&quot; parameter when calling the {@link CB_intToBase} function internally. * @param {boolean} [unsigned=false] - Determines whether to treat the input and output numbers as unsigned or not. Used as the &quot;unsigned&quot; parameter for calling both {@link CB_intToBase} and {@link CB_baseToInt} functions internally. * @param {string} [minusSymbolOrigin='-'|'0'] - Used as the &quot;minusSymbol&quot; parameter when calling the {@link CB_baseToInt} function internally. * @param {string} [minusSymbolDestiny='-'|'0'] - Used as the &quot;minusSymbol&quot; parameter when calling the {@link CB_intToBase} function internally. * @param {prefix} [prefixOrigin='0'|'0x'|''] - Used as the &quot;prefix&quot; parameter when calling the {@link CB_baseToInt} function internally. * @param {prefix} [prefixDestiny='0'|'0x'|''] - Used as the &quot;prefix&quot; parameter when calling the {@link CB_intToBase} function internally. * @returns {string} Returns the returning value of the internal call to the {@link CB_intToBase} function. * @todo Think about accepting a decimal symbol to separate decimals and support float numbers. */ function CB_baseToBase(number, baseSymbolsOrigin, baseSymbolsDestiny, unsigned, minusSymbolOrigin, minusSymbolDestiny, prefixOrigin, prefixDestiny) { var numberDecimal = CB_baseToInt(number, baseSymbolsOrigin, unsigned, minusSymbolOrigin, prefixOrigin); return CB_intToBase(numberDecimal, baseSymbolsDestiny, unsigned, minusSymbolDestiny, prefixDestiny); } /** * Returns the string or array of strings with all the desired occurrences replaced. Calls itself recursively and calls the {@link CB_regularExpressionString} function internally. * @function * @param {string|array} stringOrArray - An string or an array of strings whose content we want to replace. It can also be an array of arrays of strings (as many levels as you wish). If an array is given, it will not be modified and a copy from it will be generated and returned with the occurrences replaced. * @param {string|array} stringOrArrayFind - An string or an array of strings (not a regular expressions) that we want to find to be replaced (special characters will be escaped). * @param {string} [stringReplace=&quot;&quot;] - The string that will replace &quot;stringFind&quot;. If not provided, it will be replaced as an empty string (it will just remove the occurrences found). * @param {boolean} [caseInsensitive=false] - Defines whether we want to be case insensitive or not. * @returns {string|array} Returns the &quot;stringOrArray&quot; given with occurrences replaced. If the &quot;stringOrArray&quot; given was neither a string nor an array, it will be returned without being modified. */ function CB_replaceAll(stringOrArray, stringOrArrayFind, stringReplace, caseInsensitive) { if (CB_isArray(stringOrArray)) { var arrayCopy = []; for (var x = 0; x &lt; stringOrArray.length; x++) { arrayCopy[x] = CB_replaceAll(stringOrArray[x], stringOrArrayFind, stringReplace, caseInsensitive); } stringOrArray = arrayCopy; } else if (CB_isString(stringReplace)) { stringOrArrayFind = CB_isArray(stringOrArrayFind) ? stringOrArrayFind : [ stringOrArrayFind ]; for (var x = 0; x &lt; stringOrArrayFind.length; x++) { stringOrArray = (stringOrArray + &quot;&quot;).replace(CB_regularExpressionString(stringOrArrayFind[x], true, caseInsensitive), stringReplace); } } return stringOrArray; //If it is neither a string nor an array, it will be returned without being modified. } /** * Returns a desired regular expression (escaping the string) using the native JavaScript's [RegExp]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp} from a given string. * @function * @param {string} string - The string (not a regular expression) that we want to use (special characters will be escaped). * @param {boolean} [allOccurrences=false] - Defines whether we want the regular expression returned to match all occurrences of the given string or only first found. * @param {boolean} [caseInsensitive=false] - Defines whether we want the regular expression returned to be case insensitive or not. * @returns {RegExp} Returns the desired regular expression (escaping the string) using the native JavaScript's [RegExp]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/RegExp} from a given string. */ //* Source: Cory Gross @ http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript function CB_regularExpressionString(string, allOccurrences, caseInsensitive) { var parameters = &quot;&quot;; if (allOccurrences) { parameters += &quot;g&quot;; } if (caseInsensitive) { parameters += &quot;i&quot;; } return new RegExp(string.replace(/[.*+?^${}()|[\\]\\\\]/g, &quot;\\\\$&amp;&quot;), parameters === &quot;&quot; ? undefined : parameters); } /** * Returns the &quot;LZString&quot; object (used by the [lz-string]{@link http://pieroxy.net/blog/pages/lz-string/index.html} library), if any. Useful for compressing/decompressing strings. * @function * @returns {Object} Returns the &quot;LZString&quot; object (used by the [lz-string]{@link http://pieroxy.net/blog/pages/lz-string/index.html} library) if available or null otherwise. */ function CB_getLZStringObject() { return (typeof(LZString) === &quot;object&quot;) ? LZString : null; } /** * Returns the &quot;Base64String&quot; object (used by the base64-string library included in [lz-string]{@link http://pieroxy.net/blog/pages/lz-string/index.html}), if any. Useful for compressing/decompressing base64 code. * @function * @returns {Object} Returns the &quot;Base64String&quot; object (used by the base64-string library included in [lz-string]{@link http://pieroxy.net/blog/pages/lz-string/index.html}) if available or null otherwise. */ function CB_getBase64StringObject() { return (typeof(Base64String) === &quot;object&quot;) ? Base64String : null; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioDetector.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioDetector.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioDetector.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioDetector.js /** * @file Audio formats and audio APIs support detection. Contains the {@link CB_AudioDetector} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to detect audio API and formats supported. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). It will return itself if it is tried to be instantiated. * @namespace */ var CB_AudioDetector = function() { return CB_AudioDetector; }; { CB_AudioDetector.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_AudioDetector.init = function() { if (CB_AudioDetector.initialized) { return CB_AudioDetector; } //Sets that the object has already been initialized: CB_AudioDetector.initialized = true; //TODO. return CB_AudioDetector; } CB_AudioDetector._getSupportedAudioFormatsReturnCache = {}; /** * Returns an array of strings with the audio formats that are supported (from an array if it is given) by the current client and ordered by support level. Uses the {@link CB_AudioDetector.isAudioFormatSupported} function internally. * @function * @param {array} [audioFormats=CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS] - An array of strings with the audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') that we want to check. * @param {array} [supportLevels=['probably', 'maybe']] - An array with the support level or support levels allowed. Two possible levels: &quot;probably&quot; and &quot;maybe&quot;. The &quot;probably&quot; audio formats are more likely to be supported than the &quot;maybe&quot; ones. * @param {boolean} [dataURI=false] - Specifies whether we want to check the support for data URI audios or just for normal audio files. * @returns {array} Returns an array of strings with the audio formats that are supported (from an array if it is given) and ordered by support level. */ CB_AudioDetector.getSupportedAudioFormats = function(audioFormats, supportLevels, dataURI) { //If not given any APIs, uses the default ones with the default order: if (typeof(audioFormats) === &quot;undefined&quot; || audioFormats === null || !CB_isArray(audioFormats)) { audioFormats = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_FORMATS; } //If not given, it will return &quot;probably&quot; and &quot;maybe&quot; ones and in that order (&quot;probably&quot; are more likely to be supported than &quot;maybe&quot; ones): if (!CB_isArray(supportLevels)) { supportLevels = [&quot;probably&quot;, &quot;maybe&quot;]; } //If it is not the first time, returns the same as the first time (from the cache): if (typeof(CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats] !== null) { if (typeof(CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels] !== null) { if (typeof(CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels][dataURI]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels][dataURI] !== null) { return CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels][dataURI]; } } } var supportedAudioFormats = []; var audioFormatsLength = audioFormats.length; //Checks the different support levels by order of preference (&quot;probably&quot; are more likely to be supported than &quot;maybe&quot; ones): var supportLevelsLength = supportLevels.length; var y; for (var x = 0; x &lt; supportLevelsLength; x++) { for (y = 0; y &lt; audioFormatsLength; y++) { if (CB_AudioDetector.isAudioFormatSupported(audioFormats[y], dataURI) === supportLevels[x]) { if (CB_indexOf(supportedAudioFormats, audioFormats[y]) === -1) { supportedAudioFormats[supportedAudioFormats.length] = audioFormats[y]; } } } } //Stores the result in the cache for the next time: if (typeof(CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats]) === &quot;undefined&quot;) { CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats] = {}; } if (typeof(CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels]) === &quot;undefined&quot;) { CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels] = {}; } CB_AudioDetector._getSupportedAudioFormatsReturnCache[audioFormats][supportLevels][dataURI] = supportedAudioFormats; return supportedAudioFormats; } CB_AudioDetector._isAudioFormatSupportedReturnCache = {}; CB_AudioDetector._audioObject = null; /** * Returns the support level of a given audio format by the current client. * @function * @param {string} audioFormat - The audio format (it can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') that we want to check. * @param {boolean} [dataURI=false] - Specifies whether we want to check the support for data URI audios or just for normal audio files. * @returns {string} Returns the support level of the given audio format (it will return &quot;probably&quot;, &quot;maybe&quot; or an empty string which means not supported). The &quot;probably&quot; audio formats are more likely to be supported than the &quot;maybe&quot; ones. * @todo Think about using MediaSource.isTypeSupported(). * @todo Some web clients does not support data URIs for Audio element so we should take this into account. * @todo Take into account that data URIs may not be supported when WAAPI is being emulated. */ CB_AudioDetector.isAudioFormatSupported = function(audioFormat, dataURI) { audioFormat = CB_trim(audioFormat).toLowerCase(); //If it is not the first time, returns the same as the first time (from the cache): if (typeof(CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat] !== null) { if (typeof(CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat][dataURI]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat][dataURI] !== null) { return CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat][dataURI]; } } var isSupported = &quot;&quot;; //TODO: think about using MediaSource.isTypeSupported(). if (CB_AudioDetector.isAPISupported(&quot;AAPI&quot;, false)) { if (CB_AudioDetector._audioObject === null) { CB_AudioDetector._audioObject = new Audio(); } //TODO: some web clients does not support data URIs for Audio element so we should take this into account. if (CB_AudioDetector._audioObject !== null &amp;&amp; typeof(CB_AudioDetector._audioObject.canPlayType) === &quot;function&quot;) { isSupported = CB_AudioDetector._audioObject.canPlayType(audioFormat); } } //...otherwise, if SoundManager 2 is loaded and it is using Flash: else if (CB_AudioDetector.isAPISupported(&quot;SM2&quot;, false) &amp;&amp; CB_AudioDetector.isSM2UsingFlash()) { //SoundManager 2 using Flash supports MP3 only and does not support data URIs: if (!dataURI &amp;&amp; audioFormat.substring(0, 10) === &quot;audio/mpeg&quot;) { isSupported = &quot;maybe&quot;; } } //Stores the result in the cache for the next time: if (typeof(CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat]) === &quot;undefined&quot;) { CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat] = {}; } CB_AudioDetector._isAudioFormatSupportedReturnCache[audioFormat][dataURI] = isSupported; return (&quot;&quot; + isSupported).toLowerCase(); } /** * Returns whether a given audio API exists or not (without keeping into account whether it is supported or not). All existing ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. * @function * @param {string} audioAPI - The audio API that we want to check. All existing ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {boolean} [sanitize=true] - If set to true, the &quot;audioAPI&quot; given will be trimmed and converted to upper case. * @returns {boolean} Returns whether the given audio API exists or not (without keeping into account whether it is supported or not). */ CB_AudioDetector.APIExists = function(audioAPI, sanitize) { if (typeof(sanitize) === &quot;undefined&quot; || sanitize === null) { sanitize = true; } if (sanitize) { audioAPI = CB_trim(audioAPI).toUpperCase(); } return (CB_indexOf(CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_APIS, audioAPI) !== -1); } CB_AudioDetector._getPreferredAPIReturnCache = {}; /** * Calculates and returns the preferred audio API (from an array if it is given) for the current client, if any. * @function * @param {array} [audioAPIs=CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS] - An array of strings with the audio APIs that we want to check, in order of preference. All existing ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {boolean} [allowEmulation=!!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT] - If set to true, it will also detect as supported emulated audio APIs (as &quot;WAAPI&quot; using [waapisim.js]{@link https://github.com/g200kg/WAAPISim} instead of supported natively). * @param {boolean} [returnOnEmpty=undefined] - If set to true and no audio API is supported, it will return the value of this parameter instead of null. * @returns {string|*} Returns a string with the preferred audio API (from an array if it is given) for the current client, if any. If no audio API is supported, it will return the value set in the &quot;returnOnEmpty&quot; parameter. */ CB_AudioDetector.getPreferredAPI = function(audioAPIs, allowEmulation, returnOnEmpty) { audioAPIs = CB_AudioDetector.getSupportedAPIs(audioAPIs, allowEmulation); if (allowEmulation !== true &amp;&amp; allowEmulation !== false) { allowEmulation = !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT; } //If it is not the first time, returns the same as the first time (from the cache): if (typeof(CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs] !== null) { if (typeof(CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs][allowEmulation]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs][allowEmulation] !== null) { return CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs][allowEmulation]; } else if (CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs][allowEmulation] === null) { return returnOnEmpty; } } else { CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs] = {}; } var preferredAPI = null; if (audioAPIs.length &gt; 0) { preferredAPI = audioAPIs[0]; } //Stores the result in the cache for the next time: CB_AudioDetector._getPreferredAPIReturnCache[audioAPIs][allowEmulation] = preferredAPI; if (preferredAPI === null) { preferredAPI = returnOnEmpty; } return preferredAPI; } CB_AudioDetector._getSupportedAPIsReturnCache = {}; /** * Calculates and returns an array with the audio APIs supported (from an array if it is given) for the current client, if any. * @function * @param {array} [audioAPIs=CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS] - An array of strings with the audio APIs that we want to check. All existing ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {boolean} [allowEmulation=!!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT] - If set to true, it will also detect as supported emulated audio APIs (as &quot;WAAPI&quot; using [waapisim.js]{@link https://github.com/g200kg/WAAPISim} instead of supported natively). * @returns {array} Returns an array with the audio APIs supported (from an array if it is given) for the current client, if any. If no audio API is supported, an empty array will be returned. */ CB_AudioDetector.getSupportedAPIs = function(audioAPIs, allowEmulation) { //If not given any APIs, uses the default ones with the default order: if (typeof(audioAPIs) === &quot;undefined&quot; || audioAPIs === null || !CB_isArray(audioAPIs)) { audioAPIs = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_APIS; } if (allowEmulation !== true &amp;&amp; allowEmulation !== false) { allowEmulation = !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT; } //If it is not the first time, returns the same as the first time (from the cache): if (typeof(CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs] !== null) { if (typeof(CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs][allowEmulation]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs][allowEmulation] !== null) { return CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs][allowEmulation]; } } else { CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs] = {}; } var supportedAudioAPIs = []; var audioAPIsLength = audioAPIs.length; for (var x = 0; x &lt; audioAPIsLength; x++) { if (CB_AudioDetector.isAPISupported(audioAPIs[x], allowEmulation)) { if (CB_indexOf(supportedAudioAPIs, audioAPIs[x]) === -1) { supportedAudioAPIs[supportedAudioAPIs.length] = audioAPIs[x]; } } } //Stores the result in the cache for the next time: CB_AudioDetector._getSupportedAPIsReturnCache[audioAPIs][allowEmulation] = supportedAudioAPIs; return supportedAudioAPIs; } CB_AudioDetector._isAPISupportedReturnCache = {}; /** * Tells whether a given audio API is supported or not by the current client. * @function * @param {string} audioAPI - The audio API that we want to check. All existing ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {boolean} [allowEmulation=!!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT] - If set to true, it will detect as supported also emulated audio APIs (as &quot;WAAPI&quot; using [waapisim.js]{@link https://github.com/g200kg/WAAPISim} instead of supported natively). * @returns {boolean} Returns whether the given audio API is supported or not. * @todo Have into account allowEmulation and detect whether emulation is being used if so (for example, detect whether [waapisim.js]{@link https://github.com/g200kg/WAAPISim} is being used). */ CB_AudioDetector.isAPISupported = function(audioAPI, allowEmulation) { audioAPI = CB_trim(audioAPI).toUpperCase(); if (allowEmulation !== true &amp;&amp; allowEmulation !== false) { allowEmulation = !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT; } //If it is not the first time, returns the same as the first time (from the cache): if (typeof(CB_AudioDetector._isAPISupportedReturnCache[audioAPI]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._isAPISupportedReturnCache[audioAPI] !== null) { if (typeof(CB_AudioDetector._isAPISupportedReturnCache[audioAPI][allowEmulation]) !== &quot;undefined&quot; &amp;&amp; CB_AudioDetector._isAPISupportedReturnCache[audioAPI][allowEmulation] !== null) { return CB_AudioDetector._isAPISupportedReturnCache[audioAPI][allowEmulation]; } } else { CB_AudioDetector._isAPISupportedReturnCache[audioAPI] = {}; } var isSupported = false; //TODO: Have into account allowEmulation and detect whether emulation is being used if so (for example, detect whether waapisim.js is being used). //Detects whether it is supported or not: if (audioAPI === &quot;WAAPI&quot;) //Web Audio API. { isSupported = (allowEmulation || !CB_AudioDetector.isWAAPIUsingEmulation()) &amp;&amp; (typeof(window.AudioContext) !== &quot;undefined&quot; || typeof(window.webkitAudioContext) !== &quot;undefined&quot;); } else if (audioAPI === &quot;ACMP&quot;) //Apache Cordova Media Plugin. { isSupported = (typeof(Media) !== &quot;undefined&quot;); } else if (audioAPI === &quot;AAPI&quot;) //Audio API. { isSupported = (typeof(window.Audio) !== &quot;undefined&quot;); } else if (audioAPI === &quot;SM2&quot;) //SoundManager 2. { //SM2 needs either Audio API or Flash: isSupported = CB_soundManager2Supported &amp;&amp; (CB_AudioDetector.isAPISupported(&quot;AAPI&quot;, false) || CB_AudioDetector.isSM2UsingFlash() &amp;&amp; CB_Client.supportsFlash()); } //Stores the result in the cache for the next time: CB_AudioDetector._isAPISupportedReturnCache[audioAPI][allowEmulation] = isSupported; return isSupported; } /** * Tells whether &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}) is using emulation (through [WAAPISim]{@link https://github.com/g200kg/WAAPISim}) or not. * @function * @returns {boolean} Returns whether &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}) is using emulation (through [WAAPISim]{@link https://github.com/g200kg/WAAPISim}) or not. */ CB_AudioDetector.isWAAPIUsingEmulation = function() { return CB_Configuration[CB_BASE_NAME].WAAPISIM_LOAD; } /** * Tells whether [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} is using [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} to emulate sound or not. * @function * @returns {boolean} Returns whether [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} is using [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} to emulate sound or not. */ CB_AudioDetector.isSM2UsingFlash = function() { return (typeof(soundManager) !== &quot;undefined&quot; &amp;&amp; soundManager !== null &amp;&amp; typeof(soundManager.html5) !== &quot;undefined&quot; &amp;&amp; soundManager.html5 !== null &amp;&amp; soundManager.html5.usingFlash); } } //End of the static class CB_AudioDetector. × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFile.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFile.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFile.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFile.js /** * @file Audio files management, including abstraction for different audio APIs. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Contains the {@link CB_AudioFile} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some clients may need this at least the first time in order to be able to play the audio. * @class * @classdesc Class to manage an audio file. Internally, it uses one audio API object which belongs to the audio API being used (when the audio API is changed, it keeps the old audio API objects just in case they are needed in the future when the audio API is changed again). Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {string} filePath - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioId='CB_AudioFile_' + CB_AudioFile._idUnique++] - Desired identifier for the audio object (can be a different element depending on the audio API used). If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. * @param {CB_AudioFile.OPTIONS} [options={@link CB_AudioFile#DEFAULT_OPTIONS}] - Object with the desired options. * @param {string} [audioAPI=CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null)] - The desired audio API to be used. If not provided, it will try to calculate the best one for the current client by calling the {@link CB_AudioDetector.getPreferredAPI} function internally. Audio API support will depend on the current client being used. All possible ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object itself. * @returns {CB_AudioFile} Returns a new {@link CB_AudioFile} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. * @todo Send the {@link CB_AudioFile} object itself as a parameter when calling both &quot;callbackOk&quot; and &quot;callbackError&quot;. * @todo Think about allowing to define 'useXHR' and 'useCache' options (used by {@link CB_AudioFile_API.WAAPI} objects). * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ var CB_AudioFile = function(filePath, audioId, options, audioAPI, callbackOk, callbackError) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFile)) { return new CB_AudioFile(filePath, audioId, options, audioAPI, callbackOk, callbackError); } //Constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFile.prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; /** * Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @constant * @type {CB_AudioFile.OPTIONS} * @default { autoLoad: true, autoPlay: false, loop: false, volume: [CB_AudioFile.prototype.DEFAULT_VOLUME]{@link CB_AudioFile#DEFAULT_VOLUME} } */ CB_AudioFile.prototype.DEFAULT_OPTIONS = { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile.prototype.DEFAULT_VOLUME }; //Properties and variables: /** * Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the {@link CB_AudioFile#play} method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). * @var * @readonly * @type {boolean} * @default [CB_AudioFile.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile#DEFAULT_OPTIONS}.loop */ this.loop = CB_AudioFile.prototype.DEFAULT_OPTIONS.loop; /** * Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var * @readonly * @type {number} * @default [CB_AudioFile.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile#DEFAULT_OPTIONS}.volume */ this.volume = CB_AudioFile.prototype.DEFAULT_OPTIONS.volume; /** * Stores the identifier for the audio file. * @var * @readonly * @type {string} * @default 'CB_AudioFile_' + CB_AudioFile._idUnique++ */ this.id = &quot;&quot;; /** * Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @var * @readonly * @type {string} * @default */ this.filePath = &quot;&quot;; /** * Defines the Audio API used for this audio file. Audio API support will depend on the current client being used. All possible ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @var * @readonly * @type {string} * @default */ this.audioAPI = null; this._onStopFunction = null; //Function to call when the audio stops. //Fake AudioFile[x] object: var that = this; CB_AudioFile._audioFileObject_prototype = CB_AudioFile._audioFileObject_prototype || { usingPrototype : true, status : CB_AudioFile.UNLOADED, paused : false, stopped : true, destructor : function() {}, getDuration : function() { return 0; }, checkPlaying : function(callbackOk, callbackError) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;audioFileObject is not loaded (using CB_AudioFile._audioFileObject_prototype)&quot;); } return false; }, play : function() {}, resume : function() {}, pause : function() {}, stop : function() {}, volume : this.DEFAULT_OPTIONS.volume, volumeBeforeMute : this.DEFAULT_OPTIONS.volume, setVolume : function(volume) { var MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM ? CB_Speaker.getVolume() : 100; if (volume &gt; MAX_VOLUME) { volume = MAX_VOLUME; } else if (volume &lt; 0) { volume = 0; } this.volume = volume; return volume; }, mute : function() { this.volumeBeforeMute = this.volume; this.volume = 0; return 0; }, unmute : function() { this.volume = this.volumeBeforeMute; return this.volume; }, getCurrentTime : function() { return 0; }, onStop : function() { return false; }, getProgress : function() { return 0; } }; CB_AudioFile._audioFileObject_prototype.volume = CB_AudioFile.prototype.DEFAULT_OPTIONS.volume; //Updates the property because maybe the volume has changed. CB_AudioFile._audioFileObject_prototype.volumeBeforeMute = CB_AudioFile.prototype.DEFAULT_OPTIONS.volume; //Updates the property because maybe the volume has changed. /** * It will store the created audio file objects for the different audio APIs (for optimization purposes, to avoid creating more than one per API). Being each index the name of the audio API (&quot;WAAPI&quot;, &quot;AAPI&quot;, &quot;SM2&quot; or &quot;ACMP&quot;), their value will be an object which can be {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Recommended for internal usage only. * @var * @type {Object} * @default */ this.audioFileObjects = {}; //It will store the created objects for the different audio APIs (for optimization purposes, to avoid creating more than one per API). /** * It will store the current audio file object for the current audio API. The {@link CB_AudioFile#load} method will set the value of this property only after the audio file object (stored in its value) is loaded properly. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). When no audio API object is being set, it will contain a fake object with same methods and properties (defined in {@link CB_AudioFile._audioFileObject_prototype}). Recommended for internal usage only. * @var * @type {CB_AudioFile_API.WAAPI | CB_AudioFile_API.SM2 | CB_AudioFile_API.ACMP | CB_AudioFile_API.AAPI | Object} * @default */ this.audioFileObject = CB_AudioFile._audioFileObject_prototype; /** * Stores the last audio file object created or reused, for the current API being used. The {@link CB_AudioFile#load} method will set the value of this property before knowing whether the audio file object (stored in its value) will be loaded properly or not. Used by the {@link CB_AudioFile#load} and {@link CB_AudioFile#getProgress} methods. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). When no audio API object is being set, it will contain a fake object with same methods and properties (defined in {@link CB_AudioFile._audioFileObject_prototype}). Recommended for internal usage only. * @var * @type {CB_AudioFile_API.WAAPI | CB_AudioFile_API.SM2 | CB_AudioFile_API.ACMP | CB_AudioFile_API.AAPI | Object} * @default */ this.audioFileObjectLast = CB_AudioFile._audioFileObject_prototype; this._loadingAudioFileObject = false; //Tells when the audio object is being loading. //Variables to keep same parameters when API is changed: this._avoidDelayedPlayLast = null; this._allowedRecursiveDelayLast = null; //this._onPlayStartLast = undefined; this._onLoadErrorLast = null; //Calls the constructor of the object when creates an instance: return this._init(filePath, audioId, options, audioAPI, callbackOk, callbackError); } /** * Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @memberof CB_AudioFile * @typedef {Object} CB_AudioFile.OPTIONS * @property {boolean} [autoLoad={@link CB_AudioFile#DEFAULT_OPTIONS}.autoLoad] - Value which will be used as the &quot;autoLoad&quot; parameter when calling the {@link CB_AudioFile#setAudioAPI} method internally (when the constructor is called). * @property {boolean} [autoPlay={@link CB_AudioFile#DEFAULT_OPTIONS}.autoPlay] - Value which will be used as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile#setAudioAPI} method internally (when the constructor is called). * @property {boolean} [loop={@link CB_AudioFile#DEFAULT_OPTIONS}.loop] - Value that will be used for the {@link CB_AudioFile#loop} property. * @property {number} [volume={@link CB_AudioFile#DEFAULT_OPTIONS}.volume] - The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that will be used for the {@link CB_AudioFile#volume} property. */ //Static properties and constants: CB_AudioFile._idUnique = 0; //Counter to make the id unique. /** * Status value for an audio file which is unloaded. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default 0 */ CB_AudioFile.UNLOADED = 0; /** * Status value for an audio file which is loading. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.LOADING = 1; /** * Status value for an audio file which has been not checked yet. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.UNCHECKED = 2; /** * Status value for an audio file which is being checked currently. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.CHECKING = 3; /** * Status value for an audio file which has been loaded. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.LOADED = 4; /** * Status value for an audio file which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.FAILED = 5; /** * Status value for an audio file which has been aborted. This will happen when the audio file has been destroyed with the {@link CB_AudioFile#destructor} method. Can be used to compare the value returned by the {@link CB_AudioFile#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFile.ABORTED = 6; //Constructor: CB_AudioFile.prototype._init = function(filePath, audioId, options, audioAPI, callbackOk, callbackError) { //If not given, defines the default parameters: if (typeof(audioId) === &quot;undefined&quot; || audioId === null) { audioId = &quot;CB_AudioFile_&quot; + CB_AudioFile._idUnique++; } //Uses the file path as default id. if (typeof(options) === &quot;undefined&quot; || options === null) { options = this.DEFAULT_OPTIONS; } else { if (typeof(options.loop) === &quot;undefined&quot; || options.loop === null) { options.loop = this.DEFAULT_OPTIONS.loop; } if (typeof(options.autoLoad) === &quot;undefined&quot; || options.autoLoad === null) { options.autoLoad = this.DEFAULT_OPTIONS.autoLoad; } if (typeof(options.autoPlay) === &quot;undefined&quot; || options.autoPlay === null) { options.autoPlay = this.DEFAULT_OPTIONS.autoPlay; } if (typeof(options.volume) === &quot;undefined&quot; || options.volume === null) { options.volume = this.DEFAULT_OPTIONS.volume; } } //Sets the audio ID: this.id = CB_trim(audioId).toUpperCase(); //Sets the file path: this.filePath = filePath; //Sets whether it will loop or not: this.loop = options.loop; //Sets the volume: //this.volume = options.volume; this.setVolume(options.volume); //Sets the audio API and proceeds according to the options received: this.setAudioAPI(audioAPI, options.autoLoad, options.autoPlay, callbackOk, callbackError); //Will load the audio too. //Returns the object: return this; } /** * Destroys the audio file object and frees memory. Sets its current status to ABORTED ({@link CB_AudioFile.ABORTED} value). * @function * @param {boolean} [stopSound=false] - If set to true, it will also call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the {@link CB_AudioFile#audioFileObject} property). This method has the same parameters as the {@link CB_AudioFile#stop} method. * @param {boolean} [keepStoppedUnaltered=false] - Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the {@link CB_AudioFile#audioFileObject} property). This method has the same parameters as the {@link CB_AudioFile#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [avoidOnStop=false] - Used internally as the &quot;avoidOnStop&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the {@link CB_AudioFile#audioFileObject} property). This method has the same parameters as the {@link CB_AudioFile#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [forceOnStop=false] - Used internally as the &quot;forceOnStop&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the {@link CB_AudioFile#audioFileObject} property). This method has the same parameters as the {@link CB_AudioFile#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. */ CB_AudioFile.prototype.destructor = function(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop) { this.audioFileObject.destructor(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop); this.audioFileObject = CB_AudioFile._audioFileObject_prototype; this.audioFileObject.status = CB_AudioFile.ABORTED; } /** * Sets the desired audio API. This method will also be called automatically by the constructor. If the &quot;autoLoad&quot; parameter is set to true, it will call the {@link CB_AudioFile#load} method internally, changing the audio API on-the-fly, and the audio will try to continue playing if it was playing at the moment of calling this method. Check the {@link CB_AudioFile#load} method documentation for more information. If the &quot;autoLoad&quot; parameter is set to true, it is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. The audio API used will be stored in the {@link CB_AudioFile#audioAPI} property. * @function * @param {string} [audioAPI=CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null)] - The desired audio API to be used. If not provided, it will try to calculate the best one for the current client by calling the {@link CB_AudioDetector.getPreferredAPI} function internally. Audio API support will depend on the current client being used. All possible ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Used internally as the &quot;audioAPI&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {string} [autoLoad=true] - If set to false, it will not call the {@link CB_AudioFile#load} method internally and will only set the {@link CB_AudioFile#audioAPI} property (not recommended). * @param {string} [autoPlay=false] - Used internally as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile} object itself. Used internally as the &quot;callbackOk&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object itself. Used internally as the &quot;callbackError&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {string} [ignoreOldValues=false] - Used internally as the &quot;ignoreOldValues&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {string} [filePath={@link CB_AudioFile#filePath}] - Used internally as the &quot;filePath&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @param {string} [forceReload=false] - Used internally as the &quot;forceReload&quot; parameter when calling the {@link CB_AudioFile#load} method internally (only when the &quot;autoLoad&quot; parameter is set to true). * @returns {string} Returns the desired audio API that has been tried to set, in upper case (successfully or not). * @todo Think about using the &quot;forceReload&quot; just after the &quot;callbackError&quot; to match the parameter order of the &quot;load&quot; method of all the audio API objects. */ CB_AudioFile.prototype.setAudioAPI = function(audioAPI, autoLoad, autoPlay, callbackOk, callbackError, ignoreOldValues, filePath, forceReload) { if (typeof(audioAPI) === &quot;undefined&quot; || audioAPI === null) //Uses the preferred API as default. { audioAPI = CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null); } audioAPI = CB_trim(audioAPI).toUpperCase(); if (!CB_AudioDetector.APIExists(audioAPI)) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Audio API given does not exist (&quot; + audioAPI + &quot;).&quot;); } return audioAPI; } if (typeof(autoLoad) === &quot;undefined&quot; || autoLoad === null) { autoLoad = true; } //Since AJAX doesn't allow to load local files, if the file is local we can't use WAAPI: //if (CB_isFileLocal(this.filePath)) { if (audioAPI === &quot;WAAPI&quot;) { audioAPI = &quot;SM2&quot;; } } //Uses SM2 instead. //If it is the same audio API as the current one, we don't need to do more: if (this.audioAPI === audioAPI) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this); } return audioAPI; } //First time is undefined, so we accept any first value: if (typeof(this.audioAPI) === &quot;undefined&quot;) { this.audioAPI = audioAPI; } //We (re)load the audio file if we want to (NOTE: audioAPI will change only if the object is created and loaded successfully): if (autoLoad) { this.load(filePath ? filePath : this.filePath, audioAPI, autoPlay, callbackOk, callbackError, ignoreOldValues, forceReload); } //...otherwise, we just change the audioAPI property: else { this.audioAPI = audioAPI; } return audioAPI; } /** * Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. This method will be called automatically if the &quot;autoLoad&quot; option was set to true when calling the {@link CB_AudioFile#setAudioAPI} method. The audio API used will be stored in the {@link CB_AudioFile#audioAPI} property. * When this method is called, if the &quot;status&quot; property of the audio API object already has the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the {@link CB_AudioFile.LOADING} constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the {@link CB_AudioFile.UNCHECKED} constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the &quot;checkPlaying&quot; method of the audio API object after it). After it and only if the &quot;autoPlay&quot; is set to true, as the &quot;checkPlaying&quot; method of the audio API object will be called internally, it will have the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant) and finally the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) if all goes well. * Although it is not recommended to do so, if this method is called when the audio API object has the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will call the &quot;checkPlaying&quot; method of the audio API object internally. * Internally, it can use the {@link CB_AudioFile#audioFileObjects} property as a cache. * @function * @param {string} [filePath={@link CB_AudioFile#filePath}] - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioAPI={@link CB_AudioFile#audioAPI}] - The desired audio API to be used. If not provided, it will try to use the previously-set one (in the {@link CB_AudioFile#audioAPI} property). All possible ones are defined in {@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}. For example: &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {string} [autoPlay=false] - If set to true, it will start playing the audio automatically (by calling the {@link CB_AudioFile#play} method internally) unless the &quot;ignoreOldValues&quot; parameter is set to false and the previous audio was playing or paused. If set to true and the &quot;status&quot; property of the audio API object reaches to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will also call internally the &quot;checkPlaying&quot; method of the audio API object before anything. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {string} [ignoreOldValues=false] - If set to true, it will ignore the old values of the previous used audio API object. This means that it will neither continue playing if it was playing (changing the audio API on-the-fly) nor keep the paused status if it was paused nor copy its &quot;loop&quot; property to the new audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {string} [forceReload=false] - Used internally as the &quot;forceReload&quot; parameter when calling the &quot;load&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @returns {CB_AudioFile_API.WAAPI|CB_AudioFile_API.SM2|CB_AudioFile_API.ACMP|CB_AudioFile_API.AAPI|null} Returns the used audio API object or null otherwise. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @todo Think about using the &quot;forceReload&quot; just after the &quot;callbackError&quot; to match the parameter order of the &quot;load&quot; method of all the audio API objects. */ CB_AudioFile.prototype.load = function(filePath, audioAPI, autoPlay, callbackOk, callbackError, ignoreOldValues, forceReload) { //Defines the default parameters: if (typeof(audioAPI) === &quot;undefined&quot; || audioAPI === null) { audioAPI = this.audioAPI; //Uses the previously set Audio API as default. //if (typeof(audioAPI) === &quot;undefined&quot; || audioAPI === null) { audioAPI = CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null); } //Uses the preferred API as default. } audioAPI = CB_trim(audioAPI).toUpperCase(); filePath = filePath || this.filePath; var that = this; var callbackErrorFunction = function(error) { that._loadingAudioFileObject = false; //The audio object is not being loaded anymore. that.audioFileObjectLast = that.audioFileObject; //If we are using the prototype (no real audio object adopted), and the audio API requested has been set or the audio API was never set (first time), status is failed: if (that.audioFileObject.usingPrototype &amp;&amp; (audioAPI === that.audioAPI || that.audioAPI === null)) //This way, we avoid setting as FAILED if the audio API has not been changed. { that.audioFileObject.status = CB_AudioFile.FAILED; } //Calls the error function (if any): if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } }; //Creates the audio object depending on the API chosen: if (typeof(CB_AudioFile_API) !== &quot;undefined&quot; &amp;&amp; typeof(CB_AudioFile_API[audioAPI]) !== &quot;undefined&quot;) { this._loadingAudioFileObject = true; //The audio object is being loaded. var callbackOkFunction = function() { //If there is an object already: var wasPlaying = false; var wasPaused = false; //If we wanto to play automatically and the status of the new object is unchecked, checks the file and the function will be called when finishes: if (autoPlay &amp;&amp; audioFileObject.status === CB_AudioFile.UNCHECKED &amp;&amp; typeof(audioFileObject.checkPlaying) !== &quot;undefined&quot;) { audioFileObject.checkPlaying(callbackOkFunction, callbackErrorFunction, false, false, false); return; } //If we do not want to ignore old values and the previous audio file object used was not a prototype (it was a real one): if (!ignoreOldValues &amp;&amp; typeof(that.audioFileObject.usingPrototype) === &quot;undefined&quot;) { //If the status of the new object is unchecked, checks the file and the function will be called when finishes: if (audioFileObject.status === CB_AudioFile.UNCHECKED &amp;&amp; typeof(audioFileObject.checkPlaying) !== &quot;undefined&quot;) { audioFileObject.checkPlaying(callbackOkFunction, callbackErrorFunction, false, false, false); return; } //var status = that.getStatus(); var status = that.audioFileObject.status; //audioFileObject.status = LOADED; //If the audio was LOADED: if (status === CB_AudioFile.LOADED) { //Stores the startAt: audioFileObject.lastStartAt = that.audioFileObject.lastStartAt; //Stores the stopAt: audioFileObject.lastStopAt = that.audioFileObject.lastStopAt; //Stores loop: that.loop = audioFileObject.loop = that.audioFileObject.loop; //If the sound is playing, pauses it: if (that.isPlaying()) { //Stops it: that.pause(); wasPlaying = true; } else if (that.audioFileObject.paused) { wasPaused = true; } //Stores the pause time (if any): audioFileObject.pauseTime = that.audioFileObject.pauseTime; //If it was using WAAPI and not now, we need to substract the startTime: /* if (that.audioAPI === &quot;WAAPI&quot; &amp;&amp; audioAPI !== &quot;WAAPI&quot; &amp;&amp; typeof(that.audioFileObject.startTime) !== &quot;undefined&quot; &amp;&amp; that.audioFileObject.startTime !== null &amp;&amp; !isNaN(that.audioFileObject.startTime)) { audioFileObject.pauseTime -= that.audioFileObject.startTime * 1000; } */ } } //If we changed the API (this means the object will have changed too): if (that.audioAPI !== audioAPI) { //Stops and destroys previous object (if any) and declares it as ABORTED: //////that.destructor(true, false, true); //Stops the object (avoiding to fire onStop) and destroys the object (sets status as ABORTED). } //Stores the volume: that.volume = audioFileObject.volume = that.getVolume(); //Stores the new audio object: that.audioFileObject = audioFileObject; //If it was playing, continues playing from the same point: if (!ignoreOldValues &amp;&amp; (wasPlaying || wasPaused)) { that.audioFileObject.stopped = false; that.audioFileObject.paused = true; //that.resume(that.loop); //that.resume(that.loop, that._avoidDelayedPlayLast, that._allowedRecursiveDelayLast, that._onPlayStartLast, that._onLoadErrorLast); that.resume(that.loop, that._avoidDelayedPlayLast, that._allowedRecursiveDelayLast, null, that._onLoadErrorLast); if (wasPaused) { that.pause(); } } //...otherwise, if we wanted to play automatically, we start playing: else if (autoPlay) { that.play(); } //Now the new API can be accepted: that.audioAPI = audioAPI; //Sets the file path: that.filePath = filePath; //Set the desired onStop event (if any): /////////that.onStop(that.onStopFunction, false); that.onStop(that._onStopFunction, false); that._loadingAudioFileObject = false; //The audio object has been loaded already. //Calls the OK function (if any): if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } }; //Creates a new CB_AudioFile[x] object or uses the existing one (if available): var audioFileObject; if (typeof(this.audioFileObjects[audioAPI]) !== &quot;undefined&quot; &amp;&amp; this.audioFileObjects[audioAPI] !== null) { //Gets the existing object: audioFileObject = this.audioFileObjects[audioAPI]; //Sets the desired options: ////if (typeof(this.id) === &quot;undefined&quot; || this.id === null) { audioFileObject.id = filePath; } //Uses the file path as default id. if (typeof(this.id) === &quot;undefined&quot; || this.id === null) { audioFileObject.id = CB_trim(&quot;CB_AudioFile_&quot; + CB_AudioFile._idUnique++).toUpperCase(); } //Uses the file path as default id. else { audioFileObject.id = this.id; } audioFileObject.loop = this.loop; //audioFileObject.setVolume(this.volume); //audioFileObject.setVolume(0); //Sets volume to zero to prevent hearing the sound in some web clients when checkPlaying is called. if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { audioFileObject.mute(); } //Sets volume to zero to prevent hearing the sound in some web clients when checkPlaying is called. //Calls the load method of the object (load method also calls the destructor method): audioFileObject.load(filePath, false, callbackOkFunction, callbackErrorFunction, forceReload); } else { //Creates the new object and stores it (sets volume to zero to prevent hearing the sound in some web clients when checkPlaying is called): //audioFileObject = new CB_AudioFile_API[audioAPI](filePath, this.id, { autoLoad: true, autoPlay: autoPlay, loop: this.loop, volume: this.volume }, callbackOkFunction, callbackErrorFunction); this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; audioFileObject = new CB_AudioFile_API[audioAPI](filePath, this.id, { autoLoad: true, autoPlay: false, loop: this.loop, volume: CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING ? 0 : this.DEFAULT_VOLUME }, callbackOkFunction, callbackErrorFunction); this.audioFileObjects[audioAPI] = audioFileObject; } this.audioFileObjectLast = this.audioFileObjects[audioAPI]; return audioFileObject; } else { callbackErrorFunction(&quot;CB_AudioFile_API['&quot; + audioAPI + &quot;'] not found&quot;); return null; } } /** * Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the {@link CB_AudioFile#play} method the first time. Internally, uses the &quot;checkPlaying&quot; method of the used audio API object. The checking action will only be performed if the value of the &quot;status&quot; property of the used audio API object belongs to the {@link CB_AudioFile.UNCHECKED} or to the {@link CB_AudioFile.CHECKING} value. After checking, if the audio can be played, the &quot;status&quot; property of the used audio API object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the &quot;status&quot; property of the used audio API object will get the value of {CB_AudioFile.FAILED}. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {boolean} [ignoreStatus=false] - If set to false and the audio status is neither &quot;UNCHECKED&quot; nor &quot;CHECKING&quot;, it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. * @param {boolean} [ignoreQueue=false] - If set to false and there is already the maximum number of audio files being checked (defined internally, depending on the audio API), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. Some audio APIs will ignore this parameter as they do not use checking queues. * @param {boolean} [useCache=false] - If set to true (not recommended) and the same audio file was checked previously, it will not perform the checking process again and it will do the same as the previous call. Some audio APIs will ignore this parameter as they do not use cache. * @returns {boolean} Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. */ CB_AudioFile.prototype.checkPlaying = function(callbackOk, callbackError, ignoreStatus, ignoreQueue, useCache) { var that = this; return this.audioFileObject.checkPlaying ( function() { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } }, //callbackOk. function(error) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } }, //callbackError. ignoreStatus, ignoreQueue, useCache ); } /** * Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Internally, uses the &quot;getDuration&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {number} Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. */ CB_AudioFile.prototype.getDuration = function() { return this.audioFileObject.getDuration(); } /** * Plays the audio. Internally, uses the &quot;play&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile#onStop} method) will not be called. Used internally as the &quot;loop&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. Used internally as the &quot;onPlayStart&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onLoadError&quot; parameter to call the &quot;play&quot; method of the audio API object. * @param {boolean} [isResume=false] - If set to true (not recommended) and it is a looping audio, the next loop will use the value of the &quot;lastStartAt&quot; property of the audio API object as the &quot;startAt&quot; parameter when it calls the &quot;play&quot; method again automatically (internally). Recommended for internal usage only. Used internally as the &quot;isResume&quot; parameter to call the &quot;play&quot; method of the audio API object. * @returns {boolean|integer} Returns the returning value of the &quot;play&quot; method of the audio API object. It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). */ CB_AudioFile.prototype.play = function(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume) { if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). else { this.loop = loop; } //...otherwise, stores the new setting given. //Backups the parameters given: this._avoidDelayedPlayLast = avoidDelayedPlay; this._allowedRecursiveDelayLast = allowedRecursiveDelay; //this._onPlayStartLast = onPlayStart; this._onLoadErrorLast = onLoadError; var that = this; //Plays the sound: return this.audioFileObject.play ( startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, function(startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime) { if (typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(that, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); } }, function (error) { if (typeof(onPlayStart) === &quot;function&quot;) { onLoadError.call(that, error); } }, isResume, false ); } /** * Resumes the audio (after being paused), starting from the same point it was paused previously. Internally, uses the &quot;resume&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {boolean} [loop={@link CB_AudioFile#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile#onStop} method) will not be called. Used internally as the &quot;loop&quot; parameter to call the &quot;resume&quot; method of the audio API object. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the &quot;resume&quot; method of the audio API object. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the &quot;resume&quot; method of the audio API object. * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. Used internally as the &quot;onPlayStart&quot; parameter to call the &quot;resume&quot; method of the audio API object. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onLoadError&quot; parameter to call the &quot;resume&quot; method of the audio API object. * @returns {boolean|integer} Returns the returning value of the &quot;resume&quot; method of the audio API object. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). */ //CB_AudioFile.prototype.resume = function(stopAt, loop, /*startAtNextLoop,*/ allowOverlapping) CB_AudioFile.prototype.resume = function(loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError) { /////////if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.DEFAULT_OPTIONS.loop; } if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). this.loop = loop; //return this.audioFileObject.resume(stopAt, loop, /*startAtNextLoop,*/ allowOverlapping); //Backups the parameters given: this._avoidDelayedPlayLast = avoidDelayedPlay; this._allowedRecursiveDelayLast = allowedRecursiveDelay; //this._onPlayStartLast = onPlayStart; this._onLoadErrorLast = onLoadError; var that = this; //Resumes the sound: return this.audioFileObject.resume ( loop, avoidDelayedPlay, allowedRecursiveDelay, //////function() { if (typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(that); } }, function(startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime) { if (typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(that, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); } }, function (error) { if (typeof(onPlayStart) === &quot;function&quot;) { onLoadError.call(that, error); } } ); } /** * Pauses the audio when it is being played. Internally, uses the &quot;pause&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onPause&quot; parameter (with a wrapper function) to call the &quot;pause&quot; method of the audio API object. * @param {boolean} [keepPausedUnaltered=false] - If set to true (not recommended), the &quot;paused&quot; property of the audio API object will not be set to true and it will remain with its current value. Used internally as the &quot;keepPausedUnaltered&quot; parameter to call the &quot;pause&quot; method of the audio API object. * @returns {boolean} Returns the returning value of the &quot;pause&quot; method of the audio API object. It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). */ CB_AudioFile.prototype.pause = function(onPause, keepPausedUnaltered) { var that = this; return this.audioFileObject.pause(function() { if (typeof(onPause) === &quot;function&quot;) { onPause.call(that); } }, keepPausedUnaltered); } /** * Stops the audio. Internally, uses the &quot;stop&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {boolean} [keepStoppedUnaltered=false] - If set to true (not recommended), the &quot;stopped&quot; property of the audio API object will not be set to true and it will remain with its current value. Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the &quot;stop&quot; method of the audio API object. * @param {boolean} [avoidOnStop=false] - If set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile#onStop} method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. Used internally as the &quot;avoidOnStop&quot; parameter to call the &quot;stop&quot; method of the audio API object. * @param {boolean} [forceOnStop=false] - If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile#onStop} method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Used internally as the &quot;forceOnStop&quot; parameter to call the &quot;stop&quot; method of the audio API object. * @returns {boolean} Returns the returning value of the &quot;stop&quot; method of the audio API object. It returns false if the stopping action cannot be performed at all (this could happen with the internal audio API has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). */ CB_AudioFile.prototype.stop = function(keepStoppedUnaltered, avoidOnStop, forceOnStop) { return this.audioFileObject.stop(keepStoppedUnaltered, avoidOnStop, forceOnStop); } /** * Returns the volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that was set before the audio was muted. Internally, uses the &quot;volumeBeforeMute&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {number} Returns the volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that was set before the audio was muted. If the audio was not muted before, it will contain the default volume used in the &quot;volume&quot; property of the used audio API object. */ CB_AudioFile.prototype.getVolumeBeforeMute = function() { return this.audioFileObject.volumeBeforeMute; } /** * Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). Internally, uses the &quot;volume&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile.prototype.getVolume = function() { this.volume = this.audioFileObject.volume; return this.volume; } /** * Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). Internally, uses the &quot;setVolume&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). Used internally as the &quot;volume&quot; parameter to call the &quot;setVolume&quot; method of the audio API object. * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the &quot;volume&quot; property of the used audio API object even when the volume failed to be changed. Used internally as the &quot;forceSetVolumeProperty&quot; parameter to call the &quot;setVolume&quot; method of the audio API object. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onSetVolume&quot; parameter (with a wrapper function) to call the &quot;setVolume&quot; method of the audio API object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile.prototype.setVolume = function(volume, forceSetVolumeProperty, onSetVolume) { var that = this; this.volume = this.audioFileObject.setVolume(volume, forceSetVolumeProperty, function() { if (typeof(onSetVolume) === &quot;function&quot;) { onSetVolume.call(that); } }, false); return this.volume; } /** * Mutes the audio file. Internally, uses the &quot;mute&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {function} [onMute] - Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onMute&quot; parameter (with a wrapper function) to call the &quot;mute&quot; method of the audio API object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. */ CB_AudioFile.prototype.mute = function(onMute) { var that = this; this.volume = this.audioFileObject.mute(function() { if (typeof(onMute) === &quot;function&quot;) { onMute.call(that); } }); return this.volume; } /** * Restores audio after muting it (unmutes it). Internally, uses the &quot;unmute&quot; method of the used audio API object which uses its own &quot;volumeBeforeMute&quot; property. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {function} [onUnmute] - Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onUnmute&quot; parameter (with a wrapper function) to call the &quot;unmute&quot; method of the audio API object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile.prototype.unmute = function(onUnmute) { var that = this; this.volume = this.audioFileObject.unmute(function() { if (typeof(onUnmute) === &quot;function&quot;) { onUnmute.call(that); } }); return this.volume; } /** * Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Internally, uses the &quot;getCurrentTime&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {number} Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. */ CB_AudioFile.prototype.getCurrentTime = function() { return this.audioFileObject.getCurrentTime(); } /** * Gets the current status of the audio file. * @function * @param {boolean} [realStatus=false] - If set to true, it will return the &quot;status&quot; property of the used audio API object instead of the &quot;status&quot; property of the current CB_AudioFile object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @returns {number} Returns the current status of the audio file. It is a number, which should match the value of the CB_AudioFile.UNLOADED (still unloaded), CB_AudioFile.LOADING (loading), CB_AudioFile.UNCHECKED (not checked by calling the &quot;checkPlaying&quot; method yet), CB_AudioFile.CHECKING (being checked by the &quot;checkPlaying&quot; method), CB_AudioFile.LOADED (loaded), CB_AudioFile.FAILED (failed loading or failed to play or by any other reason) or CB_AudioFile.ABORTED (aborted because it was destroyed with the &quot;destructor&quot; method) property. */ CB_AudioFile.prototype.getStatus = function(realStatus) { if (this._loadingAudioFileObject &amp;&amp; !realStatus) { return CB_AudioFile.LOADING; } return this.audioFileObject.status; } /** * Gets the current status of the audio file, as a string. * @function * @param {boolean} [realStatus=false] - If set to true, it will have in mind the &quot;status&quot; property of the used audio API object instead of the &quot;status&quot; property of the current CB_AudioFile object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @returns {string} Returns the current status of the audio file, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the &quot;status&quot; property not recognized as any possible status). */ CB_AudioFile.prototype.getStatusString = function(realStatus) { var status = this.getStatus(realStatus); var statuses = [ &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; ]; if (typeof(statuses[status]) !== &quot;undefined&quot;) { return statuses[status]; } else { return &quot;UNKNOWN (&quot; + status + &quot;)&quot;; } } /** * Tells whether the audio file is playing or not. Internally, uses the {@link CB_AudioFile#isStopped} and {@link CB_AudioFile#isPaused} methods. * @function * @returns {boolean} Returns whether the audio file is playing or not. */ CB_AudioFile.prototype.isPlaying = function() { return (!this.isStopped() &amp;&amp; !this.isPaused()); } /** * Tells whether the audio is paused or not. Internally, uses the &quot;paused&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {boolean} Returns whether the audio is paused or not. */ CB_AudioFile.prototype.isPaused = function() { return this.audioFileObject.paused; } /** * Tells whether the audio file is stopped or not. Internally, uses the &quot;stopped&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {boolean} Returns whether the audio file is stopped or not. */ CB_AudioFile.prototype.isStopped = function() { return this.audioFileObject.stopped; } /* //Returns the bytes loaded of the file: CB_AudioFile.prototype.getBytesLoaded = function() { return this.audioFileObject.getBytesLoaded(); } //Returns the total bytes of the file: CB_AudioFile.prototype.getBytesTotal = function() { return this.audioFileObject.getBytesTotal(); } */ /** * Sets a function to execute when the audio file stops playing or removes it. Internally, uses the &quot;onStop&quot; method of the used audio API object (wrapping the given function). * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the {@link CB_AudioFile} object. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @returns {boolean} Returns whether the event has been set or not (removed). */ CB_AudioFile.prototype.onStop = function(callbackFunction, keepOldFunction) { //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } if (typeof(callbackFunction) !== &quot;function&quot;) { this._onStopFunction = null; return false; } var that = this; //If we don't want to keep the old function: if (!keepOldFunction) { this._onStopFunction = callbackFunction; } //...otherwise if we want to keep the old function, we keep it: else { //Stores old function: var oldFunction = this._onStopFunction; //Stores old function of eventFunctionHolder. this._onStopFunction = function() { if (typeof(oldFunction) === &quot;function&quot;) { oldFunction.call(that); } callbackFunction.call(that); }; } ////return this.audioFileObject.onStop(callbackFunction, false); //We have already kept the function (if desired). return this.audioFileObject.onStop(function() { if (typeof(that._onStopFunction) === &quot;function&quot;) { that._onStopFunction.call(that); } }, false); //We have already kept the function (if desired). } /** * Tells the last &quot;startAt&quot; parameter value used by the {@link CB_AudioFile#play} or the {@link CB_AudioFile#resume} method (or used by the equivalents methods of the same name from the used audio API object). Internally, uses the &quot;lastStartAt&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {boolean} [numeric=false] - If set to true, it will sanitize the returning value by returning zero instead of undefined, null or any other non-numeric value. * @returns {number|*} Returns the last &quot;startAt&quot; value used by the {@link CB_AudioFile#play} or the {@link CB_AudioFile#resume} method (or used by the equivalents methods of the same name from the used audio API object). If we want it to be numeric always, the &quot;numeric&quot; parameter should be set to true. */ CB_AudioFile.prototype.getStartAt = function(numeric) { var value = undefined; if (typeof(this.audioFileObject.lastStartAt) !== &quot;undefined&quot;) { value = this.audioFileObject.lastStartAt; } if (numeric &amp;&amp; (typeof(value) === &quot;undefined&quot; || value === null || isNaN(value))) { value = 0; } return value; } /** * Tells the last &quot;stopAt&quot; parameter value used by the {@link CB_AudioFile#play} or the {@link CB_AudioFile#resume} method (or used by the equivalents methods of the same name from the used audio API object). Internally, uses the &quot;lastStopAt&quot; property of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @param {boolean} [numeric=false] - If set to true, it will sanitize the returning value by returning zero instead of undefined, null or any other non-numeric value. * @returns {number|*} Returns the last &quot;stopAt&quot; value used by the {@link CB_AudioFile#play} or the {@link CB_AudioFile#resume} method (or used by the equivalents methods of the same name from the used audio API object). If we want it to be numeric always, the &quot;numeric&quot; parameter should be set to true. */ CB_AudioFile.prototype.getStopAt = function(numeric) { var value = undefined; if (typeof(this.audioFileObject.lastStopAt) !== &quot;undefined&quot;) { value = this.audioFileObject.lastStopAt; } if (numeric &amp;&amp; (typeof(value) === &quot;undefined&quot; || value === null || isNaN(value))) { value = 0; } return value; } /** * Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Internally, uses the &quot;getProgress&quot; method of the used audio API object. Possible internal audio API objects are {@link CB_AudioFile_API.WAAPI} object for &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), {@link CB_AudioFile_API.SM2} object for &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), {@link CB_AudioFile_API.ACMP} object for &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or {@link CB_AudioFile_API.AAPI} object for &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @function * @returns {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFile.prototype.getProgress = function() { return this.audioFileObjectLast.getProgress(); } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFile_API_AAPI.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFile_API_AAPI.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js /** * @file Audio files management using &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Contains the {@link CB_AudioFile_API.AAPI} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ //We need a limit to prevent Firefox error (&quot;Media resource [URI] could not be decoded&quot;) since many calls to play() method would fail: if (typeof(CB_AudioFile_API_AAPI_SM2_beingLoading) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } //Counts how many objects are loading. if (typeof(CB_AudioFile_API_AAPI_SM2_maximumLoading) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_maximumLoading = 5; } //Maximum of objects that can be loading at the same time. if (typeof(CB_AudioFile_API_AAPI_SM2_beingChecking) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } //Counts how many objects are loading. if (typeof(CB_AudioFile_API_AAPI_SM2_maximumChecking) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_maximumChecking = CB_AudioFile_API_AAPI_SM2_maximumLoading; } //Maximum of objects that can be loading at the same time. //Class to manage an audio file with AAPI (Audio API): if (typeof(CB_AudioFile_API) === &quot;undefined&quot;) { var CB_AudioFile_API = {}; } /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. * @class CB_AudioFile_API.AAPI * @memberof! &lt;global&gt; * @classdesc Class to manage an audio file using &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Used by the {@link CB_AudioFile} class internally and it shares most of its properties and methods. Recommended for internal usage only. * @param {string} filePath - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioId='CB_AUDIOFILE_AAPI_' + CB_AudioFile_API.AAPI._idUnique++] - Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. * @param {CB_AudioFile_API.AAPI.OPTIONS} [options=CB_AudioFile_API.AAPI#DEFAULT_OPTIONS] - Object with the desired options. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @returns {CB_AudioFile_API.AAPI} Returns a new {@link CB_AudioFile_API.AAPI} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ CB_AudioFile_API[&quot;AAPI&quot;] = function(filePath, audioId, options, callbackOk, callbackError) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFile_API[&quot;AAPI&quot;])) { return new CB_AudioFile_API[&quot;AAPI&quot;](filePath, audioId, options, callbackOk, callbackError); } //Constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant CB_AudioFile_API.AAPI#DEFAULT_VOLUME * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; /** * Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @constant CB_AudioFile_API.AAPI#DEFAULT_OPTIONS * @type {CB_AudioFile_API.AAPI.OPTIONS} * @default { autoLoad: true, autoPlay: false, loop: false, volume: [CB_AudioFile_API.AAPI.prototype.DEFAULT_VOLUME]{@link CB_AudioFile_API.AAPI#DEFAULT_VOLUME} } */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.DEFAULT_OPTIONS = { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API[&quot;AAPI&quot;].prototype.DEFAULT_VOLUME }; //Properties and variables: /** * Tells whether the file is unloaded ({@link CB_AudioFile.UNLOADED}), loading ({@link CB_AudioFile.LOADING}), unchecked ({@link CB_AudioFile.UNCHECKED}), checking ({@link CB_AudioFile.CHECKING}), loaded ({@link CB_AudioFile.LOADED}), failed ({@link CB_AudioFile.FAILED}) or aborted ({@link CB_AudioFile.ABORTED}). * @var CB_AudioFile_API.AAPI#status * @readonly * @type {integer} * @default {@link CB_AudioFile.UNLOADED} */ this.status = CB_AudioFile.UNLOADED; /** * Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the {@link CB_AudioFile_API.AAPI#play} method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). * @var CB_AudioFile_API.AAPI#loop * @readonly * @type {boolean} * @default [CB_AudioFile_API.AAPI.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.loop */ this.loop = CB_AudioFile_API[&quot;AAPI&quot;].prototype.DEFAULT_OPTIONS.loop; /** * Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.AAPI#volume * @readonly * @type {number} * @default [CB_AudioFile_API.AAPI.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.volume */ this.volume = CB_AudioFile_API[&quot;AAPI&quot;].prototype.DEFAULT_OPTIONS.volume; /** * Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.AAPI#volumeBeforeMute * @readonly * @type {number} * @default {@link CB_AudioFile_API.AAPI#volume} */ this.volumeBeforeMute = this.volume; /** * Stores the identifier for the audio file. * @var CB_AudioFile_API.AAPI#id * @readonly * @type {string} * @default 'CB_AUDIOFILE_AAPI_' + CB_AudioFile_API.AAPI._idUnique++ */ this.id = &quot;&quot;; /** * Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @var CB_AudioFile_API.AAPI#filePath * @readonly * @type {string} * @default */ this.filePath = &quot;&quot;; /** * Tells whether the audio is paused or not. * @var CB_AudioFile_API.AAPI#paused * @readonly * @type {boolean} * @default false */ this.paused = false; /** * Stores the time (in milliseconds) when the audio has been paused. * @var CB_AudioFile_API.AAPI#pauseTime * @readonly * @type {number} * @default */ this.pauseTime = 0; /** * Tells whether the audio is stopped or not. * @var CB_AudioFile_API.AAPI#stopped * @readonly * @type {boolean} * @default true */ this.stopped = true; /** * Function to call when the audio stops. * @var CB_AudioFile_API.AAPI#onStopFunction * @readonly * @type {function} * @default */ this.onStopFunction = null; /** * Stores the last &quot;startAt&quot; parameter value used by the {@link CB_AudioFile_API.AAPI#play} or the {@link CB_AudioFile_API.AAPI#resume} method. * @var CB_AudioFile_API.AAPI#lastStartAt * @readonly * @type {number} * @default */ this.lastStartAt = null; /** * Stores the last &quot;stopAt&quot; parameter value used by the {@link CB_AudioFile_API.AAPI#play} or the {@link CB_AudioFile_API.AAPI#resume} method. * @var CB_AudioFile_API.AAPI#lastStopAt * @readonly * @type {number} * @default */ this.lastStopAt = null; /** * Stores the [HTMLAudioElement]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement} object of the audio, used by the &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @var CB_AudioFile_API.AAPI#audioObject * @readonly * @type {HTMLAudioElement} * @default */ this.audioObject = null; //Internal properties: this._timeoutWhenStop = null; //Keeps the timeout that is executed when the audio has finished playing (to either stop or loop). this._id_internal = null; //Internal id. this._recursiveCallTimeout = null; this._onReadyTimeout = null; this._stopAfterPlayingTimeout = null; this._onCanplaythroughHandlerLast = null; this._onErrorHandlerLast = null; this._loadingCounterIncreased = false; this._checkPlayingTimeout = null; this._checkPlayingFinishingTimeout = null; this._recursiveCallCheckingTimeout = null; this._checkingCounterIncreased = false; this._onPlayingErrorFunctionExecuted = false; this._lastDuration = null; //Calls the constructor of the object when creates an instance: return this._init(filePath, audioId, options, callbackOk, callbackError); } /** * Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @memberof CB_AudioFile_API.AAPI * @typedef {Object} CB_AudioFile_API.AAPI.OPTIONS * @property {boolean} [autoLoad={@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.autoLoad] - If set to false, it will not call the {@link CB_AudioFile_API.AAPI#load} method internally when the constructor is called (not recommended). * @property {boolean} [autoPlay={@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.autoPlay] - Value which will be used as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile_API.AAPI#load} method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). * @property {boolean} [loop={@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.loop] - Value that will be used for the {@link CB_AudioFile_API.AAPI#loop} property. * @property {number} [volume={@link CB_AudioFile_API.AAPI#DEFAULT_OPTIONS}.volume] - The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that will be used for the {@link CB_AudioFile_API.AAPI#volume} property. */ //Static properties: CB_AudioFile_API[&quot;AAPI&quot;]._counter = 0; //Internal counter. CB_AudioFile_API[&quot;AAPI&quot;]._idUnique = 0; //Counter to make the id unique. //Constructor: CB_AudioFile_API[&quot;AAPI&quot;].prototype._init = function(filePath, audioId, options, callbackOk, callbackError) { //If not given, defines the default parameters: if (typeof(audioId) === &quot;undefined&quot; || audioId === null) { audioId = &quot;CB_AUDIOFILE_AAPI_&quot; + CB_AudioFile_API[&quot;AAPI&quot;]._idUnique++; } //Uses the file path as default id. if (typeof(options) === &quot;undefined&quot; || options === null) { options = this.DEFAULT_OPTIONS; } else { if (typeof(options.loop) === &quot;undefined&quot; || options.loop === null) { options.loop = this.DEFAULT_OPTIONS.loop; } if (typeof(options.autoLoad) === &quot;undefined&quot; || options.autoLoad === null) { options.autoLoad = this.DEFAULT_OPTIONS.autoLoad; } if (typeof(options.autoPlay) === &quot;undefined&quot; || options.autoPlay === null) { options.autoPlay = this.DEFAULT_OPTIONS.autoPlay; } if (typeof(options.volume) === &quot;undefined&quot; || options.volume === null) { options.volume = this.DEFAULT_OPTIONS.volume; } } //Sets the audio ID: this.id = CB_trim(audioId).toUpperCase(); //Sets the internal id: if (typeof(this._id_internal) === &quot;undefined&quot; || this._id_internal === null) { this._id_internal = CB_AudioFile_API[&quot;AAPI&quot;]._counter++; } //Sets the file path: this.filePath = filePath; //Proceeds according to the options sent: this.loop = options.loop; this.volume = options.volume; this.volumeBeforeMute = this.volume; if (options.autoLoad) { var that = this; setTimeout ( function() { that.load(that.filePath, options.autoPlay, callbackOk, callbackError); }, 10 ); } //Returns the object: return this; } /** * Destroys the audio file object and frees memory. Sets its current {@link CB_AudioFile_API.AAPI#status} property to ABORTED ({@link CB_AudioFile.ABORTED} value). * @function CB_AudioFile_API.AAPI#destructor * @param {boolean} [stopSound=false] - If set to true, it will also call the {@link CB_AudioFile_API.AAPI#stop} method. * @param {boolean} [keepStoppedUnaltered=false] - Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the {@link CB_AudioFile_API.AAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [avoidOnStop=false] - Used internally as the &quot;avoidOnStop&quot; parameter to call the {@link CB_AudioFile_API.AAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [forceOnStop=false] - Used internally as the &quot;forceOnStop&quot; parameter to call the {@link CB_AudioFile_API.AAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.destructor = function(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop) { this._lastDuration = null; //if (typeof(this.audioObject) === &quot;undefined&quot; || this.audioObject === null) { this.status = CB_AudioFile.ABORTED; return; } if (stopSound) { this.stop(keepStoppedUnaltered, avoidOnStop, forceOnStop); } //this.onerror = this.oncanplaythrough = null; //this.audioObject.src = &quot;&quot;; //this.audioObject.load(); CB_Elements.remove(this.audioObject); //if (this.status === CB_AudioFile.LOADING) if (this._loadingCounterIncreased) { this._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } if (this._checkingCounterIncreased) { this._checkingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_AAPI_SM2_beingChecking &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } } this.status = CB_AudioFile.ABORTED; } /** * Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter. * When this method is called, if the {@link CB_AudioFile_API.AAPI#status} property already has the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the {@link CB_AudioFile.LOADING} constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the {@link CB_AudioFile.UNCHECKED} constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the {@link CB_AudioFile_API.AAPI#checkPlaying} method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the {@link CB_AudioFile_API.AAPI#checkPlaying} method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant) and finally the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) if all goes well. * @function CB_AudioFile_API.AAPI#load * @param {string} [filePath={@link CB_AudioFile_API.AAPI#filePath}] - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [autoPlay=false] - If set to true, it will start playing the audio automatically (by calling the {@link CB_AudioFile_API.AAPI#play} method internally). If set to true and the {@link CB_AudioFile_API.AAPI#status} property reaches to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will also call internally the {@link CB_AudioFile_API.AAPI#checkPlaying} method. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @param {boolean} [forceReload=false] - If set to false, the &quot;filePath&quot; has not been changed from the previously used and the {@link CB_AudioFile_API.AAPI#status} property belongs to the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). * @returns {CB_AudioFile_API.AAPI|null} Returns the audio API object (if it was possible to create) or null otherwise. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.load = function(filePath, autoPlay, callbackOk, callbackError, forceReload) { clearTimeout(this._stopAfterPlayingTimeout); clearTimeout(this._checkPlayingTimeout); clearTimeout(this._onReadyTimeout); clearTimeout(this._recursiveCallTimeout); clearTimeout(this._checkPlayingFinishingTimeout); filePath = filePath || this.filePath; //If the status is LOADED and the file path give is the same as the current one, just exits: if (!forceReload &amp;&amp; this.status === CB_AudioFile.LOADED &amp;&amp; this.filePath === filePath) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this); } return this; } this.status = CB_AudioFile.LOADING; //The file is loading. var that = this; //If the maximum of objects loading is reached, calls the function again after some time and exits: //if (CB_AudioFile_API_AAPI_SM2_beingLoading &gt;= CB_AudioFile_API_AAPI_SM2_maximumLoading) if (autoPlay &amp;&amp; CB_AudioFile_API_AAPI_SM2_beingLoading &gt;= CB_AudioFile_API_AAPI_SM2_maximumLoading) { this._recursiveCallTimeout = setTimeout(function() { that.load(filePath, autoPlay, callbackOk, callbackError, forceReload); }, 10); return this; } //Destroys previous object (if any): this.destructor(true, false, true); //Also stops the sound (if any) and prevents firing onStop. this.status = CB_AudioFile.LOADING; //The file is loading. if (!this._loadingCounterIncreased) { this._loadingCounterIncreased = true; CB_AudioFile_API_AAPI_SM2_beingLoading++; //Increases the counter of the objects which are loading (destructor has decreased 1). } this.filePath = filePath; var callbackFunctionError = function(error, ignoreFailed) { //Prevents the execution of the function after the oncanplaythrough event has fired: ////if (onReadyFunctionExecuted) { return; } //Prevents the execution of the function if the object has been declared as LOADED: if (that.status === CB_AudioFile.LOADED || that.status === CB_AudioFile.UNCHECKED || that.status === CB_AudioFile.CHECKING) { return; } CB_Events.remove(that.audioObject, &quot;canplaythrough&quot;, onCanplaythroughHandler, false); CB_Events.remove(that.audioObject, &quot;error&quot;, onErrorHandler, false); if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //If it has already failed before, exits: if (!ignoreFailed &amp;&amp; that.status === CB_AudioFile.FAILED) { return; } if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } that.status = CB_AudioFile.FAILED; //File failed to load. autoPlay = false; //var fileName = filePath; if (filePath.substring(0, 5).toLowerCase() === &quot;data:&quot;) { filePath = filePath.substring(0, 15) + &quot;[...]&quot; + filePath.substring(filePath.length - 2); } error = &quot;Error message for &quot; + filePath + &quot; file: &quot; + error; if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } //Calls the Error function back. }; try { //If the Audio object doesn't exist, creates it: if (typeof(this.audioObject) === &quot;undefined&quot; || this.audioObject === null) { if (typeof(window.Audio) === &quot;undefined&quot;) { callbackFunctionError(&quot;Audio API not found&quot;); return null; } this.audioObject = new Audio(filePath); /////////this.audioObject.src = filePath; } //...otherwise, it updates its source (to avoid creating more than one Audio object): else { CB_Events.remove(this.audioObject, &quot;canplaythrough&quot;, this._onCanplaythroughHandlerLast, false); CB_Events.remove(this.audioObject, &quot;error&quot;, this._onErrorHandlerLast, false); this.audioObject.src = filePath; } var audioObjectOnReadyFunction = function() { CB_Events.remove(that.audioObject, &quot;canplaythrough&quot;, onCanplaythroughHandler, false); CB_Events.remove(that.audioObject, &quot;error&quot;, onErrorHandler, false); onReadyFunction(); //Prepares the sound to be playable (and plays it automatically if we want to). }; //Adds oncanplaythrough event: var onCanplaythroughHandler = this._onCanplaythroughHandlerLast = function() { that._onReadyTimeout = setTimeout(audioObjectOnReadyFunction, 1500); //Gives time to onerror event to be fired before canplaythrough event. }; CB_Events.add ( this.audioObject, &quot;canplaythrough&quot;, onCanplaythroughHandler, false, true, true ); //Adds onerror event: var onErrorHandler = this._onErrorHandlerLast = function() { callbackFunctionError(&quot;Could not be loaded (onerror event fired)&quot;); }; CB_Events.add ( this.audioObject, &quot;error&quot;, onErrorHandler, false, true, true ); //Loads the sound: this.audioObject.load(); //Makes the sound seekable for some iOS versions (strange bug) and forces Firefox for Android to fire canplaythrough event (strange bug too): var previousVolume = this.volume; if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); this.audioObject.muted = true; } var possiblePromise = this.audioObject.play(); //In the case the play method returned a Promise (newer clients), it adds the error event to the catch: var isPromise = false; if (possiblePromise &amp;&amp; typeof(possiblePromise[&quot;catch&quot;]) !== &quot;undefined&quot;) { isPromise = true; possiblePromise[&quot;catch&quot;](function(error) { callbackFunctionError(&quot;Error caught in Promise (load method): &quot; + error); }); //Calls the Error function back. } this._stopAfterPlayingTimeout = setTimeout(function() { that.audioObject.pause(); }, isPromise ? 50 : 1); //If it is a Promise, prevents the 'The play() request was interrupted by a call to pause()' error on Chrome. //Plays the sound during some time because otherwise some web clients, as WebView used by Cordova on Android, receive duration 0 (strange bug): var onReadyFunctionExecuted = false; var onReadyFunction = function() { //Prevents the execution of the function more than once: if (onReadyFunctionExecuted) { return; } onReadyFunctionExecuted = true; //Prevents to be executed after the onerror event has fired: if (that.status === CB_AudioFile.FAILED) { return; } //Function to execute when all is OK: var allIsFine = function() { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } //Restores the volume: that.audioObject.muted = false; that.setVolume(previousVolume); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } //Calls the OK function back. //Plays automatically if we want to: if (autoPlay) { that.play(); } }; that.status = CB_AudioFile.UNCHECKED; //The file is still unchecked. //If we want to play automatically, checks if the currentTime changes (some web clients cannot play if the user did not fire an event to call the play function): if (autoPlay) { that.checkPlaying(function() { allIsFine(); }, function(error) { callbackFunctionError(error, true); }, false, false); } else { allIsFine(); } }; } catch(E) { callbackFunctionError(E); return null; } return this; } /** * Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the {@link CB_AudioFile_API.AAPI#play} method the first time. The checking action will only be performed if the value of the {@link CB_AudioFile_API.AAPI#status} property belongs to the {@link CB_AudioFile.UNCHECKED} or to the {@link CB_AudioFile.CHECKING} value. After checking, if the audio can be played, the {@link CB_AudioFile_API.AAPI#status} of the object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the {@link CB_AudioFile_API.AAPI#status} property will get the value of {CB_AudioFile.FAILED}. * @function CB_AudioFile_API.AAPI#checkPlaying * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object itself. * @param {boolean} [ignoreStatus=false] - If set to false and the {@link CB_AudioFile_API.AAPI#status} property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant) nor to the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. * @param {boolean} [ignoreQueue=false] - If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. * @param {boolean} [useCache=false] - This parameter will be ignored in this audio API. * @returns {boolean} Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.checkPlaying = function(callbackOk, callbackError, ignoreStatus, ignoreQueue, useCache) { /////clearTimeout(this._recursiveCallCheckingTimeout); if (!ignoreStatus &amp;&amp; this.status !== CB_AudioFile.UNCHECKED &amp;&amp; this.status !== CB_AudioFile.CHECKING) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Cannot check if status is not unchecked or checking (status is &quot; + this.status + &quot;)&quot;); } return false; } this.status = CB_AudioFile.CHECKING; var that = this; //If we do not use cache the maximum of objects checking is reached or we use cache but the file path is checking, calls the function again after some time and exits: if (!ignoreQueue &amp;&amp; CB_AudioFile_API_AAPI_SM2_beingChecking &gt;= CB_AudioFile_API_AAPI_SM2_maximumChecking) { this._recursiveCallCheckingTimeout = setTimeout(function() { that.checkPlaying(callbackOk, callbackError, ignoreStatus, useCache); }, 10); return true; } //////this.status = CB_AudioFile.CHECKING; if (!this._checkingCounterIncreased) { this._checkingCounterIncreased = true; CB_AudioFile_API_AAPI_SM2_beingChecking++; //Increases the counter of the objects which are checking. } var previousVolume = this.volume; var finishedChecking = function(ok, error, keepStatus) { //Stops the file: that.audioObject.pause(); //Restores the volume: that._checkPlayingFinishingTimeout = //Timeout to prevent hearing the sound in some web clients. setTimeout ( function() { that.audioObject.muted = false; that.setVolume(previousVolume); //If the file is ok: if (ok) { if (!keepStatus) { that.status = CB_AudioFile.LOADED; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } } //...otherwise, if the file has failed: else { if (!keepStatus) { that.status = CB_AudioFile.FAILED; } if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } } }, 10 ); if (that._checkingCounterIncreased) { that._checkingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_AAPI_SM2_beingChecking &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } } }; try { //Plays the sound during some time to let some web clients get the duration correctly (strange bug): if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); this.audioObject.muted = true; } var possiblePromise = this.audioObject.play(); //In the case the play method returned a Promise (newer clients), it adds the error event to the catch: if (possiblePromise &amp;&amp; typeof(possiblePromise[&quot;catch&quot;]) !== &quot;undefined&quot;) { possiblePromise[&quot;catch&quot;](function(error) { finishedChecking(false, &quot;Error caught in Promise (checkPlaying method): &quot; + error); }); //Calls the Error function back. } var durationDetected = this.getDuration(); var timesCurrentTimeChecked = 0; clearTimeout(this._checkPlayingTimeout); clearTimeout(this._checkPlayingFinishingTimeout); var checkFunction = function(callbackOk, callbackError) { clearTimeout(that._checkPlayingTimeout); //If it is has been aborted, we exit: if (that.status === CB_AudioFile.ABORTED || that.status === CB_AudioFile.FAILED) { finishedChecking(false, &quot;Audio file object is &quot; + (that.status === CB_AudioFile.ABORTED ? &quot;ABORTED&quot; : &quot;FAILED&quot;) + &quot;.&quot;, true); return; } try { that.status = CB_AudioFile.CHECKING; //If the duration has changed, it calls the function again because it means the audio is still loading (otherwise, Firefox has issues with data URIs and detects a shorter duration): var durationDetectedNow = that.getDuration(); if (durationDetected !== durationDetectedNow) { durationDetected = durationDetectedNow; that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS); return; } //If the current time is still 0: if (that.audioObject.currentTime == 0) { //We give it some opportunities more to change current time: if (timesCurrentTimeChecked &lt; 1000) { timesCurrentTimeChecked++; if (timesCurrentTimeChecked % 20 === 0) { that.audioObject.pause(); try { that.audioObject.currentTime = 0; } catch(E) {} //Avoid Firefox complain about using an object which is no longer available. var possiblePromise = that.audioObject.play(); //In the case the play method returned a Promise (newer clients), it adds the error event to the catch: if (possiblePromise &amp;&amp; typeof(possiblePromise[&quot;catch&quot;]) !== &quot;undefined&quot;) { possiblePromise[&quot;catch&quot;](function(error) { finishedChecking(false, &quot;Error caught in Promise (checkPlaying method in CheckFunction): &quot; + error); }); //Calls the Error function back. } /* try { if (that.audioObject.currentTime != 0) { that.audioObject.currentTime = 0.00000000001; //Executed after play method because otherwise Safari Mobile does not change currentTime. } } catch(E) {} */ } that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, 1); return; } //...if all opportunities failed, we declare it as FAILED and exits: else { finishedChecking(false, &quot;currentTime does not change (it is &quot; + that.audioObject.currentTime + &quot;).&quot;); return; } } //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (that.audioObject.currentTime != 0) { that.audioObject.currentTime = 0; } //If the duration is zero, we declare it as FAILED and exits: if (that.getDuration() === 0) { finishedChecking(false, &quot;Duration is zero&quot;); return; } finishedChecking(true); } catch(E) { finishedChecking(false, E); } }; this._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS); return true; } catch(E) { finishedChecking(false, E); return false; } } /** * Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. * @function CB_AudioFile_API.AAPI#getDuration * @returns {number} Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.getDuration = function() { var duration; if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null) { duration = this.audioObject.duration * 1000; } if (typeof(duration) === &quot;undefined&quot; || duration === null || isNaN(duration) || duration &lt; 0) { duration = 0; } return duration; } //Executed when there is an error playing: CB_AudioFile_API[&quot;AAPI&quot;].prototype._onPlayingErrorFunction = function(onPlayingErrorFunction) { CB_Events.remove(this.audioObject, &quot;error&quot;, onPlayingErrorFunction, false); if (this._onPlayingErrorFunctionExecuted) { return; } this._onPlayingErrorFunctionExecuted = true; this.status = CB_AudioFile.FAILED; //Declares it as failed. this.stop(false, false, true); //Also fires onStop event. }; //Executed when the sound stops playing: CB_AudioFile_API[&quot;AAPI&quot;].prototype._checkWhenStopFunction = function(e, finished, startAtNextLoop, stopAt, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, checkWhenStopFunction, whenStopFunction, flags) { //If we are using timeupdadte event (finished is undefined) but whenStopFunction has been executed (ended event or timeout has been executed), exits: //if (!finished &amp;&amp; whenStopFunctionExecuted) { return; } //If the sound has been stopped or paused or the stop time has changed: if (this.stopped || this.paused || this.lastStopAt !== stopAt) { //Removes the events: clearTimeout(this._timeoutWhenStop); this._onPlayingErrorFunctionExecuted = true; CB_Events.remove(this.audioObject, &quot;timeupdate&quot;, checkWhenStopFunction, false); CB_Events.remove(this.audioObject, &quot;ended&quot;, whenStopFunction, false); } //...otherwise, if the stop time has been reached: else if (finished || this.getCurrentTime() &gt;= stopAt - 1) //Allows 1 ms of margin (because in some web clients, currentTime will never reach the total duration). { //Removes the event: clearTimeout(this._timeoutWhenStop); CB_Events.remove(this.audioObject, &quot;timeupdate&quot;, checkWhenStopFunction, false); CB_Events.remove(this.audioObject, &quot;ended&quot;, whenStopFunction, false); //if (finished) { this.audioObject.pause(); this.audioObject.currentTime = 0; this.audioObject.play(); this.audioObject.currentTime = 0; this.audioObject.pause(); } //If we want to loop, loops again: if (this.loop) //Only allows one loop per time. { if (!flags.loopPerformed) { flags.loopPerformed = true; //this.stop(true); //Stops the sound without setting its property as stopped. this.play(startAtNextLoop, stopAt, true, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, false, true); //Plays again the sound. } } //...otherwise, if we don't want to loop, we stop at the given position (ms): else { this._onPlayingErrorFunctionExecuted = true; this.stop(); } //Stops the sound. } }; /** * Plays the audio. * @function CB_AudioFile_API.AAPI#play * @param {number} [startAt=0 | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the {@link CB_AudioFile_API.AAPI#lastStartAt} property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the {@link CB_AudioFile_API.AAPI#lastStartAt} value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. * @param {number} [stopAt={@link CB_AudioFile_API.AAPI#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the {@link CB_AudioFile_API.AAPI#getDuration} method (which should belong to the total duration of the audio, if it was calculated correctly). * @param {boolean} [loop={@link CB_AudioFile_API.AAPI#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.AAPI#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.AAPI#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @param {boolean} [isResume=false] - If set to true (not recommended) and it is a looping audio, the next loop will use the value of the {@link CB_AudioFile_API.AAPI#lastStartAt} property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. * @param {boolean} [isLooping=false] - Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. * @param {integer} [startPlayingTime] - Contains the time when the audio should start playing. Recommended for internal usage only. * @returns {boolean|integer} It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.play = function(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime) { var that = this; var duration = this.getDuration(); if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } var onPlayingErrorFunction = function() { that._onPlayingErrorFunction.call(that, onPlayingErrorFunction); }; //If the sound is not ready yet, calls the function again but later: if (this.status !== CB_AudioFile.LOADED || duration === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; CB_Events.remove(this.audioObject, &quot;error&quot;, onPlayingErrorFunction, false); //If it has not failed or aborted: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) //It must be UNLOADED, LOADING, LOADED, UNCHECKED or CHECKING. { //Function that calls the play method recursively (unless the maximum time allowed has expired): var playLaterFunctionCalled = false; var playLaterFunction = function() { if (playLaterFunctionCalled) { return; } playLaterFunctionCalled = true; //If the recursive delay is not null and is a valid number: if (typeof(allowedRecursiveDelay) === &quot;undefined&quot; || allowedRecursiveDelay === null || isNaN(allowedRecursiveDelay) || allowedRecursiveDelay &lt; 0) { allowedRecursiveDelay = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT; //We use default value. } var timeNow = CB_Device.getTiming(); //If the time expired is less or equal to the delay allowed: if (timeNow - startPlayingTime &lt;= allowedRecursiveDelay) { //Calls play method again: that.play(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime); } //...otherwise, just stops the sound: /////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //Function to execute when the sound loads successfully (or finishes checking successfully): var onLoad = function() { //If we allow delayed play, plays the sound: if (!avoidDelayedPlay) { playLaterFunction(); } //...otherwise, just stops the sound (to fire onStop function): //////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //If it is UNLOADED or we had a duration before but not now and it is not LOADING, loads the file again: if (this.status === CB_AudioFile.UNLOADED || this.status !== CB_AudioFile.LOADING &amp;&amp; this._lastDuration !== null &amp;&amp; duration === 0) { this.load(this.filePath, false, onLoad, onLoadError, true); } //...otherwise, if it is UNCHECKED, we call the checking function: else if (this.status === CB_AudioFile.UNCHECKED) { this.checkPlaying(onLoad, onLoadError, false, true, false); } //...otherwise, if it is not CHECKING (it must be LOADING or LOADED with duration 0 from the beginning), we will not reload the sound: else if (this.status !== CB_AudioFile.CHECKING) { //If we allow delayed play, calls the play method again but after some time: if (!avoidDelayedPlay) { setTimeout(playLaterFunction, 1); } //...otherwise, just stops the sound (to fire onStop function): //////else { this.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { this.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). } } return -1; } this._lastDuration = duration; //Defines the default parameters: if (CB_trim(startAt) === &quot;&quot;) { startAt = 0; } //Starts at the beginning as default. if (CB_trim(stopAt) === &quot;&quot;) { stopAt = 0; } //If it is not a number, default is zero. if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). else { this.loop = loop; } //...otherwise, stores the new setting given. //Sanitizes startAt and stopAt: startAt = parseFloat(startAt); stopAt = parseFloat(stopAt); if (startAt &lt; 0) { startAt = 0; } if (stopAt &lt;= 0 || stopAt &gt; duration) { stopAt = duration; } //If the stopAt is not correct, plays until the end of the file. if (startAt &gt; stopAt) { startAt = this.lastStartAt; } //In the case start time is than stop time, starts as the previous time. if (startAt &gt; stopAt || isNaN(startAt)) { startAt = stopAt; } //If the duration is zero (startAt and stopAt are equal), exits: if (startAt === stopAt) { this.stop(); return false; } //Next loop (if any) it will start at the same time by default: var startAtNextLoop = startAt; //If it is a resume, next loop we should start from the previous startAt used: if (isResume) { startAtNextLoop = this.lastStartAt; } //...otherwise, if it is not a resume, stores the startAt used: else { this.lastStartAt = startAt; } this.lastStopAt = stopAt; //Stores stopAt used. //Adds the events to check when the file reaches the stop time: this.audioObject.loop = false; //We will use our own way to loop, so we don't need the normal way. var flags = { &quot;loopPerformed&quot; : false }; var checkWhenStopFunction = function(e, finished) { that._checkWhenStopFunction.call(that, e, finished, startAtNextLoop, stopAt, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, checkWhenStopFunction, whenStopFunction, flags); }; var whenStopFunctionExecuted = false; var whenStopFunction = function(e) { //Just allows executing the function once: if (whenStopFunctionExecuted) { return; } whenStopFunctionExecuted = true; checkWhenStopFunction.call(that, e, true); }; CB_Events.add(this.audioObject, &quot;ended&quot;, whenStopFunction, false, true, true); this._onPlayingErrorFunctionExecuted = false; CB_Events.remove(this.audioObject, &quot;error&quot;, onPlayingErrorFunction, false); CB_Events.add(this.audioObject, &quot;error&quot;, onPlayingErrorFunction, false); clearTimeout(this._timeoutWhenStop); //Clears the previous timeout (if any). //If we want to use timeout: if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AAPI_USE_TIMEOUT_TO_DETECT_STOPAT) { //If it is not a loop (it is the first call to the play method) or we do not want to loop: if (!isLooping || !loop) { CB_symmetricCallClear(&quot;AAPI_AUDIO_FILE&quot; + this._id_internal); } //We clean the cache of setTimeoutSynchronized for the loop function. var msToFinish = stopAt - startAt; this._timeoutWhenStop = CB_symmetricCall(whenStopFunction, msToFinish, &quot;AAPI_AUDIO_FILE&quot; + this._id_internal); } //...otherwise, we use timeupdate: else { CB_Events.add(this.audioObject, &quot;timeupdate&quot;, checkWhenStopFunction, false, true, true); } //If it is looping or does not allow overlapping and it is not paused, stops the possible previous sound (although AAPI would never overlap normally): //if (isLooping || !allowOverlapping &amp;&amp; !this.paused) { this.stop(true); } //Stops the sound without setting its property as stopped. this.stop(true, true); //Stops the sound without setting its property as stopped. //Applies the current volume: this.setVolume(this.volume); //If defined, starts at the given position (ms): var currentTime = startAt / 1000; //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (currentTime !== 0 || this.audioObject.currentTime != 0) { this.audioObject.currentTime = currentTime; } //Plays the file: var possiblePromise = this.audioObject.play(); //In the case the play method returned a Promise (newer clients), it adds the error event to the catch: if (possiblePromise &amp;&amp; typeof(possiblePromise[&quot;catch&quot;]) !== &quot;undefined&quot;) { possiblePromise[&quot;catch&quot;] ( function(error) { that.status = CB_AudioFile.FAILED; onLoadError(false, &quot;Error caught in Promise (play method): &quot; + error); } ); } //If defined, starts at the given position (ms): ////////if (currentTime === 0) { currentTime = 0.001; } //Safari Mobile works wrong the second loop if it we set currentTime to 0, so we add 0.00000000001 (strange bug). //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): ///////if (this.audioObject.currentTime !== currentTime &amp;&amp; (currentTime !== 0 || this.audioObject.currentTime != 0)) if (currentTime !== 0 || this.audioObject.currentTime != 0) { this.audioObject.currentTime = currentTime + 0.00000000001; //Executed after play method because otherwise Safari Mobile does not change currentTime. } //The sound is neither paused nor stopped: this.paused = this.stopped = false; //If it is the first time (not a loop) and there is a function to call when the play starts, we call it: if (!isLooping &amp;&amp; typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(this, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); onPlayStart = null; } //Prevents execution again. return true; } /** * Resumes the audio (after being paused), starting from the same point it was paused previously. * @function CB_AudioFile_API.AAPI#resume * @param {boolean} [loop={@link CB_AudioFile_API.AAPI#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.AAPI#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the {@link CB_AudioFile_API.AAPI#stop} method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.AAPI#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @returns {boolean|integer} Returns the returning value of the {@link CB_AudioFile_API.AAPI#play} method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.resume = function(loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError) { //If it not paused or it is stopped, exits the function: if (!this.paused || this.stopped) { return false; } var startAt = this.pauseTime; //If it has been paused after the stop time (happens sometimes when the sound was nearly to finish): if (startAt &gt;= this.lastStopAt) { startAt = this.lastStopAt - 1; //We will begin just 1 millisecond before (otherwise the play method would begin again from lastStartAt). } return this.play(startAt, this.lastStopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, true, false); } /** * Pauses the audio when it is being played. * @function CB_AudioFile_API.AAPI#pause * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @param {boolean} [keepPausedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.AAPI#paused} property will not be set to true and it will remain with its current value. * @returns {boolean} It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.pause = function(onPause, keepPausedUnaltered) { //If it already paused or stopped, exits the function: if (this.paused || this.stopped) { return false; } if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null) { clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.audioObject.pause(); this.pauseTime = this.getCurrentTime(); if (!keepPausedUnaltered) { this.paused = true; } if (typeof(onPause) === &quot;function&quot;) { onPause.call(this); } return true; } return false; } /** * Stops the audio. * @function CB_AudioFile_API.AAPI#stop * @param {boolean} [keepStoppedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.AAPI#stopped} property will not be set to true and it will remain with its current value. * @param {boolean} [avoidOnStop=false] - If set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.AAPI#onStop} method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. * @param {boolean} [forceOnStop=false] - If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.AAPI#onStop} method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. * @returns {boolean} It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.stop = function(keepStoppedUnaltered, avoidOnStop, forceOnStop) { if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null) { ///////clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.audioObject.pause(); //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (this.audioObject.currentTime != 0) { this.audioObject.currentTime = 0; } var stoppedBefore = this.stopped; if (!keepStoppedUnaltered) { this.stopped = true; } this.paused = false; //If it is stopped, it is not paused. //If we do not want to avoid onStop, it was not stopped before but it is now and onStop has a valid function assigned, we execute it: if (!avoidOnStop &amp;&amp; (!stoppedBefore &amp;&amp; this.stopped || forceOnStop) &amp;&amp; typeof(this.onStopFunction) === &quot;function&quot;) { this.onStopFunction.call(this); } return true; } return false; } /** * Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @function CB_AudioFile_API.AAPI#setVolume * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the {@link CB_AudioFile_API.AAPI#volume} property even when the volume failed to be changed. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @param {boolean} [saveForUnmute=false] - If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the {@link CB_AudioFile_API.AAPI#unmute} method. Internal usage only recommended. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.setVolume = function(volume, forceSetVolumeProperty, onSetVolume, saveForUnmute) { //Defines the default parameters: volume = parseInt(volume); if (isNaN(volume)) { this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; volume = this.DEFAULT_VOLUME; } //Sets the volume within their limits if it is beyond them: var MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM ? CB_Speaker.getVolume() : 100; if (volume &gt; MAX_VOLUME) { volume = MAX_VOLUME; } else if (volume &lt; 0) { volume = 0; } if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null) { this.audioObject.volume = volume / 100; if ((saveForUnmute || volume === 0) &amp;&amp; this.volume &gt; 0) { this.volumeBeforeMute = this.volume; } //Also saves the previous volume if the desired one is zero (muted). this.volume = volume; if (typeof(onSetVolume) === &quot;function&quot;) { onSetVolume.call(this); } } if (forceSetVolumeProperty) { this.volume = volume; } return this.volume; } /** * Mutes the audio file. * @function CB_AudioFile_API.AAPI#mute * @param {function} [onMute] - Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.mute = function(onMute) { //Only mutes the sound if it is not muted already: if (this.volume &gt; 0) { //Mutes the audio: this.setVolume(0, false, onMute, true); //It modifies this.volumeBeforeMute. } return this.volume; } /** * Restores audio after muting it (unmutes it). * @function CB_AudioFile_API.AAPI#unmute * @param {function} [onUnmute] - Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.unmute = function(onUnmute) { //Only unmutes if it is still muted: if (this.volume === 0) { //Restores the volume before muting: this.setVolume(this.volumeBeforeMute, false, onUnmute); } return this.volume; } /** * Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. * @function CB_AudioFile_API.AAPI#getCurrentTime * @returns {number} Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.getCurrentTime = function() { var currentTime; if (this.status !== CB_AudioFile.LOADED) { return 0; } if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null) { currentTime = this.audioObject.currentTime * 1000; } if (typeof(currentTime) === &quot;undefined&quot; || currentTime === null || isNaN(currentTime) || currentTime &lt; 0) { currentTime = 0; } return currentTime; } /** * Sets a function to execute when the audio file stops playing or removes it. * @function CB_AudioFile_API.AAPI#onStop * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the {@link CB_AudioFile_API.AAPI} object. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @returns {boolean} Returns whether the event has been set or not (removed). */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.onStop = function(callbackFunction, keepOldFunction) { //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } if (typeof(callbackFunction) !== &quot;function&quot;) { this.onStopFunction = null; return false; } //If we don't want to keep the old function: if (!keepOldFunction) { this.onStopFunction = callbackFunction; } //...otherwise if we want to keep the old function, we keep it: else { var that = this; //Stores old function: var oldFunction = this.onStopFunction; //Stores old function of eventFunctionHolder. this.onStopFunction = function() { if (typeof(oldFunction) === &quot;function&quot;) { oldFunction.call(that); } callbackFunction.call(that); }; } return true; } /** * Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @function CB_AudioFile_API.AAPI#getProgress * @returns {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFile_API[&quot;AAPI&quot;].prototype.getProgress = function() { if (this.status === CB_AudioFile.LOADED || this.status === CB_AudioFile.UNCHECKED || this.status === CB_AudioFile.CHECKING) { return 100; } else if (this.status === CB_AudioFile.UNLOADED) { return 0; } var progress = 0; //Calculates the progress (only if it is LOADING, FAILED or ABORTED): if (typeof(this.audioObject) !== &quot;undefined&quot; &amp;&amp; this.audioObject !== null &amp;&amp; typeof(this.audioObject.buffered) !== &quot;undefined&quot;) { var duration = this.getDuration() / 1000; var bufferedLength = this.audioObject.buffered.length; var secondsBuffered = 0; for (var x = 0; x &lt; bufferedLength; x++) { secondsBuffered += this.audioObject.buffered.end(x) - this.audioObject.buffered.start(x); } if (duration === 0) { if (secondsBuffered &gt; 0) { return 100; } else { return 0; } } else { progress = secondsBuffered / duration * 100; } if (progress &gt; 100) { progress = 100; } else if (progress &lt; 0) { progress = 0; } } return progress; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFile_API_ACMP.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFile_API_ACMP.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js /** * @file Audio files management using &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}). Contains the {@link CB_AudioFile_API.ACMP} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ //Class to manage an audio file with ACMP (Apache Cordova Media Plugin): if (typeof(CB_AudioFile_API) === &quot;undefined&quot;) { var CB_AudioFile_API = {}; } /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. * @class CB_AudioFile_API.ACMP * @memberof! &lt;global&gt; * @classdesc Class to manage an audio file using &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}). Used by the {@link CB_AudioFile} class internally and it shares most of its properties and methods. Recommended for internal usage only. * @param {string} filePath - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioId='CB_AUDIOFILE_ACMP_' + CB_AudioFile_API.ACMP._idUnique++] - Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. * @param {CB_AudioFile_API.ACMP.OPTIONS} [options=CB_AudioFile_API.ACMP#DEFAULT_OPTIONS] - Object with the desired options. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @returns {CB_AudioFile_API.ACMP} Returns a new {@link CB_AudioFile_API.ACMP} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ CB_AudioFile_API[&quot;ACMP&quot;] = function(filePath, audioId, options, callbackOk, callbackError) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFile_API[&quot;ACMP&quot;])) { return new CB_AudioFile_API[&quot;ACMP&quot;](filePath, audioId, options, callbackOk, callbackError); } //Constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant CB_AudioFile_API.ACMP#DEFAULT_VOLUME * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; /** * Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @constant CB_AudioFile_API.ACMP#DEFAULT_OPTIONS * @type {CB_AudioFile_API.ACMP.OPTIONS} * @default { autoLoad: true, autoPlay: false, loop: false, volume: [CB_AudioFile_API.ACMP.prototype.DEFAULT_VOLUME]{@link CB_AudioFile_API.ACMP#DEFAULT_VOLUME} } */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.DEFAULT_OPTIONS = { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API[&quot;ACMP&quot;].prototype.DEFAULT_VOLUME }; //Properties and variables: /** * Tells whether the file is unloaded ({@link CB_AudioFile.UNLOADED}), loading ({@link CB_AudioFile.LOADING}), unchecked ({@link CB_AudioFile.UNCHECKED}), checking ({@link CB_AudioFile.CHECKING}), loaded ({@link CB_AudioFile.LOADED}), failed ({@link CB_AudioFile.FAILED}) or aborted ({@link CB_AudioFile.ABORTED}). * @var CB_AudioFile_API.ACMP#status * @readonly * @type {integer} * @default {@link CB_AudioFile.UNLOADED} */ this.status = CB_AudioFile.UNLOADED; /** * Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the {@link CB_AudioFile_API.ACMP#play} method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). * @var CB_AudioFile_API.ACMP#loop * @readonly * @type {boolean} * @default [CB_AudioFile_API.ACMP.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.loop */ this.loop = CB_AudioFile_API[&quot;ACMP&quot;].prototype.DEFAULT_OPTIONS.loop; /** * Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.ACMP#volume * @readonly * @type {number} * @default [CB_AudioFile_API.ACMP.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.volume */ this.volume = CB_AudioFile_API[&quot;ACMP&quot;].prototype.DEFAULT_OPTIONS.volume; /** * Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.ACMP#volumeBeforeMute * @readonly * @type {number} * @default {@link CB_AudioFile_API.ACMP#volume} */ this.volumeBeforeMute = this.volume; /** * Stores the identifier for the audio file. * @var CB_AudioFile_API.ACMP#id * @readonly * @type {string} * @default 'CB_AUDIOFILE_ACMP_' + CB_AudioFile_API.ACMP._idUnique++ */ this.id = &quot;&quot;; /** * Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @var CB_AudioFile_API.ACMP#filePath * @readonly * @type {string} * @default */ this.filePath = &quot;&quot;; /** * Tells whether the audio is paused or not. * @var CB_AudioFile_API.ACMP#paused * @readonly * @type {boolean} * @default false */ this.paused = false; /** * Stores the time (in milliseconds) when the audio has been paused. * @var CB_AudioFile_API.ACMP#pauseTime * @readonly * @type {number} * @default */ this.pauseTime = 0; /** * Tells whether the audio is stopped or not. * @var CB_AudioFile_API.ACMP#stopped * @readonly * @type {boolean} * @default true */ this.stopped = true; /** * Function to call when the audio stops. * @var CB_AudioFile_API.ACMP#onStopFunction * @readonly * @type {function} * @default */ this.onStopFunction = undefined; /** * Stores the last &quot;startAt&quot; parameter value used by the {@link CB_AudioFile_API.ACMP#play} or the {@link CB_AudioFile_API.ACMP#resume} method. * @var CB_AudioFile_API.ACMP#lastStartAt * @readonly * @type {number} * @default */ this.lastStartAt = null; /** * Stores the last &quot;stopAt&quot; parameter value used by the {@link CB_AudioFile_API.ACMP#play} or the {@link CB_AudioFile_API.ACMP#resume} method. * @var CB_AudioFile_API.ACMP#lastStopAt * @readonly * @type {number} * @default */ this.lastStopAt = null; /** * Stores the [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object of the audio, used by the &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}). * @var CB_AudioFile_API.ACMP#mediaObject * @readonly * @type {Object} * @default */ this.mediaObject = undefined; /** * Stores the current position (in seconds) where the audio is playing (returned by the [getCurrentPosition]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} method), used by the &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}). * @var CB_AudioFile_API.ACMP#position * @readonly * @type {number} * @default */ this.position = 0; //Internal properties: this._mediaObjectSwap = null; //Media object for swapping (used for ACMP). Necessary due ACMP issues when looping a sprite near the end of the audio file. this._positionSwap = 0; //Keeps the current position (in seconds) for the swap object. this._timeoutWhenStop = null; //Keeps the timeout that is executed when the audio has finished playing (to either stop or loop). this._id_internal = null; //Internal id. this._checkDurationTimeout = null; this._swapChecked = false; this._updatePositionLoopExecuted = false; this._checkPlayingTimeout = null; this._checkPlayingFinishingTimeout = null; //this._recursiveCallCheckingTimeout = null; this._lastDuration = null; //this._resuming = false; //Calls the constructor of the object when creates an instance: return this._init(filePath, audioId, options, callbackOk, callbackError); } /** * Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @memberof CB_AudioFile_API.ACMP * @typedef {Object} CB_AudioFile_API.ACMP.OPTIONS * @property {boolean} [autoLoad={@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.autoLoad] - If set to false, it will not call the {@link CB_AudioFile_API.ACMP#load} method internally when the constructor is called (not recommended). * @property {boolean} [autoPlay={@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.autoPlay] - Value which will be used as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile_API.ACMP#load} method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). * @property {boolean} [loop={@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.loop] - Value that will be used for the {@link CB_AudioFile_API.ACMP#loop} property. * @property {number} [volume={@link CB_AudioFile_API.ACMP#DEFAULT_OPTIONS}.volume] - The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that will be used for the {@link CB_AudioFile_API.ACMP#volume} property. */ //Static properties: CB_AudioFile_API[&quot;ACMP&quot;]._counter = 0; //Internal counter. CB_AudioFile_API[&quot;ACMP&quot;]._idUnique = 0; //Counter to make the id unique. //Constructor: CB_AudioFile_API[&quot;ACMP&quot;].prototype._init = function(filePath, audioId, options, callbackOk, callbackError) { //If not given, defines the default parameters: if (typeof(audioId) === &quot;undefined&quot; || audioId === null) { audioId = &quot;CB_AUDIOFILE_ACMP_&quot; + CB_AudioFile_API[&quot;ACMP&quot;]._idUnique++; } //Uses the file path as default id. if (typeof(options) === &quot;undefined&quot; || options === null) { options = this.DEFAULT_OPTIONS; } else { if (typeof(options.loop) === &quot;undefined&quot; || options.loop === null) { options.loop = this.DEFAULT_OPTIONS.loop; } if (typeof(options.autoLoad) === &quot;undefined&quot; || options.autoLoad === null) { options.autoLoad = this.DEFAULT_OPTIONS.autoLoad; } if (typeof(options.autoPlay) === &quot;undefined&quot; || options.autoPlay === null) { options.autoPlay = this.DEFAULT_OPTIONS.autoPlay; } if (typeof(options.volume) === &quot;undefined&quot; || options.volume === null) { options.volume = this.DEFAULT_OPTIONS.volume; } } //Sets the audio ID: this.id = CB_trim(audioId).toUpperCase(); //Sets the internal id: if (typeof(this._id_internal) === &quot;undefined&quot; || this._id_internal === null) { this._id_internal = CB_AudioFile_API[&quot;ACMP&quot;]._counter++; } //Sets the file path: this.filePath = filePath; //Proceeds according to the options sent: this.loop = options.loop; this.volume = options.volume; this.volumeBeforeMute = this.volume; if (options.autoLoad) { var that = this; setTimeout ( function() { that.load(that.filePath, options.autoPlay, callbackOk, callbackError); }, 10 ); } //Returns the object: return this; } /** * Destroys the audio file object and frees memory. Sets its current {@link CB_AudioFile_API.ACMP#status} property to ABORTED ({@link CB_AudioFile.ABORTED} value). * @function CB_AudioFile_API.ACMP#destructor * @param {boolean} [stopSound=false] - If set to true, it will also call the {@link CB_AudioFile_API.ACMP#stop} method. * @param {boolean} [keepStoppedUnaltered=false] - Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the {@link CB_AudioFile_API.ACMP#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [avoidOnStop=false] - Used internally as the &quot;avoidOnStop&quot; parameter to call the {@link CB_AudioFile_API.ACMP#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [forceOnStop=false] - Used internally as the &quot;forceOnStop&quot; parameter to call the {@link CB_AudioFile_API.ACMP#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.destructor = function(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop) { try { if (typeof(this._mediaObjectSwap) !== &quot;undefined&quot; &amp;&amp; this._mediaObjectSwap !== null) { this._mediaObjectSwap.release(); CB_Elements.remove(this.mediaObject); } } catch(E) {} this._lastDuration = null; if (typeof(this.mediaObject) === &quot;undefined&quot; || this.mediaObject === null) { this.status = CB_AudioFile.ABORTED; return; } if (stopSound) { this.stop(keepStoppedUnaltered, avoidOnStop, forceOnStop); } try { this.mediaObject.release(); CB_Elements.remove(this.mediaObject); } catch(E) {} this.status = CB_AudioFile.ABORTED; } /** * Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter. * When this method is called, if the {@link CB_AudioFile_API.ACMP#status} property already has the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the {@link CB_AudioFile.LOADING} constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the {@link CB_AudioFile.UNCHECKED} constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the {@link CB_AudioFile_API.ACMP#checkPlaying} method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the {@link CB_AudioFile_API.ACMP#checkPlaying} method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant) and finally the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) if all goes well. * @function CB_AudioFile_API.ACMP#load * @param {string} [filePath={@link CB_AudioFile_API.ACMP#filePath}] - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [autoPlay=false] - If set to true, it will start playing the audio automatically (by calling the {@link CB_AudioFile_API.ACMP#play} method internally). If set to true and the {@link CB_AudioFile_API.ACMP#status} property reaches to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will also call internally the {@link CB_AudioFile_API.ACMP#checkPlaying} method. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @param {boolean} [forceReload=false] - If set to false, the &quot;filePath&quot; has not been changed from the previously used and the {@link CB_AudioFile_API.ACMP#status} property belongs to the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). * @returns {CB_AudioFile_API.ACMP|null} Returns the audio API object (if it was possible to create) or null otherwise. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.load = function(filePath, autoPlay, callbackOk, callbackError, forceReload) { clearTimeout(this._checkDurationTimeout); clearTimeout(this._checkPlayingTimeout); clearTimeout(this._checkPlayingFinishingTimeout); filePath = filePath || this.filePath; //If the status is LOADED and the file path give is the same as the current one, just exits: if (!forceReload &amp;&amp; this.status === CB_AudioFile.LOADED &amp;&amp; this.filePath === filePath) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this); } return this; } //Destroys previous object (if any): this.destructor(true, false, true); //Also stops the sound (if any) and prevents firing onStop. this.status = CB_AudioFile.LOADING; //The file is loading. this.filePath = filePath; var that = this; var anyCallbackFunctionCalled = false; this._swapChecked = false; this.position = this._positionSwap = 0; var callbackFunctionError = function(error) { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //If the success function has been called already (sound is loaded), ignores the fail: if (anyCallbackFunctionCalled) { return; } anyCallbackFunctionCalled = true; that.status = CB_AudioFile.FAILED; //File failed to load. autoPlay = false; //var fileName = filePath; if (filePath.substring(0, 5).toLowerCase() === &quot;data:&quot;) { filePath = filePath.substring(0, 15) + &quot;[...]&quot; + filePath.substring(filePath.length - 2); } if (!CB_isString(error) &amp;&amp; typeof(error) !== &quot;undefined&quot; &amp;&amp; (typeof(error.message) !== &quot;undefined&quot; || typeof(error.code) !== &quot;undefined&quot;)) { error = &quot;Error for &quot; + filePath + &quot; file: &quot; + error.message + &quot; [code: &quot; + error.code + &quot;]&quot;; } else { error = &quot;Error for &quot; + filePath + &quot; file: &quot; + error; } try { if (typeof(that.mediaObject) !== &quot;undefined&quot; &amp;&amp; that.mediaObject !== null) { that.mediaObject.release(); } if (typeof(that._mediaObjectSwap) !== &quot;undefined&quot; &amp;&amp; that._mediaObjectSwap !== null) { that._mediaObjectSwap.release(); } } catch(E) {} if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } //Calls the Error function back. }; try { var timesChecked = 0; var callbackFunctionSuccess = function() { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //If the success function has been called already (sound is loaded), exits: if (anyCallbackFunctionCalled) { return; } //Success callback is called all the time the file plays successfully in ACMP, so we need to call callbackOk just once: if (that.status !== CB_AudioFile.LOADED) { //Checks for the duration and fails after some attempts: if (that.getDuration() === 0) { if (++timesChecked &lt; 1000) { that._checkDurationTimeout = setTimeout(callbackFunctionSuccess, 1); } else { callbackFunctionError(&quot;Duration is zero&quot;); } return; } anyCallbackFunctionCalled = true; //Function to execute when all is OK: var allIsFine = function() { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //Restores the volume: that.setVolume(previousVolume); var checkSwapFinished = function() { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } //Calls the OK function back. //Plays automatically if we want to: if (autoPlay) { that.play(); } }; //Function that checks swap object: var checkSwapObject = function() { //If the swap object has been created successfully: if (that._mediaObjectSwap !== null &amp;&amp; !that._swapChecked) { var updatePositionSwap = function() { var callAgain = true; if (!that._swapChecked &amp;&amp; typeof(that._mediaObjectSwap) !== &quot;undefined&quot; &amp;&amp; that._mediaObjectSwap !== null) { that._mediaObjectSwap.getCurrentPosition ( function(positionSwap) { that._positionSwap = positionSwap; if (isNaN(that._positionSwap) || that._positionSwap &lt; 0) { that._positionSwap = 0; } } ); setTimeout(updatePositionSwap, 1); } else { that._positionSwap = 0; } }; updatePositionSwap(); that.checkPlaying(checkSwapFinished, function() { that._mediaObjectSwap = null; checkSwapFinished(); }, false, false, false, true); } }; //Creates the second mediaObject for swapping: var swapFunctionCalled = false; that._mediaObjectSwap = new Media ( filePath, function() { if (swapFunctionCalled) { return; } swapFunctionCalled = true; //Checks the swap object: checkSwapObject(); }, function() { if (swapFunctionCalled) { return; } swapFunctionCalled = true; try { if (typeof(that._mediaObjectSwap) !== &quot;undefined&quot; &amp;&amp; that._mediaObjectSwap !== null) { that._mediaObjectSwap.release(); } } catch(E) {} that._mediaObjectSwap = null; } ); that._mediaObjectSwap.play(); //Needs to be played to fire events. that._mediaObjectSwap.stop(); }; that.status = CB_AudioFile.UNCHECKED; //The file is still unchecked. //If we want to play automatically, checks if the currentTime changes (some web clients cannot play if the user did not fire an event to call the play function): if (autoPlay) { that.checkPlaying(function() { allIsFine(); }, function(error) { callbackFunctionError(error, true); }, false, false, false); } else { allIsFine(); } } }; if (typeof(Media) === &quot;undefined&quot;) { callbackFunctionError(&quot;Apache Cordova Media plugin not found&quot;); return null; } this.mediaObject = new Media(filePath, callbackFunctionSuccess, callbackFunctionError); var previousVolume = this.volume; if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); } //Media object needs to be played to fire events, so we call play method and stop it immediately: this.mediaObject.play(); //this.mediaObject.seekTo(0); this.mediaObject.stop(); //Starts the interval that will update the position all the time: if (!this._updatePositionLoopExecuted) { this._updatePositionLoopExecuted = true; var updatePosition = function() { if (typeof(that.mediaObject) !== &quot;undefined&quot; &amp;&amp; that.mediaObject !== null) { that.mediaObject.getCurrentPosition ( function(position) { that.position = position; if (isNaN(that.position) || that.position &lt; 0) { that.position = 0; } } ); } else { that.position = 0; } setTimeout(updatePosition, 1); }; updatePosition(); } } catch(E) { callbackFunctionError(E); return null; } return this; } /** * Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the {@link CB_AudioFile_API.ACMP#play} method the first time. The checking action will only be performed if the value of the {@link CB_AudioFile_API.ACMP#status} property belongs to the {@link CB_AudioFile.UNCHECKED} or to the {@link CB_AudioFile.CHECKING} value. After checking, if the audio can be played, the {@link CB_AudioFile_API.ACMP#status} of the object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the {@link CB_AudioFile_API.ACMP#status} property will get the value of {CB_AudioFile.FAILED}. * @function CB_AudioFile_API.ACMP#checkPlaying * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object itself. * @param {boolean} [ignoreStatus=false] - If set to false and the {@link CB_AudioFile_API.ACMP#status} property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant) nor to the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. * @param {boolean} [ignoreQueue=false] - This parameter will be ignored in this audio API. * @param {boolean} [useCache=false] - This parameter will be ignored in this audio API. * @param {boolean} [isSwapObject=false] - Defines whether the [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object to check is a swap object or the normal one (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. * @returns {boolean} Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.checkPlaying = function(callbackOk, callbackError, ignoreStatus, ignoreQueue, useCache, isSwapObject) { /////clearTimeout(this._recursiveCallCheckingTimeout); if (!ignoreStatus &amp;&amp; this.status !== CB_AudioFile.UNCHECKED &amp;&amp; this.status !== CB_AudioFile.CHECKING) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Cannot check if status is not unchecked or checking (status is &quot; + this.status + &quot;)&quot;); } return false; } var that = this; var mediaObject = this.mediaObject; if (isSwapObject) { mediaObject = this._mediaObjectSwap; } else { this.status = CB_AudioFile.CHECKING; } var previousVolume = this.volume; var finishedChecking = function(ok, error, keepStatus) { if (isSwapObject) { that._swapChecked = true; } //Stops the file: mediaObject.pause(); //Restores the volume: that._checkPlayingFinishingTimeout = //Timeout to prevent hearing the sound in some web clients. setTimeout ( function() { that.setVolume(previousVolume, false, null, false, isSwapObject ? that._mediaObjectSwap : null); //If the file is ok: if (ok) { if (!keepStatus &amp;&amp; !isSwapObject) { that.status = CB_AudioFile.LOADED; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } } //...otherwise, if the file has failed: else { if (!keepStatus &amp;&amp; !isSwapObject) { that.status = CB_AudioFile.FAILED; } if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } } }, 10 ); }; try { //Plays the sound during some time to let some web clients get the duration correctly (strange bug): if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0, false, null, false, isSwapObject ? this._mediaObjectSwap : null); } mediaObject.play(); var durationDetected = this.getDuration(isSwapObject ? this._mediaObjectSwap : null); var timesCurrentTimeChecked = 0; clearTimeout(this._checkPlayingTimeout); clearTimeout(this._checkPlayingFinishingTimeout); var checkFunction = function(callbackOk, callbackError) { clearTimeout(that._checkPlayingTimeout); //If it is has been aborted, we exit: if (that.status === CB_AudioFile.ABORTED || that.status === CB_AudioFile.FAILED) { finishedChecking(false, &quot;Audio file object is &quot; + (that.status === CB_AudioFile.ABORTED ? &quot;ABORTED&quot; : &quot;FAILED&quot;) + &quot;.&quot;, true); return; } try { if (!isSwapObject) { that.status = CB_AudioFile.CHECKING; } //If the duration has changed, it calls the function again because it means the audio is still loading (otherwise, Firefox has issues with data URIs and detects a shorter duration): var durationDetectedNow = that.getDuration(isSwapObject ? that._mediaObjectSwap : null); if (durationDetected !== durationDetectedNow) { durationDetected = durationDetectedNow; that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS); return; } //If the current time is still 0: if (!isSwapObject &amp;&amp; that.position == 0 || isSwapObject &amp;&amp; that._positionSwap == 0) { //We give it some opportunities more to change current time: if (timesCurrentTimeChecked &lt; 100) { timesCurrentTimeChecked++; if (timesCurrentTimeChecked % 20 === 0) { mediaObject.pause(); mediaObject.play(); try { mediaObject.seekTo(0); } catch(E) {} //Executed after play method because otherwise Intel XDK emulator and Android WebView kit does not perform seekTo. } that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, 1); return; } //...if all opportunities failed, we declare it as FAILED and exits: else { finishedChecking(false, &quot;position does not change (it is &quot; + (isSwapObject ? that._positionSwap : that.position) + &quot;).&quot;); return; } } //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (!isSwapObject &amp;&amp; that.position != 0 || isSwapObject &amp;&amp; that._positionSwap != 0) { mediaObject.seekTo(0); } //If the duration is zero, we declare it as FAILED and exits: if (that.getDuration(isSwapObject ? that._mediaObjectSwap : null) === 0) { finishedChecking(false, &quot;Duration is zero&quot;); return; } finishedChecking(true); } catch(E) { finishedChecking(false, E); } }; checkFunction(callbackOk, callbackError); return true; } catch(E) { finishedChecking(false, E); return false; } } /** * Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. * @function CB_AudioFile_API.ACMP#getDuration * @param {Object} [mediaObject={@link CB_AudioFile_API.ACMP#mediaObject}] - [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object whose audio duration we want to check. Used internally to check either normal or swap [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. * @returns {number} Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.getDuration = function(mediaObject) { var duration; if (typeof(mediaObject) === &quot;undefined&quot; || mediaObject === null) { mediaObject = this.mediaObject; } if (typeof(mediaObject) !== &quot;undefined&quot; &amp;&amp; mediaObject !== null &amp;&amp; typeof(mediaObject.getDuration) !== &quot;undefined&quot; &amp;&amp; mediaObject.getDuration !== null) { duration = mediaObject.getDuration() * 1000; } if (typeof(duration) === &quot;undefined&quot; || duration === null || isNaN(duration) || duration &lt; 0) { duration = 0; } return duration; } /** * Plays the audio. * @function CB_AudioFile_API.ACMP#play * @param {number} [startAt=0 | {@link CB_AudioFile_API.ACMP#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the {@link CB_AudioFile_API.ACMP#lastStartAt} property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the {@link CB_AudioFile_API.ACMP#lastStartAt} value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. * @param {number} [stopAt={@link CB_AudioFile_API.ACMP#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the {@link CB_AudioFile_API.ACMP#getDuration} method (which should belong to the total duration of the audio, if it was calculated correctly). * @param {boolean} [loop={@link CB_AudioFile_API.ACMP#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.ACMP#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.ACMP#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @param {boolean} [isResume=false] - If set to true (not recommended) and it is a looping audio, the next loop will use the value of the {@link CB_AudioFile_API.ACMP#lastStartAt} property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. * @param {boolean} [isLooping=false] - Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. * @param {integer} [startPlayingTime] - Contains the time when the audio should start playing. Recommended for internal usage only. * @returns {boolean|integer} It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.play = function(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime) { var that = this; var duration = this.getDuration(); if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } //If the sound is not ready yet, calls the function again but later: /*if (this.status !== CB_AudioFile.LOADED || this.getDuration() === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted, calls the function again but later: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) { setTimeout(function() { that.play(startAt, stopAt, loop, allowOverlapping, avoidDelayedPlay, onLoadError, isResume, isLooping); }, 1); } //...otherwise, if it has failed, sets it as stopped: //else { this.stopped = true; } return -1; }*/ if (this.status !== CB_AudioFile.LOADED || duration === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) //It must be UNLOADED, LOADING, LOADED, UNCHECKED or CHECKING. { //Function that calls the play method recursively (unless the maximum time allowed has expired): var playLaterFunctionCalled = false; var playLaterFunction = function() { if (playLaterFunctionCalled) { return; } playLaterFunctionCalled = true; //If the recursive delay is not null and is a valid number: if (typeof(allowedRecursiveDelay) === &quot;undefined&quot; || allowedRecursiveDelay === null || isNaN(allowedRecursiveDelay) || allowedRecursiveDelay &lt; 0) { allowedRecursiveDelay = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT; //We use default value. } var timeNow = CB_Device.getTiming(); //If the time expired is less or equal to the delay allowed: if (timeNow - startPlayingTime &lt;= allowedRecursiveDelay) { //Calls play method again: that.play(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime); } //...otherwise, just stops the sound: //////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //Function to execute when the sound loads successfully: var onLoad = function() { //If we allow delayed play, plays the sound: if (!avoidDelayedPlay) { playLaterFunction(); } //...otherwise, just stops the sound (to fire onStop function): ///////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //If it is UNLOADED or we had a duration before but not now and it is not LOADING, loads the file again: if (this.status === CB_AudioFile.UNLOADED || this.status !== CB_AudioFile.LOADING &amp;&amp; this._lastDuration !== null &amp;&amp; duration === 0) { this.load(this.filePath, false, onLoad, onLoadError, true); } //...otherwise, if it is UNCHECKED, we call the checking function: else if (this.status === CB_AudioFile.UNCHECKED) { this.checkPlaying(onLoad, onLoadError, false, true, false); } //...otherwise, if it is not CHECKING (it must be LOADING or LOADED with duration 0 from the beginning), we will not reload the sound: else if (this.status !== CB_AudioFile.CHECKING) { //If we allow delayed play, calls the play method again but after some time: if (!avoidDelayedPlay) { setTimeout(playLaterFunction, 1); } //...otherwise, just stops the sound (to fire onStop function): ///////else { this.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { this.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). } } return -1; } this._lastDuration = duration; //Defines the default parameters: if (CB_trim(startAt) === &quot;&quot;) { startAt = 0; } //Starts at the beginning as default. if (CB_trim(stopAt) === &quot;&quot;) { stopAt = 0; } //If it is not a number, default is zero. if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). else { this.loop = loop; } //...otherwise, stores the new setting given. //Sanitizes startAt and stopAt: startAt = parseFloat(startAt); stopAt = parseFloat(stopAt); if (startAt &lt; 0) { startAt = 0; } if (stopAt &lt;= 0 || stopAt &gt; duration) { stopAt = duration; } //If the stopAt is not correct, plays until the end of the file. if (startAt &gt; stopAt) { startAt = this.lastStartAt; } //In the case start time is than stop time, starts as the previous time. if (startAt &gt; stopAt || isNaN(startAt)) { startAt = stopAt; } //If the duration is zero (startAt and stopAt are equal), exits: if (startAt === stopAt) { this.stop(); return false; } //Next loop (if any) it will start at the same time by default: var startAtNextLoop = startAt; //If it is a resume, next loop we should start from the previous startAt used: if (isResume) { startAtNextLoop = this.lastStartAt; } //...otherwise, if it is not a resume, stores the startAt used: else { this.lastStartAt = startAt; } this.lastStopAt = stopAt; //Stores stopAt used. //Adds the event to check when the file reaches the stop time: var whenStopFunction = function() { //Removes the event and timeout: clearTimeout(that._timeoutWhenStop); //Clears the previous timeout. //If the sound has been stopped or paused or the stop time has changed, exits: if (that.stopped || that.paused || that.lastStopAt !== stopAt) { return; } //...otherwise, if the stop time has not been reached yet, calls the function again after a while: //else if (that.getCurrentTime() &lt; stopAt) { setTimeout(whenStopFunction, 1); return; } //If we want to loop, loops again: if (that.loop) { if (that._mediaObjectSwap !== null &amp;&amp; that._swapChecked) { var temp = that.mediaObject; that.stop(true, true); that.mediaObject = that._mediaObjectSwap; that._mediaObjectSwap = temp; } //that.stop(true); //Stops the sound without setting its property as stopped. that.play(startAtNextLoop, stopAt, true, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, false, true); //Plays again the sound. } //...otherwise, if we don't want to loop, we stop: else { that.stop(); } }; //Clears the previous timeout (if any): clearTimeout(this._timeoutWhenStop); //If it is looping or does not allow overlapping and it is not paused, stops the possible previous sound: //if (isLooping || !allowOverlapping &amp;&amp; !this.paused) { this.stop(true); } //Stops the sound without setting its property as stopped. //if (isLooping || !allowOverlapping) { this.stop(true); } //Stops the sound without setting its property as stopped. //Stop because otherwise Android with WebView takes long time to perform play again if stopAt is near the total duration (so next loop would take long time to start): this.stop(true, true); //Stops the sound without setting its property as stopped. //If defined, starts at the given position (ms): ////this.mediaObject.seekTo(startAt); //Applies the current volume: this.setVolume(this.volume); //If it is not a loop (it is the first call to the play method) or we do not want to loop: if (!isLooping || !loop) { CB_symmetricCallClear(&quot;ACMP_AUDIO_FILE&quot; + this._id_internal); } //We clean the cache of setTimeoutSynchronized for the loop function. //Plays the file: //this.mediaObject.play({ numberOfLoops: 9999999999 }); //We will use our own way to loop, so we don't need the normal way. this.mediaObject.play(); //We will use our own way to loop, so we don't need the normal way. this.mediaObject.seekTo(startAt); //Executed after play method because otherwise Intel XDK emulator and Android WebView kit does not perform seekTo. //Sets the event and timeout for when the sound finishes: var msToFinish = stopAt - startAt; this._timeoutWhenStop = CB_symmetricCall(whenStopFunction, msToFinish, &quot;ACMP_AUDIO_FILE&quot; + this._id_internal); //The sound is neither paused nor stopped: this.paused = this.stopped = false; //If it is the first time (not a loop) and there is a function to call when the play starts, we call it: if (!isLooping &amp;&amp; typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(this, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); onPlayStart = null; } //Prevents execution again. return true; } /** * Resumes the audio (after being paused), starting from the same point it was paused previously. * @function CB_AudioFile_API.ACMP#resume * @param {boolean} [loop={@link CB_AudioFile_API.ACMP#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.ACMP#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the {@link CB_AudioFile_API.ACMP#stop} method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.ACMP#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @returns {boolean|integer} Returns the returning value of the {@link CB_AudioFile_API.ACMP#play} method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.resume = function(loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError) { //If it not paused or it is stopped, exits the function: if (!this.paused || this.stopped) { return false; } //this._resuming = true; var startAt = this.pauseTime; //If it has been paused after the stop time (happens sometimes when the sound was nearly to finish): if (startAt &gt;= this.lastStopAt) { startAt = this.lastStopAt - 1; //We will begin just 1 millisecond before (otherwise the play method would begin again from lastStartAt). } return this.play(startAt, this.lastStopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, true, false); } /** * Pauses the audio when it is being played. * @function CB_AudioFile_API.ACMP#pause * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @param {boolean} [keepPausedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.ACMP#paused} property will not be set to true and it will remain with its current value. * @returns {boolean} It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.pause = function(onPause, keepPausedUnaltered) { //If it already paused or stopped, exits the function: if (this.paused || this.stopped) { return false; } //this._resuming = false; if (typeof(this.mediaObject) !== &quot;undefined&quot; &amp;&amp; this.mediaObject !== null) { clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.mediaObject.pause(); this.pauseTime = this.getCurrentTime(); if (!keepPausedUnaltered) { this.paused = true; } if (typeof(onPause) === &quot;function&quot;) { onPause.call(this); } return true; } return false; } /** * Stops the audio. * @function CB_AudioFile_API.ACMP#stop * @param {boolean} [keepStoppedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.ACMP#stopped} property will not be set to true and it will remain with its current value. * @param {boolean} [avoidOnStop=false] - If set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.ACMP#onStop} method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. * @param {boolean} [forceOnStop=false] - If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.ACMP#onStop} method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. * @returns {boolean} It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.stop = function(keepStoppedUnaltered, avoidOnStop, forceOnStop) { if (typeof(this.mediaObject) !== &quot;undefined&quot; &amp;&amp; this.mediaObject !== null) { ///////clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.mediaObject.seekTo(0); this.mediaObject.stop(); var stoppedBefore = this.stopped; if (!keepStoppedUnaltered) { this.stopped = true; } this.paused = false; //If it is stopped, it is not paused. //If we do not want to avoid onStop, it was not stopped before but it is now and onStop has a valid function assigned, we execute it: if (!avoidOnStop &amp;&amp; (!stoppedBefore &amp;&amp; this.stopped || forceOnStop) &amp;&amp; typeof(this.onStopFunction) === &quot;function&quot;) { this.onStopFunction.call(this); } return true; } return false; } /** * Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @function CB_AudioFile_API.ACMP#setVolume * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the {@link CB_AudioFile_API.ACMP#volume} property even when the volume failed to be changed. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @param {boolean} [saveForUnmute=false] - If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the {@link CB_AudioFile_API.ACMP#unmute} method. Internal usage only recommended. * @param {Object} [mediaObject={@link CB_AudioFile_API.ACMP#mediaObject}] - [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object whose volume we want to set. Used internally to affect either normal or swap [Media]{@link https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-media/} object (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.setVolume = function(volume, forceSetVolumeProperty, onSetVolume, saveForUnmute, mediaObject) { //Defines the default parameters: volume = parseInt(volume); if (isNaN(volume)) { this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; volume = this.DEFAULT_VOLUME; } //Sets the volume within their limits if it is beyond them: var MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM ? CB_Speaker.getVolume() : 100; if (volume &gt; MAX_VOLUME) { volume = MAX_VOLUME; } else if (volume &lt; 0) { volume = 0; } var originalObject = false; if (typeof(mediaObject) === &quot;undefined&quot; || mediaObject === null) { mediaObject = this.mediaObject; originalObject = true; } if (typeof(mediaObject) !== &quot;undefined&quot; &amp;&amp; mediaObject !== null) { mediaObject.setVolume(volume / 100); if (originalObject) { if ((saveForUnmute || volume === 0) &amp;&amp; this.volume &gt; 0) { this.volumeBeforeMute = this.volume; } //Also saves the previous volume if the desired one is zero (muted). this.volume = volume; if (typeof(onSetVolume) === &quot;function&quot;) { onSetVolume.call(this); } } } if (forceSetVolumeProperty) { this.volume = volume; } return this.volume; } /** * Mutes the audio file. * @function CB_AudioFile_API.ACMP#mute * @param {function} [onMute] - Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.mute = function(onMute) { //Only mutes the sound if it is not muted already: if (this.volume &gt; 0) { //Mutes the audio: this.setVolume(0, false, onMute, true); //It modifies this.volumeBeforeMute. } return this.volume; } /** * Restores audio after muting it (unmutes it). * @function CB_AudioFile_API.ACMP#unmute * @param {function} [onUnmute] - Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.unmute = function(onUnmute) { //Only unmutes if it is still muted: if (this.volume === 0) { //Restores the volume before muting: this.setVolume(this.volumeBeforeMute, false, onUnmute); } return this.volume; } /** * Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. * @function CB_AudioFile_API.ACMP#getCurrentTime * @returns {number} Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.getCurrentTime = function() { var currentTime; /* if (typeof(this.mediaObject) !== &quot;undefined&quot; &amp;&amp; this.mediaObject !== null) { currentTime = this.mediaObject.position * 1000; } */ currentTime = this.position * 1000; if (typeof(currentTime) === &quot;undefined&quot; || currentTime === null || isNaN(currentTime) || currentTime &lt; 0) { currentTime = 0; } return currentTime; } /** * Sets a function to execute when the audio file stops playing or removes it. * @function CB_AudioFile_API.ACMP#onStop * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the {@link CB_AudioFile_API.ACMP} object. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @returns {boolean} Returns whether the event has been set or not (removed). */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.onStop = function(callbackFunction, keepOldFunction) { //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } if (typeof(callbackFunction) !== &quot;function&quot;) { this.onStopFunction = null; return false; } //If we don't want to keep the old function: if (!keepOldFunction) { this.onStopFunction = callbackFunction; } //...otherwise if we want to keep the old function, we keep it: else { var that = this; //Stores old function: var oldFunction = this.onStopFunction; //Stores old function of eventFunctionHolder. this.onStopFunction = function() { if (typeof(oldFunction) === &quot;function&quot;) { oldFunction.call(that); } callbackFunction.call(that); }; } return true; } /** * Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @function CB_AudioFile_API.ACMP#getProgress * @returns {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFile_API[&quot;ACMP&quot;].prototype.getProgress = function() { if (this.status === CB_AudioFile.LOADED || this.status === CB_AudioFile.UNCHECKED || this.status === CB_AudioFile.CHECKING) { return 100; } else if (this.status === CB_AudioFile.UNLOADED) { return 0; } var progress = 0; //Calculates the progress (only if it is LOADING, FAILED or ABORTED): //TODO: use onProgress method from Apache Cordova Media Plugin when it is finally available (it is not usable yet). return progress; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFile_API_SM2.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFile_API_SM2.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js /** * @file Audio files management using &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}). Contains the {@link CB_AudioFile_API.SM2} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ //We need a limit to prevent Firefox error (&quot;Media resource [URI] could not be decoded&quot;) since many calls to play() method would fail: if (typeof(CB_AudioFile_API_AAPI_SM2_beingLoading) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } //Counts how many objects are loading. if (typeof(CB_AudioFile_API_AAPI_SM2_maximumLoading) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_maximumLoading = 5; } //Maximum of objects that can be loading at the same time. if (typeof(CB_AudioFile_API_AAPI_SM2_beingChecking) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } //Counts how many objects are loading. if (typeof(CB_AudioFile_API_AAPI_SM2_maximumChecking) === &quot;undefined&quot;) { var CB_AudioFile_API_AAPI_SM2_maximumChecking = CB_AudioFile_API_AAPI_SM2_maximumLoading; } //Maximum of objects that can be loading at the same time. //Class to manage an audio file with SM2 (SoundManager 2): if (typeof(CB_AudioFile_API) === &quot;undefined&quot;) { var CB_AudioFile_API = {}; } /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. * @class CB_AudioFile_API.SM2 * @memberof! &lt;global&gt; * @classdesc Class to manage an audio file using &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}). Used by the {@link CB_AudioFile} class internally and it shares most of its properties and methods. Recommended for internal usage only. * @param {string} filePath - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioId='CB_AUDIOFILE_SM2_' + CB_AudioFile_API.SM2._idUnique++] - Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. * @param {CB_AudioFile_API.SM2.OPTIONS} [options=CB_AudioFile_API.SM2#DEFAULT_OPTIONS] - Object with the desired options. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @returns {CB_AudioFile_API.SM2} Returns a new {@link CB_AudioFile_API.SM2} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ CB_AudioFile_API[&quot;SM2&quot;] = function(filePath, audioId, options, callbackOk, callbackError) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFile_API[&quot;SM2&quot;])) { return new CB_AudioFile_API[&quot;SM2&quot;](filePath, audioId, options, callbackOk, callbackError); } //Constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant CB_AudioFile_API.SM2#DEFAULT_VOLUME * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFile_API[&quot;SM2&quot;].prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; /** * Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @constant CB_AudioFile_API.SM2#DEFAULT_OPTIONS * @type {CB_AudioFile_API.SM2.OPTIONS} * @default { autoLoad: true, autoPlay: false, loop: false, volume: [CB_AudioFile_API.SM2.prototype.DEFAULT_VOLUME]{@link CB_AudioFile_API.SM2#DEFAULT_VOLUME} } */ CB_AudioFile_API[&quot;SM2&quot;].prototype.DEFAULT_OPTIONS = { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API[&quot;SM2&quot;].prototype.DEFAULT_VOLUME }; //Properties and variables: /** * Tells whether the file is unloaded ({@link CB_AudioFile.UNLOADED}), loading ({@link CB_AudioFile.LOADING}), unchecked ({@link CB_AudioFile.UNCHECKED}), checking ({@link CB_AudioFile.CHECKING}), loaded ({@link CB_AudioFile.LOADED}), failed ({@link CB_AudioFile.FAILED}) or aborted ({@link CB_AudioFile.ABORTED}). * @var CB_AudioFile_API.SM2#status * @readonly * @type {integer} * @default {@link CB_AudioFile.UNLOADED} */ this.status = CB_AudioFile.UNLOADED; /** * Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the {@link CB_AudioFile_API.SM2#play} method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). * @var CB_AudioFile_API.SM2#loop * @readonly * @type {boolean} * @default [CB_AudioFile_API.SM2.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.loop */ this.loop = CB_AudioFile_API[&quot;SM2&quot;].prototype.DEFAULT_OPTIONS.loop; /** * Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.SM2#volume * @readonly * @type {number} * @default [CB_AudioFile_API.SM2.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.volume */ this.volume = CB_AudioFile_API[&quot;SM2&quot;].prototype.DEFAULT_OPTIONS.volume; /** * Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.SM2#volumeBeforeMute * @readonly * @type {number} * @default {@link CB_AudioFile_API.SM2#volume} */ this.volumeBeforeMute = this.volume; /** * Stores the identifier for the audio file. * @var CB_AudioFile_API.SM2#id * @readonly * @type {string} * @default 'CB_AUDIOFILE_SM2_' + CB_AudioFile_API.SM2._idUnique++ */ this.id = &quot;&quot;; /** * Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @var CB_AudioFile_API.SM2#filePath * @readonly * @type {string} * @default */ this.filePath = &quot;&quot;; /** * Tells whether the audio is paused or not. * @var CB_AudioFile_API.SM2#paused * @readonly * @type {boolean} * @default false */ this.paused = false; /** * Stores the time (in milliseconds) when the audio has been paused. * @var CB_AudioFile_API.SM2#pauseTime * @readonly * @type {number} * @default */ this.pauseTime = 0; /** * Tells whether the audio is stopped or not. * @var CB_AudioFile_API.SM2#stopped * @readonly * @type {boolean} * @default true */ this.stopped = true; /** * Function to call when the audio stops. * @var CB_AudioFile_API.SM2#onStopFunction * @readonly * @type {function} * @default */ this.onStopFunction = null; /** * Stores the last &quot;startAt&quot; parameter value used by the {@link CB_AudioFile_API.SM2#play} or the {@link CB_AudioFile_API.SM2#resume} method. * @var CB_AudioFile_API.SM2#lastStartAt * @readonly * @type {number} * @default */ this.lastStartAt = null; /** * Stores the last &quot;stopAt&quot; parameter value used by the {@link CB_AudioFile_API.SM2#play} or the {@link CB_AudioFile_API.SM2#resume} method. * @var CB_AudioFile_API.SM2#lastStopAt * @readonly * @type {number} * @default */ this.lastStopAt = null; /** * Stores the &quot;SMSound&quot; object (returned by the [createSound]{@link http://schillmania.com/projects/soundmanager2/doc/#soundmanager-createsound} method) of the audio, used by the &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}). * @var CB_AudioFile_API.SM2#soundObject * @readonly * @type {Object} * @default */ this.soundObject = null; //Internal properties: this._timeoutWhenStop = null; //Keeps the timeout that is executed when the audio has finished playing (to either stop or loop). this._id_internal = null; //Internal id. //this._resuming = false; this._recursiveCallTimeout = null; this._onReadyTimeout = null; this._onErrorFunctionTimeout = null; this._stopAfterPlayingTimeout = null; this._onLoadTimeout = null; this._loadingCounterIncreased = false; this._checkPlayingTimeout = null; this._checkPlayingFinishingTimeout = null; this._recursiveCallCheckingTimeout = null; this._checkingCounterIncreased = false; this._lastDuration = null; this._onPlayingErrorFunctionTimeout = null; this._onPlayingErrorFunctionExecuting = false; this._startPlayingTimeReal = 0; //Calls the constructor of the object when creates an instance: return this._init(filePath, audioId, options, callbackOk, callbackError); } /** * Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @memberof CB_AudioFile_API.SM2 * @typedef {Object} CB_AudioFile_API.SM2.OPTIONS * @property {boolean} [autoLoad={@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.autoLoad] - If set to false, it will not call the {@link CB_AudioFile_API.SM2#load} method internally when the constructor is called (not recommended). * @property {boolean} [autoPlay={@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.autoPlay] - Value which will be used as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile_API.SM2#load} method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). * @property {boolean} [loop={@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.loop] - Value that will be used for the {@link CB_AudioFile_API.SM2#loop} property. * @property {number} [volume={@link CB_AudioFile_API.SM2#DEFAULT_OPTIONS}.volume] - The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that will be used for the {@link CB_AudioFile_API.SM2#volume} property. */ //Static properties: CB_AudioFile_API[&quot;SM2&quot;]._counter = 0; //Internal counter. CB_AudioFile_API[&quot;SM2&quot;]._idUnique = 0; //Counter to make the id unique (otherwise SM2 will never create an object with the same id after destroying it). //Constructor: CB_AudioFile_API[&quot;SM2&quot;].prototype._init = function(filePath, audioId, options, callbackOk, callbackError) { //If not given, defines the default parameters: if (typeof(audioId) === &quot;undefined&quot; || audioId === null) { audioId = &quot;CB_AUDIOFILE_SM2_&quot; + CB_AudioFile_API[&quot;SM2&quot;]._idUnique++; } //Uses the file path as default id. if (typeof(options) === &quot;undefined&quot; || options === null) { options = this.DEFAULT_OPTIONS; } else { if (typeof(options.loop) === &quot;undefined&quot; || options.loop === null) { options.loop = this.DEFAULT_OPTIONS.loop; } if (typeof(options.autoLoad) === &quot;undefined&quot; || options.autoLoad === null) { options.autoLoad = this.DEFAULT_OPTIONS.autoLoad; } if (typeof(options.autoPlay) === &quot;undefined&quot; || options.autoPlay === null) { options.autoPlay = this.DEFAULT_OPTIONS.autoPlay; } if (typeof(options.volume) === &quot;undefined&quot; || options.volume === null) { options.volume = this.DEFAULT_OPTIONS.volume; } } //Sets the audio ID: this.id = CB_trim(audioId).toUpperCase(); //Sets the internal id: if (typeof(this._id_internal) === &quot;undefined&quot; || this._id_internal === null) { this._id_internal = CB_AudioFile_API[&quot;SM2&quot;]._counter++; } //Sets the file path: this.filePath = filePath; //Proceeds according to the options sent: this.loop = options.loop; this.volume = options.volume; this.volumeBeforeMute = this.volume; if (options.autoLoad) { var that = this; setTimeout ( function() { that.load(that.filePath, options.autoPlay, callbackOk, callbackError); }, 10 ); } //Returns the object: return this; } /** * Destroys the audio file object and frees memory. Sets its current {@link CB_AudioFile_API.SM2#status} property to ABORTED ({@link CB_AudioFile.ABORTED} value). * @function CB_AudioFile_API.SM2#destructor * @param {boolean} [stopSound=false] - If set to true, it will also call the {@link CB_AudioFile_API.SM2#stop} method. * @param {boolean} [keepStoppedUnaltered=false] - Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the {@link CB_AudioFile_API.SM2#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [avoidOnStop=false] - Used internally as the &quot;avoidOnStop&quot; parameter to call the {@link CB_AudioFile_API.SM2#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [forceOnStop=false] - Used internally as the &quot;forceOnStop&quot; parameter to call the {@link CB_AudioFile_API.SM2#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.destructor = function(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop) { this._lastDuration = null; if (typeof(this.soundObject) === &quot;undefined&quot; || this.soundObject === null) { this.status = CB_AudioFile.ABORTED; return; } if (stopSound) { this.stop(keepStoppedUnaltered, avoidOnStop, forceOnStop); } if (typeof(this.soundObject.destruct) !== &quot;undefined&quot; &amp;&amp; this.soundObject.destruct !== null) { this.soundObject.destruct(); } CB_Elements.remove(this.soundObject); //if (this.status === CB_AudioFile.LOADING) if (this._loadingCounterIncreased) { this._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } if (this._checkingCounterIncreased) { this._checkingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_AAPI_SM2_beingChecking &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } } this.status = CB_AudioFile.ABORTED; } /** * Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter. * When this method is called, if the {@link CB_AudioFile_API.SM2#status} property already has the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the {@link CB_AudioFile.LOADING} constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the {@link CB_AudioFile.UNCHECKED} constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the {@link CB_AudioFile_API.SM2#checkPlaying} method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the {@link CB_AudioFile_API.SM2#checkPlaying} method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant) and finally the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) if all goes well. * @function CB_AudioFile_API.SM2#load * @param {string} [filePath={@link CB_AudioFile_API.SM2#filePath}] - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [autoPlay=false] - If set to true, it will start playing the audio automatically (by calling the {@link CB_AudioFile_API.SM2#play} method internally). If set to true and the {@link CB_AudioFile_API.SM2#status} property reaches to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will also call internally the {@link CB_AudioFile_API.SM2#checkPlaying} method. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @param {boolean} [forceReload=false] - If set to false, the &quot;filePath&quot; has not been changed from the previously used and the {@link CB_AudioFile_API.SM2#status} property belongs to the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). * @returns {CB_AudioFile_API.SM2|null} Returns the audio API object (if it was possible to create) or null otherwise. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.load = function(filePath, autoPlay, callbackOk, callbackError, forceReload) { clearTimeout(this._checkPlayingTimeout); clearTimeout(this._onReadyTimeout); clearTimeout(this._onErrorFunctionTimeout); clearTimeout(this._stopAfterPlayingTimeout); clearTimeout(this._onLoadTimeout); clearTimeout(this._recursiveCallTimeout); clearTimeout(this._checkPlayingFinishingTimeout); filePath = filePath || this.filePath; //If the status is LOADED and the file path give is the same as the current one, just exits: if (!forceReload &amp;&amp; this.status === CB_AudioFile.LOADED &amp;&amp; this.filePath === filePath) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this); } return this; } this.status = CB_AudioFile.LOADING; //The file is loading. var that = this; //If the maximum of objects loading is reached, calls the function again after some time and exits: //if (CB_AudioFile_API_AAPI_SM2_beingLoading &gt;= CB_AudioFile_API_AAPI_SM2_maximumLoading) if (autoPlay &amp;&amp; CB_AudioFile_API_AAPI_SM2_beingLoading &gt;= CB_AudioFile_API_AAPI_SM2_maximumLoading) { this._recursiveCallTimeout = setTimeout(function() { that.load(filePath, autoPlay, callbackOk, callbackError, forceReload); }, 10); return this; } if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { //this.soundObject.onload = function() { }; this.soundObject.onload = null; } //Destroys previous object (if any): this.destructor(true, false, true); //Also stops the sound (if any) and prevents firing onStop. this.status = CB_AudioFile.LOADING; //The file is loading. if (!this._loadingCounterIncreased) { this._loadingCounterIncreased = true; CB_AudioFile_API_AAPI_SM2_beingLoading++; //Increases the counter of the objects which are loading (destructor has decreased 1). } this.filePath = filePath; var callbackFunctionError = function(error, ignoreFailed) { //Prevents the execution of the function if the object has been declared as LOADED: if (that.status === CB_AudioFile.LOADED || that.status === CB_AudioFile.UNCHECKED || that.status === CB_AudioFile.CHECKING) { return; } if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //If it has already failed before, exits: if (!ignoreFailed &amp;&amp; that.status === CB_AudioFile.FAILED) { return; } if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } that.status = CB_AudioFile.FAILED; //File failed to load. autoPlay = false; //var fileName = filePath; if (filePath.substring(0, 5).toLowerCase() === &quot;data:&quot;) { filePath = filePath.substring(0, 15) + &quot;[...]&quot; + filePath.substring(filePath.length - 2); } error = &quot;Error message for &quot; + filePath + &quot; file: &quot; + error; if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } //Calls the Error function back. }; try { if (typeof(soundManager) === &quot;undefined&quot;) { callbackFunctionError(&quot;SoundManager 2 not found&quot;); return null; } //Creates an object and destroy it because otherwise in Intel XDK emulator and Android test with WebView does not work the second time (strange bug): this.soundObject = soundManager.createSound ( { id: &quot;fake_sound_sm2_&quot; + CB_AudioFile_API[&quot;SM2&quot;]._idUnique, url: filePath } ); this.destructor(); this.status = CB_AudioFile.LOADING; //The file is loading. var onLoadCalled = false; var onLoad = function(success) { onLoadCalled = true; clearTimeout(that._onLoadTimeout); //Cancels callbackError call (if any) in case onload has been called before with a wrong &quot;success&quot; (happens on Android with WebView): clearTimeout(that._onErrorFunctionTimeout); //if (this.readyState === 3) if (success) { //Prepares the sound to be playable (and plays it automatically if we want to): that._onReadyTimeout = setTimeout(onReadyFunction, 2000); //Gives time to onerror event to be fired before canplaythrough event. } else { //Gives a little bit of time because sometimes the onLoad function is called again (on Android with WebView sometimes the first call contains a wrong &quot;success&quot;): that._onErrorFunctionTimeout = setTimeout ( function() { callbackFunctionError(&quot;Sound could not be loaded&quot;); }, 1000 ); } }; //Creates the object: this.soundObject = soundManager.createSound ( { id: this.id + &quot;_&quot; + CB_AudioFile_API[&quot;SM2&quot;]._idUnique++, url: filePath, autoLoad: true, onload: onLoad } ); //Timeout to declare the sound as failed if the onload event is not fired before: this._onLoadTimeout = setTimeout(function() { if (!onLoadCalled) { callbackFunctionError(&quot;Sound's onload event timeout (not fired after &quot; + CB_Configuration[CB_BASE_NAME].CB_AudioFile_ONLOAD_TIMEOUT_MS + &quot; ms)&quot;); } }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_ONLOAD_TIMEOUT_MS); //Makes the sound seekable for some iOS versions (strange bug) and forces Firefox for Android to fire canplaythrough event (strange bug too): var previousVolume = this.volume; //Stores the current volume. if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); //Mutes the sound. } this.soundObject.play({ loops: 1 }); this._stopAfterPlayingTimeout = setTimeout(function() { that.soundObject.pause(); }, 1); //Plays the sound during some time because otherwise some web clients, as WebView used by Cordova on Android, receive duration 0 (strange bug): var onReadyFunctionExecuted = false; var onReadyFunction = function() { //Prevents the execution of the function more than once: if (onReadyFunctionExecuted) { return; } onReadyFunctionExecuted = true; //Prevents to be executed after the onerror event has fired: if (that.status === CB_AudioFile.FAILED) { return; } //Function to execute when all is OK: var allIsFine = function() { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_AAPI_SM2_beingLoading &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingLoading = 0; } } //Restores the volume: that.setVolume(previousVolume); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } //Calls the OK function back. //Plays automatically if we want to: if (autoPlay) { that.play(); } }; that.status = CB_AudioFile.UNCHECKED; //The file is still unchecked. //If we want to play automatically, checks if the currentTime changes (some web clients cannot play if the user did not fire an event to call the play function): if (autoPlay) { that.checkPlaying(function() { allIsFine(); }, function(error) { callbackFunctionError(error, true); }, false, false); } else { allIsFine(); } }; } catch(E) { callbackFunctionError(E); return null; } return this; } /** * Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the {@link CB_AudioFile_API.SM2#play} method the first time. The checking action will only be performed if the value of the {@link CB_AudioFile_API.SM2#status} property belongs to the {@link CB_AudioFile.UNCHECKED} or to the {@link CB_AudioFile.CHECKING} value. After checking, if the audio can be played, the {@link CB_AudioFile_API.SM2#status} of the object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the {@link CB_AudioFile_API.SM2#status} property will get the value of {CB_AudioFile.FAILED}. * @function CB_AudioFile_API.SM2#checkPlaying * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object itself. * @param {boolean} [ignoreStatus=false] - If set to false and the {@link CB_AudioFile_API.SM2#status} property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant) nor to the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. * @param {boolean} [ignoreQueue=false] - If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. * @param {boolean} [useCache=false] - This parameter will be ignored in this audio API. * @returns {boolean} Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.checkPlaying = function(callbackOk, callbackError, ignoreStatus, ignoreQueue, useCache) { /////clearTimeout(this._recursiveCallCheckingTimeout); if (!ignoreStatus &amp;&amp; this.status !== CB_AudioFile.UNCHECKED &amp;&amp; this.status !== CB_AudioFile.CHECKING) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Cannot check if status is not unchecked or checking (status is &quot; + this.status + &quot;)&quot;); } return false; } this.status = CB_AudioFile.CHECKING; var that = this; //If we do not use cache the maximum of objects checking is reached or we use cache but the file path is checking, calls the function again after some time and exits: if (!ignoreQueue &amp;&amp; CB_AudioFile_API_AAPI_SM2_beingChecking &gt;= CB_AudioFile_API_AAPI_SM2_maximumChecking) { this._recursiveCallCheckingTimeout = setTimeout(function() { that.checkPlaying(callbackOk, callbackError, ignoreStatus, useCache); }, 10); return true; } ////this.status = CB_AudioFile.CHECKING; if (!this._checkingCounterIncreased) { this._checkingCounterIncreased = true; CB_AudioFile_API_AAPI_SM2_beingChecking++; //Increases the counter of the objects which are checking. } var previousVolume = this.volume; var finishedChecking = function(ok, error, keepStatus) { //Stops the file: that.soundObject.pause(); //Restores the volume: that._checkPlayingFinishingTimeout = //Timeout to prevent hearing the sound in some web clients. setTimeout ( function() { that.setVolume(previousVolume); //If the file is ok: if (ok) { if (!keepStatus) { that.status = CB_AudioFile.LOADED; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } } //...otherwise, if the file has failed: else { if (!keepStatus) { that.status = CB_AudioFile.FAILED; } if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } } }, 10 ); if (that._checkingCounterIncreased) { that._checkingCounterIncreased = false; CB_AudioFile_API_AAPI_SM2_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_AAPI_SM2_beingChecking &lt; 0) { CB_AudioFile_API_AAPI_SM2_beingChecking = 0; } } }; try { //Plays the sound during some time to let some web clients get the duration correctly (strange bug): if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); } this.soundObject.play({ loops: 1 }); var durationDetected = this.getDuration(); var timesCurrentTimeChecked = 0; clearTimeout(this._checkPlayingTimeout); clearTimeout(this._checkPlayingFinishingTimeout); var checkFunction = function(callbackOk, callbackError) { clearTimeout(that._checkPlayingTimeout); //If it is has been aborted, we exit: if (that.status === CB_AudioFile.ABORTED || that.status === CB_AudioFile.FAILED) { finishedChecking(false, &quot;Audio file object is &quot; + (that.status === CB_AudioFile.ABORTED ? &quot;ABORTED&quot; : &quot;FAILED&quot;) + &quot;.&quot;, true); return; } try { that.status = CB_AudioFile.CHECKING; //If the duration has changed, it calls the function again because it means the audio is still loading (otherwise, Firefox has issues with data URIs and detects a shorter duration): var durationDetectedNow = that.getDuration(); if (durationDetected !== durationDetectedNow) { durationDetected = durationDetectedNow; that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS); return; } //If the current time is still 0: if (that.soundObject.position == 0) { //We give it some opportunities more to change current time: if (timesCurrentTimeChecked &lt; 1000) { timesCurrentTimeChecked++; if (timesCurrentTimeChecked % 20 === 0) { that.soundObject.pause(); try { that.soundObject.setPosition(0); } catch(E) {} //Avoid Firefox complain about using an object which is no longer available. that.soundObject.play({ loops: 1 }); /* try { if (that.soundObject.position != 0) { that.soundObject.setPosition(0.00000000001); //Executed after play method because otherwise Safari Mobile does not change currentTime. } } catch(E) {} */ } that._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, 1); return; } //...if all opportunities failed, we declare it as FAILED and exits: else { finishedChecking(false, &quot;position does not change (it is &quot; + that.soundObject.position + &quot;).&quot;); return; } } //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (that.soundObject.position != 0) { that.soundObject.setPosition(0); } //If the duration is zero, we declare it as FAILED and exits: if (that.getDuration() === 0) { finishedChecking(false, &quot;Duration is zero&quot;); return; } else if (that.soundObject.readyState === 2) { finishedChecking(false, &quot;readyState is 2 (failed/error)&quot;); return; } finishedChecking(true); } catch(E) { finishedChecking(false, E); } }; this._checkPlayingTimeout = setTimeout(function() { checkFunction(callbackOk, callbackError); }, CB_Configuration[CB_BASE_NAME].CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS); return true; } catch(E) { finishedChecking(false, E); return false; } } /** * Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. * @function CB_AudioFile_API.SM2#getDuration * @returns {number} Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.getDuration = function() { var duration; if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null &amp;&amp; typeof(this.soundObject.duration) !== &quot;undefined&quot; &amp;&amp; this.soundObject.duration !== null) { duration = this.soundObject.duration; } if (typeof(duration) === &quot;undefined&quot; || duration === null || isNaN(duration) || duration &lt; 0) { duration = 0; } return duration; } //Executed when there is an error playing: CB_AudioFile_API[&quot;SM2&quot;].prototype._onPlayingErrorFunction = function() { this._onPlayingErrorFunctionExecuting = true; clearTimeout(this._onPlayingErrorFunctionTimeout); if (this.soundObject.readyState === 2 &amp;&amp; this.status === CB_AudioFile.LOADED) { this.status = CB_AudioFile.FAILED; //Declares it as failed. this.stop(false, false, true); //Also fires onStop event. } if (this.status === CB_AudioFile.LOADED) { var that = this; this._onPlayingErrorFunctionTimeout = setTimeout(function() { that._onPlayingErrorFunction.call(that); }, 1); } else { this._onPlayingErrorFunctionExecuting = false; } }; //Executed when the sound stops playing: CB_AudioFile_API[&quot;SM2&quot;].prototype._whenStopFunction = function(startAtNextLoop, stopAt, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, whenStopFunction, onPlayingErrorFunction, flags) { //Just allows executing the function once: if (flags.whenStopFunctionExecuted) { return; } flags.whenStopFunctionExecuted = true; //Removes the event and timeout: this.soundObject.clearOnPosition(stopAt, whenStopFunction); //Clears the event: clearTimeout(this._timeoutWhenStop); //Clears the previous timeout. //If the sound has been stopped or paused or the stop time has changed, exits: if (this.stopped || this.paused || this.lastStopAt !== stopAt) { return; } //...otherwise, if the stop time has not been reached yet, calls the function again after a while: //else if (this.getCurrentTime() &lt; stopAt) { setTimeout(whenStopFunction, 1); return; } //If the object has failed, just calls the error function and exits: if (this.soundObject.readyState === 2) { clearTimeout(this._onPlayingErrorFunctionTimeout); this._onPlayingErrorFunctionTimeout = setTimeout(onPlayingErrorFunction, 1); return; } //If we want to loop, loops again: if (this.loop) { //this.stop(true); //Stops the sound without setting its property as stopped. this.play(startAtNextLoop, stopAt, true, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, false, true); //Plays again the sound. } //...otherwise, if we don't want to loop, we stop: else { this.stop(); } }; /** * Plays the audio. * @function CB_AudioFile_API.SM2#play * @param {number} [startAt=0 | {@link CB_AudioFile_API.SM2#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the {@link CB_AudioFile_API.SM2#lastStartAt} property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the {@link CB_AudioFile_API.SM2#lastStartAt} value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. * @param {number} [stopAt={@link CB_AudioFile_API.SM2#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the {@link CB_AudioFile_API.SM2#getDuration} method (which should belong to the total duration of the audio, if it was calculated correctly). * @param {boolean} [loop={@link CB_AudioFile_API.SM2#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.SM2#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.SM2#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. * @param {boolean} [isResume=false] - If set to true (not recommended) and it is a looping audio, the next loop will use the value of the {@link CB_AudioFile_API.SM2#lastStartAt} property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. * @param {boolean} [isLooping=false] - Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. * @param {integer} [startPlayingTime] - Contains the time when the audio should start playing. Recommended for internal usage only. * @returns {boolean|integer} It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.play = function(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime) { var that = this; var duration = this.getDuration(); if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } var onPlayingErrorFunction = function() { that._onPlayingErrorFunction.call(that); }; //If the sound is not ready yet, calls the function again but later: /*if (this.status !== CB_AudioFile.LOADED || this.getDuration() === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted, calls the function again but later: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) { setTimeout(function() { that.play(startAt, stopAt, loop, allowOverlapping, avoidDelayedPlay, onLoadError, isResume, isLooping); }, 1); } //...otherwise, if it has failed, sets it as stopped: //else { this.stopped = true; } return -1; }*/ if (this.status !== CB_AudioFile.LOADED || duration === 0 || this.soundObject.readyState === 2) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) //It must be UNLOADED, LOADING, LOADED, UNCHECKED or CHECKING. { //Function that calls the play method recursively (unless the maximum time allowed has expired): var playLaterFunctionCalled = false; var playLaterFunction = function() { if (playLaterFunctionCalled) { return; } playLaterFunctionCalled = true; //If the recursive delay is not null and is a valid number: if (typeof(allowedRecursiveDelay) === &quot;undefined&quot; || allowedRecursiveDelay === null || isNaN(allowedRecursiveDelay) || allowedRecursiveDelay &lt; 0) { allowedRecursiveDelay = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT; //We use default value. } var timeNow = CB_Device.getTiming(); //If the time expired is less or equal to the delay allowed: if (timeNow - startPlayingTime &lt;= allowedRecursiveDelay) { //Calls play method again: that.play(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime); } //...otherwise, just stops the sound: ///////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //Function to execute when the sound loads successfully (or finishes checking successfully): var onLoad = function() { //If we allow delayed play, plays the sound: if (!avoidDelayedPlay) { playLaterFunction(); } //...otherwise, just stops the sound (to fire onStop function): ////////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //If it is UNLOADED or we had a duration before but not now and it is not LOADING, loads the file again: if (this.status === CB_AudioFile.UNLOADED || this.status !== CB_AudioFile.LOADING &amp;&amp; this._lastDuration !== null &amp;&amp; duration === 0 || this.soundObject.readyState === 2) { this.load(this.filePath, false, onLoad, onLoadError, true); } //...otherwise, if it is UNCHECKED, we call the checking function: else if (this.status === CB_AudioFile.UNCHECKED) { this.checkPlaying(onLoad, onLoadError, false, true, false); } //...otherwise, if it is not CHECKING (it must be LOADING or LOADED with duration 0 from the beginning), we will not reload the sound: else if (this.status !== CB_AudioFile.CHECKING) { //If we allow delayed play, calls the play method again but after some time: if (!avoidDelayedPlay) { setTimeout(playLaterFunction, 1); } //...otherwise, just stops the sound (to fire onStop function): //////else { this.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { this.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). } } return -1; } this._lastDuration = duration; //Defines the default parameters: if (CB_trim(startAt) === &quot;&quot;) { startAt = 0; } //Starts at the beginning as default. if (CB_trim(stopAt) === &quot;&quot;) { stopAt = 0; } //If it is not a number, default is zero. if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). else { this.loop = loop; } //...otherwise, stores the new setting given. //Sanitizes startAt and stopAt: startAt = parseFloat(startAt); stopAt = parseFloat(stopAt); if (startAt &lt; 0) { startAt = 0; } if (stopAt &lt;= 0 || stopAt &gt; duration) { stopAt = duration; } //If the stopAt is not correct, plays until the end of the file. if (startAt &gt; stopAt) { startAt = this.lastStartAt; } //In the case start time is than stop time, starts as the previous time. if (startAt &gt; stopAt || isNaN(startAt)) { startAt = stopAt; } //If the duration is zero (startAt and stopAt are equal), exits: if (startAt === stopAt) { this.stop(); return false; } //Next loop (if any) it will start at the same time by default: var startAtNextLoop = startAt; //If it is a resume, next loop we should start from the previous startAt used: if (isResume) { startAtNextLoop = this.lastStartAt; } //...otherwise, if it is not a resume, stores the startAt used: else { this.lastStartAt = startAt; } this.lastStopAt = stopAt; //Stores stopAt used. //Adds the event to check when the file reaches the stop time: var whenStopFunction = function() { that._whenStopFunction.call(that, startAtNextLoop, stopAt, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, whenStopFunction, onPlayingErrorFunction, flags); }; var flags = { &quot;whenStopFunctionExecuted&quot; : false }; //Clears the previous timeout (if any): clearTimeout(this._timeoutWhenStop); //If it is looping or does not allow overlapping and it is not paused, stops the possible previous sound: //if (isLooping || !allowOverlapping &amp;&amp; !this.paused) { this.stop(true); } //Stops the sound without setting its property as stopped. this.stop(true, true); //Stops the sound without setting its property as stopped. //Applies the current volume: this.setVolume(this.volume); //If it is not a loop (it is the first call to the play method) or we do not want to loop: if (!isLooping || !loop) { CB_symmetricCallClear(&quot;SM2_AUDIO_FILE&quot; + this._id_internal); } //We clean the cache of setTimeoutSynchronized for the loop function. //If defined, starts at the given position (ms): var currentTime = startAt; //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (currentTime !== 0 || this.soundObject.position != 0) { this.soundObject.setPosition(currentTime); } //this.soundObject.setPosition(startAt); //Plays the file: this.soundObject.play({ loops: 99999999, onfinish: whenStopFunction }); //We will use our own way to loop. Many loops (although seems that 2 would be enough) because Android WebView returns position as 0 the second loop if the file is played completely. //If defined, starts at the given position (ms): //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (currentTime !== 0 || this.soundObject.position != 0) { this.soundObject.setPosition(currentTime + 0.00000000001); } //this.soundObject.setPosition(startAt); //Executed after play method because otherwise Intel XDK emulator and Android WebView kit does not perform setPosition. //Sets the event and timeout for when the sound finishes: this.soundObject.onPosition(stopAt, whenStopFunction); var msToFinish = stopAt - startAt; this._timeoutWhenStop = CB_symmetricCall(whenStopFunction, msToFinish, &quot;SM2_AUDIO_FILE&quot; + this._id_internal); //The sound is neither paused nor stopped: this._startPlayingTimeReal = CB_Device.getTiming(); //Useful to calculate approximate currentTime when position returns 0 (SM2 bug). this.paused = this.stopped = false; //If it is has failed, calls the onPlayingError function: if (!this._onPlayingErrorFunctionExecuting) { clearTimeout(this._onPlayingErrorFunctionTimeout); this._onPlayingErrorFunctionTimeout = setTimeout(onPlayingErrorFunction, 1); } if (this.soundObject.readyState === 2) { return -1; } //If it is the first time (not a loop) and there is a function to call when the play starts, we call it: if (!isLooping &amp;&amp; typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(this, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); onPlayStart = null; } //Prevents execution again. return true; } /** * Resumes the audio (after being paused), starting from the same point it was paused previously. * @function CB_AudioFile_API.SM2#resume * @param {boolean} [loop={@link CB_AudioFile_API.SM2#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.SM2#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the {@link CB_AudioFile_API.SM2#stop} method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.SM2#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. * @returns {boolean|integer} Returns the returning value of the {@link CB_AudioFile_API.SM2#play} method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.resume = function(loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError) { //If it not paused or it is stopped, exits the function: if (!this.paused || this.stopped) { return false; } //this._resuming = true; var startAt = this.pauseTime; //If it has been paused after the stop time (happens sometimes when the sound was nearly to finish): if (startAt &gt;= this.lastStopAt) { startAt = this.lastStopAt - 1; //We will begin just 1 millisecond before (otherwise the play method would begin again from lastStartAt). } return this.play(startAt, this.lastStopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, true, false); } /** * Pauses the audio when it is being played. * @function CB_AudioFile_API.SM2#pause * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. * @param {boolean} [keepPausedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.SM2#paused} property will not be set to true and it will remain with its current value. * @returns {boolean} It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.pause = function(onPause, keepPausedUnaltered) { //If it already paused or stopped, exits the function: if (this.paused || this.stopped) { return false; } //this._resuming = false; if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.soundObject.pause(); this.pauseTime = this.getCurrentTime(); //Bug fix: sometimes SM2 returns position as 0 (getCurrentTime returns 0) and pauseTime is 0. if (this.pauseTime === 0) { var timeNow = CB_Device.getTiming(); var pauseTime = this.lastStartAt + (timeNow - this._startPlayingTimeReal); if (pauseTime &gt; this.lastStopAt) { pauseTime = this.lastStartAt; } this.pauseTime = pauseTime; } if (!keepPausedUnaltered) { this.paused = true; } if (typeof(onPause) === &quot;function&quot;) { onPause.call(this); } return true; } return false; } /** * Stops the audio. * @function CB_AudioFile_API.SM2#stop * @param {boolean} [keepStoppedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.SM2#stopped} property will not be set to true and it will remain with its current value. * @param {boolean} [avoidOnStop=false] - If set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.SM2#onStop} method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. * @param {boolean} [forceOnStop=false] - If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.SM2#onStop} method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. * @returns {boolean} It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). */ CB_AudioFile_API[&quot;SM2&quot;].prototype.stop = function(keepStoppedUnaltered, avoidOnStop, forceOnStop) { if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { ///////clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. this.soundObject.stop(); //Only updates the currentTime to 0 if it is not zero already (because otherwise some web clients will fail or have a wrong behaviour): if (this.soundObject.position != 0) { this.soundObject.setPosition(0); } var stoppedBefore = this.stopped; if (!keepStoppedUnaltered) { this.stopped = true; } this.paused = false; //If it is stopped, it is not paused. //If we do not want to avoid onStop, it was not stopped before but it is now and onStop has a valid function assigned, we execute it: if (!avoidOnStop &amp;&amp; (!stoppedBefore &amp;&amp; this.stopped || forceOnStop) &amp;&amp; typeof(this.onStopFunction) === &quot;function&quot;) { this.onStopFunction.call(this); } return true; } return false; } /** * Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @function CB_AudioFile_API.SM2#setVolume * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the {@link CB_AudioFile_API.SM2#volume} property even when the volume failed to be changed. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. * @param {boolean} [saveForUnmute=false] - If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the {@link CB_AudioFile_API.SM2#unmute} method. Internal usage only recommended. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;SM2&quot;].prototype.setVolume = function(volume, forceSetVolumeProperty, onSetVolume, saveForUnmute) { //Defines the default parameters: volume = parseInt(volume); if (isNaN(volume)) { this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; volume = this.DEFAULT_VOLUME; } //Sets the volume within their limits if it is beyond them: var MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM ? CB_Speaker.getVolume() : 100; if (volume &gt; MAX_VOLUME) { volume = MAX_VOLUME; } else if (volume &lt; 0) { volume = 0; } if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { this.soundObject.setVolume(volume); if ((saveForUnmute || volume === 0) &amp;&amp; this.volume &gt; 0) { this.volumeBeforeMute = this.volume; } //Also saves the previous volume if the desired one is zero (muted). this.volume = volume; if (typeof(onSetVolume) === &quot;function&quot;) { onSetVolume.call(this); } } if (forceSetVolumeProperty) { this.volume = volume; } return this.volume; } /** * Mutes the audio file. * @function CB_AudioFile_API.SM2#mute * @param {function} [onMute] - Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.mute = function(onMute) { //Only mutes the sound if it is not muted already: if (this.volume &gt; 0) { //Mutes the audio: this.setVolume(0, false, onMute, true); //It modifies this.volumeBeforeMute. } return this.volume; } /** * Restores audio after muting it (unmutes it). * @function CB_AudioFile_API.SM2#unmute * @param {function} [onUnmute] - Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;SM2&quot;].prototype.unmute = function(onUnmute) { //Only unmutes if it is still muted: if (this.volume === 0) { //Restores the volume before muting: this.setVolume(this.volumeBeforeMute, false, onUnmute); } return this.volume; } /** * Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. * @function CB_AudioFile_API.SM2#getCurrentTime * @returns {number} Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.getCurrentTime = function() { var currentTime; if (this.status !== CB_AudioFile.LOADED) { return 0; } if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { currentTime = this.soundObject.position; } if (typeof(currentTime) === &quot;undefined&quot; || currentTime === null || isNaN(currentTime) || currentTime &lt; 0) { currentTime = 0; } return currentTime; } /* //Returns the bytes loaded of the file: CB_AudioFile_API[&quot;SM2&quot;].prototype.getBytesLoaded = function() { var bytesLoaded; if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { bytesLoaded = this.soundObject.bytesLoaded; } if (typeof(bytesLoaded) === &quot;undefined&quot; || bytesLoaded === null || isNaN(bytesLoaded)) { bytesLoaded = 0; } return bytesLoaded; } //Returns the total bytes of the file: CB_AudioFile_API[&quot;SM2&quot;].prototype.getBytesTotal = function() { var bytesTotal; if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null) { bytesTotal = this.soundObject.bytesTotal; } if (typeof(bytesTotal) === &quot;undefined&quot; || bytesTotal === null || isNaN(bytesTotal)) { bytesTotal = 0; } return bytesTotal; } */ /** * Sets a function to execute when the audio file stops playing or removes it. * @function CB_AudioFile_API.SM2#onStop * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the {@link CB_AudioFile_API.SM2} object. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @returns {boolean} Returns whether the event has been set or not (removed). */ CB_AudioFile_API[&quot;SM2&quot;].prototype.onStop = function(callbackFunction, keepOldFunction) { //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } if (typeof(callbackFunction) !== &quot;function&quot;) { this.onStopFunction = null; return false; } //If we don't want to keep the old function: if (!keepOldFunction) { this.onStopFunction = callbackFunction; } //...otherwise if we want to keep the old function, we keep it: else { var that = this; //Stores old function: var oldFunction = this.onStopFunction; //Stores old function of eventFunctionHolder. this.onStopFunction = function() { if (typeof(oldFunction) === &quot;function&quot;) { oldFunction.call(that); } callbackFunction.call(that); }; } return true; } /** * Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @function CB_AudioFile_API.SM2#getProgress * @returns {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFile_API[&quot;SM2&quot;].prototype.getProgress = function() { if (this.status === CB_AudioFile.LOADED || this.status === CB_AudioFile.UNCHECKED || this.status === CB_AudioFile.CHECKING) { return 100; } else if (this.status === CB_AudioFile.UNLOADED) { return 0; } var progress = 0; //Calculates the progress (only if it is LOADING, FAILED or ABORTED): if (typeof(this.soundObject) !== &quot;undefined&quot; &amp;&amp; this.soundObject !== null &amp;&amp; typeof(this.soundObject.buffered) !== &quot;undefined&quot;) { var duration = this.getDuration(); var bufferedLength = this.soundObject.buffered.length; var secondsBuffered = 0; for (var x = 0; x &lt; bufferedLength; x++) { secondsBuffered += this.soundObject.buffered[x].end - this.soundObject.buffered[x].start; } if (duration === 0) { if (secondsBuffered &gt; 0) { return 100; } else { return 0; } } else { progress = secondsBuffered / duration * 100; } if (progress &gt; 100) { progress = 100; } else if (progress &lt; 0) { progress = 0; } } return progress; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFile_API_WAAPI.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFile_API_WAAPI.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js /** * @file Audio files management using &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). Contains the {@link CB_AudioFile_API.WAAPI} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ //var CB_AudioFile_WAAPI_filePathsLoading = []; //Stores the file paths which are being loaded. //var CB_AudioFile_WAAPI_BuffersCache = {}; //Cache of buffers for every file path. //var CB_AudioFile_WAAPI_BuffersCacheMessage = {}; //Cache of buffers for every file path. //var CB_AudioFile_WAAPI_CheckedCache = {}; //Cache of results of checkPlaying method for every file path. //We need a limit to prevent out of memory error when many calls to play() are performed: var CB_AudioFile_API_WAAPI_beingLoading = 0; //Counts how many objects are loading. var CB_AudioFile_API_WAAPI_maximumLoading = 3; //Maximum of objects that can be loading at the same time. var CB_AudioFile_API_WAAPI_beingChecking = 0; //Counts how many objects are loading. var CB_AudioFile_API_WAAPI_maximumChecking = 75; //Maximum of objects that can be loading at the same time. //Class to manage an audio file with WAAPI (Web Audio API): if (typeof(CB_AudioFile_API) === &quot;undefined&quot;) { var CB_AudioFile_API = {}; } /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. * @class CB_AudioFile_API.WAAPI * @memberof! &lt;global&gt; * @classdesc Class to manage an audio file using &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). Used by the {@link CB_AudioFile} class internally and it shares most of its properties and methods. Recommended for internal usage only. Uses [Base64Binary]{@link https://gist.github.com/htchaan/108b7aa6b71eb03e38019e64450ea095} internally. Some old clients can use this audio API thanks to [AudioContext-MonkeyPatch]{@link https://github.com/cwilso/AudioContext-MonkeyPatch} and [WAAPISim]{@link https://github.com/g200kg/WAAPISim}. * @param {string} filePath - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [audioId='CB_AUDIOFILE_WAAPI_' + CB_AudioFile_API.WAAPI._idUnique++] - Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. * @param {CB_AudioFile_API.WAAPI.OPTIONS} [options=CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS] - Object with the desired options. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @returns {CB_AudioFile_API.WAAPI} Returns a new {@link CB_AudioFile_API.WAAPI} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ CB_AudioFile_API[&quot;WAAPI&quot;] = function(filePath, audioId, options, callbackOk, callbackError) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFile_API[&quot;WAAPI&quot;])) { return new CB_AudioFile_API[&quot;WAAPI&quot;](filePath, audioId, options, callbackOk, callbackError); } //Constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant CB_AudioFile_API.WAAPI#DEFAULT_VOLUME * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; /** * Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @constant CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS * @type {CB_AudioFile_API.WAAPI.OPTIONS} * @default { autoLoad: true, autoPlay: false, loop: false, volume: [CB_AudioFile_API.WAAPI.prototype.DEFAULT_VOLUME]{@link CB_AudioFile_API.WAAPI#DEFAULT_VOLUME} } */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.DEFAULT_OPTIONS = { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API[&quot;WAAPI&quot;].prototype.DEFAULT_VOLUME, useXHR: true, useCache: true }; //Default options when the file is created. //Properties and variables: /** * Tells whether the file is unloaded ({@link CB_AudioFile.UNLOADED}), loading ({@link CB_AudioFile.LOADING}), unchecked ({@link CB_AudioFile.UNCHECKED}), checking ({@link CB_AudioFile.CHECKING}), loaded ({@link CB_AudioFile.LOADED}), failed ({@link CB_AudioFile.FAILED}) or aborted ({@link CB_AudioFile.ABORTED}). * @var CB_AudioFile_API.WAAPI#status * @readonly * @type {integer} * @default {@link CB_AudioFile.UNLOADED} */ this.status = CB_AudioFile.UNLOADED; /** * Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the {@link CB_AudioFile_API.WAAPI#play} method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). * @var CB_AudioFile_API.WAAPI#loop * @readonly * @type {boolean} * @default [CB_AudioFile_API.WAAPI.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.loop */ this.loop = CB_AudioFile_API[&quot;WAAPI&quot;].prototype.DEFAULT_OPTIONS.loop; /** * Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.WAAPI#volume * @readonly * @type {number} * @default [CB_AudioFile_API.WAAPI.prototype.DEFAULT_OPTIONS]{@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.volume */ this.volume = CB_AudioFile_API[&quot;WAAPI&quot;].prototype.DEFAULT_OPTIONS.volume; /** * Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is false or otherwise MAX_VOLUME is the returning value of the {@link CB_Speaker.getVolume} function. * @var CB_AudioFile_API.WAAPI#volumeBeforeMute * @readonly * @type {number} * @default {@link CB_AudioFile_API.WAAPI#volume} */ this.volumeBeforeMute = this.volume; /** * Stores the identifier for the audio file. * @var CB_AudioFile_API.WAAPI#id * @readonly * @type {string} * @default 'CB_AUDIOFILE_WAAPI_' + CB_AudioFile_API.WAAPI._idUnique++ */ this.id = &quot;&quot;; /** * Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @var CB_AudioFile_API.WAAPI#filePath * @readonly * @type {string} * @default */ this.filePath = &quot;&quot;; /** * Tells whether the audio is paused or not. * @var CB_AudioFile_API.WAAPI#paused * @readonly * @type {boolean} * @default false */ this.paused = false; /** * Stores the time (in milliseconds) when the audio has been paused. * @var CB_AudioFile_API.WAAPI#pauseTime * @readonly * @type {number} * @default */ this.pauseTime = 0; /** * Tells whether the audio is stopped or not. * @var CB_AudioFile_API.WAAPI#stopped * @readonly * @type {boolean} * @default true */ this.stopped = true; /** * Function to call when the audio stops. * @var CB_AudioFile_API.WAAPI#onStopFunction * @readonly * @type {function} * @default */ this.onStopFunction = null; /** * Stores the last &quot;startAt&quot; parameter value used by the {@link CB_AudioFile_API.WAAPI#play} or the {@link CB_AudioFile_API.WAAPI#resume} method. * @var CB_AudioFile_API.WAAPI#lastStartAt * @readonly * @type {number} * @default */ this.lastStartAt = null; /** * Stores the last &quot;stopAt&quot; parameter value used by the {@link CB_AudioFile_API.WAAPI#play} or the {@link CB_AudioFile_API.WAAPI#resume} method. * @var CB_AudioFile_API.WAAPI#lastStopAt * @readonly * @type {number} * @default */ this.lastStopAt = null; /** * Stores the &quot;source&quot; ([AudioBufferSourceNode]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode} object) of the audio, used by the &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). * @var CB_AudioFile_API.WAAPI#source * @readonly * @type {AudioBufferSourceNode} * @default */ this.source = null; /** * Stores the &quot;buffer&quot; ([AudioBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/buffer} object) of the audio, used by the &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). * @var CB_AudioFile_API.WAAPI#buffer * @readonly * @type {AudioBuffer} * @default */ this.buffer = null; /** * Stores the &quot;gain node&quot; ([GainNode]{@link https://developer.mozilla.org/en-US/docs/Web/API/GainNode} object created with the [createGain]{@link https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createGain} method) of the audio, used by the &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). * @var CB_AudioFile_API.WAAPI#gainNode * @readonly * @type {GainNode} * @default */ this.gainNode = null; /** * Progress of the loading process (or downloading through [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) the audio data, used by the &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}). Internal usage only recommended (use the {@link CB_AudioFile_API.WAAPI#getProgress} method instead to know the progress). * @var CB_AudioFile_API.WAAPI#progressDownloading * @readonly * @type {number} * @default 0 */ this.progressDownloading = 0; //Internal properties: this._startTime = 0; //Stores the time when the play starts (used for WAAPI). this._timeoutWhenStop = null; //Keeps the timeout that is executed when the audio has finished playing (to either stop or loop). this._id_internal = null; //Internal id. this._recursiveCallTimeout = null; this._checkCurrentTimeChangesTimeout = null; this._callbackFunctionOkTimeout = null; this._loadingCounterIncreased = false; this._checkPlayingFinishingTimeout = null; this._recursiveCallCheckingTimeout = null; this._checkingCounterIncreased = false; this._lastDuration = null; //Calls the constructor of the object when creates an instance: return this._init(filePath, audioId, options, callbackOk, callbackError); } /** * Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. * @memberof CB_AudioFile_API.WAAPI * @typedef {Object} CB_AudioFile_API.WAAPI.OPTIONS * @property {boolean} [autoLoad={@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.autoLoad] - If set to false, it will not call the {@link CB_AudioFile_API.WAAPI#load} method internally when the constructor is called (not recommended). * @property {boolean} [autoPlay={@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.autoPlay] - Value which will be used as the &quot;autoPlay&quot; parameter when calling the {@link CB_AudioFile_API.WAAPI#load} method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). * @property {boolean} [loop={@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.loop] - Value that will be used for the {@link CB_AudioFile_API.WAAPI#loop} property. * @property {number} [volume={@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.volume] - The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise) that will be used for the {@link CB_AudioFile_API.WAAPI#volume} property. */ //Static properties: CB_AudioFile_API[&quot;WAAPI&quot;]._counter = 0; //Internal counter. CB_AudioFile_API[&quot;WAAPI&quot;]._idUnique = 0; //Counter to make the id unique. CB_AudioFile_API[&quot;WAAPI&quot;]._cache = []; CB_AudioFile_API[&quot;WAAPI&quot;].audioContext = null; //Constructor: CB_AudioFile_API[&quot;WAAPI&quot;].prototype._init = function(filePath, audioId, options, callbackOk, callbackError) { //If not given, defines the default parameters: if (typeof(audioId) === &quot;undefined&quot; || audioId === null) { audioId = &quot;CB_AUDIOFILE_WAAPI_&quot; + CB_AudioFile_API[&quot;WAAPI&quot;]._idUnique++; } //Uses the file path as default id. if (typeof(options) === &quot;undefined&quot; || options === null) { options = this.DEFAULT_OPTIONS; } else { if (typeof(options.loop) === &quot;undefined&quot; || options.loop === null) { options.loop = this.DEFAULT_OPTIONS.loop; } if (typeof(options.autoLoad) === &quot;undefined&quot; || options.autoLoad === null) { options.autoLoad = this.DEFAULT_OPTIONS.autoLoad; } if (typeof(options.autoPlay) === &quot;undefined&quot; || options.autoPlay === null) { options.autoPlay = this.DEFAULT_OPTIONS.autoPlay; } if (typeof(options.volume) === &quot;undefined&quot; || options.volume === null) { options.volume = this.DEFAULT_OPTIONS.volume; } if (typeof(options.useXHR) === &quot;undefined&quot; || options.useXHR === null) { options.useXHR = this.DEFAULT_OPTIONS.useXHR; } if (typeof(options.useCache) === &quot;undefined&quot; || options.useCache === null) { options.useCache = this.DEFAULT_OPTIONS.useCache; } } //Sets the audio ID: this.id = CB_trim(audioId).toUpperCase(); //Sets the internal id: if (typeof(this._id_internal) === &quot;undefined&quot; || this._id_internal === null) { this._id_internal = CB_AudioFile_API[&quot;WAAPI&quot;]._counter++; } //Sets the file path: this.filePath = filePath; //Proceeds according to the options sent: this.loop = options.loop; this.volume = options.volume; this.volumeBeforeMute = this.volume; if (options.autoLoad) { var that = this; setTimeout ( function() { that.load(that.filePath, options.autoPlay, callbackOk, callbackError, null, options.useXHR, options.useCache); }, 10 ); } //Returns the object: return this; } /** * Destroys the audio file object and frees memory. Sets its current {@link CB_AudioFile_API.WAAPI#status} property to ABORTED ({@link CB_AudioFile.ABORTED} value). * @function CB_AudioFile_API.WAAPI#destructor * @param {boolean} [stopSound=false] - If set to true, it will also call the {@link CB_AudioFile_API.WAAPI#stop} method. * @param {boolean} [keepStoppedUnaltered=false] - Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the {@link CB_AudioFile_API.WAAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [avoidOnStop=false] - Used internally as the &quot;avoidOnStop&quot; parameter to call the {@link CB_AudioFile_API.WAAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. * @param {boolean} [forceOnStop=false] - Used internally as the &quot;forceOnStop&quot; parameter to call the {@link CB_AudioFile_API.WAAPI#stop} method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.destructor = function(stopSound, keepStoppedUnaltered, avoidOnStop, forceOnStop) { this._lastDuration = null; //if (typeof(this.audioObject) === &quot;undefined&quot; || this.audioObject === null) { this.status = CB_AudioFile.ABORTED; return; } if (stopSound) { this.stop(keepStoppedUnaltered, avoidOnStop, forceOnStop); } CB_Elements.remove(this.source); CB_Elements.remove(this.buffer); CB_Elements.remove(this.gainNode); //CB_Elements.remove(this.audioObject); //if (this.status === CB_AudioFile.LOADING) if (this._loadingCounterIncreased) { this._loadingCounterIncreased = false; CB_AudioFile_API_WAAPI_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_WAAPI_beingLoading &lt; 0) { CB_AudioFile_API_WAAPI_beingLoading = 0; } } if (this._checkingCounterIncreased) { this._checkingCounterIncreased = false; CB_AudioFile_API_WAAPI_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_WAAPI_beingChecking &lt; 0) { CB_AudioFile_API_WAAPI_beingChecking = 0; } } this.status = CB_AudioFile.ABORTED; } //Returns index of the cache of a given filepath or creates a new slot for it: CB_AudioFile_API[&quot;WAAPI&quot;].prototype._getCacheIndex = function(filePath) { var index = -1; var cacheLength = CB_AudioFile_API[&quot;WAAPI&quot;]._cache.length; for (var x = 0; x &lt; cacheLength; x++) { if (CB_AudioFile_API[&quot;WAAPI&quot;]._cache[x].filePath === filePath) { index = x; break; } } if (index === -1) { index = CB_AudioFile_API[&quot;WAAPI&quot;]._cache.length; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index] = []; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index].filePath = filePath; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index].loading = false; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index].buffer = null; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index].error = null; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[index].checkResult = null; } return index; } /** * Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Uses [Base64Binary]{@link https://gist.github.com/htchaan/108b7aa6b71eb03e38019e64450ea095} internally. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter. * When this method is called, if the {@link CB_AudioFile_API.WAAPI#status} property already has the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the {@link CB_AudioFile.LOADING} constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the {@link CB_AudioFile.UNCHECKED} constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the {@link CB_AudioFile_API.WAAPI#checkPlaying} method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the {@link CB_AudioFile_API.WAAPI#checkPlaying} method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant) and finally the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant) if all goes well. * @function CB_AudioFile_API.WAAPI#load * @param {string} [filePath={@link CB_AudioFile_API.WAAPI#filePath}] - The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. * @param {string} [autoPlay=false] - If set to true, it will start playing the audio automatically (by calling the {@link CB_AudioFile_API.WAAPI#play} method internally). If set to true and the {@link CB_AudioFile_API.WAAPI#status} property reaches the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant), it will also call internally the {@link CB_AudioFile_API.WAAPI#checkPlaying} method. * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {boolean} [forceReload=false] - If set to false, the &quot;filePath&quot; has not been changed from the previously used and the {@link CB_AudioFile_API.WAAPI#status} property belongs to the &quot;LOADED&quot; status (defined in the {@link CB_AudioFile.LOADED} constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). * @param {boolean} [useXHR=[CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS]{@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.useXHR] - Defines whether to use or not [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} ([AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}) to load the audio file. * @param {boolean} [useCache=[CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS]{@link CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS}.useCache] - Defines whether to try to use or not a cache for performance purposes. If set to true and the audio file was loaded before, it will try to use the cache (if possible) to accelerate the loading process. * @returns {CB_AudioFile_API.WAAPI|null} Returns the audio API object (if it was possible to create) or null otherwise. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.load = function(filePath, autoPlay, callbackOk, callbackError, forceReload, useXHR, useCache) { clearTimeout(this._checkCurrentTimeChangesTimeout); clearTimeout(this._callbackFunctionOkTimeout); clearTimeout(this._recursiveCallTimeout); clearTimeout(this._checkPlayingFinishingTimeout); filePath = filePath || this.filePath; //If the status is LOADED and the file path give is the same as the current one, just exits: if (!forceReload &amp;&amp; this.status === CB_AudioFile.LOADED &amp;&amp; this.filePath === filePath) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this); } return this; } this.status = CB_AudioFile.LOADING; //The file is loading. var that = this; if (typeof(useCache) === &quot;undefined&quot; || useCache === null) { useCache = this.DEFAULT_OPTIONS.useCache; } var filePathIndex = this._getCacheIndex(filePath); //If we do not use cache the maximum of objects loading is reached or we use cache but the file path is loading, calls the function again after some time and exits: //if (!useCache &amp;&amp; CB_AudioFile_API_WAAPI_beingLoading &gt;= CB_AudioFile_API_WAAPI_maximumLoading || useCache &amp;&amp; typeof(CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading) if (autoPlay &amp;&amp; !useCache &amp;&amp; CB_AudioFile_API_WAAPI_beingLoading &gt;= CB_AudioFile_API_WAAPI_maximumLoading || useCache &amp;&amp; typeof(CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading) { this._recursiveCallTimeout = setTimeout(function() { that.load(filePath, autoPlay, callbackOk, callbackError, forceReload, useXHR, useCache); }, 100); return this; } //If the buffer for this file path is still not in the cache, other files will have to wait until it loads: if (typeof(CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer) === &quot;undefined&quot; || CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer === null) { CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = true; //The file path is loading. } if (typeof(useXHR) === &quot;undefined&quot; || useXHR === null) { useXHR = this.DEFAULT_OPTIONS.useXHR; } //Destroys previous object (if any): this.destructor(true, false, true); //Also stops the sound (if any) and prevents firing onStop. this.status = CB_AudioFile.LOADING; //The file is loading. if (!this._loadingCounterIncreased) { this._loadingCounterIncreased = true; CB_AudioFile_API_WAAPI_beingLoading++; //Increases the counter of the objects which are loading (destructor has decreased 1). } this.filePath = filePath; //Callback wrapper function when an error happens: var callbackFunctionError = function(error, failedChecking, avoidRegisteringError) { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. if (filePath.substring(0, 5).toLowerCase() === &quot;data:&quot;) { filePath = filePath.substring(0, 15) + &quot;[...]&quot; + filePath.substring(filePath.length - 2); } if (typeof(error) === &quot;undefined&quot; || error === null) { error = &quot;Unknown error for &quot; + filePath + &quot; file&quot;; } else if (typeof(error.status) !== &quot;undefined&quot;) { error = &quot;XHR request for &quot; + filePath + &quot; file returned &quot; + error.status; } else { error = &quot;Error message for &quot; + filePath + &quot; file: &quot; + error; } //Stores as failed (-1) in the cache (for the next time if any CB_AudioFile_API[&quot;WAAPI&quot;] object wants to use cache for the same file path): if (!failedChecking) //We do not store in the cache as it has failed if it has failed checking (because maybe the file is fine but just failed checking). { if (!avoidRegisteringError) { CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].error = error; } CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer = -1; } if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_WAAPI_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_WAAPI_beingLoading &lt; 0) { CB_AudioFile_API_WAAPI_beingLoading = 0; } } CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading anymore. that.status = CB_AudioFile.FAILED; //File failed to load. autoPlay = false; //var fileName = filePath; if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } //Calls the Error function back. }; //Callback wrapper function when all goes well: var callbackFunctionOk = function() { //Function to execute when all is OK: var allIsFine = function() { if (that.status === CB_AudioFile.ABORTED) { return; } //If it is has been aborted, we exit. //Stores the buffer in the cache (for the next time if any CB_AudioFile_API[&quot;WAAPI&quot;] object wants to use cache for the same file path): CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer = that.buffer; if (that._loadingCounterIncreased) { that._loadingCounterIncreased = false; CB_AudioFile_API_WAAPI_beingLoading--; //Decreases the counter of the objects which are loading. if (CB_AudioFile_API_WAAPI_beingLoading &lt; 0) { CB_AudioFile_API_WAAPI_beingLoading = 0; } } CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading anymore. if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } //Calls the OK function back. //Plays automatically if we want to: if (autoPlay) { that.play(); } }; that.status = CB_AudioFile.UNCHECKED; //The file is still unchecked. //If we want to play automatically, checks if the currentTime changes (some web clients cannot play if the user did not fire an event to call the play function): if (autoPlay) { that.checkPlaying(function() { allIsFine(); }, function(error) { callbackFunctionError(error, true); }, false, false, useCache); } else { //Starts playing and stops immediately the sound (needed for some web clients, as Edge, to be able to play the sound later from the first attempt): try { that.source = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createBufferSource(); var source = that.source; source.buffer = that.buffer; that.gainNode = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); that.source.connect(that.gainNode); that.gainNode.connect(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.destination); var previousVolume = that.volume; if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { that.setVolume(0); } source.loop = false; source.start(0, 0); that.source.stop(0); that.setVolume(previousVolume); } catch(E) {} //Calls the final function: allIsFine(); } } try { //Function that decodes the binary data: var callbackFunctionDecode = function(binaryData) { that.progressDownloading = 100; //The file must have been downloaded since we want to decode it now. that.decodeAudioData(binaryData, callbackFunctionOk, callbackFunctionError); }; if (typeof(window.AudioContext) === &quot;undefined&quot; &amp;&amp; typeof(window.webkitAudioContext) === &quot;undefined&quot;) { callbackFunctionError(&quot;Web Audio API not found&quot;); CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading. return null; } //Just creates an audio context: if (typeof(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) === &quot;undefined&quot; || CB_AudioFile_API[&quot;WAAPI&quot;].audioContext === null) { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext = new (window.AudioContext || window.webkitAudioContext)(); //Hack (source: https://stackoverflow.com/questions/56768576/safari-audiocontext-suspended-even-with-onclick-creation/56770254#56770254): try { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); } catch (createGainError) { CB_console(&quot;Error creating a GainNode for the AudioContext: &quot; + createGainError); } try { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.resume(); } catch (audioContextResumeError) { CB_console(&quot;Error resuming AudioContext: &quot; + audioContextResumeError); } if (!CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) { callbackFunctionError(&quot;AudioContext/webkitAudioContext object could not be created! Value returned: &quot; + CB_AudioFile_API[&quot;WAAPI&quot;].audioContext); CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading. return null; } } if (CB_AudioFile_API[&quot;WAAPI&quot;].audioContext &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.state === &quot;suspended&quot;) { CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading. try { var readStateHack = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.state; //Hack. Source: https://stackoverflow.com/questions/56768576/safari-audiocontext-suspended-even-with-onclick-creation/56770254#56770254 CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.resume(); //CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.onstatechange = function() CB_Events.on ( CB_AudioFile_API[&quot;WAAPI&quot;].audioContext, &quot;statechange&quot;, function() { if (CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.state === &quot;running&quot;) { that.load(filePath, autoPlay, callbackOk, callbackError, forceReload, useXHR, useCache); } }, false, //useCapture. true, //keepOldEventFunction. true //erasable. ); } catch (resumeOrOnStateChangeError) { CB_console(&quot;Error resuming or managing 'onStateChange' event: &quot; + resumeOrOnStateChangeError); } return this; } //If we want to use the cache and the file has already been loaded before, gets the buffer from the cache: if (useCache &amp;&amp; typeof(CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer !== null) { this.buffer = CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].buffer; this.progressDownloading = 100; this._callbackFunctionOkTimeout = setTimeout ( (this.buffer === -1) ? function() { callbackFunctionError(&quot;File path from the cache already failed before. Previous message: &quot; + CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].error, false, true); } : callbackFunctionOk, 10 ); } //If we have received a data URI (base64), we don't need to use AJAX (XHR): else if (filePath.substring(0, 5).toLowerCase() === &quot;data:&quot;) { if (filePath.indexOf(&quot;;base64&quot;) !== -1) { //Note: Base64Binary needs Uint8Array and ArrayBuffer support. But the web client will support it if the Web Audio API is supported. var base64Data = filePath.substring(filePath.indexOf(&quot;,&quot;) + 1); //We just need the data. this.progressDownloading = 100; var byteArray = Base64Binary.decodeArrayBuffer(base64Data); callbackFunctionDecode(byteArray); } else { callbackFunctionError(&quot;Data URI does not contain the ';base64' string&quot;); } } //...otherwise, we use AJAX (XHR) to load the file given: else if (useXHR) { //When the file is loaded, calls the function to set it as ready and load the buffer too: var XHR = CB_Net.XHR.callBinary(filePath, null, null, &quot;arraybuffer&quot;, null, function(XHR) { callbackFunctionDecode(XHR.response); }, callbackFunctionError, [200, 206]); //Allows partial content (206 XHR status). this.progressDownloading = 0; XHR.onprogress = function updateProgress (event) { if (event.lengthComputable) { that.progressDownloading = event.loaded / event.total * 100; } }; } //...otherwise, we use WAAPI from an Audio object: else { this.progressDownloading = 0; //Function that processes the Audio element: var processAudioElement = function() { if (typeof(audioFileObject) !== &quot;undefined&quot; &amp;&amp; typeof(audioFileObject.audioObject) !== &quot;undefined&quot; &amp;&amp; audioFileObject.audioObject !== null) { try { var source = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createMediaElementSource(audioFileObject.audioObject); var gainNode = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); /////source.connect(gainNode); /////gainNode.connect(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.destination); analyser = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createAnalyser(); source.connect(analyser); analyser.connect(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.destination); //source.start(0, 0); callbackFunctionOk(); //Calls the OK function back. } catch (error) { callbackFunctionError(error); } } else { callbackFunctionError(&quot;Audio element is undefined or null&quot;); } }; //Creates an Audio object with AAPI: var audioFileObject = new CB_AudioFile_API[&quot;AAPI&quot;](filePath, &quot;CB_media_&quot; + this.id, { autoLoad: true, autoPlay: false, loop: false }, processAudioElement, callbackFunctionError); } } catch(E) { callbackFunctionError(E); CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].loading = false; //The file path is not loading. return null; } //Plays automatically if we want to: //if (autoPlay) { this.play(); } //if (autoPlay) { setTimeout(function() { that.play(); }, 5000); } return this; } /** * Decodes binary audio data given. Internal usage only recommended. * @function CB_AudioFile_API.WAAPI#decodeAudioData * @param {ArrayBuffer} binaryData - [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer} with the audio data to be decoded. * @param {function} [callbackOk] - Function with no parameters to be called when the audio data has been decoded successfully, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio data has not been decoded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @returns {undefined|Promise} Returns the returning value of calling the [BaseAudioContext.decodeAudioData]{@link https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData} function, which returns void (undefined) or a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} (whose methods &quot;then&quot; and &quot;catch&quot; will have already been used internally by this function). */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.decodeAudioData = function(binaryData, callbackOk, callbackError) { var that = this; var callbackCalled = false; var callbackDecodedOk = function(buffer) { if (callbackCalled) { return; } callbackCalled = true; //In case of error: //if (typeof(buffer) === &quot;undefined&quot; || buffer === null || !buffer) if (!buffer) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;Buffer is not defined or null or empty&quot;); } } //...otherwise, the sound has been loaded correctly: else { that.buffer = buffer; //Stores the buffer in this object. if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } //Calls the OK function back. } }; var callbackDecodedError = function(error) //In case of error: { if (callbackCalled) { return; } callbackCalled = true; if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } }; var returningValue = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.decodeAudioData(binaryData, callbackDecodedOk, callbackDecodedError); if (typeof(returningValue) !== &quot;undefined&quot; &amp;&amp; returningValue !== null &amp;&amp; typeof(returningValue.then) === &quot;function&quot;) { returningValue.then(callbackDecodedOk)[&quot;catch&quot;](callbackDecodedError); } return returningValue; } /** * Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the {@link CB_AudioFile_API.WAAPI#play} method the first time. The checking action will only be performed if the value of the {@link CB_AudioFile_API.WAAPI#status} property belongs to the {@link CB_AudioFile.UNCHECKED} or to the {@link CB_AudioFile.CHECKING} value. After checking, if the audio can be played, the {@link CB_AudioFile_API.WAAPI#status} of the object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the {@link CB_AudioFile_API.WAAPI#status} property will get the value of {CB_AudioFile.FAILED}. * @function CB_AudioFile_API.WAAPI#checkPlaying * @param {function} [callbackOk] - Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {function} [callbackError] - Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object itself. * @param {boolean} [ignoreStatus=false] - If set to false and the {@link CB_AudioFile_API.WAAPI#status} property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the {@link CB_AudioFile.UNCHECKED} constant) nor to the &quot;CHECKING&quot; status (defined in the {@link CB_AudioFile.CHECKING} constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. * @param {boolean} [ignoreQueue=false] - If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. * @param {boolean} [useCache=false] - If set to true (not recommended) and the same audio file was checked previously, it will not perform the checking process again and it will do the same as the previous call. * @returns {boolean} Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.checkPlaying = function(callbackOk, callbackError, ignoreStatus, ignoreQueue, useCache) { /////clearTimeout(this._recursiveCallCheckingTimeout); if (!ignoreStatus &amp;&amp; this.status !== CB_AudioFile.UNCHECKED &amp;&amp; this.status !== CB_AudioFile.CHECKING) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Cannot check if status is not unchecked or checking (status is &quot; + this.status + &quot;)&quot;); } return false; } this.status = CB_AudioFile.CHECKING; var that = this; var filePathIndex = this._getCacheIndex(this.filePath); if (useCache &amp;&amp; typeof(CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].checkResult) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].checkResult !== null) { if (CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].checkResult) { this.status = CB_AudioFile.LOADED; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } return true; } else { this.status = CB_AudioFile.FAILED; if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;File path from the cache already failed checking before.&quot;); } return false; } } //If we do not use cache the maximum of objects checking is reached or we use cache but the file path is checking, calls the function again after some time and exits: if (!ignoreQueue &amp;&amp; CB_AudioFile_API_WAAPI_beingChecking &gt;= CB_AudioFile_API_WAAPI_maximumChecking) { this._recursiveCallCheckingTimeout = setTimeout(function() { that.checkPlaying(callbackOk, callbackError, ignoreStatus, useCache); }, 10); return true; } //////this.status = CB_AudioFile.CHECKING; if (!this._checkingCounterIncreased) { this._checkingCounterIncreased = true; CB_AudioFile_API_WAAPI_beingChecking++; //Increases the counter of the objects which are checking. } var previousVolume = this.volume; var finishedChecking = function(ok, error, keepStatus) { //Stops the file: that.source.stop(0); //Restores the volume: that._checkPlayingFinishingTimeout = //Timeout to prevent hearing the sound in some web clients. setTimeout ( function() { that.setVolume(previousVolume); //If the file is ok: if (ok) { if (!keepStatus) { that.status = CB_AudioFile.LOADED; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } } //...otherwise, if the file has failed: else { if (!keepStatus) { that.status = CB_AudioFile.FAILED; } if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } } }, 10 ); if (that._checkingCounterIncreased) { that._checkingCounterIncreased = false; CB_AudioFile_API_WAAPI_beingChecking--; //Decreases the counter of the objects which are checking. if (CB_AudioFile_API_WAAPI_beingChecking &lt; 0) { CB_AudioFile_API_WAAPI_beingChecking = 0; } } CB_AudioFile_API[&quot;WAAPI&quot;]._cache[filePathIndex].checkResult = ok; //Stores the result in the cache. }; try { //Tries to play it silently and checks whether current time has changed. If it has not changed, the file has not been loaded properly. //Note: In Opera with Android sometimes it doesn't throw any error and status is &quot;playing&quot; but currentTime is always zero and no sound can be heard. this.source = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createBufferSource(); var source = this.source; source.buffer = this.buffer; this.gainNode = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); this.source.connect(this.gainNode); this.gainNode.connect(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.destination); if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { this.setVolume(0); } source.loop = false; source.start(0, 0); var currentTime = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime; var timesChecked = 0; clearTimeout(this._checkCurrentTimeChangesTimeout); clearTimeout(this._checkPlayingFinishingTimeout); var checkCurrentTimeChanges = function(callbackOk, callbackError) { if (that.status === CB_AudioFile.ABORTED || that.status === CB_AudioFile.FAILED) { finishedChecking(false, &quot;Audio file object is &quot; + (that.status === CB_AudioFile.ABORTED ? &quot;ABORTED&quot; : &quot;FAILED&quot;) + &quot;.&quot;, true); return; } try { that.status = CB_AudioFile.CHECKING; clearTimeout(that._checkCurrentTimeChangesTimeout); var currentTimeNow = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime; //We check whther the currentTime has changed or not, until a certain number of times: if (currentTime === currentTimeNow) { if (timesChecked &lt; 1000) { timesChecked++; that._checkCurrentTimeChangesTimeout = setTimeout(function() { checkCurrentTimeChanges(callbackOk, callbackError); }, 1); return; } else { finishedChecking(false, &quot;currentTime does not change (it is &quot; + currentTime + &quot;).&quot;); } } else { /////that.status = CB_AudioFile.LOADED; //The file has been loaded. finishedChecking(true); } } catch(E) { finishedChecking(false, E); } }; checkCurrentTimeChanges(callbackOk, callbackError); return true; } catch(E) { finishedChecking(false, E); return false; } } /** * Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. * @function CB_AudioFile_API.WAAPI#getDuration * @returns {number} Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.getDuration = function() { var duration; if (typeof(this.buffer) !== &quot;undefined&quot; &amp;&amp; this.buffer !== null) { duration = this.buffer.duration * 1000; } if (typeof(duration) === &quot;undefined&quot; || duration === null || isNaN(duration) || duration &lt; 0) { duration = 0; } return duration; } /** * Plays the audio. * @function CB_AudioFile_API.WAAPI#play * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the {@link CB_AudioFile_API.WAAPI#lastStartAt} property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the {@link CB_AudioFile_API.WAAPI#lastStartAt} value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the {@link CB_AudioFile_API.WAAPI#getDuration} method (which should belong to the total duration of the audio, if it was calculated correctly). * @param {boolean} [loop={@link CB_AudioFile_API.WAAPI#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.WAAPI#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.WAAPI#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @param {boolean} [isResume=false] - If set to true (not recommended) and it is a looping audio, the next loop will use the value of the {@link CB_AudioFile_API.WAAPI#lastStartAt} property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. * @param {boolean} [isLooping=false] - Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. * @param {integer} [startPlayingTime] - Contains the time when the audio should start playing. Recommended for internal usage only. * @returns {boolean|integer} It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.play = function(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime) { var that = this; var duration = this.getDuration(); if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } //If the sound is not ready yet, calls the function again but later: /*if (this.status !== CB_AudioFile.LOADED || this.getDuration() === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted, calls the function again but later: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) { setTimeout(function() { that.play(startAt, stopAt, loop, allowOverlapping, avoidDelayedPlay, onLoadError, isResume, isLooping); }, 1); } //...otherwise, if it has failed, sets it as stopped: //else { this.stopped = true; } return -1; }*/ if (this.status !== CB_AudioFile.LOADED || duration === 0) //Duration must be greater than zero. { this.stopped = true; this.paused = false; //If it has not failed or aborted: if (this.status !== CB_AudioFile.FAILED &amp;&amp; this.status !== CB_AudioFile.ABORTED) //It must be UNLOADED, LOADING, LOADED, UNCHECKED or CHECKING. { //Function that calls the play method recursively (unless the maximum time allowed has expired): var playLaterFunctionCalled = false; var playLaterFunction = function() { if (playLaterFunctionCalled) { return; } playLaterFunctionCalled = true; //If the recursive delay is not null and is a valid number: if (typeof(allowedRecursiveDelay) === &quot;undefined&quot; || allowedRecursiveDelay === null || isNaN(allowedRecursiveDelay) || allowedRecursiveDelay &lt; 0) { allowedRecursiveDelay = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT; //We use default value. } var timeNow = CB_Device.getTiming(); //If the time expired is less or equal to the delay allowed: if (timeNow - startPlayingTime &lt;= allowedRecursiveDelay) { //Calls play method again: that.play(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, isResume, isLooping, startPlayingTime); } //...otherwise, just stops the sound: /////else { that.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //Function to execute when the sound loads successfully (or finishes checking successfully): var onLoad = function() { //If we allow delayed play, plays the sound: if (!avoidDelayedPlay) { playLaterFunction(); } //...otherwise, just stops the sound (to fire onStop function): else { that.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). }; //If it is UNLOADED or we had a duration before but not now and it is not LOADING, loads the file again: if (this.status === CB_AudioFile.UNLOADED || this.status !== CB_AudioFile.LOADING &amp;&amp; this._lastDuration !== null &amp;&amp; duration === 0) { this.load(this.filePath, false, onLoad, onLoadError, true); } //...otherwise, if it is UNCHECKED, we call the checking function: else if (this.status === CB_AudioFile.UNCHECKED) { this.checkPlaying(onLoad, onLoadError, false, true, false); } //...otherwise, if it is not CHECKING (it must be LOADING or LOADED with duration 0 from the beginning), we will not reload the sound: else if (this.status !== CB_AudioFile.CHECKING) { //If we allow delayed play, calls the play method again but after some time: if (!avoidDelayedPlay) { setTimeout(playLaterFunction, 1); } //...otherwise, just stops the sound (to fire onStop function): /////else { this.stop(false, false); } //Sets as stopped and fires onStop function (if any). else { this.stop(false, false, true); } //Sets as stopped and fires onStop function (if any). } } return -1; } this._lastDuration = duration; //Defines the default parameters: if (CB_trim(startAt) === &quot;&quot;) { startAt = 0; } //Starts at the beginning as default. if (CB_trim(stopAt) === &quot;&quot;) { stopAt = 0; } //If it is not a number, default is zero. if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //If not set, uses the default (or last one used). else { this.loop = loop; } //...otherwise, stores the new setting given. //Sanitizes startAt and stopAt: startAt = parseFloat(startAt); stopAt = parseFloat(stopAt); if (startAt &lt; 0) { startAt = 0; } if (stopAt &lt;= 0 || stopAt &gt; duration) { stopAt = duration; } //If the stopAt is not correct, plays until the end of the file. if (startAt &gt; stopAt) { startAt = this.lastStartAt; } //In the case start time is greater than the stop time, starts as the previous time. if (startAt &gt; stopAt || isNaN(startAt)) { startAt = stopAt; } //If the duration is zero (startAt and stopAt are equal), exits: if (startAt === stopAt) { this.stop(); return false; } //Next loop (if any) it will start at the same time by default: var startAtNextLoop = startAt; //If it is a resume, next loop we should start from the previous startAt used: if (isResume) { startAtNextLoop = this.lastStartAt; } //...otherwise, if it is not a resume, stores the startAt used: else { this.lastStartAt = startAt; } this.lastStopAt = stopAt; //Stores stopAt used. //Adds the event to check when the file reaches the stop time: var whenStopFunction = function() { //Removes the event and timeout: clearTimeout(that._timeoutWhenStop); //Clears the previous timeout. //CB_Events.remove(source, &quot;ended&quot;, whenStopFunction, false); //CB_Events.remove(source, &quot;webkitended&quot;, whenStopFunction, false); //If the sound has been stopped or paused or the stop time has changed, exits: if (that.stopped || that.paused || that.lastStopAt !== stopAt) { return; } //...otherwise, if the stop time has not been reached yet, calls the function again after a while: ///////else if (that.getCurrentTime() &lt; stopAt) { setTimeout(whenStopFunction, 1); return; } //If we want to loop, loops again: if (that.loop) { //that.stop(true); //Stops the sound without setting its property as stopped. that.play(startAtNextLoop, stopAt, true, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, false, true); //Plays again the sound. } //...otherwise, if we don't want to loop, we stop: else { that.stop(); } }; //Clears the previous timeout (if any): clearTimeout(this._timeoutWhenStop); //If it is not a loop (it is the first call to the play method) or we do not want to loop: if (!isLooping || !loop) { CB_symmetricCallClear(&quot;WAAPI_AUDIO_FILE&quot; + this._id_internal); } //We clean the cache of setTimeoutSynchronized for the loop function. //If it is looping or does not allow overlapping and it is not paused, stops the possible previous sound: //if (isLooping || !allowOverlapping &amp;&amp; !this.paused) { this.stop(true); } //Stops the sound without setting its property as stopped. this.stop(true, true); //Stops the sound without setting its property as stopped. //Prepares the mystical stuff: this.source = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createBufferSource(); var source = this.source; source.buffer = this.buffer; //Creates a gain node to be able to set the volume later: this.gainNode = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); this.source.connect(this.gainNode); this.gainNode.connect(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.destination); //Applies the current volume: this.setVolume(this.volume); //Plays the sound: source.loop = false; //We will use our own way to loop, so we don't need the normal way. source.start(0, startAt / 1000, (stopAt - startAt) / 1000); //WAAPI needs seconds. //Stores the start time (useful for pause/resume): this._startTime = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime - (startAt / 1000); //WAAPI needs seconds. //Sets the event and timeout for when the sound finishes: //if (typeof(source.onended) !== &quot;undefined&quot;) { CB_Events.add(source, &quot;ended&quot;, whenStopFunction, false, true, true); } //else if (typeof(source.webkitended) !== &quot;undefined&quot;) { CB_Events.add(source, &quot;webkitended&quot;, whenStopFunction, false, true, true); } //else //{ var msToFinish = stopAt - startAt; this._timeoutWhenStop = CB_symmetricCall(whenStopFunction, msToFinish, &quot;WAAPI_AUDIO_FILE&quot; + this._id_internal); //} //The sound is neither paused nor stopped: this.paused = this.stopped = false; //If it is the first time (not a loop) and there is a function to call when the play starts, we call it: if (!isLooping &amp;&amp; typeof(onPlayStart) === &quot;function&quot;) { onPlayStart.call(this, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); onPlayStart = null; } //Prevents execution again. return true; } /** * Resumes the audio (after being paused), starting from the same point it was paused previously. * @function CB_AudioFile_API.WAAPI#resume * @param {boolean} [loop={@link CB_AudioFile_API.WAAPI#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.WAAPI#onStop} method) will not be called. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the {@link CB_AudioFile_API.WAAPI#stop} method will be called immediately. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the {@link CB_AudioFile_API.WAAPI#stop} method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. * @param {function} [onLoadError] - Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @returns {boolean|integer} Returns the returning value of the {@link CB_AudioFile_API.WAAPI#play} method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.resume = function(loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError) { //If it not paused or it is stopped, exits the function: if (!this.paused || this.stopped) { return false; } //var startAt = this.pauseTime - (this._startTime * 1000); var startAt = this.pauseTime; //If it has been paused after the stop time (happens sometimes when the sound was nearly to finish): if (startAt &gt;= this.lastStopAt) { startAt = this.lastStopAt - 1; //We will begin just 1 millisecond before (otherwise the play method would begin again from lastStartAt). } return this.play(startAt, this.lastStopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onLoadError, true, false); } /** * Pauses the audio when it is being played. * @function CB_AudioFile_API.WAAPI#pause * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @param {boolean} [keepPausedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.WAAPI#paused} property will not be set to true and it will remain with its current value. * @returns {boolean} It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.pause = function(onPause, keepPausedUnaltered) { //If it already paused or stopped, exits the function: if (this.paused || this.stopped) { return false; } if (typeof(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;].audioContext !== null) { if (typeof(this.source) !== &quot;undefined&quot; &amp;&amp; this.source !== null) { clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. if (!keepPausedUnaltered) { this.paused = true; } //Prevents error on Safari Mobile (&quot;InvalidStateError: DOM Exception 11: An attempt was made to use an object that is not, or is no longer, usable.&quot;): try { this.source.stop(0); } catch(E) {} //this.pauseTime = CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime * 1000; this.pauseTime = (CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime - this._startTime) * 1000; if (typeof(onPause) === &quot;function&quot;) { onPause.call(this); } return true; } } return false; } /** * Stops the audio. * @function CB_AudioFile_API.WAAPI#stop * @param {boolean} [keepStoppedUnaltered=false] - If set to true (not recommended), the {@link CB_AudioFile_API.WAAPI#stopped} property will not be set to true and it will remain with its current value. * @param {boolean} [avoidOnStop=false] - If set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.WAAPI#onStop} method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. * @param {boolean} [forceOnStop=false] - If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the {@link CB_AudioFile_API.WAAPI#onStop} method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. * @returns {boolean} It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.stop = function(keepStoppedUnaltered, avoidOnStop, forceOnStop) { if (typeof(this.source) !== &quot;undefined&quot; &amp;&amp; this.source !== null) { ///////clearTimeout(this._timeoutWhenStop); //Prevents that the file is set as stopped or to be executed again. var stoppedBefore = this.stopped; if (!keepStoppedUnaltered) { this.stopped = true; } this.paused = false; //If it is stopped, it is not paused. //Prevents error on Safari Mobile (&quot;InvalidStateError: DOM Exception 11: An attempt was made to use an object that is not, or is no longer, usable.&quot;): try { this.source.stop(0); } catch(E) {} //If we do not want to avoid onStop, it was not stopped before but it is now and onStop has a valid function assigned, we execute it: if (!avoidOnStop &amp;&amp; (!stoppedBefore &amp;&amp; this.stopped || forceOnStop) &amp;&amp; typeof(this.onStopFunction) === &quot;function&quot;) { this.onStopFunction.call(this); } return true; } return false; } /** * Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @function CB_AudioFile_API.WAAPI#setVolume * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the {@link CB_AudioFile_API.WAAPI#volume} property even when the volume failed to be changed. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @param {boolean} [saveForUnmute=false] - If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the {@link CB_AudioFile_API.WAAPI#unmute} method. Internal usage only recommended. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.setVolume = function(volume, forceSetVolumeProperty, onSetVolume, saveForUnmute) { //Defines the default parameters: volume = parseInt(volume); if (isNaN(volume)) { this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; volume = this.DEFAULT_VOLUME; } //Sets the volume within their limits if it is beyond them: var MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM ? CB_Speaker.getVolume() : 100; if (volume &gt; MAX_VOLUME) { volume = MAX_VOLUME; } else if (volume &lt; 0) { volume = 0; } if (typeof(this.gainNode) !== &quot;undefined&quot; &amp;&amp; this.gainNode !== null) { if (typeof(this.gainNode.gain.setValueAtTime) !== &quot;undefined&quot;) { this.gainNode.gain.setValueAtTime(volume / 100, CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime); } else { this.gainNode.gain.value = volume / 100; } //fraction * fraction; if ((saveForUnmute || volume === 0) &amp;&amp; this.volume &gt; 0) { this.volumeBeforeMute = this.volume; } //Also saves the previous volume if the desired one is zero (muted). this.volume = volume; if (typeof(onSetVolume) === &quot;function&quot;) { onSetVolume.call(this); } } if (forceSetVolumeProperty) { this.volume = volume; } return this.volume; } /** * Mutes the audio file. * @function CB_AudioFile_API.WAAPI#mute * @param {function} [onMute] - Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.mute = function(onMute) { //Only mutes the sound if it is not muted already: if (this.volume &gt; 0) { //Mutes the audio: this.setVolume(0, false, onMute, true); //It modifies this.volumeBeforeMute. } return this.volume; } /** * Restores audio after muting it (unmutes it). * @function CB_AudioFile_API.WAAPI#unmute * @param {function} [onUnmute] - Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. * @returns {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.unmute = function(onUnmute) { //Only unmutes if it is still muted: if (this.volume === 0) { //Restores the volume before muting: this.setVolume(this.volumeBeforeMute, false, onUnmute); } return this.volume; } /** * Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. * @function CB_AudioFile_API.WAAPI#getCurrentTime * @returns {number} Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.getCurrentTime = function() { var currentTime; if (typeof(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) !== &quot;undefined&quot; &amp;&amp; CB_AudioFile_API[&quot;WAAPI&quot;].audioContext !== null) { if (this.stopped) { currentTime = 0; } else if (this.paused) { //currentTime = this.pauseTime - (this._startTime * 1000); currentTime = this.pauseTime; } else { currentTime = (CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.currentTime - this._startTime) * 1000; } //Maybe it is a loop: var duration = this.getDuration(); if (duration &gt; 0) //Avoids division by zero. { currentTime %= duration; } } if (typeof(currentTime) === &quot;undefined&quot; || currentTime === null || isNaN(currentTime) || currentTime &lt; 0) { currentTime = 0; } return currentTime; } /** * Sets a function to execute when the audio file stops playing or removes it. * @function CB_AudioFile_API.WAAPI#onStop * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the {@link CB_AudioFile_API.WAAPI} object. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @returns {boolean} Returns whether the event has been set or not (removed). */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.onStop = function(callbackFunction, keepOldFunction) { //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } if (typeof(callbackFunction) !== &quot;function&quot;) { this.onStopFunction = null; return false; } //If we don't want to keep the old function: if (!keepOldFunction) { this.onStopFunction = callbackFunction; } //...otherwise if we want to keep the old function, we keep it: else { var that = this; //Stores old function: var oldFunction = this.onStopFunction; //Stores old function of eventFunctionHolder. this.onStopFunction = function() { if (typeof(oldFunction) === &quot;function&quot;) { oldFunction.call(that); } callbackFunction.call(that); }; } return true; } /** * Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @function CB_AudioFile_API.WAAPI#getProgress * @returns {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFile_API[&quot;WAAPI&quot;].prototype.getProgress = function() { if (this.status === CB_AudioFile.LOADED || this.status === CB_AudioFile.UNCHECKED || this.status === CB_AudioFile.CHECKING) { return 100; } else if (this.status === CB_AudioFile.UNLOADED) { return 0; } var progress = 0; //Calculates the progress (only if it is LOADING, FAILED or ABORTED): //TODO: if decodeAudioData method gets a way to know its progress in the future, use that way here. //Progress downloading is considered as the 50% of the process (the other 50% would be te decodinng by decodeAudioData method): progress = this.progressDownloading / 2; return progress; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFileCache.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFileCache.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js /** * @file Audio files cache management. Contains the {@link CB_AudioFileCache} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Object whose property names are audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. * @example * { * &quot;audio/mp4&quot; : [ &quot;first/path/sound.m4a&quot;, &quot;alternative/path/sound.m4a&quot;, &quot;alternative/path/2/sound.mp4&quot;, ... ], * &quot;audio/ogg&quot; : [ &quot;first/path/sound.opus&quot;, &quot;alternative/path/sound.ogg&quot;, &quot;alternative/path/2/sound.ogg&quot;, ... ], * &quot;audio/mpeg&quot; : [ &quot;first/path/sound.mp3&quot;, &quot;alternative/path/sound.mp3&quot;, &quot;alternative/path/2/sound.mp3&quot;, ... ], * &quot;audio/wav&quot; : [ &quot;first/path/sound.wav&quot;, &quot;alternative/path/sound.wav&quot;, &quot;alternative/path/2/sound.wav&quot;, ... ], * ... * } * @memberof CB_AudioFileCache * @typedef {Object} CB_AudioFileCache.URIS_OBJECT * @property {array} filePaths - Being the name of each property the audio format (it can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), the value will always be a numeric array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. */ /** * Object with the desired data and options for the audio files cache. * @memberof CB_AudioFileCache * @typedef {Object} CB_AudioFileCache.DATA_OBJECT * @property {CB_AudioFileCache.URIS_OBJECT} URIs - Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. If a valid value is given, this will be added to the {@link CB_AudioFileCache#URIs} property. * @property {string} [id=&quot;&quot;] - Desired identifier for the audio files cache. Internal usage only recommended. If a valid value is given, this will be added to the {@link CB_AudioFileCache#id} property. * @property {array} [preferredAPIs={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}] - Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileCache#preferredAPIs} property. * @property {array} [preferredFormats={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS}] - Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileCache#preferredFormats} property. * @property {integer} [minimumAudioFiles={@link CB_AudioFileCache.minimumAudioFiles_DEFAULT}] - Minimum {@link CB_AudioFile} objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#minimumAudioFiles} property. * @property {integer|null} [maximumAudioFiles={@link CB_AudioFileCache.maximumAudioFiles_DEFAULT}] - Maximum {@link CB_AudioFile} objects that are allowed to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the {@link CB_AudioFileCache#minimumAudioFiles} property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#maximumAudioFiles} property. * @property {integer} [minimumAudioFilesFree=parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.25 + 0.5)] - New {@link CB_AudioFile} objects will be created internally when the number of free {@link CB_AudioFile} objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#minimumAudioFilesFree} property. * @property {integer} [newAudioFilesWhenNeeded=Math.min(parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.1 + 0.5), 1)] - Number of new {@link CB_AudioFile} objects to create internally when the minimum limit of free {@link CB_AudioFile} objects ({@link CB_AudioFileCache#minimumAudioFilesFree}) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#newAudioFilesWhenNeeded} property. * @property {integer} [retries={@link CB_AudioFileCache.retries_DEFAULT}] - Number of retries to try to load a {@link CB_AudioFile} object internally before trying to load the next possible one (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#retries} property. * @property {boolean} [checkManually={@link CB_AudioFileCache.checkManually_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManually} property. * @property {boolean} [checkManuallyOnNeededCreated={@link CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when creates a new {@link CB_AudioFile} object needed. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnNeededCreated} property. * @property {boolean} [checkManuallyOnPlayingFailed={@link CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnPlayingFailed} property. * @property {boolean} [checkManuallyOnCheckingFailed={@link CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnCheckingFailed} property. * @property {function} [onLoad] - Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the {@link CB_AudioFile} objects that still need to be checked, if any, being &quot;this&quot; the current {@link CB_AudioFileCache} object. If a valid value is given, this will be added to the {@link CB_AudioFileCache#onLoad} property. * @property {function} [onError] - Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current {@link CB_AudioFileCache} object. If a valid value is given, this will be added to the {@link CB_AudioFileCache#onError} property. * @property {boolean} [disableAutoLoad=false] - If set to true, it will not create automatically the {@link CB_AudioFile} objects by calling the {@link CB_AudioFileCache#createAudioFiles} method internally. Internal usage only recommended. */ /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @class * @classdesc Class to manage a cache with multiple {@link CB_AudioFile} objects (they should be the same sound although they can be in different formats). This is not only useful for performance purposes but also for being able to play the same sound simultaneously and multiple times in different audio APIs and clients. * @param {CB_AudioFileCache.DATA_OBJECT} [dataObject] - Object with the desired data and options for the audio files cache. * @returns {CB_AudioFileCache} Returns a new {@link CB_AudioFileCache} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ var CB_AudioFileCache = function(dataObject) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFileCache)) { return new CB_AudioFileCache(dataObject); } //Static properties and constants: /** * Keeps the default volume. If the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT} property is true, this will keep the result of calling the {@link CB_Speaker.getVolume} function. Otherwise, it will use the value of the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} variable. * @constant * @type {number} * @default CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME */ CB_AudioFileCache.prototype.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; //Properties and variables: /** * Tells whether the cache is unloaded ({@link CB_AudioFileCache.UNLOADED}), loading ({@link CB_AudioFileCache.LOADING}), unchecked ({@link CB_AudioFileCache.UNCHECKED}), checking ({@link CB_AudioFileCache.CHECKING}), loaded ({@link CB_AudioFileCache.LOADED}), failed ({@link CB_AudioFileCache.FAILED}) or aborted ({@link CB_AudioFileCache.ABORTED}). * @var CB_AudioFileCache#status * @readonly * @type {integer} * @default {@link CB_AudioFileCache.UNLOADED} */ this.status = CB_AudioFileCache.UNLOADED; /** * Stores the identifier for the audio files cache. * @var * @readonly * @type {string} * @default */ this.id = &quot;&quot;; /** * Stores an array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Internal usage only recommended. * @var * @readonly * @type {array} * @default CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS */ this.preferredAPIs = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_APIS; /** * Stores an array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. Internal usage only recommended. * @var * @readonly * @type {array} * @default CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS */ this.preferredFormats = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_FORMATS; /** * Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. Internal usage only recommended. * @var * @readonly * @type {CB_AudioFileCache.URIS_OBJECT} */ this.URIs = {}; /** * Minimum {@link CB_AudioFile} objects to create internally. It must be an integer being 1 the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default CB_AudioFileCache.minimumAudioFiles_DEFAULT */ this.minimumAudioFiles = CB_AudioFileCache.minimumAudioFiles_DEFAULT; /** * Maximum {@link CB_AudioFile} objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the {@link CB_AudioFileCache#minimumAudioFiles} property, allowing 1 minimum. Internal usage only recommended. * @var * @readonly * @type {integer|null} * @default CB_AudioFileCache.maximumAudioFiles_DEFAULT */ this.maximumAudioFiles = CB_AudioFileCache.maximumAudioFiles_DEFAULT; /** * New {@link CB_AudioFile} objects will be created internally when the number of free {@link CB_AudioFile} objects reaches this limit. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.25 + 0.5) */ this.minimumAudioFilesFree = CB_AudioFileCache._minimumAudioFilesFree_FIRST_VALUE; /** * Number of new {@link CB_AudioFile} objects to create internally when the minimum limit of free {@link CB_AudioFile} objects ({@link CB_AudioFileCache#minimumAudioFilesFree}) is reached. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default Math.min(parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.1 + 0.5), 1) */ this.newAudioFilesWhenNeeded = CB_AudioFileCache._newAudioFilesWhenNeeded_FIRST_VALUE; /** * Number of retries to try to load a {@link CB_AudioFile} object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default CB_AudioFileCache.retries_DEFAULT */ this.retries = CB_AudioFileCache.retries_DEFAULT; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually). Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManually_DEFAULT */ this.checkManually = CB_AudioFileCache.checkManually_DEFAULT; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when creates a new {@link CB_AudioFile} object needed. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT */ this.checkManuallyOnNeededCreated = CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT */ this.checkManuallyOnPlayingFailed = CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT */ this.checkManuallyOnCheckingFailed = CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT; /** * Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the {@link CB_AudioFile} objects that still need to be checked, if any, being &quot;this&quot; the current {@link CB_AudioFileCache} object. Internal usage only recommended. * @var * @readonly * @type {function} * @default */ this.onLoad = null; /** * Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current {@link CB_AudioFileCache} object. Internal usage only recommended. * @var * @readonly * @type {function} * @default */ this.onError = null; /** * Numeric array containing all the {@link CB_AudioFile} objects created internally. Internal usage only recommended. * @var * @readonly * @type {array} * @default */ this.audioFiles = []; /** * Total number of {@link CB_AudioFile} objects created internally (optimization purposes, to avoid using {@link CB_AudioFileCache#audioFiles}.length). Internal usage only recommended. * @var * @readonly * @type {integer} * @default */ this.audioFilesCreated = 0; /** * Stack that stores the indexes (belonged to the {@link CB_AudioFileCache#audioFiles} array) of the free {@link CB_AudioFile} objects. Internal usage only recommended. * @var * @readonly * @type {array} * @default */ this.audioFilesFree = []; /** * Pointer for the {@link CB_AudioFileCache#audioFilesFree} stack (for optimization purposes). Internal usage only recommended. * @var * @readonly * @type {integer} * @default */ this.audioFilesFreePointer = -1; /** * Object with sound instance identifiers (integers created by the {@link CB_AudioFileCache#play} method) which are going to play (this way we can cancel the sound before it starts playing). Each property name is the identifier of the sound instance and the value will be an object with &quot;cancelled&quot; (boolean, to know whether the sound instance was cancelled or not) and &quot;object&quot; (containing the {@link CB_AudioFile} object used) properties. Internal usage only recommended. * @var * @readonly * @type {Object} * @default */ this.soundInstancesQueued = {}; /** * Stores the minimum duration found among all the {@link CB_AudioFile} objects. Internal usage only recommended. * @var * @readonly * @type {number} * @default 0 */ this.duration = 0; /** * Stores the maximum duration found among all the {@link CB_AudioFile} objects. Internal usage only recommended. * @var * @readonly * @type {number} * @default 0 */ this.durationMaximum = 0; //Internal properties: this._URIsListLast = undefined; this._lastSuccededIndexes = {}; //Stores last indexes that were used when an object is created successfully, ordered by URIs and APIs (for optimization purposes). this._checkCacheLoadedTimeout = null; this._checkCacheLoadedTimeoutMs = 500; this._onLoadCalled = false; //Tells whether the onLoad has been called already or not. this._existingObjectIds = []; this._clearAudioFilesTimeout = null; this._createNewAudioFilesIfNeededTimeout = null; ///////this._callRecursivelyIfNotTooLateCalled = false; this._checkingPlaying = false; this._settingAPI = false; //Calls the constructor of the object when creates an instance: return this._init(dataObject); } //Static properties and constants: /////CB_AudioFileCache.MAX_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM; CB_AudioFileCache._soundInstanceIdUnique = 0; /** * Status value for audio file cache which is unloaded. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default 0 */ CB_AudioFileCache.UNLOADED = 0; /** * Status value for an audio file cache which is loading. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.LOADING = 1; /** * Status value for an audio file cache which has not been checked yet. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.UNCHECKED = 2; /** * Status value for an audio file cache which is being checked currently. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.CHECKING = 3; /** * Status value for an audio file cache which has been loaded. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.LOADED = 4; /** * Status value for an audio file cache which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.FAILED = 5; /** * Status value for an audio file cache which has been aborted. This will happen when the audio file cache has been destroyed with the {@link CB_AudioFileCache#destructor} method. Can be used to compare the value returned by the {@link CB_AudioFileCache#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileCache.ABORTED = 6; /** * Default value for the {@link CB_AudioFileCache#minimumAudioFiles} property. * @constant * @type {integer} * @default */ CB_AudioFileCache.minimumAudioFiles_DEFAULT = 2; /** * Default value for the {@link CB_AudioFileCache#maximumAudioFiles} property. * @constant * @type {integer|null} * @default null */ CB_AudioFileCache.maximumAudioFiles_DEFAULT = null; /** * Default value for the {@link CB_AudioFileCache#retries} property. * @constant * @type {integer} * @default */ CB_AudioFileCache.retries_DEFAULT = 1; /** * Default value for the {@link CB_AudioFileCache#checkManually} property. * @constant * @type {boolean} * @default false */ CB_AudioFileCache.checkManually_DEFAULT = false; /** * Default value for the {@link CB_AudioFileCache#checkManuallyOnNeededCreated} property. * @constant * @type {boolean} * @default false */ CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT = false; /** * Default value for the {@link CB_AudioFileCache#checkManuallyOnPlayingFailed} property. * @constant * @type {boolean} * @default false */ CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT = false; /** * Default value for the {@link CB_AudioFileCache#checkManuallyOnCheckingFailed} property. * @constant * @type {boolean} * @default false */ CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT = false; CB_AudioFileCache._minimumAudioFilesFree_FIRST_VALUE = 1; //First value for the {@link CB_AudioFileCache#minimumAudioFilesFree} property, although it will end using a 25% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 0 (zero) minimum. CB_AudioFileCache._newAudioFilesWhenNeeded_FIRST_VALUE = 1; //First value for the {@link CB_AudioFileCache#newAudioFilesWhenNeeded} property, although it will end using a 10% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 1 minimum. //Constructor: CB_AudioFileCache.prototype._init = function(dataObject) { /* FORMAT: dataObject = { [id : String,] [preferredAPIs : Array&lt;String&gt;,] [preferredFormats : Array&lt;String&gt;,] URIs : Object, [minimumAudioFiles : Integer,] [maximumAudioFiles : Integer,] [minimumAudioFilesFree : Integer,] [newAudioFilesWhenNeeded : Integer,] [retries : Integer,] [checkManually : Boolean,] [checkManuallyOnNeededCreated : Boolean,] [checkManuallyOnPlayingFailed : Boolean,] [checkManuallyOnCheckingFailed : Boolean,] [disableAutoLoad : Boolean,] [onLoad : Function,] [onError : Function] }; */ //Tries to load the data (if any): this.load(dataObject); //Returns the object: return this; } /** * Destroys the audio file cache object, including all the internal {@link CB_AudioFile} objects, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of the audio file cache object as ABORTED ({@link CB_AudioFileCache.ABORTED} value). * @function * @param {boolean} [stopSounds=false] - Used as the &quot;stopSound&quot; parameter when calling internally the {@link CB_AudioFile#destructor} method for all the {@link CB_AudioFile} objects. * @param {boolean} [preventAbortedStatus=false] - If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not assign the value of {@link CB_AudioFileCache.ABORTED} to the {@link CB_AudioFileCache#status} property). */ CB_AudioFileCache.prototype.destructor = function(stopSounds, preventAbortedStatus) { clearTimeout(this._checkCacheLoadedTimeout); clearTimeout(this._clearAudioFilesTimeout); clearTimeout(this._createNewAudioFilesIfNeededTimeout); this.cancelSoundInstances(true, true); //Destroys all sounds: this.destroyAll(stopSounds); //Resets properties to their default value: this.preferredAPIs = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_APIS; this.preferredFormats = CB_Configuration[CB_BASE_NAME].CB_AudioFileCache_PREFERRED_AUDIO_FORMATS; this.URIs = {}; this.minimumAudioFiles = CB_AudioFileCache.minimumAudioFiles_DEFAULT; this.maximumAudioFiles = CB_AudioFileCache.maximumAudioFiles_DEFAULT; this.minimumAudioFilesFree = CB_AudioFileCache._minimumAudioFilesFree_FIRST_VALUE; this.newAudioFilesWhenNeeded = CB_AudioFileCache._newAudioFilesWhenNeeded_FIRST_VALUE; this.retries = CB_AudioFileCache.retries_DEFAULT; this.checkManually = CB_AudioFileCache.checkManually_DEFAULT; this.checkManuallyOnNeededCreated = CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT; this.checkManuallyOnPlayingFailed = CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT; this.checkManuallyOnCheckingFailed = CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT; this.onLoad = null; this.onError = null; this.audioFiles = []; this.audioFilesCreated = 0; this.soundInstancesQueued = {}; this.duration = 0; this.durationMaximum = 0; //Resets the audioFilesFree stack and its pointer: this.audioFilesFree = []; this.audioFilesFreePointer = -1; //Sets the status as ABORTED: if (!preventAbortedStatus) { this.status = CB_AudioFileCache.ABORTED; } } /** * Loads the audio file cache with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @function * @param {CB_AudioFileCache.DATA_OBJECT} dataObject - Object with the desired data and options for the audio files cache. * @returns {CB_AudioFileCache|null} If a &quot;dataObject&quot; is given, it returns the current {@link CB_AudioFileCache} object. Otherwise, it returns null. */ CB_AudioFileCache.prototype.load = function(dataObject) { if (typeof(dataObject) === &quot;undefined&quot; || dataObject === null) { return null; } this.status = CB_AudioFileCache.LOADING; //The cache is loading. //Destroys all previous data (if any): this.destructor(true, true); //Also stops all sounds. //Sanitizes the given data: dataObject.id = CB_trim(dataObject.id); dataObject.minimumAudioFiles = parseInt(CB_trim(dataObject.minimumAudioFiles)); if (dataObject.maximumAudioFiles !== null) { dataObject.maximumAudioFiles = parseInt(CB_trim(dataObject.maximumAudioFiles)); } dataObject.minimumAudioFilesFree = parseInt(CB_trim(dataObject.minimumAudioFilesFree)) dataObject.newAudioFilesWhenNeeded = parseInt(CB_trim(dataObject.newAudioFilesWhenNeeded)) dataObject.retries = parseInt(CB_trim(dataObject.retries)); //Sets the new data: if (dataObject.id !== &quot;&quot;) { this.id = dataObject.id; } if (CB_isArray(dataObject.preferredAPIs) &amp;&amp; dataObject.preferredAPIs.length &gt; 0 &amp;&amp; CB_trim(dataObject.preferredAPIs.join(&quot;&quot;)) !== &quot;&quot;) { this.preferredAPIs = dataObject.preferredAPIs; } if (CB_isArray(dataObject.preferredFormats) &amp;&amp; dataObject.preferredFormats.length &gt; 0 &amp;&amp; CB_trim(dataObject.preferredFormats.join(&quot;&quot;)) !== &quot;&quot;) { this.preferredFormats = dataObject.preferredFormats; } if (typeof(dataObject.URIs) !== &quot;undefined&quot;) { this.URIs = dataObject.URIs; } if (dataObject.minimumAudioFiles !== &quot;&quot; &amp;&amp; !isNaN(dataObject.minimumAudioFiles) &amp;&amp; dataObject.minimumAudioFiles &gt;= 1) { this.minimumAudioFiles = dataObject.minimumAudioFiles; } if (dataObject.maximumAudioFiles === null || dataObject.maximumAudioFiles !== &quot;&quot; &amp;&amp; !isNaN(dataObject.maximumAudioFiles) &amp;&amp; dataObject.maximumAudioFiles &gt;= this.minimumAudioFiles) { this.maximumAudioFiles = dataObject.maximumAudioFiles; } else { this.maximumAudioFiles = CB_AudioFileCache.maximumAudioFiles_DEFAULT; } if (dataObject.minimumAudioFilesFree !== &quot;&quot; &amp;&amp; !isNaN(dataObject.minimumAudioFilesFree) &amp;&amp; dataObject.minimumAudioFilesFree &gt;= 0) { this.minimumAudioFilesFree = dataObject.minimumAudioFilesFree; } else { //Uses a limit of 25% of the minimum by default: this.minimumAudioFilesFree = parseInt(this.minimumAudioFiles * 0.25 + 0.5); //Ceil round. } if (dataObject.newAudioFilesWhenNeeded !== &quot;&quot; &amp;&amp; !isNaN(dataObject.newAudioFilesWhenNeeded) &amp;&amp; dataObject.newAudioFilesWhenNeeded &gt;= 0) { this.newAudioFilesWhenNeeded = dataObject.newAudioFilesWhenNeeded; } else { //Creates a 10% of the minimum by default: this.newAudioFilesWhenNeeded = parseInt(this.minimumAudioFiles * 0.1 + 0.5); //Ceil round. if (this.newAudioFilesWhenNeeded &lt; 1) { this.newAudioFilesWhenNeeded = 1; } } if (dataObject.retries !== &quot;&quot; &amp;&amp; !isNaN(dataObject.retries) &amp;&amp; dataObject.retries &gt;= 0) { this.retries = dataObject.retries; } if (typeof(dataObject.checkManually) !== &quot;undefined&quot; &amp;&amp; dataObject.checkManually !== null) { this.checkManually = dataObject.checkManually; } if (typeof(dataObject.checkManuallyOnNeededCreated) !== &quot;undefined&quot; &amp;&amp; dataObject.checkManuallyOnNeededCreated !== null) { this.checkManuallyOnNeededCreated = dataObject.checkManuallyOnNeededCreated; } if (typeof(dataObject.checkManuallyOnPlayingFailed) !== &quot;undefined&quot; &amp;&amp; dataObject.checkManuallyOnPlayingFailed !== null) { this.checkManuallyOnPlayingFailed = dataObject.checkManuallyOnPlayingFailed; } if (typeof(dataObject.checkManuallyOnCheckingFailed) !== &quot;undefined&quot; &amp;&amp; dataObject.checkManuallyOnCheckingFailed !== null) { this.checkManuallyOnCheckingFailed = dataObject.checkManuallyOnCheckingFailed; } if (typeof(dataObject.onLoad) === &quot;function&quot;) { this.onLoad = dataObject.onLoad; } if (typeof(dataObject.onError) === &quot;function&quot;) { this.onError = dataObject.onError; } //If we want, loads the needed objects (if any): var disableAutoLoad = false; if (typeof(dataObject.disableAutoLoad) !== &quot;undefined&quot; &amp;&amp; dataObject.disableAutoLoad !== null) { disableAutoLoad = dataObject.disableAutoLoad; } if (!disableAutoLoad) { this.createAudioFiles(this.minimumAudioFiles); } //Creates the minimum number of objects desired. return this; } /** * Creates the desired number of internal {@link CB_AudioFile} objects (inside the {@link CB_AudioFileCache#audioFiles} property). This method is already called by the {@link CB_AudioFileCache#load} method automatically (unless the &quot;disableAutoLoad&quot; property has been set to true in the &quot;dataObject&quot; given). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @function * @param {integer} minimumAudioFiles - Minimum {@link CB_AudioFile} objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#minimumAudioFiles} property. * @param {boolean} [setAsLoaded=false] - If the {@link CB_AudioFile} objects already created internally (before calling this method) does not reach the number given in the &quot;minimumAudioFiles&quot;, this parameter will be ignored. Otherwise, if set to true, it will set the {@link CB_AudioFileCache.status} property as &quot;LOADED&quot; (the value of the {@link CB_AudioFileCache#LOADED} property) after reaching the desired number. If set to false, the {@link CB_AudioFileCache.status} property will be set as &quot;LOADED&quot; {@link CB_AudioFileCache#LOADED} property) if the {@link CB_AudioFileCache#checkManually} property is set to true or set as &quot;UNCHECKED&quot; if the {@link CB_AudioFileCache#checkManually} property is set to false. Internal usage only recommended. * @returns {integer} Returns the number of {@link CB_AudioFile} objects which are intended to be created (they could fail). */ CB_AudioFileCache.prototype.createAudioFiles = function(minimumAudioFiles, setAsLoaded) { this.status = CB_AudioFileCache.LOADING; //The cache is loading. if (typeof(minimumAudioFiles) === &quot;undefined&quot; || minimumAudioFiles === null || isNaN(minimumAudioFiles) || minimumAudioFiles &lt; 1) { minimumAudioFiles = this.minimumAudioFiles; } //If there is a maximum of files set: if (typeof(this.maximumAudioFiles) !== &quot;undefined&quot; &amp;&amp; this.maximumAudioFiles !== null &amp;&amp; !isNaN(this.maximumAudioFiles) &amp;&amp; this.maximumAudioFiles &gt;= 1) { //If the minimum of files we want is bigger than the maximum, throws an error and exits: if (minimumAudioFiles &gt; this.maximumAudioFiles) { this.errorFunction(&quot;Cannot create &quot; + minimumAudioFiles + &quot; audio files. Maximum is &quot; + this.maximumAudioFiles + &quot;.&quot;); return 0; } } //Sets as the minimum objects to create the number given: this.minimumAudioFiles = minimumAudioFiles; //Clears the array of the AudioFiles: this.clearAudioFiles(); //Creates the objects if they do not exist already: this.audioFilesCreated = 0; var audioFilesCreated = 0; var audioFilesCreating = 0; var audioFile; var that = this; for (var x = 0; x &lt; minimumAudioFiles; x++) { //If an object is needed: if (typeof(this.audioFiles[x]) === &quot;undefined&quot; || this.audioFiles[x] === null) { //this.audioFiles[x] = this.createAudioFile(); //If loads correctly, it will increase the audioFilesCreated property. //Creates a new object: /////setTimeout //Uses a delay to prevent Firefox error (&quot;Media resource [URI] could not be decoded&quot;) since AAPI and SM2 call play() method (and many calls to play() method would fail). /////( ////////// function() /////{ audioFile = that.createAudioFile(null, null, null, null, null, null, true); //If loads correctly, it will increase the audioFilesCreated property. audioFilesCreating++; //////}, /////////x * 10 + 1 //////); //If no object has been created, throws an error (cache status will be FAILED): //////////if (typeof(audioFile) === &quot;undefined&quot; || audioFile === null) { ////////////this.errorFunction(&quot;Tried to create the audio object #&quot; + x + &quot; but is undefined or null.&quot;); ////////////return; //Exits the function. } } else { audioFilesCreated++; } //If the cache has already failed or is aborted, just exits: if (this.status === CB_AudioFileCache.FAILED || this.status === CB_AudioFileCache.ABORTED) { return audioFilesCreating; } } //If the files are already created, the cache has finished loading: //if (audioFilesCreated &gt;= minimumAudioFiles) { this.status = CB_AudioFileCache.LOADED; } if (audioFilesCreated &gt;= minimumAudioFiles) { this.status = this.checkManually &amp;&amp; !setAsLoaded ? CB_AudioFileCache.UNCHECKED : CB_AudioFileCache.LOADED; } //Stores the number of files already created: this.audioFilesCreated += audioFilesCreated; //It is an addition because some objects could have been created asynchronously. return audioFilesCreating; } /** * Creates one internal {@link CB_AudioFile} object (inside the {@link CB_AudioFileCache#audioFiles} property). This method is already called by the {@link CB_AudioFileCache#createAudioFiles} method and other methods automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Internal usage only recommended. * @function * @param {CB_AudioFileCache.URIS_OBJECT} [URIs={@link CB_AudioFileCache#URIs}] - Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. It will try to calculate and use the best audio format for the current client and use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. * @param {array} [preferredAPIs={@link CB_AudioFileCache#preferredAPIs}] - Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). It will try to calculate and use the best one for the current client. * @param {array} [preferredFormats={@link CB_AudioFileCache#preferredFormats}] - Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. * @param {CB_AudioFile} [audioObject] - A {@link CB_AudioFile} object that we want to reuse instead of creating a new one (for performance purposes). * @param {function} [callbackOk] - Function with no parameters that will be called once the {@link CB_AudioFile} object is created and loaded successfully (or after it has been checked successfully, depending on the desired option), being &quot;this&quot; the {@link CB_AudioFileCache} object itself. * @param {function} [callbackError] - Function called when any error is produced during creation, loading or checking process, etc. The unique parameter will be a string describing the error (if it was possible to be determined), being &quot;this&quot; the {@link CB_AudioFileCache} object itself. * @param {boolean} [storeURIsList=false] - If set to true, it will store internally the valid supported &quot;URIs&quot; from the given ones (needed by the {@link CB_AudioFileCache#setAudioAPIAll} method, for example). Internal usage only recommended. * @param {boolean} [checkAutomatically=false] - If set to true (not recommended), it will call the {@link CB_AudioFile#checkPlaying} method automatically. Otherwise, it will perform according to the value set at the {@link CB_AudioFileCache#checkManually} property. Internal usage only recommended. * @returns {CB_AudioFile|null} If it fails, it returns null. Otherwise, returns the {@link CB_AudioFile} that has been created or reused. */ CB_AudioFileCache.prototype.createAudioFile = function(URIs, preferredAPIs, preferredFormats, audioObject, callbackOk, callbackError, storeURIsList, checkAutomatically) { //If the cache has already failed or is aborted, just exits: if (this.status === CB_AudioFileCache.FAILED || this.status === CB_AudioFileCache.ABORTED) { return null; } this.status = CB_AudioFileCache.LOADING; //The cache is loading. //If not given, uses default parameters: if (typeof(URIs) === &quot;undefined&quot; || URIs === null) { URIs = this.URIs; } if (!CB_isArray(preferredAPIs) || preferredAPIs.length === 0 || CB_trim(preferredAPIs.join(&quot;&quot;)) === &quot;&quot;) { preferredAPIs = this.preferredAPIs; } if (!CB_isArray(preferredFormats) || preferredFormats.length === 0 || CB_trim(preferredFormats.join(&quot;&quot;)) === &quot;&quot;) { preferredFormats = this.preferredFormats; } //Filters the audio APIs to just use the supported ones: preferredAPIs = CB_AudioDetector.getSupportedAPIs(preferredAPIs); //If preferredAPIs is empty, throws the error and exits: if (preferredAPIs.length === 0) { this.errorFunction(&quot;No API supported from the provided ones.&quot;); return null; } //Filters the audio formats to just use the supported ones (also orders them with the &quot;probably&quot; ones first): var preferredFormatsSupported = CB_AudioDetector.getSupportedAudioFormats(preferredFormats, [&quot;probably&quot;, &quot;maybe&quot;]); if (preferredFormatsSupported.length &gt; 0) { preferredFormats = preferredFormatsSupported; } //Only uses the filtered ones if there is at least one. else { this.errorFunction(&quot;No format supported from the provided ones.&quot;); return null; } //Filters the URIs given to just use the ones whose format is supported: var URIsList = []; var preferredFormatsLength = preferredFormats.length; var y, URIsListCurrentLength, isDataURI; for (var x = 0; x &lt; preferredFormatsLength; x++) { //If the support format has URIs associated: if (typeof(URIs[preferredFormats[x]]) !== &quot;undefined&quot; &amp;&amp; CB_isArray(URIs[preferredFormats[x]])) { URIsListCurrentLength = URIs[preferredFormats[x]].length; for (y = 0; y &lt; URIsListCurrentLength; y++) { //Only stores it if this kind of URI (data URI or normal one) is supported by the format: if (!CB_isString(URIs[preferredFormats[x]][y])) { continue; } isDataURI = (URIs[preferredFormats[x]][y].substring(0, 5).toLowerCase() === &quot;data:&quot;); if (CB_AudioDetector.isAudioFormatSupported(preferredFormats[x], isDataURI) !== &quot;&quot;) { //Stores the current URI: URIsList[URIsList.length] = URIs[preferredFormats[x]][y++]; } } } } //If there are not URIs supported, throws the error and exits: if (URIsList.length === 0) { this.errorFunction(&quot;No URI supported from the provided ones.&quot;); return null; } else if (storeURIsList) { this._URIsListLast = URIsList; } //Returns the object created: return this._createAudioFileObjectRecursively(URIsList, preferredAPIs, audioObject, callbackOk, callbackError, null, null, null, null, null, checkAutomatically); } //Function that creates an audio file object trying given URIs and given APIs (internal usage only): CB_AudioFileCache.prototype._createAudioFileObjectRecursively = function(URIsList, preferredAPIs, audioObject, callbackOk, callbackError, URIsListIndex, stopAtURIsListIndex, preferredAPIsIndex, stopAtPreferredAPIsIndex, retryNumber, checkAutomatically) { this.status = CB_AudioFileCache.LOADING; //The cache is loading. //If there are not URIs supported, throws the error and exits: if (!CB_isArray(URIsList) || URIsList.length === 0) { this.errorFunction(&quot;The URIs provided are not in an array or its length is 0.&quot;); return null; } //If not given, uses default parameters: if (typeof(URIsListIndex) === &quot;undefined&quot; || URIsListIndex === null || isNaN(URIsListIndex)) { URIsListIndex = 0; } if (typeof(preferredAPIsIndex) === &quot;undefined&quot; || preferredAPIsIndex === null || isNaN(preferredAPIsIndex)) { preferredAPIsIndex = 0; } if (typeof(retryNumber) === &quot;undefined&quot; || retryNumber === null || isNaN(retryNumber)) { retryNumber = 0; } //If it does not exist yet, creates the last succeeded indexes for the given URIs and the given preferred APIs: if (typeof(this._lastSuccededIndexes[URIsList]) === &quot;undefined&quot; || this._lastSuccededIndexes[URIsList] === null) { this._lastSuccededIndexes[URIsList] = {}; } if (typeof(this._lastSuccededIndexes[URIsList][preferredAPIs]) === &quot;undefined&quot; || this._lastSuccededIndexes[URIsList][preferredAPIs] === null) { this._lastSuccededIndexes[URIsList][preferredAPIs] = { &quot;URIsListIndex&quot; : 0, &quot;preferredAPIsIndex&quot; : 0 }; //The first time, starts at the beginning. } //If this is not a recursive call (stopAtURIsListIndex will still not be created): if (typeof(stopAtURIsListIndex) === &quot;undefined&quot; || stopAtURIsListIndex === null) { //We continue from the last succeeded API and last succeeded URI (optimization purposes): URIsListIndex = this._lastSuccededIndexes[URIsList][preferredAPIs][&quot;URIsListIndex&quot;]; preferredAPIsIndex = this._lastSuccededIndexes[URIsList][preferredAPIs][&quot;preferredAPIsIndex&quot;]; //Calculates when we should stop trying to create the object (the last API and last URI we should try): stopAtPreferredAPIsIndex = preferredAPIsIndex; stopAtURIsListIndex = URIsListIndex - 1; if (stopAtURIsListIndex &lt; 0) { stopAtURIsListIndex = URIsList.length - 1; stopAtPreferredAPIsIndex--; if (stopAtPreferredAPIsIndex &lt; 0) { stopAtPreferredAPIsIndex = preferredAPIs.length - 1; } } } var that = this; //Function to call when the object is created successfully: var callbackOkFunction = function() { //Stores the API index and the URI index to use the next time (for optimization purposes): that._lastSuccededIndexes[URIsList][preferredAPIs][&quot;URIsListIndex&quot;] = URIsListIndex; that._lastSuccededIndexes[URIsList][preferredAPIs][&quot;preferredAPIsIndex&quot;] = preferredAPIsIndex; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } }; //Function to call when the object has failed (has not been created): var callbackErrorFunction = function(error) { //If the cache has already failed or is aborted, just exits: if (that.status === CB_AudioFileCache.FAILED || that.status === CB_AudioFileCache.ABORTED) { return; } ///////if (allAttemptsFailed) { return; } //If we have already tried all, throws an error (the status of the cache will be set to FAILED): if (preferredAPIsIndex === stopAtPreferredAPIsIndex &amp;&amp; URIsListIndex === stopAtURIsListIndex &amp;&amp; retryNumber === that.retries) { ///////allAttemptsFailed = true; that.errorFunction(&quot;A new audio object could not be created. All attempts failed. Last message: &quot; + error); if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;A new audio object could not be created. All attempts failed. Last message: &quot; + error); } return; } //...otherwise, continues trying: else { retryNumber++; //Increases the retries counter. //If the current retries are more than the allowed ones, passes to try the next method: if (retryNumber &gt; that.retries) { //Sanitizes the indexes for the next recursive call: URIsListIndex++; URIsListIndex %= URIsList.length; if (URIsListIndex === 0) { preferredAPIsIndex++; preferredAPIsIndex %= preferredAPIs.length; } retryNumber = 0; } //Calls the function again: that._createAudioFileObjectRecursively(URIsList, preferredAPIs, audioObject, callbackOk, callbackError, URIsListIndex, stopAtURIsListIndex, preferredAPIsIndex, stopAtPreferredAPIsIndex, retryNumber, checkAutomatically); //that._createAudioFileObject(URIsList[URIsListIndex], null, preferredAPIs[preferredAPIsIndex], callbackOk, callbackError, audioObject); } }; this._onLoadCalled = false; //Forces to call onLoad function again. audioObject = this._createAudioFileObject(URIsList[URIsListIndex], null, preferredAPIs[preferredAPIsIndex], callbackOkFunction, callbackErrorFunction, audioObject, checkAutomatically); return audioObject; } //Checks and declares whether the cache is completely loaded or not: CB_AudioFileCache.prototype._checkCacheLoaded = function(objectsNeedChecking) { clearTimeout(this._checkCacheLoadedTimeout); //If the method checkPlayingAll is executing, exits: if (this._checkingPlaying || this._settingAPI) { return; } //If the cache has failed or has been aborted or it is already loaded, just exits: if (this.status === CB_AudioFileCache.FAILED || this.status === CB_AudioFileCache.ABORTED || this.status === CB_AudioFileCache.LOADED) { return; } //Clears the array of the AudioFiles: this.clearAudioFiles(true); if (typeof(objectsNeedChecking) === &quot;undefined&quot; || objectsNeedChecking === null || isNaN(objectsNeedChecking) || objectsNeedChecking &lt; 0) { objectsNeedChecking = 0; } //If we don't need more objects, the cache is LOADED: if (this.audioFilesCreated &gt;= this.minimumAudioFiles || this.checkManually &amp;&amp; this.audioFilesCreated + objectsNeedChecking &gt;= this.minimumAudioFiles) { //Sets the cache status as loaded: //this.status = CB_AudioFileCache.LOADED; this.status = (objectsNeedChecking &gt; 0) ? CB_AudioFileCache.UNCHECKED : CB_AudioFileCache.LOADED; //If we have not called the onLoad function, calls the onLoad function (if any): if (!this._onLoadCalled &amp;&amp; typeof(this.onLoad) === &quot;function&quot;) { this._onLoadCalled = true; this.onLoad.call(this, objectsNeedChecking); } } } //Function that creates an audio file (internal usage only): CB_AudioFileCache.prototype._createAudioFileObject = function(filePath, audioId, audioAPI, callbackOk, callbackError, audioObject, checkAutomatically) { this.status = CB_AudioFileCache.LOADING; //The cache is loading. //If there is a limit and we have already reached the maximum of objects allowed, throws an error: if (typeof(this.maximumAudioFiles) !== &quot;undefined&quot; &amp;&amp; this.maximumAudioFiles !== null &amp;&amp; !isNaN(this.maximumAudioFiles) &amp;&amp; this.maximumAudioFiles &gt;= 1) { if (this.audioFilesCreated &gt;= this.maximumAudioFiles) { this.errorFunction(&quot;A new object cannot be created. Maximum (&quot; + this.maximumAudioFiles + &quot;) reached.&quot;); return null; } } var that = this; //Defines the function to call when the audio object is created successfully: var callbackOkFunction = function() { //If the sound needs to be checked, checks it and calls the function again if all is fine: if ((!that.checkManually || checkAutomatically) &amp;&amp; audioObject.getStatus() === CB_AudioFile.UNCHECKED) { audioObject.checkPlaying(callbackOkFunction, callbackErrorFunction, false, false, true); return; } //Clears the array of the AudioFiles: that.clearAudioFiles(); var audioFilesIndex = that.audioFiles.length; //If the object already exists, gets its index in the array: if (CB_indexOf(that._existingObjectIds, audioObject.id) !== -1) { //Search the object in the array: var audioFilesLength = that.audioFiles.length; var indexFound = false; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object is defined and not null: if (typeof(that.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; that.audioFiles[x] !== null) { //If the object ID is the same as the current one: if (typeof(that.audioFiles[x].id) !== &quot;undefined&quot; &amp;&amp; that.audioFiles[x].id === audioObject.id) { //Gets its index and exists the bucle: audioFilesIndex = x; indexFound = true; //Exists the bucle: break; } } } //The object already existed but could not be found (which means it has been deleted by the Error function), so exits: //if (!indexFound) { return; } //Avoids calling the Ok function if the Error function has already been called. } //Stores the object ID to the existing ones: that._existingObjectIds[that._existingObjectIds.length] = audioObject.id; //Inserts the object into the array: that.audioFiles[audioFilesIndex] = audioObject; //The new object is free so we insert its index in the stack for free elements: that.audioFilesFree[++that.audioFilesFreePointer] = audioFilesIndex; //Also increases the pointer. //Increases the counter of the objects created: that.audioFilesCreated++; //Clears the array of the AudioFiles: that.clearAudioFiles(); //If we don't need more objects, we will check again after some time (before declaring the cache as LOADED) because some objects can still fire onerror (specially with SM2): /* clearTimeout(that._checkCacheLoadedTimeout); //Stops the previous timeout to check whether the cache is loaded (if any). if (that.audioFilesCreated &gt;= that.minimumAudioFiles) { that._checkCacheLoadedTimeout = setTimeout(function() { that._checkCacheLoaded.call(that); }, that._checkCacheLoadedTimeoutMs); } */ //Stores the minimum and maximum duration found: var duration = audioObject.getDuration(); if (duration &gt; 0 &amp;&amp; (that.duration === 0 || duration &lt; that.duration)) { that.duration = duration; } if (duration &gt; that.durationMaximum) { that.durationMaximum = duration; } //Calls the given OK function (if any): if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that); } }; //Defines the function to call when the audio object could not be created (failed): var callbackErrorFunction = function(error) { //Clears the array of the AudioFiles: that.clearAudioFiles(); //If the object was already stored in the array (already existed): if (CB_indexOf(that._existingObjectIds, audioObject.id) !== -1) { //Finds its index in the array: var audioFilesLength = that.audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object is defined and not null: if (typeof(that.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; that.audioFiles[x] !== null) { //If the object ID is the same as the current one: if (typeof(that.audioFiles[x].id) !== &quot;undefined&quot; &amp;&amp; that.audioFiles[x].id === audioObject.id) { //Deletes the object from the array: that.audioFiles[x] = null; //This object should not count as created anymore: that.audioFilesCreated--; //Clears the array of the AudioFiles: that.clearAudioFiles(); //Exists the bucle: break; } } } } //Stores the object ID to the existing ones: that._existingObjectIds[that._existingObjectIds.length] = audioObject.id; //Calls the given error function (if any): if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error); } }; //If it does not exist yet, tries to create the object: if (typeof(audioObject) === &quot;undefined&quot; || audioObject === null) { this.DEFAULT_VOLUME = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; audioObject = new CB_AudioFile ( filePath, //filePath. null, //audioId. { autoLoad: true, autoPlay: false, loop: false, volume: CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING ? 0 : this.DEFAULT_VOLUME }, //options (volume is zero to prevent hearing the sound in some web clients). audioAPI, //audioAPI. callbackOkFunction, //callbackOk. callbackErrorFunction //callbackError. ); } //...otherwise, if the object already exists, loads it again with the new desired options: else { //audioObject.setVolume(0); //Sets volume to zero to prevent hearing the sound in some web clients. if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { audioObject.mute(); } //Sets volume to zero to prevent hearing the sound in some web clients. audioObject.load ( filePath, //filePath. audioAPI, //audioAPI. false, //autoPlay. callbackOkFunction, //callbackOk. callbackErrorFunction, //callbackError. true //ignoreOldValues. ); } return audioObject; } /** * Cleans the array of the {@link CB_AudioFile} objects (taking off the undefined or null ones) which is in the {@link CB_AudioFileCache#audioFiles} property, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Internal usage only recommended. * @function * @param {boolean} [avoidCallingCheckCacheLoaded=false] - If set to false and neither the {@link CB_AudioFileCache#checkPlayingAll} nor the {@link CB_AudioFileCache#setAudioAPIAll} methods are being executed, it will call the {@link CB_AudioFileCache#_checkCacheLoaded} internal method which will call the &quot;onLoad&quot; function defined in the {@link CB_AudioFileCache#onLoad} property if the number of needed {@link CB_AudioFile} objects has been reached (after performing the cleaning process). Internal usage only recommended. * @returns {array} Returns the value of the {@link CB_AudioFileCache#audioFiles} property. */ CB_AudioFileCache.prototype.clearAudioFiles = function(avoidCallingCheckCacheLoaded) { clearTimeout(this._clearAudioFilesTimeout); var audioFilesClean = []; var audioFilesFree = []; var audioFilesFreePointer = -1; var existingIDs = []; var someChecking = false; var audioFilesLength = this.audioFiles.length; var y = 0; var objectsLoaded = 0; var objectsNeedChecking = 0; var duration = 0; var durationMaximum = 0; var durationCurrent = 0; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object is defined and not null: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { //If the object status exists (it means it is a real CB_AudioFile object): if (typeof(this.audioFiles[x].getStatus) !== &quot;undefined&quot;) { //If the object is LOADED, LOADING or CHECKING or UNCHECKED, we keep it: if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED || this.audioFiles[x].getStatus() === CB_AudioFile.LOADING || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING || this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED) { //Only adds if it has not been added before: if (CB_indexOf(existingIDs, this.audioFiles[x].id) === -1) { audioFilesClean[y] = this.audioFiles[x]; existingIDs[y++] = this.audioFiles[x].id; //If the object is still unchecked or checking, we will wait for it: if (this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING || this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED) { objectsNeedChecking++; someChecking = true; } //...otherwise, if it is LOADED, or its LOADING but its internal object is LOADED (it happens when changing API): else if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED || this.audioFiles[x].getStatus() === CB_AudioFile.LOADING &amp;&amp; this.audioFiles[x].getStatus(true) === CB_AudioFile.LOADED) //|| this.checkManually &amp;&amp; (this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING) //, or we want to check manually and it is UNCHECKED or CHECKING, increases the counter for loaded objects { objectsLoaded++; //If the sound is not playing, it is a free object: if (!this.audioFiles[x].isPlaying()) { audioFilesFree[++audioFilesFreePointer] = x; //Stores the position of the object in the array. } durationCurrent = this.audioFiles[x].getDuration(); if (durationCurrent &gt; 0 &amp;&amp; (duration === 0 || durationCurrent &lt; duration)) { duration = durationCurrent; } if (durationCurrent &gt; durationMaximum) { durationMaximum = durationCurrent; } } } } //...otherwise, just destroy it: else { this.audioFiles[x].destructor(true, false, true); //Also stops it and avoids firing its onStop. this.audioFiles[x] = null; } } } } //Sets the real audio files created: this.audioFilesCreated = objectsLoaded; this.audioFiles = audioFilesClean; //Stores the new clean array. this.audioFilesFree = audioFilesFree; //Stores the free objects encountered. this.audioFilesFreePointer = audioFilesFreePointer; //Stores the pointer for the array of the free objects. //Stores the minimum and maximum duration found: this.duration = duration; this.durationMaximum = durationMaximum; var that = this; if (!avoidCallingCheckCacheLoaded &amp;&amp; !this._checkingPlaying &amp;&amp; !this._settingAPI) //Avoids calling the function if checkPlayingAll or setAudioAPIAll are being executed. { clearTimeout(this._checkCacheLoadedTimeout); //Stops the previous timeout to check whether the cache is loaded (if any). //If minimum objects are loaded or we are using manual checkingn and minimum objects are loaded or unchecked/checking: if (this.audioFilesCreated &gt;= this.minimumAudioFiles || this.checkManually &amp;&amp; this.audioFilesCreated + objectsNeedChecking &gt;= this.minimumAudioFiles) { //Calls the function to check whether the cache is loaded or not: this._checkCacheLoadedTimeout = setTimeout(function() { that._checkCacheLoaded.call(that, objectsNeedChecking); }, this._checkCacheLoadedTimeoutMs); } } //If some were checking, calls the function again after some time: if (!this.checkManually &amp;&amp; someChecking) { this._clearAudioFilesTimeout = setTimeout ( function() { that.clearAudioFiles.call(that); }, 1 ); } return this.audioFiles; } /** * If found, takes a given {@link CB_AudioFile} object off the {@link CB_AudioFileCache#audioFiles} property (and reloads it if we want to). NOTE: It does neither destroy nor remove the {@link CB_AudioFile} object so it can be used for other purposes (and if a {@link CB_AudioFile} object is given, it will be tried to be reused by the {@link CB_AudioFileCache#createAudioFile} method internally if it is called). Internal usage only recommended. * @function * @param {CB_AudioFile|string} audioObjectOrId - The {@link CB_AudioFile} object or a string with its identifier (not case sensitive) that we want to remove from the {@link CB_AudioFileCache#audioFiles} property. If a {@link CB_AudioFile} object is given, its {@link CB_AudioFile#id} property (which should be unique always) must be set as it is used to identify the object. NOTE: It does neither destroy nor remove the {@link CB_AudioFile} object so it can be used for other purposes (and if a {@link CB_AudioFile} object is given, it will be tried to be reused by the {@link CB_AudioFileCache#createAudioFile} method internally if it is called). * @param {boolean} [reload=false] - If it is set to true, the {@link CB_AudioFileCache#createAudioFile} method will be called automatically at the end of the process. If a {@link CB_AudioFile} object has been given (through the &quot;audioObjectOrId&quot; parameter) or found by its identifier, it will be tried to be reused by the {@link CB_AudioFileCache#createAudioFile} method (as its &quot;audioObject&quot; parameter). * @param {boolean} [checkManually=false] - Only used when the &quot;reload&quot; parameter is set to true, to calculate the &quot;checkAutomatically&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @returns {boolean|CB_AudioFile|null} Returns null if the given &quot;audioObjectOrId&quot; parameter is not a valid {@link CB_AudioFile} object or its {@link CB_AudioFile#id} property is not set or when the &quot;audioObjectOrId&quot; parameter is an empty string. Returns a {@link CB_AudioFile} object, the given one through the &quot;audioObjectOrId&quot; parameter of the first one removed (it should be the first and unique one removed as the ID must be unique), if the {@link CB_AudioFileCache#createAudioFile} method is called internally (it will reuse this {@link CB_AudioFile} object). Otherwise, returns true if the number of internal {@link CB_AudioFile} objects (inside the {@link CB_AudioFileCache#audioFiles} property) has decreased or false otherwise. * @todo Think about calling the {@link CB_AudioFileCache#createAudioFile} method internally (when the &quot;reload&quot; parameter is set to true) only when the {@link CB_AudioFile} object has been found and removed from the {@link CB_AudioFileCache#audioFiles} property. */ CB_AudioFileCache.prototype.removeAudioFile = function(audioObjectOrId, reload, checkManually) { if (typeof(audioObjectOrId) === &quot;undefined&quot; || audioObjectOrId === null) { return null; } if (!(audioObjectOrId instanceof CB_AudioFile)) { //If a string or number is given, it will be assumed that it is the &quot;id&quot; desired: if (CB_isString(audioObjectOrId) || !isNaN(audioObjectOrId)) { audioObjectOrId = { &quot;id&quot; : audioObjectOrId + &quot;&quot; }; } else { return null; } } var id = CB_trim(audioObjectOrId.id).toUpperCase(); if (id === &quot;&quot;) { return null; } //Looks through the array of the objects: var audioFilesNew = []; var audioFilesFree = []; var audioFilesFreePointer = -1; var objectsLoaded = 0; var audioFilesLength = this.audioFiles.length; var duration = 0; var durationMaximum = 0; var durationCurrent = 0; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object exists: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { //If the object does not have the desired ID: if (typeof(this.audioFiles[x].id) !== &quot;undefined&quot;) { //If it is not the desired id, stores it in the new array: //if (CB_trim(this.audioFiles[x].id).toUpperCase() !== id) if (this.audioFiles[x].id !== id) { audioFilesNew[audioFilesNew.length] = this.audioFiles[x]; //If it is LOADED or its LOADING but its internal object is LOADED (it happens when changing API): if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED || this.audioFiles[x].getStatus() === CB_AudioFile.LOADING &amp;&amp; this.audioFiles[x].getStatus(true) === CB_AudioFile.LOADED) { objectsLoaded++; //Increases the counter of files loaded (files successfully created). //If it is not playing, the sound is free: if (!this.audioFiles[x].isPlaying()) { audioFilesFree[++audioFilesFreePointer] = x; //Stores the position of the object in the array. } } } //...else, if the CB_AudioFile object has been found and the &quot;audioObjectOrId&quot; is not a CB_AudioFile object (as for example if the &quot;audioObjectOrId&quot; parameter was a string with the id instead of a CB_AudioFile object): else if (!(audioObjectOrId instanceof CB_AudioFile)) { audioObjectOrId = this.audioFiles[x]; } //Stores it to call the &quot;this.createAudioFile&quot; method later (if we want to). //Stores the minimum and maximum duration found: durationCurrent = this.audioFiles[x].getDuration(); if (durationCurrent &gt; 0 &amp;&amp; (duration === 0 || durationCurrent &lt; duration)) { duration = durationCurrent; } if (durationCurrent &gt; durationMaximum) { durationMaximum = durationCurrent; } } } } //Sets the real audio files created: this.audioFilesCreated = objectsLoaded; //Replaces the audio files array with the new one (which should lacks of the id we wanted to remove): this.audioFiles = audioFilesNew; //Replaces the array of the free audio files and its pointer: this.audioFilesFree = audioFilesFree; //Stores the free objects encountered. this.audioFilesFreePointer = audioFilesFreePointer; //Stores the pointer for the array of the free objects. //Stores the minimum and maximum duration found: this.duration = duration; this.durationMaximum = durationMaximum; //Returns whether the number of internal CB_AudioFile objects has decreased or not: var returningValue = (this.audioFiles.length &lt; audioFilesLength); //If we want to reload the sound, we reload it (and will be returned): if (reload) { returningValue = this.createAudioFile(null, null, null, audioObjectOrId instanceof CB_AudioFile ? audioObjectOrId : null, null, null, null, !checkManually); } //Uses the same audio object. return returningValue; } //Removes objects with a given status from the cache until reach a desired number (if able): CB_AudioFileCache.prototype._purgeObjectsStatus = function(desiredNumber, status, includePlaying, stopSounds) { if (typeof(desiredNumber) === &quot;undefined&quot; || desiredNumber === null || isNaN(desiredNumber) || desiredNumber &lt;= 0) { return 0; } this.clearAudioFiles(true); var audioFilesLength = this.audioFiles.length; var existingObjects = audioFilesLength; if (existingObjects &lt;= this.minimumAudioFiles || existingObjects &lt;= desiredNumber) { return 0; } //First, removes not playing ones: for (var x = 0; x &lt; audioFilesLength &amp;&amp; existingObjects !== desiredNumber; x++) { //If the object exists and has the desired status, removes it: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { if (this.audioFiles[x].getStatus() === status) { if (!this.audioFiles[x].isPlaying()) { this.audioFiles[x].destructor(stopSounds, false, true); //Avoids firing onStop. this.audioFiles[x] = null; existingObjects--; } } } } //Secondly, removes playing ones (if we want to): if (includePlaying) { for (x = 0; x &lt; audioFilesLength &amp;&amp; existingObjects !== desiredNumber; x++) { //If the object exists and has the desired status, removes it: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { if (this.audioFiles[x].getStatus() === status) { this.audioFiles[x].destructor(stopSounds, false, true); //Avoids firing onStop. this.audioFiles[x] = null; existingObjects--; } } } } this.clearAudioFiles(true); return audioFilesLength - existingObjects; } /** * Tries to purge the audio file cache until it reaches a desired number of {@link CB_AudioFile} objects internally (set in the {@link CB_AudioFileCache#audioFiles} property), by removing and destroying some of the current {@link CB_AudioFile} objects. For performance purposes. * @function * @param {integer} desiredNumber - The desired number of internal {@link CB_AudioFile} objects that we want to keep in the {@link CB_AudioFileCache#audioFiles} property. It mus be 1 or greater. * @param {boolean} [setAsMinimumAudioFiles=false] - If set to true, it will set the value of the &quot;desiredNumber&quot; parameter to the {@link CB_AudioFileCache#minimumAudioFiles} property (only when there is a maximum defined in {@link CB_AudioFileCache#maximumAudioFiles}). * @param {boolean} [includePlaying=false] - If it is set to true and removing non-playing {@link CB_AudioFile} objects was not enough to reach the desired number (defined in the &quot;desiredNumber&quot; parameter), it will also try to remove objects which are being playing currently. * @param {boolean} [stopSounds=false] - Used as the &quot;stopSound&quot; parameter when calling the {@link CB_AudioFile#destructor} method of each {@link CB_AudioFile} object removed. * @param {array} [statuses=Array({@link CB_AudioFile.LOADING}, {@link CB_AudioFile.UNCHECKED}, {@link CB_AudioFile.CHECKING}, {@link CB_AudioFile.LOADED})] - Numeric array containing the statuses of the {@link CB_AudioFile} objects that we want this method to authorize to remove. This means that if the returning value of the {@link CB_AudioFile#getStatus} method of a {@link CB_AudioFile} object is not in this list, it will not be tried to be removed (unless they end removed by the {@link CB_AudioFileCache#clearAudioFiles} method called internally). Have in mind that this method will call the {@link CB_AudioFileCache#clearAudioFiles} method internally, which destroys the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returns {@link CB_AudioFile.ABORTED} and {@link CB_AudioFile.FAILED}, so these two statuses need not be indicated. It will respect the order given. Possible values for this array are: {@link CB_AudioFile.UNLOADED}, {@link CB_AudioFile.LOADING}, {@link CB_AudioFile.UNCHECKED}, {@link CB_AudioFile.CHECKING}, {@link CB_AudioFile.LOADED}, {@link CB_AudioFile.FAILED} and {@link CB_AudioFile.ABORTED}. * @returns {integer} Returns the number of {@link CB_AudioFile} objects removed. */ CB_AudioFileCache.prototype.purge = function(desiredNumber, setAsMinimumAudioFiles, includePlaying, stopSounds, statuses) { desiredNumber = parseInt(CB_trim(desiredNumber)); if (desiredNumber === &quot;&quot; || isNaN(desiredNumber)) { return 0; } desiredNumber = parseInt(desiredNumber); if (desiredNumber &lt;= 0) { return 0; } if (setAsMinimumAudioFiles &amp;&amp; (typeof(this.maximumAudioFiles) === &quot;undefined&quot; || this.maximumAudioFiles === null || isNaN(this.maximumAudioFiles) || this.maximumAudioFiles === 0 || desiredNumber &lt;= this.maximumAudioFiles)) { this.minimumAudioFiles = desiredNumber; } var objectsRemoved = 0; if (typeof(statuses) === &quot;undefined&quot; || statuses === null || !CB_isArray(statuses) || statuses.length &lt;= 0) { statuses = [ CB_AudioFile.LOADING, CB_AudioFile.UNCHECKED, CB_AudioFile.CHECKING, CB_AudioFile.LOADED ]; //this._purgeObjectStatus will call clearAudioFiles which destroys ABORTED and FAILED. } var statusesLength = statuses.length; for (var x = 0; x &lt; statusesLength; x++) { objectsRemoved += this._purgeObjectsStatus(desiredNumber, statuses[x], includePlaying, stopSounds); if (this.audioFiles.length &lt;= desiredNumber) { break; } } return objectsRemoved; } //Creates a new audio file if neeed: CB_AudioFileCache.prototype._createNewAudioFilesIfNeeded = function() { //If we don't want to create any new file, just exists: if (this.newAudioFilesWhenNeeded &lt;= 0) { return; } //If it is not LOADED, exits: if (this.status !== CB_AudioFileCache.LOADED) { return; } //If there is not a minimum limit set, just exits: if (typeof(this.minimumAudioFilesFree) === &quot;undefined&quot; || this.minimumAudioFilesFree === null || isNaN(this.minimumAudioFilesFree)) { return; } //If we have reached the minimum, creates new ones: //if (this.audioFilesFreePointer + 1 &lt;= this.minimumAudioFilesFree) //Pointer starts with 0. if (this.audioFilesFreePointer &lt; this.minimumAudioFilesFree) //Pointer starts with 0. { var filesCreated = 0; var filesAlreadyCreated = 0; //Counts LOADED, LOADING, UNCHECKED and CHECKING as already created ones (in order not to create more than needed): var audioFilesLength = this.audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object exists: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { //if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADING || this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING) //If it is still LOADED or LOADING but its internal object is LOADED (would happen when changing API), marks the object as free and increments the pointer: if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED || this.audioFiles[x].getStatus() === CB_AudioFile.LOADING &amp;&amp; this.audioFiles[x].getStatus(true) === CB_AudioFile.LOADED) { filesAlreadyCreated++; } else if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADING || this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING) { filesCreated++; } } } /* if (this.status !== CB_AudioFileCache.LOADED) { if (typeof(this.maximumAudioFiles) === &quot;undefined&quot; || this.maximumAudioFiles === null || this.audioFilesCreated + filesCreated &lt; this.maximumAudioFiles) { if (filesCreated &lt; this.newAudioFilesWhenNeeded) { var that = this; setTimeout(function() { that._createNewAudioFilesIfNeeded.call(that); }, 1); } } return; } */ //Creates the needed files (if any): while (typeof(this.maximumAudioFiles) === &quot;undefined&quot; || this.maximumAudioFiles === null || isNaN(this.maximumAudioFiles === null) || this.maximumAudioFiles === 0 || filesAlreadyCreated + filesCreated &lt; this.maximumAudioFiles) { //Only creates a new file if there is no maximum or it it has not been reached yet: if (filesCreated &lt; this.newAudioFilesWhenNeeded) { this.createAudioFile(null, null, null, null, null, null, null, !this.checkManuallyOnNeededCreated); filesCreated++; } else { break; } } } } /** * Object returned by the {@link CB_AudioFileCache#getFreeAudioFile} method. * @memberof CB_AudioFileCache * @typedef {Object} CB_AudioFileCache.getFreeAudioFile_OBJECT * @property {CB_AudioFile|null} object - Contains the {@link CB_AudioFile} object if found or null otherwise. * @property {string|integer} index - Contains the position of the {@link CB_AudioFile} object inside the {@link CB_AudioFileCache#audioFiles} property if found or &quot;-1&quot; otherwise. */ /** * Returns a free {@link CB_AudioFile} object, if any (from the {@link CB_AudioFileCache#audioFilesFree} property). Note that this will call the internal {@link CB_AudioFileCache#_createNewAudioFilesIfNeeded} method that could end creating a new {@link CB_AudioFile} object if needed. * @function * @param {boolean} [popIt=false] - If set to true, the {@link CB_AudioFile} object will also be &quot;popped&quot; (removed) from the {@link CB_AudioFileCache#audioFilesFree} property. * @returns {CB_AudioFileCache.getFreeAudioFile_OBJECT} Returns a {@link CB_AudioFileCache.getFreeAudioFile_OBJECT} object. */ CB_AudioFileCache.prototype.getFreeAudioFile = function(popIt) { var that = this; //If there is a free object, just returns it: if (this.audioFilesFreePointer &gt; -1) { //Sets the onStop function (which will mark the sound as free) for the object: var audioFilesIndex = this.audioFilesFree[this.audioFilesFreePointer]; var audioObject = this.audioFiles[audioFilesIndex]; //If we want, pops the element from the array of the free objects: if (popIt) { //Note: Indeed, setting it to null is not needed because we should only care about the elements before the pointer. this.audioFilesFree[this.audioFilesFreePointer--] = null; //Also decreases the pointer. } //Calls the function which creates new objects if needed: ////////clearTimeout(this._createNewAudioFilesIfNeededTimeout); this._createNewAudioFilesIfNeededTimeout = setTimeout(function() { that._createNewAudioFilesIfNeeded.call(that); }, 1); //Returns the object: return { &quot;object&quot; : audioObject, &quot;index&quot; : audioFilesIndex }; } //Calls the function which creates new objects if needed: ////////clearTimeout(this._createNewAudioFilesIfNeededTimeout); this._createNewAudioFilesIfNeededTimeout = setTimeout(function() { that._createNewAudioFilesIfNeeded.call(that); }, 1); //If there is no free object, returns null: return { &quot;object&quot; : null, &quot;index&quot; : -1 }; } /** * Tells the position of a desired {@link CB_AudioFile} object (by its identifier) in the {@link CB_AudioFileCache#audioFiles} property or -1 otherwise. * @function * @param {string} id - The identifier of the {@link CB_AudioFile} object (belongs to its {@link CB_AudioFile#id} property) whose position we want to find. Note that the identifier is not case sensitive and it should be unique for each object. * @returns {integer} Returns the position of a desired {@link CB_AudioFile} object (by its identifier) in the {@link CB_AudioFileCache#audioFiles} property or -1 otherwise. */ CB_AudioFileCache.prototype.getAudioFilePosition = function(id) { id = CB_trim(id).toUpperCase(); //id = (&quot;&quot; + id).toUpperCase(); if (id === &quot;&quot;) { return -1; } //Looks through the array of the objects: var audioFilesLength = this.audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object exists: if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { //If the object has the desired ID: //if (typeof(this.audioFiles[x].id) !== &quot;undefined&quot; &amp;&amp; CB_trim(this.audioFiles[x].id).toUpperCase() === id) if (typeof(this.audioFiles[x].id) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x].id === id) { return x; //The &quot;x&quot; is the position. There should be only one with that ID (ID should be unique), so we can exit now. } } } return -1; } /** * Tells whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. * @function * @param {string} id - The identifier of the {@link CB_AudioFile} object (belongs to its {@link CB_AudioFile#id} property) that we want to check. Note that the identifier is not case sensitive and it should be unique for each object. * @returns {boolean} Returns whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. */ CB_AudioFileCache.prototype.isAudioFileFree = function(id) { var position = this.getAudioFilePosition(id); if (position === -1) { return false; } return this.isAudioFileFreeByPosition(position); } /** * Tells whether a given numeric position of a {@link CB_AudioFile} object in the {@link CB_AudioFileCache#audioFiles} property is stored in the {@link CB_AudioFileCache#audioFilesFree} property or not (this means that the {@link CB_AudioFile} object in that position of the {@link CB_AudioFileCache#audioFiles} property is free). A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. * @function * @param {integer} position - Position of the {@link CB_AudioFile} object in the {@link CB_AudioFileCache#audioFiles} property that we want to check whether it is in the {@link CB_AudioFileCache#audioFilesFree} property or not. * @returns {boolean} Returns whether the given numeric position of a {@link CB_AudioFile} object in the {@link CB_AudioFileCache#audioFiles} property is stored in the {@link CB_AudioFileCache#audioFilesFree} property or not (this means that the {@link CB_AudioFile} object in that position of the {@link CB_AudioFileCache#audioFiles} property is free). A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. */ CB_AudioFileCache.prototype.isAudioFileFreeByPosition = function(position) { //Looks through the array of the free objects: for (var x = 0; x &lt;= this.audioFilesFreePointer; x++) { if (typeof(this.audioFilesFree[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFilesFree[x] === position) { return true; } } return false; } //Calls play method play again (in the case it has failed) if the delay is not more than the allowed one: CB_AudioFileCache.prototype._callRecursivelyIfNotTooLate = function(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject) { ////////if (this._callRecursivelyIfNotTooLateCalled) { return null; } ///////this._callRecursivelyIfNotTooLateCalled = true; if (_callRecursivelyIfNotTooLateCalledObject.called) { return null; } _callRecursivelyIfNotTooLateCalledObject.called = true; //Finds out the duration of the track: var startAtReal = startAtOriginal; var stopAtReal = stopAt; if (CB_trim(startAtReal) === &quot;&quot;) { startAtReal = 0; } if (CB_trim(stopAtReal) === &quot;&quot;) { stopAtReal = 0; } startAtReal = parseFloat(startAtReal); stopAtReal = parseFloat(stopAtReal); if (startAtReal &lt; 0) { startAtReal = 0; } if (stopAtReal &lt;= 0 || stopAtReal &gt; this.duration) { stopAtReal = this.duration; } if (startAtReal &gt; stopAtReal || isNaN(startAtReal)) { startAtReal = stopAtReal; } var durationReal = stopAtReal - startAtReal; //If the recursive delay is not null and is a valid number: if (typeof(allowedRecursiveDelay) === &quot;undefined&quot; || allowedRecursiveDelay === null || isNaN(allowedRecursiveDelay) || allowedRecursiveDelay &lt; 0) { allowedRecursiveDelay = CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT; //We use default value. } if (typeof(allowedRecursiveDelaySkipping) === &quot;undefined&quot; || allowedRecursiveDelaySkipping === null || isNaN(allowedRecursiveDelaySkipping) || allowedRecursiveDelaySkipping &lt; 0) { //////allowedRecursiveDelaySkipping = this.duration - startAtOriginal; //We use duration as default value. allowedRecursiveDelaySkipping = durationReal; //We use duration as default value. //Apply margins (because some web clients have problems to play files near their end): //if (allowedRecursiveDelaySkipping &gt; 500) { allowedRecursiveDelaySkipping -= 500; } //else if (allowedRecursiveDelaySkipping &gt; 100) { allowedRecursiveDelaySkipping -= 100; } //else if (allowedRecursiveDelaySkipping &gt; 10) { allowedRecursiveDelaySkipping -= 10; } } var timeNow = CB_Device.getTiming(); var timeExpired = timeNow - startPlayingTime; //If it is a loop, it should be played always, so we allow any expired time: if (loop) { timeExpired %= durationReal; } var that = this; //If the time expired is less or equal to the delay allowed: if (timeExpired &lt;= allowedRecursiveDelay) { //Calls the function again: setTimeout ( function() { that.play.call(that, startAtOriginal, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); }, 1 ); return true; } //...otherwise, if the time expired is less or equal to the allowed recursive delay to play skipping: else if (timeExpired &lt;= allowedRecursiveDelaySkipping) { startAtOriginal = parseFloat(startAtOriginal); //Calls the function again: setTimeout ( function() { that.play.call(that, startAtOriginal + timeExpired, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); }, 1 ); return true; } return null; } /** * Clears the sound instances (created by the {@link CB_AudioFileCache#play} method) which have been cancelled. * @function * @param {boolean} [clearWithObjectAssociated=false] - If set to true, it will also clear the sound instances which have a {@link CB_AudioFile} object associated. * @returns {integer} Returns the number of cleared sound instances. */ CB_AudioFileCache.prototype.clearSoundInstances = function(clearWithObjectAssociated) { var totalBefore = 0; var kept = 0; var soundInstancesQueuedNew = {}; for (var soundInstanceId in this.soundInstancesQueued) { totalBefore++; if (typeof(this.soundInstancesQueued[soundInstanceId]) !== &quot;undefined&quot;) { //If it has not been cancelled or we do not want to clear with associated object and it has an object associated, we keep it: if (typeof(this.soundInstancesQueued[soundInstanceId].cancelled) === &quot;undefined&quot; || !this.soundInstancesQueued[soundInstanceId].cancelled || !clearWithObjectAssociated &amp;&amp; typeof(this.soundInstancesQueued[soundInstanceId].object) !== &quot;undefined&quot; &amp;&amp; this.soundInstancesQueued[soundInstanceId].object !== null) { kept++; soundInstancesQueuedNew[soundInstanceId] = this.soundInstancesQueued[soundInstanceId]; } } } this.soundInstancesQueued = soundInstancesQueuedNew; return totalBefore - kept; } /** * Cancels (to prevent they start playing) or enables all sound instances (created by the {@link CB_AudioFileCache#play} method). * @function * @param {boolean} [cancel=false] - Defines whether we want to cancel them or enable them. * @param {boolean} [affectWithObjectAssociated=false] - If set to true, it will also affect the sound instances which have a {@link CB_AudioFile} object associated. * @returns {integer} Returns the number of sound instances modified. */ CB_AudioFileCache.prototype.cancelSoundInstances = function(cancel, affectWithObjectAssociated) { var performed = 0; for (var soundInstanceId in this.soundInstancesQueued) { if (this.cancelSoundInstance(soundInstanceId, cancel, affectWithObjectAssociated)) { performed++; } } return performed; } /** * Cancels (to prevent it starts playing) or enables a sound instance (created by the {@link CB_AudioFileCache#play} method), by its identifier. * @function * @param {integer} soundInstanceId - The identifier (integer) of the sound instance we want to affect. * @param {boolean} [cancel=false] - Defines whether we want to cancel it or enable it. * @param {boolean} [affectWithObjectAssociated=false] - If set to true, it will also affect the sound instance even it has a {@link CB_AudioFile} object associated. * @returns {boolean} Returns true if the sound instance has been modified or false otherwise. */ CB_AudioFileCache.prototype.cancelSoundInstance = function(soundInstanceId, cancel, affectWithObjectAssociated) { //If the sound instance exists and the setting given is not already being used, sets it and returns true: cancel = !!cancel; if (typeof(this.soundInstancesQueued[soundInstanceId]) !== &quot;undefined&quot; &amp;&amp; typeof(this.soundInstancesQueued[soundInstanceId].cancelled) !== &quot;undefined&quot; &amp;&amp; this.soundInstancesQueued[soundInstanceId].cancelled !== cancel) { if (affectWithObjectAssociated || typeof(this.soundInstancesQueued[soundInstanceId].object) === &quot;undefined&quot; || this.soundInstancesQueued[soundInstanceId].object === null) { this.soundInstancesQueued[soundInstanceId].cancelled = cancel; return true; } } return false; } /** * Gets the {@link CB_AudioFile} object associated to a given sound instance ID (created by the {@link CB_AudioFileCache#play} method), if any, or null otherwise. * @function * @param {integer} soundInstanceId - The identifier (integer) of the sound instance we want to get. * @param {boolean} [avoidCancelled=false] - If set to true, it will not return the {@link CB_AudioFile} object if its sound instance has been cancelled. * @returns {CB_AudioFile|null} Returns the {@link CB_AudioFile} object associated to a given sound instance ID, if any, or null otherwise. */ CB_AudioFileCache.prototype.getAudioFileBySoundInstanceId = function(soundInstanceId, avoidCancelled) { //If the sound instance ID has an object associated: if (typeof(this.soundInstancesQueued[soundInstanceId]) !== &quot;undefined&quot; &amp;&amp; typeof(this.soundInstancesQueued[soundInstanceId].object) !== &quot;undefined&quot;) { if (!avoidCancelled || typeof(this.soundInstancesQueued[soundInstanceId].cancelled) === &quot;undefined&quot; || !this.soundInstancesQueued[soundInstanceId].cancelled) { return this.soundInstancesQueued[soundInstanceId].object; } } return null; } //Function to execute when a sound stops: CB_AudioFileCache.prototype._onStopDefaultFunction = function(indexObject, thisObject, statusBefore, soundInstanceId, functionWhenError) { var wasCancelled = false; if (typeof(soundInstanceId) !== &quot;undefined&quot; &amp;&amp; soundInstanceId !== null) { if (typeof(this.soundInstancesQueued[soundInstanceId]) === &quot;undefined&quot; || this.soundInstancesQueued[soundInstanceId] === null || this.soundInstancesQueued[soundInstanceId].cancelled) { wasCancelled = true; } else if (typeof(this.soundInstancesQueued[soundInstanceId]) !== &quot;undefined&quot;) { this.soundInstancesQueued[soundInstanceId].object = null; this.soundInstancesQueued[soundInstanceId].cancelled = true; } } if (typeof(thisObject) === &quot;undefined&quot; || thisObject === null) { return; } //thisObject.setVolume(0); //Sets volume to zero (to prevent hearing the sound in some web clients when checkPlaying is called). if (CB_Configuration[CB_BASE_NAME].CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING) { thisObject.mute(); } //Sets volume to zero (to prevent hearing the sound in some web clients when checkPlaying is called). //If it is still LOADED or LOADING but its internal object is LOADED (would happen when changing API), marks the object as free and increments the pointer: if (thisObject.getStatus() === CB_AudioFile.LOADED || thisObject.getStatus() === CB_AudioFile.LOADING &amp;&amp; thisObject.getStatus(true) === CB_AudioFile.LOADED) { //Marks the object as free and increments the pointer: this.audioFilesFree[++this.audioFilesFreePointer] = indexObject; //Also increases the pointer (&quot;x&quot; is the position of the object in the array). //If the status before playing was UNCHECKED (now is LOADED), it has been checked successfully, so it increases the files created counter: if (statusBefore === CB_AudioFile.UNCHECKED) { this.audioFilesCreated++; //Stores the minimum and maximum duration found: var duration = thisObject.getDuration(); if (duration &gt; 0 &amp;&amp; (this.duration === 0 || duration &lt; this.duration)) { this.duration = duration; } if (duration &gt; this.durationMaximum) { this.durationMaximum = duration; } } } //...otherwise, if it is FAILED or ABORTED, removes the sound and reloads another one: else if (thisObject.getStatus() === CB_AudioFile.FAILED || thisObject.getStatus() === CB_AudioFile.ABORTED || thisObject.getStatus() === CB_AudioFile.UNCHECKED) { this.removeAudioFile(thisObject, true, this.checkManuallyOnPlayingFailed); //Sets the sound instance as not cancelled: if (!wasCancelled &amp;&amp; typeof(soundInstanceId) !== &quot;undefined&quot; &amp;&amp; soundInstanceId !== null) { this.soundInstancesQueued[soundInstanceId] = {}; this.soundInstancesQueued[soundInstanceId].cancelled = false; this.soundInstancesQueued[soundInstanceId].object = null; } if (typeof(functionWhenError) === &quot;function&quot;) { functionWhenError(); } } } /** * Plays a sound of the cache (if there is any free). If a sound cannot be played, this method can call itself internally again and again (with most of the given parameters being the same, depending on the circumstances) to try to play the sound until a desired time limit is reached. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greater than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the {@link CB_AudioFile#play} method of the free {@link CB_AudioFile} object (if any). * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the {@link CB_AudioFile#play} method of the free {@link CB_AudioFile} object (if any). * @param {boolean} [loop={@link CB_AudioFile#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Used internally as the &quot;loop&quot; parameter to call the {@link CB_AudioFile#play} method of the free {@link CB_AudioFile} object (if any). * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Desired volume to play the audio. Used internally as the &quot;volume&quot; parameter to call the {@link CB_AudioFile#setVolume} method of the free {@link CB_AudioFile} object (if any), before playing it. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all. Used only when the audio is not able to play immediately. * @param {boolean} [allowedRecursiveDelaySkipping=stopAt-startAt] - If provided (uses milliseconds) and the time expired trying to start playing the sound without success is still inside this amount of time provided, it will try to play the sound but skipping the part of the audio which should have already been played already. In other words, it will try to start playing the sound as if the previous non-played part (which should have been playing during the time which already expired) was already being playing silently. Only used when the time set in the &quot;allowedRecursiveDelay&quot; parameter has been reached and the audio did not start playing yet. The default value is the duration of the sound that we want to play (having in mind the real value of the &quot;startAt&quot; and &quot;stopAt&quot; parameters which are calculated internally and can be different from the provided ones in the case that they had any error). * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;soundInstanceId&quot; (the identifier of the sound instance used), &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile} object used (if any). Used internally as the &quot;onPlayStart&quot; parameter (wrapped in another function) to call the {@link CB_AudioFile#play} method of the free {@link CB_AudioFile} object (if any). * @param {function} [onStop] - Function to call when the sound stops playing, with an unique parameter which belongs to the &quot;soundInstanceId&quot; (the identifier of the sound instance used), being &quot;this&quot; the {@link CB_AudioFile} object (if any). Used internally as the &quot;callbackFunction&quot; parameter (wrapped in a function) to call the {@link CB_AudioFile#onStop} method of the free {@link CB_AudioFile} object (if any), before playing it. * @param {number} [startPlayingTime=CB_Device.getTiming()] - Used internally to calculate the amount of time (in milliseconds) expired without playing the sound. Internal usage only recommended. * @param {number} [startAtOriginal=startAt] - Used internally to start playing the sound accurately and skipping the part which could not be played before, if the time expired without being played is still inside the amount of time provided in the &quot;allowedRecursiveDelaySkipping&quot; parameter. Internal usage only recommended. * @param {integer} [soundInstanceId=CB_AudioFileCache._soundInstanceIdUnique++] - The identifier of the sound instance that will be played. Used internally when the function is called recursively in the case that the sound could not be played immediately. Internal usage only recommended. * @param {Object} [_callRecursivelyIfNotTooLateCalledObject] - Object with just the &quot;called&quot; property (boolean). Used internally to know whether the current execution thread called already the {@link _callRecursivelyIfNotTooLate} internal method for the same sound instance or not. Internal usage only recommended. * @returns {integer|null} Returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. */ CB_AudioFileCache.prototype.play = function(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject) { var that = this; //The first time, we choose a unique sound instance ID: if (typeof(soundInstanceId) === &quot;undefined&quot; || soundInstanceId === null) { soundInstanceId = CB_AudioFileCache._soundInstanceIdUnique++; this.soundInstancesQueued[soundInstanceId] = {}; this.soundInstancesQueued[soundInstanceId].cancelled = false; this.soundInstancesQueued[soundInstanceId].object = null; //Since it is the first time, it modifies the onPlayStart function to assign the audio object to the sound instance ID: var onPlayStartOld = onPlayStart; onPlayStart = function(startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime) { that.soundInstancesQueued[soundInstanceId].object = this; if (typeof(onPlayStartOld) === &quot;function&quot;) { onPlayStartOld.call(this, soundInstanceId, startAt, stopAt, startAtNextLoop, loop, avoidDelayedPlay, allowedRecursiveDelay, startPlayingTime); } }; } //If the sound instance has been cancelled, we exit: if (typeof(this.soundInstancesQueued[soundInstanceId]) === &quot;undefined&quot; || this.soundInstancesQueued[soundInstanceId] === null || this.soundInstancesQueued[soundInstanceId].cancelled) { return null; } ///////this._callRecursivelyIfNotTooLateCalled[soundInstanceId] = false; if (typeof(_callRecursivelyIfNotTooLateCalledObject) === &quot;undefined&quot; || _callRecursivelyIfNotTooLateCalledObject === null) { _callRecursivelyIfNotTooLateCalledObject = {}; } _callRecursivelyIfNotTooLateCalledObject.called = false; //If there is a free audio object, proceeds: var freeAudioFile = this.getFreeAudioFile(true); if (typeof(freeAudioFile.object) !== &quot;undefined&quot; &amp;&amp; freeAudioFile.object !== null) { var audioObject = freeAudioFile.object; var statusBefore = audioObject.getStatus(); if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } if (typeof(startAtOriginal) === &quot;undefined&quot; || startAtOriginal === null) { startAtOriginal = startAt; } //Sets the onStop function that marks the sound as free: audioObject._fireOnStopByUser = true; audioObject.onStop ( function() { that._onStopDefaultFunction.call(that, freeAudioFile.index, audioObject, statusBefore, soundInstanceId, function() { that._callRecursivelyIfNotTooLate.call(that, startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); }); if (typeof(onStop) === &quot;function&quot; &amp;&amp; audioObject._fireOnStopByUser) { onStop.call(audioObject, soundInstanceId); } }, false //Does not keep any possibly existing onStop function. ); /////////////////////////audioObject.onStop(onStop, true); //Keeps the previous function (which marks object as free when it stops). //audioObject.setVolume((statusBefore === CB_AudioFile.UNCHECKED) ? 0 : volume); //If it is UNCHECKED, sets volume to zero (to prevent hearing the sound in some web clients when checkPlaying is called). audioObject.setVolume(volume); audioObject.audioFileObject.lastStartAt = startAtOriginal; //Next loop should start from the original startAt. var played = audioObject.play ( startAt, //startAt stopAt, //stopAt loop, //loop true, //avoidDelayedPlay 0, //allowedRecursiveDelay onPlayStart, //onPlayStart function() { that.soundInstancesQueued[soundInstanceId].object = null; that.removeAudioFile(audioObject, true, that.checkManuallyOnPlayingFailed); that._callRecursivelyIfNotTooLate.call(that, startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); }, //onLoadError true //isResume (simulates a resume to force next loop (if any) to start from the original startAt). ); //If the sound has not been played: if (played === -1) { this.soundInstancesQueued[soundInstanceId].object = null; //If the sound is FAILED or ABORTED, removes it: if (audioObject.getStatus() === CB_AudioFile.FAILED || audioObject.getStatus() === CB_AudioFile.ABORTED) { this.removeAudioFile(audioObject, true, this.checkManuallyOnPlayingFailed); } //If we do not allow delayed play, calls play method again (if the maximum allowed delay has still not expired): ////////if (avoidDelayedPlay) ////////{ this._callRecursivelyIfNotTooLate(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); ////////} } //////return audioObject; } //...otherwise, if there is no object free: else { this.soundInstancesQueued[soundInstanceId].object = null; //Calls the same function recursively: if (typeof(startPlayingTime) === &quot;undefined&quot; || startPlayingTime === null) { startPlayingTime = CB_Device.getTiming(); } if (typeof(startAtOriginal) === &quot;undefined&quot; || startAtOriginal === null) { startAtOriginal = startAt; } this._callRecursivelyIfNotTooLate(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, startPlayingTime, startAtOriginal, soundInstanceId, _callRecursivelyIfNotTooLateCalledObject); //return null; } return soundInstanceId; } /** * Object used by the {@link CB_AudioFileCache#executeFunctionAll} method when the &quot;returnSetTimeoutsArray&quot; parameter is set to true. * @memberof CB_AudioFileCache * @typedef {Object} CB_AudioFileCache.executeFunctionAll_OBJECT * @property {CB_AudioFile} item - The {@link CB_AudioFile} affected. * @property {integer} setTimeoutReturningValue - The returning value of calling the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} internally or null if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. * @property {number} setTimeoutDelay - The value used as the second parameter when calling the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} internally or zero if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. */ /** * Alias for {@link CB_AudioFileCache#executeFunctionAll}. * @function CB_AudioFileCache#executeAll * @see {@link CB_AudioFileCache#executeFunctionAll} */ /** * Alias for {@link CB_AudioFileCache#executeFunctionAll}. * @function CB_AudioFileCache#forEach * @see {@link CB_AudioFileCache#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing {@link CB_AudioFile} objects or on the desired ones (if provided). Calls the {@link CB_Arrays.executeFunctionAll} function internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Function that will be called for each {@link CB_AudioFile} object. As the first parameter it receives the {@link CB_AudioFile} object of the &quot;audioFiles&quot; being looped, as the second parameter the position of this {@link CB_AudioFile} object in the &quot;audioFiles&quot; array provided (or, if not provided, in the array of the {@link CB_AudioFileCache#audioFiles} property), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the {@link CB_AudioFile} object itself. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each {@link CB_AudioFile} object). * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to loop. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @param {boolean} [returnSetTimeoutsArray=false] - Defines whether we want the method to return an integer or a numeric array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call. Returning an array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call is only useful when the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). * @param {boolean} [delayBetweenEachAffectsFirst=false] - If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_AudioFile} objects given in the &quot;audioFiles&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about only allowing {@link CB_AudioFile} objects (in the &quot;audioFiles&quot; parameter) which are already in the cache (identify them by their ID), to avoid problems. */ CB_AudioFileCache.prototype.executeFunctionAll = CB_AudioFileCache.prototype.executeAll = CB_AudioFileCache.prototype.forEach = function(functionEach, delayBetweenEach, audioFiles, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { return CB_Arrays.executeFunctionAll(CB_isArray(audioFiles) ? audioFiles : this.audioFiles, functionEach, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish); /* if (typeof(functionEach) !== &quot;function&quot;) { return returnSetTimeoutsArray ? [] : 0; } if (typeof(delayBetweenEach) === &quot;undefined&quot; || delayBetweenEach === null || isNaN(delayBetweenEach) || delayBetweenEach &lt; 0) { delayBetweenEach = 0; } if (typeof(audioFiles) === &quot;undefined&quot; || audioFiles === null || !CB_isArray(audioFiles)) { audioFiles = this.audioFiles; } var setTimeoutsInformation = []; var audioFilesLength = audioFiles.length; var y = 0; var setTimeoutReturningValue = null; var setTimeoutDelay = 0; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object exists: if (typeof(audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; audioFiles[x] !== null) { //Executes the given function (&quot;this&quot; parameters will point to the current object): if (delayBetweenEach === 0) { functionEach.call(audioFiles[x], x); //&quot;x&quot; is the position of the object in the array. } else { new function(x) //Closure to get unique value of &quot;x&quot; variable for each loop. { setTimeoutDelay = delayBetweenEachAffectsFirst ? delayBetweenEach * (y + 1) : delayBetweenEach * y; setTimeoutReturningValue = setTimeout ( function() { functionEach.call(audioFiles[x], x); //&quot;x&quot; is the position of the object in the array. }, setTimeoutDelay ); }(x); } setTimeoutsInformation[setTimeoutsInformation.length] = { &quot;item&quot; : audioFiles[x], &quot;setTimeoutReturningValue&quot; : setTimeoutReturningValue, &quot;setTimeoutDelay&quot; : setTimeoutDelay }; y++; } } if (returnSetTimeoutsArray) { return setTimeoutsInformation; } else { return y; } */ } /** * Destroys all the {@link CB_AudioFile} objects and frees memory, by calling {@link CB_AudioFile#destructor}(stopSounds, false, true). * @function * @param {boolean} [stopSounds=false] - Used internally as the &quot;stopSound&quot; parameter when calling the {@link CB_AudioFile#destructor} method of each {@link CB_AudioFile} object. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#destructor} has been called. * @todo Think about implementing an &quot;audioFiles&quot; parameter. */ CB_AudioFileCache.prototype.destroyAll = function(stopSounds) { //Destroys each object: var destroyed = this.executeFunctionAll(function() { this.destructor(stopSounds, false, true); }); //Avoids firing onStop. //No one is free now: this.audioFilesFree = []; this.audioFilesFreePointer = -1; return destroyed; } /** * Callback function used by the {@link CB_AudioFileCache#checkPlayingAll} method that will be called when all the process was performed successfully. * @memberof CB_AudioFileCache * @callback CB_AudioFileCache.checkPlayingAll_CALLBACK_OK * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that can be played. * @param {integer} uncheckedObjects - The number of {@link CB_AudioFile} objects that needed to be checked before calling this method. */ /** * Callback function used by the {@link CB_AudioFileCache#checkPlayingAll} method that will be called when not all was performed successfully. * @memberof CB_AudioFileCache * @callback CB_AudioFileCache.checkPlayingAll_CALLBACK_ERROR * @param {string} errorMessage - A string describing the error, if it could be determined. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that can be played. * @param {integer|undefined} uncheckedObjects - The number of {@link CB_AudioFile} objects that needed to be checked before calling this method (it will be undefined if it could not be determined). */ /** * Checks whether each {@link CB_AudioFile} object whose {@link CB_AudioFile#getStatus} method returns the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) can be played or not. After checking, if the audio can be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.FAILED}. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). It will call the {@link CB_AudioFileCache#clearAudioFiles} method internally after finishing. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). * @function * @param {CB_AudioFileCache.checkPlayingAll_CALLBACK_OK} [callbackOk] - A function which will be called if all the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returned the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) could finally be checked successfully and all can be played, being &quot;this&quot; the {@link CB_AudioFileCache} object itself. * @param {CB_AudioFileCache.checkPlayingAll_CALLBACK_ERROR} [callbackError] - A function which will be called if not all the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returned the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) could finally be checked successfully and any cannot be played, being &quot;this&quot; the {@link CB_AudioFileCache} object itself. This function will be called immediately if the method was previously called and it is still running currently. * @param {boolean} [ignoreQueue=false] - Used internally as the &quot;ignoreQueue&quot; parameter when calling the {@link CB_AudioFile#checkPlaying} method of each {@link CB_AudioFile} object. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose status belonged to the &quot;unchecked&quot; value (the value of the {@link CB_AudioFile#UNCHECKED} property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of the audio file cache is not loaded (the {@link CB_AudioFileCache#status} property does not belong to the value set in the {@link CB_AudioFileCache.LOADED} property) nor unchecked (the {@link CB_AudioFileCache#status} property does not belong to the value set in the {@link CB_AudioFileCache.UNCHECKED} property). * @todo Think about implementing an &quot;audioFiles&quot; parameter. */ CB_AudioFileCache.prototype.checkPlayingAll = function(callbackOk, callbackError, ignoreQueue) { if (this._checkingPlaying) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Method checkPlayingAll cannot be executed again until it finishes.&quot;, 0, undefined); } return 0; } //If the cache status is not LOADED, exits: if (this.status !== CB_AudioFileCache.LOADED &amp;&amp; this.status !== CB_AudioFileCache.UNCHECKED) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Cache status is not neither loaded nor unchecked.&quot;, 0, undefined); } return 0; } this._checkingPlaying = true; var that = this; //Counts UNCHECKED objects: var uncheckedObjects = 0; this.executeFunctionAll ( function() { if (this.getStatus() === CB_AudioFile.UNCHECKED) { uncheckedObjects++; } } ); if (uncheckedObjects === 0) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this, 0, 0); } this._checkingPlaying = false; return 0; } var performedActions = 0; var errorsHappenend = 0; var lastError = &quot;&quot;; //Function to execute when an object fails to be checked: var callbackErrorFunction = function(thisObject, error) { that.removeAudioFile(thisObject, true, that.checkManuallyOnCheckingFailed); errorsHappenend++; lastError = error; if (performedActions + errorsHappenend &gt;= uncheckedObjects) { that.clearAudioFiles(); if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;Not all objects could be checked. Message: &quot; + error, performedActions, uncheckedObjects); callbackError = null; //Prevents executing again. } that._checkingPlaying = false; } }; //Function to execute when an object checks successfully: var callbackOkFunction = function(indexObject, thisObject) { //If it is LOADED or LOADING but its internal object is LOADED (would happen when changing API), marks the object as free and increments the pointer: if (thisObject.getStatus() === CB_AudioFile.LOADED || thisObject.getStatus() === CB_AudioFile.LOADING &amp;&amp; thisObject.getStatus(true) === CB_AudioFile.LOADED) { //Marks the object as free and increments the pointer: that.audioFilesFree[++that.audioFilesFreePointer] = indexObject; //Also increases the pointer (&quot;x&quot; is the position of the object in the array). //Increases the files created counter: that.audioFilesCreated++; performedActions++; //Stores the minimum and maximum duration found: var duration = thisObject.getDuration(); if (duration &gt; 0 &amp;&amp; (that.duration === 0 || duration &lt; that.duration)) { that.duration = duration; } if (duration &gt; that.durationMaximum) { that.durationMaximum = duration; } if (performedActions &gt;= uncheckedObjects) { that.clearAudioFiles(); if (that.status === CB_AudioFileCache.UNCHECKED) { that.status = CB_AudioFileCache.LOADED; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that, performedActions, uncheckedObjects); callbackOk = null; //Prevents executing again (although is very unlikely). } that._checkingPlaying = false; } else if (performedActions + errorsHappenend &gt;= uncheckedObjects) { that.clearAudioFiles(); if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, &quot;Not all objects could be checked. Message: &quot; + lastError, performedActions, uncheckedObjects); callbackError = null; //Prevents executing again. } that._checkingPlaying = false; } } //...otherwise, if it is FAILED or ABORTED, calls the error functionn: else if (audioObject.getStatus() === CB_AudioFile.FAILED || audioObject.getStatus() === CB_AudioFile.ABORTED) { callbackErrorFunction(&quot;The object status is not LOADED or is not LOADING and internal object LOADED (status: &quot; + audioObject.getStatus() + &quot;, status internal object: &quot; + audioObject.getStatus(true) + &quot;) after checking successfully.&quot;); } }; //Executes checkPlaying for all UNCHECKED objects: this.executeFunctionAll ( function(object, indexObject) { if (this.getStatus() === CB_AudioFile.UNCHECKED) { var thisObject = this; //Tries to play the sound: this.checkPlaying ( function() { callbackOkFunction(indexObject, thisObject); }, function(error) { callbackErrorFunction(thisObject, error); }, false, ignoreQueue, false ); } } ); return uncheckedObjects; } /** * Tries to play all the {@link CB_AudioFile} objects by calling their {@link CB_AudioFile#play} method internally. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). It does not create sound instances. * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greater than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined will not be called. Used internally as the &quot;loop&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Desired volume to play the audio. Used internally as the &quot;volume&quot; parameter to call the {@link CB_AudioFile#setVolume} method of the {@link CB_AudioFile} object, before playing it. * @param {boolean} [avoidDelayedPlay=false] - If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the audio file object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {function} [onPlayStart] - Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onPlayStart&quot; parameter to call the {@link CB_AudioFile#play} method of the {@link CB_AudioFile} object. * @param {function} [onStop] - Function that will be called each time that a {@link CB_AudioFile} object stops playing. Used internally as the &quot;callbackFunction&quot; parameter to call the {@link CB_AudioFile#onStop} method of the {@link CB_AudioFile} object, before playing it. * @param {boolean} [includingPlaying=false] - If set to true, it will call the {@link CB_AudioFile#play} method even for those {@link CB_AudioFile} objects which are currently playing. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). * @todo Think about implementing an &quot;audioFiles&quot; parameter. */ CB_AudioFileCache.prototype.playAll = function(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop, includingPlaying) { //Takes all objects out of the array of the free ones: this.audioFilesFree = []; this.audioFilesFreePointer = -1; var that = this; //Executes play for all: var performed = 0; this.executeFunctionAll ( function(object, indexObject) { if (includingPlaying || !this.isPlaying()) { var thisObject = this; var statusBefore = thisObject.getStatus(); //Function that removes the sound (executed when play method fails to reload it or when sound is FAILED or ABORTED): this.onStop ( function() { that._onStopDefaultFunction.call(that, indexObject, thisObject, statusBefore); if (typeof(onStop) === &quot;function&quot;) { onStop.call(thisObject); } }, false //Does not keep any possibly existing onStop function. ); ////////////this.onStop(onStop, true); //Keeps the previous function (which marks object as free when it stops). this.setVolume(volume, true); //Forces to set volume property because unchecked objects which use WAAPI still does not have gainNode created. //Tries to play the sound: var played = this.play(startAt, stopAt, loop, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, function() { that.removeAudioFile(thisObject, true, that.checkManuallyOnPlayingFailed); }); //If the sound has not been played: if (played === -1) { //If the sound is FAILED or ABORTED, removes it: if (this.getStatus() === CB_AudioFile.FAILED || this.getStatus() === CB_AudioFile.ABORTED) { that.removeAudioFile(this, true, that.checkManuallyOnPlayingFailed); } } else { performed++; } } } ); return performed; } /** * Tries to stops all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#stop} method internally. * @function * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#stop} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.stopAll = function(audioFiles) { return this.executeFunctionAll(function() { this.stop(); }, 0, audioFiles); } /** * Plays silently and stops all {@link CB_AudioFile} objects after a desired time. It can be useful for some clients which need the {@link CB_AudioFile#play} method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls {@link CB_AudioFileCache#playAll}(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the {@link CB_AudioFileCache#stopAll} method. * @function * @param {boolean} [includingPlaying=false] - If set to true, it will call the {@link CB_AudioFile#play} method even for those {@link CB_AudioFile} objects which are currently playing. * @param {number} [delayBeforeStop=100] - Delay (in milliseconds) before stopping the audio, that will be used as the second parameter of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function when calling the {@link CB_AudioFileCache#stopAll} method. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). * @todo Think about implementing an &quot;audioFiles&quot; parameter. */ CB_AudioFileCache.prototype.playAndStopAll = function(includingPlaying, delayBeforeStop) { if (typeof(delayBeforeStop) === &quot;undefined&quot; || delayBeforeStop === null || isNaN(delayBeforeStop) || delayBeforeStop &lt; 0) { delayBeforeStop = 100; } var played = this.playAll(0, null, false, 0, true, null, null, null, includingPlaying); //Plays silently. var that = this; setTimeout(function() { that.stopAll.call(that); }, delayBeforeStop); //Stops the sound after the delay desired. return played; } /** * Tries to pause all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#pause} method internally. * @function * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onPause&quot; parameter to call the {@link CB_AudioFile#pause} method of the {@link CB_AudioFile} object. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#pause} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.pauseAll = function(onPause, audioFiles) { return this.executeFunctionAll(function() { this.pause(onPause); }, 0, audioFiles); } /** * Resumes all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are paused (and not stopped). It uses the {@link CB_AudioFileCache#play} method internally. * @function * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used internally as the &quot;loop&quot; parameter to call the {@link CB_AudioFileCache#play} method. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the {@link CB_AudioFileCache#play} method. * @param {boolean} [allowedRecursiveDelaySkipping=CB_AudioFile#lastStopAt-CB_AudioFile#lastStartAt] - Used internally as the &quot;allowedRecursiveDelaySkipping&quot; parameter to call the {@link CB_AudioFileCache#play} method. * @param {function} [onPlayStart] - Used internally as the &quot;onPlayStart&quot; parameter to call the {@link CB_AudioFileCache#play} method. * @param {function} [onStop] - Used internally as the &quot;onStop&quot; parameter to call the {@link CB_AudioFileCache#play} method. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {array} Returns a numeric array containing all the return values of each internal call to the {@link CB_AudioFileCache#play} method. */ CB_AudioFileCache.prototype.resumeAll = function(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, audioFiles) { var that = this; var startAt; var startAtOriginal; var soundInstances = []; //var soundInstance; this.executeFunctionAll ( function() { if (this.isPaused() &amp;&amp; !this.isStopped()) { //Gets the data needed for the resume: startAt = this.audioFileObject.pauseTime; startAtOriginal = this.audioFileObject.lastStartAt; if (startAt &gt;= this.audioFileObject.lastStopAt) { startAt = this.audioFileObject.lastStopAt - 1; //We will begin just 1 millisecond before (otherwise the play method would begin again from lastStartAt). } //Maybe the object which will be played (resumed) will not be this one, so we stop it and declare it as not paused (no one paused should remain): this._fireOnStopByUser = false; this.stop(false, false, true); //This way we also make it free (firing onStop). this._fireOnStopByUser = true; //var loopSet = loop; //if (typeof(loopSet) === &quot;undefined&quot; || loopSet === null) { loopSet = this.loop; } //By default, uses the previous loop used. if (typeof(loop) === &quot;undefined&quot; || loop === null) { loop = this.loop; } //By default, uses the previous loop used. //Plays a sound (maybe not the same object) which will simulate a resume with the data we have: soundInstances[soundInstances.length] = that.play(startAt, this.audioFileObject.lastStopAt, loop /*loopSet*/, this.audioFileObject.volumeBeforeMute, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, null, startAtOriginal); //this.resume(loop, null, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, function() { that.removeAudioFile(thisObject, true); }); //soundInstances[soundInstances.length] = soundInstance; } }, 0, audioFiles ); return soundInstances; } /** * Mutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). It uses the {@link CB_AudioFile#mute} method internally. * @function * @param {function} [onMute] - Callback function which will be called for each audio file if it has been possible to mute it (or at least it was possible to try it), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onMute&quot; parameter to call the {@link CB_AudioFile#mute} method. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#mute} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.muteAll = function(onMute, audioFiles) { return this.executeFunctionAll(function() { this.mute(onMute); }, 0, audioFiles); } /** * Unmutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). It uses the {@link CB_AudioFile#unmute} method internally. * @function * @param {function} [onUnmute] - Callback function which will be called for each audio file if it has been possible to unmute it (or at least it was possible to try it), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onUnmute&quot; parameter to call the {@link CB_AudioFile#unmute} method. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#unmute} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.unmuteAll = function(onUnmute, audioFiles) { return this.executeFunctionAll(function() { this.unmute(onUnmute); }, 0, audioFiles); } /** * Sets the same volume for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). It uses the {@link CB_AudioFile#setVolume} method internally. * @function * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the {@link CB_Speaker.getVolume} function if the {@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM} property is set to true or it will be 100 otherwise). Used internally as the &quot;volume&quot; parameter to call the {@link CB_AudioFile#setVolume} method. * @param {boolean} [forceSetVolumeProperty=false] - If set to true (not recommended), it will change the &quot;volume&quot; property of the used audio API object even when the volume was failed to be changed. Used internally as the &quot;forceSetVolumeProperty&quot; parameter to call the {@link CB_AudioFile#setVolume} method. * @param {function} [onSetVolume] - Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onSetVolume&quot; parameter to call the {@link CB_AudioFile#setVolume} method. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setVolume} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.setVolumeAll = function(volume, forceSetVolumeProperty, onSetVolume, audioFiles) { return this.executeFunctionAll(function() { this.setVolume(volume, forceSetVolumeProperty, onSetVolume); }, 0, audioFiles); } /** * Callback function used by the {@link CB_AudioFileCache#setAudioAPIAll} method that will be called when all the process was performed successfully. * @memberof CB_AudioFileCache * @callback CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK * @param {integer} objectsChangedAPI - The number of {@link CB_AudioFile} objects that actually changed its audio API. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that ended with a desired audio API, including those ones which were already using it. * @param {integer} actionsNeeded - The total number of {@link CB_AudioFile} objects that were considered to perform the action (it will be undefined if it could not be determined). */ /** * Callback function used by the {@link CB_AudioFileCache#setAudioAPIAll} method that will be called when any error happened. * @memberof CB_AudioFileCache * @callback CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR * @param {string} error - A string describing the error, if it was possible to be determined. * @param {integer} errorsHappened - The number of errors that happened, which could be greater than 1 if more than one internal call to the {@link CB_AudioFile#setAudioAPI} method failed. * @param {integer} objectsChangedAPI - The number of {@link CB_AudioFile} objects that actually changed its audio API. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that ended with a desired audio API, including those ones which were already using it. * @param {integer} actionsNeeded - The total number of {@link CB_AudioFile} objects that were considered to perform the action (it will be undefined if it could not be determined). */ /** * Tries to change the audio API for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFile#setAudioAPI} method internally. This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. * @function * @param {array|string} preferredAPIs - Array of strings with the preferred audio API or audio APIs, in order of preference. It also accepts a string with only one audio API. If more than one audio API is provided and setting an audio API fails for a {@link CB_AudioFile} object, it will try setting the next one and so on (this means that some of the {@link CB_AudioFile} objects could end with a different audio API). Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK} [callbackOk] - Function that will be called when all the process was performed successfully, being &quot;this&quot; the {@link CB_AudioFileCache} object. * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR} [callbackError] - Function that will be called when any error happened, being &quot;this&quot; the {@link CB_AudioFileCache} object. This function will be called immediately if the method was previously called and it is still running currently. * @param {boolean} [mandatory=false] - If set to true and any {@link CB_AudioFile} object could not perform successfully any call to its {@link CB_AudioFile#setAudioAPI} method for all desired audio APIs provided in the &quot;preferredAPIs&quot; parameter (this means that, internally, all the {@link CB_AudioFile#setAudioAPI} calls, one per desired audio API, have fired an error by calling the function defined in its &quot;callbackError&quot; parameter), the audio file cache will be set as &quot;FAILED&quot; (the {@link CB_AudioFileCache#status} property will be set to the value of {@link CB_AudioFileCache.FAILED}). * @param {string} [forceReload=false] - Used internally as the &quot;forceReload&quot; parameter when calling the {@link CB_AudioFile#setAudioAPI} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - A numeric array containing the {@link CB_AudioFile} objects that we want to affect. It should contain only {@link CB_AudioFile} objects which are already in the current audio file cache. If not provided, it will use all the {@link CB_AudioFile} objects contained in the cache. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setAudioAPI} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileCache.prototype.setAudioAPIAll = function(preferredAPIs, callbackOk, callbackError, mandatory, forceReload, audioFiles) { //No sound object should be free now (because all are changing their API): ///////this.audioFilesFree = []; ///////this.audioFilesFreePointer = -1; if (this._settingAPI) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(this, &quot;Method setAudioAPIAll cannot be executed again until it finishes.&quot;, 1, 0, 0, undefined); } return 0; } this._settingAPI = true; var that = this; //Function to execute when all APIs fail to apply to a single object: var objectsChangedAPI = 0; var errorsHappened = 0; var errorFunction = function(error, avoidFailing, callErrorFunction) { errorsHappened++; //If all actions have performed (fine or with an error), sets the cache as LOADED and clears the array: if (performedActions + errorsHappened &gt;= actionsNeeded) { that.status = CB_AudioFileCache.LOADED; that.clearAudioFiles(); callErrorFunction = true; } //If it was mandatory and we do not want to avoid failing, sets the cache as FAILED: if (mandatory &amp;&amp; !avoidFailing) { that.status = CB_AudioFileCache.FAILED; } //Calls the error function (if any): if (callErrorFunction) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error, errorsHappened, objectsChangedAPI, performedActions, actionsNeeded); callbackError = null; //Prevents calling the function again. } that._settingAPI = false; } }; var performedActions = 0; var actionsNeeded = undefined; //If no preferred APIs are sent, throws an error and exits: if (typeof(preferredAPIs) === &quot;undefined&quot; || preferredAPIs === null) { errorFunction(&quot;No APIs given.&quot;, true, true); return 0; } //Avoid setting status to FAILED. //...otherwise, if the API sent is not an array, turns it into an array: else if (!CB_isArray(preferredAPIs)) { preferredAPIs = [CB_trim(preferredAPIs)]; } //Filters the audio APIs to just use the supported ones: preferredAPIs = CB_AudioDetector.getSupportedAPIs(preferredAPIs); //If preferredAPIs is empty, calls the OK function and exits: //if (preferredAPIs.length === 0) { callbackOkFunction(null, true); return 0; } //If preferredAPIs is empty, calls the error function and exits: if (preferredAPIs.length === 0) { errorFunction(&quot;No APIs supported from the provided ones.&quot;, true, true); return 0; } //If the URI list has no elements, exits: if (typeof(this._URIsListLast) === &quot;undefined&quot; || !CB_isArray(this._URIsListLast) || this._URIsListLast.length === 0) { errorFunction(&quot;URIs list is undefined or empty.&quot;, true, true); return 0; } //If the cache status is not LOADED, exits: if (this.status !== CB_AudioFileCache.LOADED) { errorFunction(&quot;Cache is not loaded.&quot;, true, true); return 0; } //Defines how many actions will have to be performed: if (typeof(audioFiles) === &quot;undefined&quot; || audioFiles === null || !CB_isArray(audioFiles)) { audioFiles = this.audioFiles; } else if (audioFiles.length === 0) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(this, 0, 0, undefined); } this._settingAPI = false; return 0; } this.status = CB_AudioFileCache.LOADING; //The cache is loading. actionsNeeded = 0; var audioFilesLength = audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { //If the object exists: if (typeof(audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; audioFiles[x] !== null) { actionsNeeded++; } } //Function to execute when the audio object has changed the API successfully: var callbackOkFunction = function(indexObject, sameAPI) { if (!sameAPI) { objectsChangedAPI++; } //The audio object is free now: ///////that.audioFilesFree[++that.audioFilesFreePointer] = indexObject; //Increments the counter of objects that have performed the action well: performedActions++; //Stores the minimum and maximum duration found: var duration = this.getDuration(); if (duration &gt; 0 &amp;&amp; (that.duration === 0 || duration &lt; that.duration)) { that.duration = duration; } if (duration &gt; that.durationMaximum) { that.durationMaximum = duration; } //If all objects have performed their action well: if (performedActions &gt;= actionsNeeded) { that.clearAudioFiles(); //The cache finished loading: that.status = CB_AudioFileCache.LOADED; //We call the OK function (if any): if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that, objectsChangedAPI, performedActions, actionsNeeded); callbackOk = null; //Prevents calling the function again. } that._settingAPI = false; } //...otherwise, if all actions have performed (fine or with an error), sets the cache as LOADED and clears the array: else if (performedActions + errorsHappened &gt;= actionsNeeded) { that.status = CB_AudioFileCache.LOADED; that.clearAudioFiles(); //If it was mandatory, sets the cache as FAILED: if (mandatory) { that.status = CB_AudioFileCache.FAILED; } //Calls the error function (if any): if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, error, errorsHappened, objectsChangedAPI, performedActions, actionsNeeded); callbackError = null; //Prevents calling the function again. } that._settingAPI = false; } }; //Function to execute when the audio object has failed to change the API: var callbackErrorFunction = function(error, indexObject, preferredAPIs, URIsList, URIsIndex, currentRetry, APIsTried) { /////that.clearAudioFiles(); var thisObject = this; //If it is the last URI and last API we can try, fails: if (URIsIndex + 1 &gt;= URIsList.length &amp;&amp; preferredAPIs.length &lt;= 1) { thisObject.settingAPI = false; //Calls the error function: errorFunction(error); return; } //...otherwise, continues trying the next desired API: else { //If the desired number of retries have been executed, passes to the next URI: if (++currentRetry &gt; that.retries) { currentRetry = 0; //If all URIs have been tried, passes to the next API: if (++URIsIndex &gt;= URIsList.length) { URIsIndex = 0; preferredAPIs = preferredAPIs.slice(1); //Takes out the first API (the one we have already tried). } } //Calls the function again to try again: setTimeout ( function() { setAPIEach.call(thisObject, thisObject, indexObject, undefined, undefined, preferredAPIs, URIsList, URIsIndex, currentRetry, APIsTried); }, (currentRetry === 0) ? 100 : 1000 //Delay is bigger if we are still trying the same API (to avoid problems with Firefox and AAPI or SM2). ); } }; /////this.clearAudioFiles(); //Function to execute to change API for a single object: var setAPIEach = function(object, indexObject, array, delay, preferredAPIsLocal, URIsList, URIsIndex, currentRetry, APIsTried) { if (typeof(preferredAPIsLocal) === &quot;undefined&quot; || preferredAPIsLocal === null) { preferredAPIsLocal = preferredAPIs; } if (typeof(URIsList) === &quot;undefined&quot; || URIsList === null) { URIsList = that._URIsListLast; } if (typeof(URIsIndex) === &quot;undefined&quot; || URIsIndex === null) { URIsIndex = 0; } if (typeof(currentRetry) === &quot;undefined&quot; || currentRetry === null) { currentRetry = 0; } if (typeof(APIsTried) === &quot;undefined&quot; || APIsTried === null) { APIsTried = []; } //If the API used is already being used, just calls the OK function and exits: if (this.audioAPI === preferredAPIsLocal[0]) { callbackOkFunction.call(this, indexObject, true); return; } //If it is the first time we try the API: if (CB_indexOf(APIsTried, preferredAPIsLocal[0]) === -1) { //Stores the new API that we are going to try: APIsTried[APIsTried.length] = preferredAPIsLocal[0]; //If the current object has already loaded the current API before, gets its URI: if (typeof(this.audioFileObjects) !== &quot;undefined&quot; &amp;&amp; typeof(this.audioFileObjects[preferredAPIsLocal[0]]) !== &quot;undefined&quot;) { if (typeof(this.audioFileObjects[preferredAPIsLocal[0]].status) !== &quot;undefined&quot; &amp;&amp; this.audioFileObjects[preferredAPIsLocal[0]].status === CB_AudioFile.LOADED) { if (typeof(this.audioFileObjects[preferredAPIsLocal[0]].filePath) !== &quot;undefined&quot; &amp;&amp; this.audioFileObjects[preferredAPIsLocal[0]].filePath !== null) { var firstURI = this.audioFileObjects[preferredAPIsLocal[0]].filePath; //If the currently used URI is in the URIs list: if (CB_indexOf(URIsList, firstURI) !== -1) { //Places the URI used at the beginning: var URIsListNew = []; URIsListNew[0] = firstURI; //Refills the array with the rest of the URIs: var URIsListLength = URIsList.length; for (var x = 0; x &lt; URIsListLength; x++) { if (URIsList[x] !== firstURI) { URIsListNew[URIsListNew.length] = URIsList[x]; } } //Saves the new order: URIsList = URIsListNew; } } } } } var thisObject = this; thisObject.settingAPI = true; //Tries to change the API: this.setAudioAPI ( preferredAPIsLocal[0], //audioAPI. true, //audoLoad. false, //autoPlay. function() { thisObject.settingAPI = false; callbackOkFunction.call(thisObject, indexObject); }, //callbackOk. function(error) { callbackErrorFunction.call(thisObject, error, indexObject, preferredAPIsLocal, URIsList, URIsIndex, currentRetry, APIsTried); }, //callbackError, false, //ignoreOldValues. URIsList[URIsIndex], //filePath. forceReload //forceReload ); /////that.clearAudioFiles(); }; //Tries to change the API for all objects: ///////this.executeFunctionAll(setAPIEach, 10); //return this.executeFunctionAll(setAPIEach); return this.executeFunctionAll(setAPIEach, 0, audioFiles); } /** * Tells whether any of the {@link CB_AudioFile} objects is playing or not. It uses the {@link CB_AudioFile#isPlaying} method internally. * @function * @returns {boolean} Returns whether any of the {@link CB_AudioFile} objects is playing or not. */ CB_AudioFileCache.prototype.isPlaying = function() { var audioFilesLength = this.audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; typeof(this.audioFiles[x].isPlaying) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x].isPlaying()) { return true; } } return false; } /** * Tells the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). * @function * @returns {integer} Returns the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). */ CB_AudioFileCache.prototype.getAudioFilesFreeNumber = function() { return this.audioFilesFreePointer + 1; } /** * Gets an array with all the {@link CB_AudioFile} objects. * @function * @param {boolean} [copy=false] - If set to true, instead of returning the {@link CB_AudioFileCache#audioFiles} property directly, it will return a new copy of it. * @returns {array} Returns an array with all the {@link CB_AudioFile} objects. */ CB_AudioFileCache.prototype.getAudioFiles = function(copy) { if (copy) { var audioFiles = []; var audioFilesLength = this.audioFiles.length; var y = 0; for (var x = 0; x &lt; audioFilesLength; x++) { if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null) { audioFiles[y++] = this.audioFiles[x]; } } return audioFiles; } else { return this.audioFiles; } } /** * Gets an array with the free {@link CB_AudioFile} objects (the objects which are available and ready to use). * @function * @returns {array} Returns an array with the free {@link CB_AudioFile} objects (the objects which are available and ready to use). */ CB_AudioFileCache.prototype.getAudioFilesFree = function() { var audioFiles = []; var audioFilesLength = this.audioFiles.length; var y = 0; for (var x = 0; x &lt; audioFilesLength; x++) { if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null &amp;&amp; this.isAudioFileFreeByPosition(x)) //&quot;x&quot; is the position. { audioFiles[y++] = this.audioFiles[x]; } } return audioFiles; } /** * Gets an array with the busy {@link CB_AudioFile} objects (the objects which are not available and ready to use). * @function * @returns {array} Returns an array with the busy {@link CB_AudioFile} objects (the objects which are not available and ready to use). */ CB_AudioFileCache.prototype.getAudioFilesBusy = function() { var audioFiles = []; var audioFilesLength = this.audioFiles.length; var y = 0; for (var x = 0; x &lt; audioFilesLength; x++) { if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; this.audioFiles[x] !== null &amp;&amp; !this.isAudioFileFreeByPosition(x)) //&quot;x&quot; is the position. { audioFiles[y++] = this.audioFiles[x]; } } return audioFiles; } /** * Tells the number of {@link CB_AudioFile} objects created. * @function * @param {boolean} [real=false] - If set to true, instead of returning the value of the {@link CB_AudioFileCache#audioFilesCreated} property, it will return the value of the &quot;length&quot; property of the {@link CB_AudioFileCache#audioFiles} array which are the real number of {@link CB_AudioFile} objects used. If all went well, the returning value should be always the same regardless of this parameter. * @returns {integer} Returns the number of {@link CB_AudioFile} objects created. */ CB_AudioFileCache.prototype.getAudioFilesNumber = function(real) { if (real) { return this.audioFiles.length; } else { return this.audioFilesCreated; } } /** * Tells the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the {@link CB_AudioFile} objects. * @function * @param {boolean} [maximum=false] - If set to true, instead of returning the value of the {@link CB_AudioFileCache#duration} property (which belongs to the minimum duration found among all the {@link CB_AudioFile} objects), it will return the value of {@link CB_AudioFileCache#durationMaximum} property (which belongs to the maximum duration found among all the {@link CB_AudioFile} objects). * @returns {number} Returns the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the {@link CB_AudioFile} objects. */ CB_AudioFileCache.prototype.getDuration = function(maximum) { if (maximum) { return this.durationMaximum; } else { return this.duration; } } /** * Returns a number representing the percentage of the loading progress for the audio file cache (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @function * @param {boolean} [countLoadedObjects=false] - If set to true, it will count the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returns &quot;LOADED&quot; (the value of the {@link CB_AudioFile#LOADED} property), instead of just using the array's &quot;length&quot; of the {@link CB_AudioFileCache#audioFiles} property. * @param {boolean} [alsoUncheckedAndCheckingObjects=false] - If set to true and the &quot;countLoadedObjects&quot; parameter is also true, it will also count the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returns &quot;UNCHECKED&quot; (the value of the {@link CB_AudioFile#UNCHECKED} property) or &quot;CHECKING&quot; (the value of the {@link CB_AudioFile#CHECKING} property). If the &quot;countLoadedObjects&quot; parameter is false, this parameter will be ignored. * @returns {number} Returns a number representing the percentage of the loading progress for the audio file cache (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. * @todo Although it would be more accurate, it does not use the {@link CB_AudioFile#getProgress} method internally because the {@link CB_AudioFile} objects are not added to the {@link CB_AudioFileCache#audioFiles} property until they are loaded. It would be nice to code a way to be able to use it (perhaps a property where the {@link CB_AudioFile} objects loading are kept temporarily). */ CB_AudioFileCache.prototype.getProgress = function(countLoadedObjects, alsoUncheckedAndCheckingObjects) { //var objectsLoaded = (this.audioFiles.length &lt; this.audioFilesCreated) ? this.audioFiles.length : this.audioFilesCreated; //Takes the smallest number. var objectsLoaded = this.audioFiles.length; if (countLoadedObjects) { var audioFilesLength = this.audioFiles.length; var objectsReallyLoaded = 0; for (var x = 0; x &lt; audioFilesLength; x++) { if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; typeof(this.audioFiles[x].getStatus) !== &quot;undefined&quot;) //if (typeof(this.audioFiles[x]) !== &quot;undefined&quot; &amp;&amp; typeof(this.audioFiles[x].getStatus) !== &quot;undefined&quot;) { if (typeof(this.audioFiles[x].settingAPI) === &quot;undefined&quot; || !this.audioFiles[x].settingAPI) { if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED) { objectsReallyLoaded++; } else if (alsoUncheckedAndCheckingObjects &amp;&amp; (this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING)) { objectsReallyLoaded++; } } /* //LOADED counts as one: if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADED) { objectsReallyLoaded++; } //UNCHECKED and CHECKING counts as 50%: else if (this.audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED || this.audioFiles[x].getStatus() === CB_AudioFile.CHECKING) { objectsReallyLoaded += 0.5; } //LOADING counts as 50% when the progress is 100%: else if (this.audioFiles[x].getStatus() === CB_AudioFile.LOADING) { objectsReallyLoaded += this.audioFiles[x].getProgress() / 200; //It will be 0.5 when the object is loaded completely (getProgress returns 100). } */ } } //objectsLoaded = (objectsLoaded &lt; objectsReallyLoaded) ? objectsLoaded : objectsReallyLoaded; //Takes the smallest number. objectsLoaded = objectsReallyLoaded; } var objectsNeeded = this.minimumAudioFiles; var progress = (objectsLoaded / objectsNeeded) * 100; if (progress &gt; 100) { progress = 100; } else if (progress &lt; 0) { progress = 0; } //if (progress === 100 &amp;&amp; this.status === CB_AudioFileCache.LOADING) { progress = 99.99; } return progress; } /** * Gets the current status of the audio file cache. * @function * @returns {number} Returns the current status of the audio file cache. It is a number, which should match the value of the {@link CB_AudioFileCache.UNLOADED} (still unloaded), {@link CB_AudioFileCache.LOADING} (loading), {@link CB_AudioFileCache.UNCHECKED} (not checked by calling the {@link CB_AudioFileCache#checkPlayingAll} method yet), {@link CB_AudioFileCache.CHECKING} (being checked by the {@link CB_AudioFileCache#checkPlayingAll} method), {@link CB_AudioFileCache.LOADED} (loaded), {@link CB_AudioFileCache.FAILED} (failed loading or failed to play or by any other reason) or {@link CB_AudioFileCache.ABORTED} (aborted because it was destroyed with the &quot;destructor&quot; method) property. */ CB_AudioFileCache.prototype.getStatus = function() { return this.status; } /** * Gets the current status of the audio file cache, as a string. * @function * @returns {string} Returns the current status of the audio file cache, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the {@link CB_AudioFileCache#status} property not recognized as any possible status). */ CB_AudioFileCache.prototype.getStatusString = function() { var status = this.getStatus(); var statuses = [ &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; ]; if (typeof(statuses[status]) !== &quot;undefined&quot;) { return statuses[status]; } else { return &quot;UNKNOWN (&quot; + status + &quot;)&quot;; } } /** * Calls the error function which should be set in the {@link CB_AudioFileCache#onError} property (if any), being &quot;this&quot; the {@link CB_AudioFileCache} object itself. Internal usage only recommended. * @function * @param {string} [message] - The message describing the error that will be sent to the set {@link CB_AudioFileCache#onError} function (if any) as the first and unique parameter. * @param {boolean} [avoidFailing=false] - If set to true, it will not set the {@link CB_AudioFileCache#status} property to &quot;FAILED&quot; (the value of the {@link CB_AudioFile#FAILED} property). * @returns {boolean} Returns true if the {@link CB_AudioFileCache#onError} function could be called or false otherwise. */ CB_AudioFileCache.prototype.errorFunction = function(message, avoidFailing) { if (!avoidFailing) { this.status = CB_AudioFileCache.FAILED; } if (typeof(this.onError) === &quot;function&quot;) { this.onError.call(this, message); return true; } return false; } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFileSprites.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFileSprites.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js /** * @file Audio sprites management. Contains the {@link CB_AudioFileSprites} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * An object representing an audio sprite which can contain, optionally, the &quot;startAt&quot; and &quot;stopAt&quot; properties with a numeric value (representing when the audio sprite starts and when it stops, respectively). If not set, the default &quot;startAt&quot; value will be 0 (zero) and the default &quot;stopAt&quot; value will be null (which means it will not stop until the end of the audio is reached unless it is paused or stopped before). The &quot;fake&quot; property should never be used as it is used internally to distinguish real sprites from fake ones (generated and returned by the {@link CB_AudioFileSprites#getSprite} method when a requested sprite is not found). * @example { startAt: 10, stopAt: 20 } * @memberof CB_AudioFileSprites * @typedef {Object} CB_AudioFileSprites.SPRITE_OBJECT * @property {number} [startAt=0] - The time (in milliseconds) of the audio file where the audio sprite starts. If not provided, it will use the value of 0 (zero) which means that it will start from the beginning. * @property {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - The time (in milliseconds) of the audio file where the audio sprite stops. If not provided (not recommended), it will use the whole duration of the file (which means until it reaches its end). NOTE: Due to some possible problems between clients with different audio APIs calculating the duration of an audio file, it is recommended to always set the &quot;stopAt&quot; property even when we want it to stop at the end of the audio. */ /** * Object whose property names the identifiers of each sprite (a case-sensitive string) and their value is a {@link CB_AudioFileSprites.SPRITE_OBJECT} object. * @example * { * &quot;whole_audio&quot; : {}, * &quot;first_sprite&quot; : { stopAt: 10 }, * &quot;second_sprite&quot; : { startAt: 10, stopAt: 20 }, * &quot;third_sprite&quot; : { startAt: 20 }, * ... * } * @memberof CB_AudioFileSprites * @typedef {Object} CB_AudioFileSprites.SPRITES_OBJECT * @property {CB_AudioFileSprites.SPRITE_OBJECT} spriteInformation - Being the name of each property the identifier of a sprite (a string which cannot be &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; as it is a reserved name), the value will always be a {@link CB_AudioFileSprites.SPRITE_OBJECT} object. */ /** * Object with the desired data and options for the audio sprites. It is almost identical to the {@link CB_AudioFileCache.DATA_OBJECT} but adding a &quot;sprites&quot; property. * @memberof CB_AudioFileSprites * @typedef {Object} CB_AudioFileSprites.DATA_OBJECT * @property {CB_AudioFileCache.URIS_OBJECT} URIs - Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. If a valid value is given, this will be added to the {@link CB_AudioFileCache#URIs} property. * @property {CB_AudioFileSprites.SPRITES_OBJECT} [sprites] Object with the desired sprites. It will be used as the first parameter to call the {@link CB_AudioFileSprites#insertSprites} method internally. It will be added (after being processed) to the {@link CB_AudioFileCache#sprites} property. * @property {string} [id=&quot;&quot;] - Desired identifier for the audio file sprites object. Internal usage only recommended. If a valid value is given, this will be added to the {@link CB_AudioFileSprites#id} property as well as to the {@link CB_AudioFileCache#id} property of the internally-created {@link CB_AudioFileCache} object. * @property {array} [preferredAPIs={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}] - Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileCache#preferredAPIs} property. * @property {array} [preferredFormats={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS}] - Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileCache#preferredFormats} property. * @property {integer} [minimumAudioFiles={@link CB_AudioFileCache.minimumAudioFiles_DEFAULT}] - Minimum {@link CB_AudioFile} objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#minimumAudioFiles} property. * @property {integer} [maximumAudioFiles={@link CB_AudioFileCache.maximumAudioFiles_DEFAULT}] - Maximum {@link CB_AudioFile} objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the {@link CB_AudioFileCache#minimumAudioFiles} property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#maximumAudioFiles} property. * @property {integer} [minimumAudioFilesFree=parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.25 + 0.5)] - New {@link CB_AudioFile} objects will be created internally when the number of free {@link CB_AudioFile} objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#minimumAudioFilesFree} property. * @property {integer} [newAudioFilesWhenNeeded=Math.min(parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.1 + 0.5), 1)] - Number of new {@link CB_AudioFile} objects to create internally when the minimum limit of free {@link CB_AudioFile} objects ({@link CB_AudioFileCache#minimumAudioFilesFree}) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the {@link CB_AudioFileCache#minimumAudioFiles} by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#newAudioFilesWhenNeeded} property. * @property {integer} [retries={@link CB_AudioFileCache.retries_DEFAULT}] - Number of retries to try to load a {@link CB_AudioFile} object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileCache#retries} property. * @property {boolean} [checkManually={@link CB_AudioFileCache.checkManually_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManually} property. * @property {boolean} [checkManuallyOnNeededCreated={@link CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when creates a new {@link CB_AudioFile} object needed. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnNeededCreated} property. * @property {boolean} [checkManuallyOnPlayingFailed={@link CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnPlayingFailed} property. * @property {boolean} [checkManuallyOnCheckingFailed={@link CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileCache#checkManuallyOnCheckingFailed} property. * @property {function} [onLoad] - Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the {@link CB_AudioFile} objects that still need to be checked, if any, being &quot;this&quot; the current {@link CB_AudioFileCache} object. If a valid value is given, this will be added to the {@link CB_AudioFileCache#onLoad} property. * @property {function} [onError] - Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current {@link CB_AudioFileCache} object. If a valid value is given, this will be added to the {@link CB_AudioFileCache#onError} property. * @property {boolean} [disableAutoLoad=false] - If set to true, it will not create automatically the {@link CB_AudioFile} objects by calling the {@link CB_AudioFileCache#createAudioFiles} method internally. Internal usage only recommended. */ /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @class * @classdesc Class to manage audio sprites of a {@link CB_AudioFileCache} object (used internally). * @param {CB_AudioFileSprites.DATA_OBJECT} [dataObject] - Object with the desired data and options for the audio sprites. Although it can contain a &quot;sprites&quot; property, it will also be used as the first and unique parameter when calling the constructor of the {@link CB_AudioFileCache} object internally. * @returns {CB_AudioFileSprites} Returns a new {@link CB_AudioFileSprites} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). * @todo Think about using wrapper to replace &quot;this&quot; in callbacks (callbackOk, callbackError) to point to the {@link CB_AudioFileSprites} object itself. * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ var CB_AudioFileSprites = function(dataObject) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFileSprites)) { return new CB_AudioFileSprites(dataObject); } //Properties and variables: /** * Stores the identifier for the audio file sprites object. * @var * @readonly * @type {string} * @default */ this.id = &quot;&quot;; /** * Object with information about the sprites. * @var * @readonly * @type {CB_AudioFileSprites.SPRITES_OBJECT} * @default */ this.sprites = {}; /** * Object whose property names are the sprite identifiers (strings), including one called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, and their values are an array containing the sound instance identifiers (created by the {@link CB_AudioFileSprites#play} method). Internal usage only recommended. * @var * @readonly * @type {Object} * @default { &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; : [] } */ this.spriteSoundInstances = { &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; : [] }; //Object with the sound instances associated to each sprite ID. //If not defined, defines a fake prototype object: CB_AudioFileSprites._audioFileCachePrototype = CB_AudioFileSprites._audioFileCachePrototype || { DEFAULT_ERROR_MESSAGE : &quot;CB_AudioFileCache object not loaded (using prototype).&quot;, usingPrototype : true, status : CB_AudioFileCache.UNLOADED, audioFiles : [], audioFilesCreated : 0, audioFilesFreePointer : 0, soundInstancesQueued : {}, duration : 0, destructor : function() {}, createAudioFiles : function() { return 0; }, createAudioFile : function(URIs, preferredAPIs, preferredFormats, audioObject, callbackOk, callbackError) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(CB_AudioFileSprites._audioFileCachePrototype, DEFAULT_ERROR_MESSAGE); } return null; }, clearAudioFiles : function() { return []; }, removeAudioFile : function() { return null; }, purge : function() { return 0; }, getFreeAudioFile : function() { return { &quot;object&quot; : null, &quot;index&quot; : -1 }; }, isAudioFileFree : function() { return false; }, clearSoundInstances : function() { return 0; }, cancelSoundInstances : function() { return false; }, cancelSoundInstance : function() { return false; }, getAudioFileBySoundInstanceId : function() { return null; }, play : function(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop) { if (typeof(onStop) === &quot;function&quot;) { onStop(); } return null; }, executeFunctionAll : function() { return 0; }, destroyAll : function() { return 0; }, checkPlayingAll : function(callbackOk, callbackError) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(CB_AudioFileSprites._audioFileCachePrototype, DEFAULT_ERROR_MESSAGE); } return 0; }, playAll : function(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop) { if (typeof(onStop) === &quot;function&quot;) { onStop(); } return 0; }, stopAll : function() { return 0; }, playAndStopAll : function() { return 0; }, pauseAll : function() { return 0; }, resumeAll : function(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop) { if (typeof(onStop) === &quot;function&quot;) { onStop(); } return 0; }, muteAll : function() { return 0; }, unmuteAll : function() { return 0; }, setVolumeAll : function() { return 0; }, setAudioAPIAll : function(preferredAPIs, callbackOk, callbackError) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(CB_AudioFileSprites._audioFileCachePrototype, DEFAULT_ERROR_MESSAGE); } return 0; }, getStatus : function() { return CB_AudioFileCache.UNLOADED; }, getStatusString : function() { return &quot;UNLOADED&quot;; }, getAudioFilesFreeNumber : function() { return 0; }, getAudioFiles : function() { return []; }, getAudioFilesFree : function() { return []; }, getAudioFilesBusy : function() { return []; }, getAudioFilesNumber : function() { return 0; }, getDuration : function() { return 0; }, getProgress : function() { return 0; }, isPlaying : function() { return false; } }; /** * Contains the {@link CB_AudioFileCache} object. Internal usage only recommended. * @var * @readonly * @type {CB_AudioFileCache} * @default */ this.audioFileCache = CB_AudioFileSprites._audioFileCachePrototype; //Keeps the CB_AudioFileCache object. //Calls the constructor of the object when creates an instance: return this._init(dataObject); } //Constructor: CB_AudioFileSprites.prototype._init = function(dataObject) { /* FORMAT: dataObject = { [id : String,] [preferredAPIs : Array&lt;String&gt;,] [preferredFormats : Array&lt;String&gt;,] URIs : Object, [minimumAudioFiles : Integer,] [maximumAudioFiles : Integer,] [minimumAudioFilesFree : Integer,] [newAudioFilesWhenNeeded : Integer,] [retries : Integer,] [checkManually : Boolean,] [checkManuallyOnNeededCreated : Boolean,] [checkManuallyOnPlayingFailed : Boolean,] [checkManuallyOnCheckingFailed : Boolean,] [disableAutoLoad : Boolean,] [onLoad : Function,] [onError : Function,] sprites : { &quot;sprite_id&quot; : { [startAt : Integer,] [stopAt : Integer,] } [, ...] } }; */ //Tries to load the data (if any): this.load(dataObject); //Returns the object: return this; } /** * Destroys the audio file sprites object (removing all sprites, etc.), including the internal audio file cache object, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of the {@link CB_AudioFileCache} object as ABORTED ({@link CB_AudioFileCache.ABORTED} value). * @function * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling internally the {@link CB_AudioFileCache#destructor} method of the {@link CB_AudioFileCache} object. * @param {boolean} [preventAbortedStatus=false] - If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not assign the value of {@link CB_AudioFileCache.ABORTED} to the {@link CB_AudioFileCache#status} property). */ CB_AudioFileSprites.prototype.destructor = function(stopSounds, preventAbortedStatus) { //Resets properties to their default value: this.sprites = {}; this.spriteSoundInstances = { &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; : [] }; //Destroys the CB_AudioFileCache object: this.audioFileCache.destructor(stopSounds, preventAbortedStatus); this.audioFileCache = CB_AudioFileSprites._audioFileCachePrototype; } /** * Loads the audio file sprites with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @function * @param {CB_AudioFileSprites.DATA_OBJECT} dataObject - Object with the desired data and options for the audio file sprites. * @returns {CB_AudioFileSprites|null} If a &quot;dataObject&quot; is given, it returns the current {@link CB_AudioFileSprites} object. Otherwise, it returns null. */ CB_AudioFileSprites.prototype.load = function(dataObject) { if (typeof(dataObject) === &quot;undefined&quot; || dataObject === null) { return null; } //Destroys all previous data (if any): this.destructor(true, true); //Also stops all sounds. //Sanitizes the given data: dataObject.id = CB_trim(dataObject.id); //Sets the new data: if (dataObject.id !== &quot;&quot;) { this.id = dataObject.id; } //Inserts the sprites: if (typeof(dataObject.sprites) !== &quot;undefined&quot; &amp;&amp; dataObject.sprites !== null) { this.removeSprites(); this.insertSprites(dataObject.sprites); } //Creates the audio file cache object: this.audioFileCache = new CB_AudioFileCache(dataObject); return this; } /** * Alias for {@link CB_AudioFileSprites#removeSprites}. * @function CB_AudioFileSprites#removeSpritesAll * @see {@link CB_AudioFileSprites#removeSprites} */ /** * Removes all the sprites by clearing the {@link CB_AudioFileSprites#sprites} property. * @function */ CB_AudioFileSprites.prototype.removeSprites = CB_AudioFileSprites.prototype.removeSpritesAll = function() { this.sprites = {}; } /** * Inserts the given sprites. It will keep the existing ones. If a sprite identifier already existed and it is given again (not recommended), it will be replaced by the new one (but keeping its current sound instances, if any). * @function * @param {CB_AudioFileSprites.SPRITES_OBJECT} sprites - Object with the desired sprites. * @returns {integer} Returns the number of sprites inserted. */ CB_AudioFileSprites.prototype.insertSprites = function(sprites) { var inserted = 0; if (typeof(sprites) !== &quot;undefined&quot; &amp;&amp; sprites !== null) { for (var spriteId in sprites) { //Inserts the sprite: if (this.insertSprite(sprites[spriteId], spriteId)) { inserted++; } } } return inserted; } /** * Inserts the given sprite. It will keep the existing ones. If a sprite identifier already existed and it is given again (not recommended), it will be replaced by the new one (but keeping its current sound instances, if any). * @function * @param {CB_AudioFileSprites.SPRITE_OBJECT} sprite - Object with the desired sprite. * @param {string} spriteId - The identifier for the sprite. * @returns {boolean} Returns true if the sprite has been inserted or false otherwise. */ CB_AudioFileSprites.prototype.insertSprite = function(sprite, spriteId) { if (typeof(spriteId) === &quot;undefined&quot; || spriteId === null) { return false; } this.sprites[spriteId] = {}; this.setStartAtSprite(spriteId, (typeof(sprite.startAt) === &quot;undefined&quot;) ? undefined : sprite.startAt); this.setStopAtSprite(spriteId, (typeof(sprite.stopAt) === &quot;undefined&quot;) ? undefined : sprite.stopAt); if (typeof(this.spriteSoundInstances[spriteId]) === &quot;undefined&quot; || this.spriteSoundInstances[spriteId] === null) { this.spriteSoundInstances[spriteId] = []; } return true; } /** * Sets when a sprite begins (stored in its &quot;startAt&quot; property), by sprite identifier. * @function * @param {string} spriteId - The identifier for the sprite. * @param {number} startAt - The time (in milliseconds) of the audio file where the audio sprite starts. * @returns {boolean} Returns true if the sprite has been modified or false otherwise. */ CB_AudioFileSprites.prototype.setStartAtSprite = function(spriteId, startAt) { if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return false; } this.sprites[spriteId].startAt = 0; if (typeof(startAt) !== &quot;undefined&quot; &amp;&amp; startAt !== null &amp;&amp; !isNaN(startAt) &amp;&amp; startAt &gt;= 0 &amp;&amp; this.sprites[spriteId].startAt !== startAt) { this.sprites[spriteId].startAt = startAt; return true; } return false; } /** * Sets when a sprite ends (stored in its &quot;stopAt&quot; property), by sprite identifier. * @function * @param {string} spriteId - The identifier for the sprite. * @param {number} stopAt - The time (in milliseconds) of the audio file where the audio sprite ends. * @returns {boolean} Returns true if the sprite has been modified or false otherwise. */ CB_AudioFileSprites.prototype.setStopAtSprite = function(spriteId, stopAt) { if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return false; } this.sprites[spriteId].stopAt = null; if (typeof(stopAt) !== &quot;undefined&quot; &amp;&amp; stopAt !== null &amp;&amp; !isNaN(stopAt) &amp;&amp; stopAt &gt; this.sprites[spriteId].startAt &amp;&amp; this.sprites[spriteId].stopAt !== stopAt) { this.sprites[spriteId].stopAt = stopAt; return true; } return false; } /** * Removes a sprite by its ID. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {boolean} Returns true if the sprite has been deleted or false otherwise. */ CB_AudioFileSprites.prototype.removeSprite = function(spriteId) { if (typeof(this.sprites[spriteId]) !== &quot;undefined&quot; &amp;&amp; this.sprites[spriteId] !== null) { this.sprites[spriteId] = null; var sprites = {}; var deleted = false; for (spriteId in this.sprites) { if (typeof(this.sprites[spriteId]) !== &quot;undefined&quot; &amp;&amp; this.sprites[spriteId] !== null) { sprites[spriteId] = this.sprites[spriteId]; deleted = true; } } this.sprites = sprites; return deleted; } return false; } /** * Returns a sprite by its ID. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {CB_AudioFileSprites.SPRITE_OBJECT} Returns the desired sprite or a fake object if it was not found. The fake object will be this one: { &quot;startAt&quot; : 0, &quot;stopAt&quot; : null, &quot;fake&quot; : true }. */ CB_AudioFileSprites.prototype.getSprite = function(spriteId) { if (typeof(this.sprites[spriteId]) !== &quot;undefined&quot;) { return this.sprites[spriteId]; } return { &quot;startAt&quot; : 0, &quot;stopAt&quot; : null, &quot;fake&quot; : true }; } /** * Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). * @function * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, the returning object will also contain a property called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; whose value will be an empty object (unless the property existed before in the object stored in the {@link CB_AudioFileSprites#sprites} property and had a value which is not an empty object). If set to false, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property unless the property existed before in the object stored in the {@link CB_AudioFileSprites#sprites} property. * @returns {CB_AudioFileSprites.SPRITES_OBJECT} Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). */ CB_AudioFileSprites.prototype.getSprites = function(includeWithoutSpriteAssociated) { if (!includeWithoutSpriteAssociated) { return this.sprites; } else { var sprites = {}; sprites[&quot;_WITHOUT_SPRITE_ASSOCIATED&quot;] = {}; for (var spriteId in this.sprites) { sprites[spriteId] = this.sprites[spriteId]; } return sprites; } } /** * Returns an array of the sound instance identifiers (created by the {@link CB_AudioFileSprites#play} method) used by the given sprite identifier. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {array} Returns a numeric array of the sound instances (created by the {@link CB_AudioFileSprites#play} method) used by the given sprite identifier. */ CB_AudioFileSprites.prototype.getSoundInstancesIdBySpriteId = function(spriteId) { if (typeof(this.spriteSoundInstances[spriteId]) !== &quot;undefined&quot;) { return this.spriteSoundInstances[spriteId]; } return []; } /** * Returns the sound instances (their ID) used (stored in the {@link CB_AudioFileSprites#spriteSoundInstances} property). * @function * @param {boolean} [oneDimension=false] - If set to true, it will return the {@link CB_AudioFileSprites#spriteSoundInstances} property directly (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated). Otherwise, if it is set to true, it will return a numeric array whose values are the sound instance IDs. * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, it will also return the sound instance identifiers which are not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#getSprites} method internally. Only used when the &quot;oneDimension&quot; parameter is set to true. * @returns {Object|array} Returns the sound instances (their ID) used (stored in the {@link CB_AudioFileSprites#spriteSoundInstances} property). If the &quot;oneDimension&quot; parameter is set to false, the property names of the returning object are the sprite identifiers (strings), including one called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, and their values are an array containing the sound instance IDs. If the &quot;oneDimension&quot; parameter is set to true, it will return a numeric array whose values are the sound instance identifiers (if the &quot;includeWithoutSpriteAssociated&quot; parameter it set to true, it will also include the sound instances which are not associated to any sprite). */ CB_AudioFileSprites.prototype.getSoundInstancesId = function(oneDimension, includeWithoutSpriteAssociated) { if (!oneDimension) { return this.spriteSoundInstances; } else { var soundInstances = []; var soundInstancesSprite; var soundInstancesSpriteLength; var y = 0; var x = 0; var sprites = this.getSprites(includeWithoutSpriteAssociated); for (var spriteId in sprites) { soundInstancesSprite = this.getSoundInstancesIdBySpriteId(spriteId); soundInstancesSpriteLength = soundInstancesSprite.length; for (x = 0; x &lt; soundInstancesSpriteLength; x++) { soundInstances[y++] = soundInstancesSprite[x]; } } return soundInstances; } } /** * Returns an array of the {@link CB_AudioFile} objects used by the sound instances that belong to a given sprite identifier. * @function * @param {string} spriteId - The identifier for the sprite. * @param {boolean} [avoidCancelled=false] - If set to true, it will not return the {@link CB_AudioFile} objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFileBySoundInstanceId} method internally. * @returns {array} Returns an array of the {@link CB_AudioFile} objects used by the sound instances that belong to the given sprite identifier. */ CB_AudioFileSprites.prototype.getAudioFilesUsedBySpriteId = function(spriteId, avoidCancelled) { var soundInstances = this.getSoundInstancesIdBySpriteId(spriteId); var audioFiles = []; var y = 0; var soundInstancesLength = soundInstances.length; var currentObject = null; for (var x = 0; x &lt; soundInstancesLength; x++) { currentObject = this.getAudioFileBySoundInstanceId(soundInstances[x], avoidCancelled); if (currentObject !== null) { audioFiles[y++] = currentObject; } } return audioFiles; } /** * Object returned by the {@link CB_AudioFileSprites#getAudioFilesUsed} method. Each property names will be the sprites identifiers except the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated (if we wanted to include them). * @memberof CB_AudioFileSprites * @typedef {Object} CB_AudioFileSprites.getAudioFilesUsed_OBJECT * @property {CB_AudioFile} spriteId - Each property name will be a sprite identifier (it can be &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, if we wanted to include them). The value will be a numeric array with the {@link CB_AudioFile} objects used. */ /** * Returns the {@link CB_AudioFile} objects used by all the sounds instances currently created. * @function * @param {boolean} [oneDimension=false] - If set to false, it will return an object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the {@link CB_AudioFile} objects used. Otherwise, if set to true, it will return a numeric array with the {@link CB_AudioFile} objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite). * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, it will also return the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#getSprites} method internally. * @param {boolean} [avoidCancelled=false] - If set to true, it will not return the {@link CB_AudioFile} objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsedBySpriteId} method internally. * @returns {CB_AudioFileSprites.getAudioFilesUsed_OBJECT|array} Returns the {@link CB_AudioFile} objects used by all the sounds instances currently created. If the &quot;oneDimension&quot; parameter is set to false, it will return a {@link CB_AudioFileSprites.getAudioFilesUsed_OBJECT} object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the {@link CB_AudioFile} objects used. Otherwise, if the &quot;oneDimension&quot; parameter set to true, it will return a numeric array with the {@link CB_AudioFile} objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite). */ CB_AudioFileSprites.prototype.getAudioFilesUsed = function(oneDimension, includeWithoutSpriteAssociated, avoidCancelled) { var audioFiles; var sprites = this.getSprites(includeWithoutSpriteAssociated); if (!oneDimension) { audioFiles = {}; for (var spriteId in sprites) { audioFiles[spriteId] = this.getAudioFilesUsedBySpriteId(spriteId, avoidCancelled); } } else { audioFiles = []; var audioFilesSprite; var audioFilesSpriteLength; var y = 0; var x = 0; for (var spriteId in sprites) { audioFilesSprite = this.getAudioFilesUsedBySpriteId(spriteId, avoidCancelled); audioFilesSpriteLength = audioFilesSprite.length; for (x = 0; x &lt; audioFilesSpriteLength; x++) { audioFiles[y++] = audioFilesSprite[x]; } } } return audioFiles; } /** * Alias for {@link CB_AudioFileSprites#executeFunctionAllSprite}. * @function CB_AudioFileSprites#executeAllSprite * @see {@link CB_AudioFileSprites#executeFunctionAllSprite} */ /** * Alias for {@link CB_AudioFileSprites#executeFunctionAllSprite}. * @function CB_AudioFileSprites#forEachSpriteById * @see {@link CB_AudioFileSprites#executeFunctionAllSprite} */ /** * Executes a desired function for all the {@link CB_AudioFile} objects used by the sound instances currently created that belong to a given sprite (by its ID). It calls the {@link CB_AudioFileSprites#executeFunctionAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Used as the &quot;functionEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - Used as the &quot;delayBetweenEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {boolean} [avoidCancelled=false] - If set to true, it will not affect the {@link CB_AudioFile} objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsedBySpriteId} method internally. * @param {boolean} [returnSetTimeoutsArray=false] - Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {boolean} [delayBetweenEachAffectsFirst=false] - Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_AudioFile} objects used by the sound instances that belong to the given sprite identifier). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. */ CB_AudioFileSprites.prototype.executeFunctionAllSprite = CB_AudioFileSprites.prototype.executeAllSprite = CB_AudioFileSprites.prototype.forEachSpriteById = function(spriteId, functionEach, delayBetweenEach, avoidCancelled, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction) { return this.executeFunctionAll(functionEach, delayBetweenEach, this.getAudioFilesUsedBySpriteId(spriteId, avoidCancelled), returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction); } /** * Alias for {@link CB_AudioFileSprites#executeFunctionAllSprites}. * @function CB_AudioFileSprites#executeAllSprites * @see {@link CB_AudioFileSprites#executeFunctionAllSprites} */ /** * Alias for {@link CB_AudioFileSprites#executeFunctionAllSprites}. * @function CB_AudioFileSprites#forEachSprite * @see {@link CB_AudioFileSprites#executeFunctionAllSprites} */ /** * Executes a desired function for all the {@link CB_AudioFile} objects used by all the sound instances currently created. It calls the {@link CB_AudioFileSprites#executeFunctionAll} method internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Used as the &quot;functionEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - Used as the &quot;delayBetweenEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, it will also affect the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsed} method internally. * @param {boolean} [avoidCancelled=false] - If set to true, it will not affect the {@link CB_AudioFile} objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsed} method internally. * @param {boolean} [returnSetTimeoutsArray=false] - Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {boolean} [delayBetweenEachAffectsFirst=false] - Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_AudioFile} objects used by the sound instances that belong to the sprites). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. */ CB_AudioFileSprites.prototype.executeFunctionAllSprites = CB_AudioFileSprites.prototype.executeAllSprites = CB_AudioFileSprites.prototype.forEachSprite = function(functionEach, delayBetweenEach, includeWithoutSpriteAssociated, avoidCancelled, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction) { return this.executeFunctionAll(functionEach, delayBetweenEach, this.getAudioFilesUsed(true, includeWithoutSpriteAssociated, avoidCancelled), returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction); } /** * Tells whether a given sprite (by its ID) is playing or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will return true if any of them is playing. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {boolean} Returns whether a given sprite (by its ID) is playing or not. */ CB_AudioFileSprites.prototype.isPlayingSprite = function(spriteId) { var audioFiles = this.getAudioFilesUsedBySpriteId(spriteId); var audioFilesLength = audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { if (audioFiles[x].isPlaying()) { return true; } } return false; } /** * Tells whether a given sprite (by its ID) is paused or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will return true if any of them is paused. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {boolean} Returns whether a given sprite (by its ID) is paused or not. */ CB_AudioFileSprites.prototype.isPausedSprite = function(spriteId) { var audioFiles = this.getAudioFilesUsedBySpriteId(spriteId); var audioFilesLength = audioFiles.length; for (var x = 0; x &lt; audioFilesLength; x++) { if (audioFiles[x].isPaused()) { return true; } } return false; } /** * Tells whether a given sprite (by its ID) is stopped or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will only return true if all of them are stopped. * @function * @param {string} spriteId - The identifier for the sprite. * @param {boolean} [checkAudioFileObjects=false] - If set to true, it will check all the {@CB_AudioFile} objects associated to the sprite. Doing so, as internally all stopped {@CB_AudioFile} objects are disassociated from their sound instances, this method should return false normally (unless something went wrong). * @returns {boolean} Returns whether a given sprite (by its ID) is stopped or not. As internally all stopped {@CB_AudioFile} objects are disassociated from their sound instances, this method should return false normally (unless something went wrong). */ CB_AudioFileSprites.prototype.isStoppedSprite = function(spriteId, checkAudioFileObjects) { var audioFiles = this.getAudioFilesUsedBySpriteId(spriteId); var audioFilesLength = audioFiles.length; if (!checkAudioFileObjects) { return audioFilesLength === 0; //If no audio file is found, it should mean that the sound instances have been stopped. } else { for (var x = 0; x &lt; audioFilesLength; x++) { if (audioFiles[x].isStopped()) { return true; } } return false; } } /** * Plays a sprite by its ID. If the sprite is found, uses the {@link CB_AudioFileSprites#play} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. Used as the &quot;spriteId&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {boolean} [allowedRecursiveDelaySkipping=stopAt-startAt] - Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileSprites#play} method internally. * @returns {integer|null} Returns null if the sprite was not found. Otherwise, returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. */ CB_AudioFileSprites.prototype.playSprite = function(spriteId, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop) { var sprite = this.getSprite(spriteId); var soundInstance = this.play(sprite.startAt, sprite.stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, spriteId); return soundInstance; } /** * Stops all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) which are playing used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#stopAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#stop} method that were performed internally. */ CB_AudioFileSprites.prototype.stopSprite = function(spriteId) { return this.stopAll(this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Pauses all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) which are playing used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#pauseAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {function} [onPause] - Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onPause&quot; parameter to call the {@link CB_AudioFileSprites#pauseAll} method. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#pause} method that were performed internally. */ CB_AudioFileSprites.prototype.pauseSprite = function(spriteId, onPause) { return this.pauseAll(onPause, this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Resumes all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#resumeAll} method internally and returns its returning value. * @function * @param {string} spriteId - Used as the &quot;spriteId&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelaySkipping=stopAt-startAt] - Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @returns {array} Returns null if the sprite identifier given could not be found. Otherwise, returns a numeric array containing all the return values of each internal call to the {@link CB_AudioFileCache#play} method (called through {@link CB_AudioFileSprites#resumeAll}). */ CB_AudioFileSprites.prototype.resumeSprite = function(spriteId, loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop) { return this.resumeAll(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, this.getAudioFilesUsedBySpriteId(spriteId), spriteId); } /** * Mutes all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#muteAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {function} [onMute] - Callback function which will be called for each audio file if it has been possible to mute it (or at least it was possible to try it), being &quot;this&quot; the {@link CB_AudioFile} object. Used internally as the &quot;onMute&quot; parameter to call the {@link CB_AudioFileSprites#muteAll} method. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#mute} method that were performed internally. */ CB_AudioFileSprites.prototype.muteSprite = function(spriteId, onMute) { return this.muteAll(onMute, this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Unmutes all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#unmuteAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {function} [onUnmute] - Used internally as the &quot;onUnmute&quot; parameter to call the {@link CB_AudioFileSprites#unmuteAll} method. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#unmute} method that were performed internally. */ CB_AudioFileSprites.prototype.unmuteSprite = function(spriteId, onUnmute) { return this.unmuteAll(onUnmute, this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Sets the same desired volume to all the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#setVolumeAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @param {boolean} [forceSetVolumeProperty=false] - Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @param {function} [onSetVolume] - Used as the &quot;onSetVolume&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setVolume} method that were performed internally. */ CB_AudioFileSprites.prototype.setVolumeSprite = function(spriteId, volume, forceSetVolumeProperty, onSetVolume) { return this.setVolumeAll(volume, forceSetVolumeProperty, onSetVolume, this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Tries to change the desired audio API of the {@link CB_AudioFile} objects that belong to the sound instances (created by the {@link CB_AudioFileSprites#play} or the {@link CB_AudioFileSprites#playSprite} methods) used by a given sprite identifier. Uses the {@link CB_AudioFileSprites#setAudioAPIAll} method internally and returns its returning value. * @function * @param {string} spriteId - The identifier for the sprite. * @param {array} preferredAPIs - Used as the &quot;preferredAPIs&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK} [callbackOk] - Used as the &quot;callbackOk&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR} [callbackError] - Used as the &quot;callbackError&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {boolean} [mandatory=false] - Used as the &quot;mandatory&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {string} [forceReload=false] - Used as the &quot;forceReload&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setAudioAPI} method that were performed internally. */ CB_AudioFileSprites.prototype.setAudioAPISprite = function(spriteId, preferredAPIs, callbackOk, callbackError, mandatory, forceReload) { return this.setAudioAPIAll(preferredAPIs, callbackOk, callbackError, mandatory, forceReload, this.getAudioFilesUsedBySpriteId(spriteId)); } /** * Creates the desired number of internal {@link CB_AudioFile} objects (inside the {@link CB_AudioFileCache#audioFiles} property). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Uses the {@link CB_AudioFileCache#createAudioFiles} method internally and returns its returning value. * @function * @param {integer} minimumAudioFiles - Used as the &quot;minimumAudioFiles&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFiles} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects which are intended to be created (they could fail). */ CB_AudioFileSprites.prototype.createAudioFiles = function(minimumAudioFiles) { return this.audioFileCache.createAudioFiles(minimumAudioFiles); } /** * Creates one internal {@link CB_AudioFile} object (inside the {@link CB_AudioFileCache#audioFiles} property). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Uses the {@link CB_AudioFileCache#createAudioFile} method internally and returns its returning value. Internal usage only recommended. * @function * @param {CB_AudioFileCache.URIS_OBJECT} [URIs={@link CB_AudioFileCache#URIs}] - Used as the &quot;URIs&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {array} [preferredAPIs={@link CB_AudioFileCache#preferredAPIs}] - Used as the &quot;preferredAPIs&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {array} [preferredFormats={@link CB_AudioFileCache#preferredFormats}] - Used as the &quot;preferredFormats&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {CB_AudioFile} [audioObject] - Used as the &quot;audioObject&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {function} [callbackOk] - Used as the &quot;callbackOk&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {function} [callbackError] - Used as the &quot;callbackError&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {boolean} [storeURIsList=false] - Used as the &quot;storeURIsList&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @param {boolean} [checkAutomatically=false] - Used as the &quot;checkAutomatically&quot; parameter when calling the {@link CB_AudioFileCache#createAudioFile} method internally. * @returns {CB_AudioFile|null} If it fails, it returns null. Otherwise, returns the {@link CB_AudioFile} that has been created or reused. */ CB_AudioFileSprites.prototype.createAudioFile = function(URIs, preferredAPIs, preferredFormats, audioObject, callbackOk, callbackError, storeURIsList, checkAutomatically) { return this.audioFileCache.createAudioFile(URIs, preferredAPIs, preferredFormats, audioObject, callbackOk, callbackError, storeURIsList, checkAutomatically); } /** * Cleans the array of the {@link CB_AudioFile} objects (taking off the undefined or null ones) which is in the {@link CB_AudioFileCache#audioFiles} property, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Uses the {@link CB_AudioFileCache#clearAudioFiles} method internally and returns its returning value. Internal usage only recommended. * @function * @param {boolean} [avoidCallingCheckCacheLoaded=false] - Used as the &quot;avoidCallingCheckCacheLoaded&quot; parameter when calling the {@link CB_AudioFileCache#clearAudioFiles} method internally. * @returns {array} Returns the value of the {@link CB_AudioFileCache#audioFiles} property. */ CB_AudioFileSprites.prototype.clearAudioFiles = function(avoidCallingCheckCacheLoaded) { return this.audioFileCache.clearAudioFiles(avoidCallingCheckCacheLoaded); } /** * If found, takes a given {@link CB_AudioFile} object off the {@link CB_AudioFileCache#audioFiles} property (and reloads it if we want to). NOTE: It does neither destroy nor remove the {@link CB_AudioFile} object so it can be used for other purposes (and if a {@link CB_AudioFile} object is given, it will be tried to be reused by the {@link CB_AudioFileCache#createAudioFile} method internally if it is called). Uses the {@link CB_AudioFileCache#removeAudioFile} method internally and returns its returning value. Internal usage only recommended. * @function * @param {CB_AudioFile|string} audioObjectOrId - Used as the &quot;audioObjectOrId&quot; parameter when calling the {@link CB_AudioFileCache#removeAudioFile} method internally. * @param {boolean} [reload=false] - Used as the &quot;reload&quot; parameter when calling the {@link CB_AudioFileCache#removeAudioFile} method internally. * @param {boolean} [checkManually=false] - Used as the &quot;checkManually&quot; parameter when calling the {@link CB_AudioFileCache#removeAudioFile} method internally. * @returns {boolean|CB_AudioFile|null} Returns null if the given &quot;audioObjectOrId&quot; parameter is not a valid {@link CB_AudioFile} object or its {@link CB_AudioFile#id} property is not set or when the &quot;audioObjectOrId&quot; parameter is an empty string. Returns a {@link CB_AudioFile} object, the given one through the &quot;audioObjectOrId&quot; parameter of the first one removed (it should be the first and unique one removed as the ID must be unique), if the {@link CB_AudioFileCache#createAudioFile} method is called internally (it will reuse this {@link CB_AudioFile} object). Otherwise, returns true if all goes well. */ CB_AudioFileSprites.prototype.removeAudioFile = function(audioObjectOrId, reload, checkManually) { return this.audioFileCache.removeAudioFile(audioObjectOrId, reload, checkManually); } /** * Tries to purge the audio file cache until it reaches a desired number of {@link CB_AudioFile} objects internally (set in the {@link CB_AudioFileCache#audioFiles} property), by removing and destroying some of the current {@link CB_AudioFile} objects. For performance purposes. Uses the {@link CB_AudioFileCache#purge} method internally and returns its returning value. * @function * @param {integer} desiredNumber - Used as the &quot;desiredNumber&quot; parameter when calling the {@link CB_AudioFileCache#purge} method internally. * @param {boolean} [setAsMinimumAudioFiles=false] - Used as the &quot;setAsMinimumAudioFiles&quot; parameter when calling the {@link CB_AudioFileCache#purge} method internally. * @param {boolean} [includePlaying=false] - Used as the &quot;includePlaying&quot; parameter when calling the {@link CB_AudioFileCache#purge} method internally. * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling the {@link CB_AudioFileCache#purge} method internally. * @param {array} [statuses=Array({@link CB_AudioFile.LOADING}, {@link CB_AudioFile.UNCHECKED}, {@link CB_AudioFile.CHECKING}, {@link CB_AudioFile.LOADED})] - Used as the &quot;statuses&quot; parameter when calling the {@link CB_AudioFileCache#purge} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects removed. */ CB_AudioFileSprites.prototype.purge = function(desiredNumber, setAsMinimumAudioFiles, includePlaying, stopSounds, statuses) { return this.audioFileCache.purge(desiredNumber, setAsMinimumAudioFiles, includePlaying, stopSounds, statuses); } /** * Returns a free {@link CB_AudioFile} object, if any (from the {@link CB_AudioFileCache#audioFilesFree} property). Note that this will call the internal {@link CB_AudioFileCache#_createNewAudioFilesIfNeeded} method that could end creating a new {@link CB_AudioFile} object if needed. Uses the {@link CB_AudioFileCache#getFreeAudioFile} method internally and returns its returning value. * @function * @param {boolean} [popIt=false] - Used as the &quot;popIt&quot; parameter when calling the {@link CB_AudioFileCache#getFreeAudioFile} method internally. * @returns {CB_AudioFileCache.getFreeAudioFile_OBJECT} Returns a {@link CB_AudioFileCache.getFreeAudioFile_OBJECT} object. */ CB_AudioFileSprites.prototype.getFreeAudioFile = function(popIt) { return this.audioFileCache.getFreeAudioFile(popIt); } /** * Tells whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. Uses the {@link CB_AudioFileCache#isAudioFileFree} method internally and returns its returning value. * @function * @param {string} id - Used as the &quot;id&quot; parameter when calling the {@link CB_AudioFileCache#isAudioFileFree} method internally. * @returns {boolean} Returns whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. */ CB_AudioFileSprites.prototype.isAudioFileFree = function(id) { return this.audioFileCache.isAudioFileFree(id); } /** * Clears the sound instances (created by the {@link CB_AudioFileCache#play} method) which have been cancelled. Uses the {@link CB_AudioFileCache#clearSoundInstances} method internally and returns its returning value. * @function * @param {boolean} [clearWithObjectAssociated=false] - Used as the &quot;clearWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileCache#clearSoundInstances} method internally. * @returns {integer} Returns the number of cleared sound instances. */ CB_AudioFileSprites.prototype.clearSoundInstances = function(clearWithObjectAssociated) { //Clears the sound instances in the cache object: var cleared = this.audioFileCache.clearSoundInstances(clearWithObjectAssociated); var soundInstances; var soundInstancesLength; var spriteSoundInstances = {}; var sprites = this.getSprites(true); var y = 0; for (var spriteId in sprites) { spriteSoundInstances[spriteId] = []; y = 0; soundInstances = this.getSoundInstancesIdBySpriteId(spriteId); soundInstancesLength = soundInstances.length; for (var x = 0; x &lt; soundInstancesLength; x++) { if (typeof(this.audioFileCache.soundInstancesQueued[soundInstances[x]]) !== &quot;undefined&quot;) { spriteSoundInstances[spriteId][y++] = soundInstances[x]; } } } this.spriteSoundInstances = spriteSoundInstances; return cleared; } /** * Cancels (to prevent they start playing) or enables all sound instances (created by the {@link CB_AudioFileCache#play} method). Uses the {@link CB_AudioFileCache#cancelSoundInstances} method internally and returns its returning value. * @function * @param {boolean} [cancel=false] - Used as the &quot;cancel&quot; parameter when calling the {@link CB_AudioFileCache#cancelSoundInstances} method internally. * @param {boolean} [affectWithObjectAssociated=false] - Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileCache#cancelSoundInstances} method internally. * @returns {integer} Returns the number of sound instances modified. */ CB_AudioFileSprites.prototype.cancelSoundInstances = function(cancel, affectWithObjectAssociated) { return this.audioFileCache.cancelSoundInstances(cancel, affectWithObjectAssociated); } /** * Cancels (to prevent it starts playing) or enables a sound instance (created by the {@link CB_AudioFileCache#play} method), by its identifier. Uses the {@link CB_AudioFileCache#cancelSoundInstance} method internally and returns its returning value. * @function * @param {integer} soundInstanceId - Used as the &quot;soundInstanceId&quot; parameter when calling the {@link CB_AudioFileCache#cancelSoundInstance} method internally. * @param {boolean} [cancel=false] - Used as the &quot;cancel&quot; parameter when calling the {@link CB_AudioFileCache#cancelSoundInstance} method internally. * @param {boolean} [affectWithObjectAssociated=false] - Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileCache#cancelSoundInstance} method internally. * @returns {boolean} Returns true if the sound instance has been modified or false otherwise. */ CB_AudioFileSprites.prototype.cancelSoundInstance = function(soundInstanceId, cancel, affectWithObjectAssociated) { return this.audioFileCache.cancelSoundInstance(soundInstanceId, cancel, affectWithObjectAssociated); } /** * Gets the {@link CB_AudioFile} object associated to a given sound instance ID (created by the {@link CB_AudioFileCache#play} method), if any, or null otherwise. Uses the {@link CB_AudioFileCache#getAudioFileBySoundInstanceId} method internally and returns its returning value. * @function * @param {integer} soundInstanceId - Used as the &quot;soundInstanceId&quot; parameter when calling the {@link CB_AudioFileCache#getAudioFileBySoundInstanceId} method internally. * @param {boolean} [avoidCancelled=false] - Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileCache#getAudioFileBySoundInstanceId} method internally. * @returns {CB_AudioFile|null} Returns the {@link CB_AudioFile} object associated to a given sound instance ID, if any, or null otherwise. */ CB_AudioFileSprites.prototype.getAudioFileBySoundInstanceId = function(soundInstanceId, avoidCancelled) { return this.audioFileCache.getAudioFileBySoundInstanceId(soundInstanceId, avoidCancelled); } /** * Plays a sound of the cache (if there is any free), using a sprite if desired. If a sound cannot be played, this method can call itself internally again and again (with most of the given parameters being the same, depending on the circumstances) to try to play the sound until a desired time limit is reached. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). Uses the {@link CB_AudioFileCache#play} method internally and returns its returning value. Internal usage only recommended. To play a sprite, better use the {@link CB_AudioFileSprites#playSprite} method instead. * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Used as the &quot;startAt&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Used as the &quot;stopAt&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {boolean} [allowedRecursiveDelaySkipping=stopAt-startAt] - Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileCache#play} method internally. * @param {string} [spriteId='_WITHOUT_SPRITE_ASSOCIATED'] - The identifier for the sprite. Internal usage only recommended. * @returns {integer|null} Returns null if a sprite identifier was given but it could not be found. Otherwise, returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. */ CB_AudioFileSprites.prototype.play = function(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, spriteId) { if (typeof(spriteId) === &quot;undefined&quot; || spriteId === null) { spriteId = &quot;_WITHOUT_SPRITE_ASSOCIATED&quot;; } else if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return null; } //if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return null; } var soundInstance = this.audioFileCache.play(startAt, stopAt, loop, volume, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop); if (typeof(this.spriteSoundInstances[spriteId]) !== &quot;undefined&quot;) { this.spriteSoundInstances[spriteId][this.spriteSoundInstances[spriteId].length] = soundInstance; } return soundInstance; } /** * Alias for {@link CB_AudioFileSprites#executeFunctionAll}. * @function CB_AudioFileSprites#executeAll * @see {@link CB_AudioFileSprites#executeFunctionAll} */ /** * Alias for {@link CB_AudioFileSprites#executeFunctionAll}. * @function CB_AudioFileSprites#forEach * @see {@link CB_AudioFileSprites#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing {@link CB_AudioFile} objects or on the desired ones (if provided). Uses the {@link CB_AudioFileCache#executeFunctionAll} method internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Used as the &quot;functionEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - Used as the &quot;delayBetweenEach&quot; parameter when calling the {@link CB_AudioFileCache#executeFunctionAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#executeFunctionAll} method internally. * @param {boolean} [returnSetTimeoutsArray=false] - Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the {@link CB_AudioFileCache#executeFunctionAll} method internally. * @param {boolean} [delayBetweenEachAffectsFirst=false] - Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the {@link CB_AudioFileCache#executeFunctionAll} method internally. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_AudioFile} objects given in the &quot;audioFiles&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. */ CB_AudioFileSprites.prototype.executeFunctionAll = CB_AudioFileSprites.prototype.executeAll = CB_AudioFileSprites.prototype.forEach = function(functionEach, delayBetweenEach, audioFiles, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction) { return this.audioFileCache.executeFunctionAll(functionEach, delayBetweenEach, audioFiles, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, finishFunction); } /** * Destroys all the {@link CB_AudioFile} objects and frees memory, by calling {@link CB_AudioFile#destructor}(stopSounds, false, true). Uses the {@link CB_AudioFileCache#destroyAll} method internally and returns its returning value. * @function * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling the {@link CB_AudioFileCache#destroyAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#destructor} has been called. */ CB_AudioFileSprites.prototype.destroyAll = function(stopSounds) { return this.audioFileCache.destroyAll(stopSounds); } /** * Checks whether each {@link CB_AudioFile} object whose {@link CB_AudioFile#getStatus} method returns the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) can be played or not. After checking, if the audio can be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.FAILED}. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). It will call the {@link CB_AudioFileCache#clearAudioFiles} method internally after finishing. Uses the {@link CB_AudioFileCache#checkPlayingAll} method internally and returns its returning value. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). * @function * @param {CB_AudioFileCache.checkPlayingAll_CALLBACK_OK} [callbackOk] - Used as the &quot;callbackOk&quot; parameter when calling the {@link CB_AudioFileCache#checkPlayingAll} method internally. * @param {CB_AudioFileCache.checkPlayingAll_CALLBACK_ERROR} [callbackError] - Used as the &quot;callbackError&quot; parameter when calling the {@link CB_AudioFileCache#checkPlayingAll} method internally. * @param {boolean} [ignoreQueue=false] - Used as the &quot;ignoreQueue&quot; parameter when calling the {@link CB_AudioFileCache#checkPlayingAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose status belonged to the &quot;unchecked&quot; value (the value of the {@link CB_AudioFile#UNCHECKED} property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of the audio file cache is not loaded (the {@link CB_AudioFileCache#status} property does not belong to the value set in the {@link CB_AudioFileCache.LOADED} property). */ CB_AudioFileSprites.prototype.checkPlayingAll = function(callbackOk, callbackError, ignoreQueue) { return this.audioFileCache.checkPlayingAll(callbackOk, callbackError, ignoreQueue); } /** * Tries to play all the {@link CB_AudioFile} objects by calling their {@link CB_AudioFile#play} method internally. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). Uses the {@link CB_AudioFileCache#playAll} method internally and returns its returning value. * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Used as the &quot;startAt&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Used as the &quot;stopAt&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {boolean} [avoidDelayedPlay=false] - Used as the &quot;avoidDelayedPlay&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @param {boolean} [includingPlaying=false] - Used as the &quot;includingPlaying&quot; parameter when calling the {@link CB_AudioFileCache#playAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). */ CB_AudioFileSprites.prototype.playAll = function(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop, includingPlaying) { return this.audioFileCache.playAll(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop, includingPlaying); } /** * Tries to stops all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#stop} method internally. Uses the {@link CB_AudioFileCache#stopAll} method internally and returns its returning value. * @function * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#stopAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#stop} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.stopAll = function(audioFiles) { return this.audioFileCache.stopAll(audioFiles); } /** * Plays silently and stops all {@link CB_AudioFile} objects after a desired time. It can be useful for some clients which need the {@link CB_AudioFile#play} method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls {@link CB_AudioFileCache#playAll}(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the {@link CB_AudioFileCache#stopAll} method. Uses the {@link CB_AudioFileCache#playAndStopAll} method internally and returns its returning value. * @function * @param {boolean} [includingPlaying=false] - Used as the &quot;includingPlaying&quot; parameter when calling the {@link CB_AudioFileCache#playAndStopAll} method internally. * @param {number} [delayBeforeStop=100] - Used as the &quot;delayBeforeStop&quot; parameter when calling the {@link CB_AudioFileCache#playAndStopAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). */ CB_AudioFileSprites.prototype.playAndStopAll = function(includingPlaying, delayBeforeStop) { return this.audioFileCache.playAndStopAll(includingPlaying, delayBeforeStop); } /** * Tries to pause all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#pause} method internally. Uses the {@link CB_AudioFileCache#pauseAll} method internally and returns its returning value. * @function * @param {function} [onPause] - Used as the &quot;onPause&quot; parameter when calling the {@link CB_AudioFileCache#pauseAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#pauseAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#pause} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.pauseAll = function(onPause, audioFiles) { return this.audioFileCache.pauseAll(onPause, audioFiles); } /** * Resumes all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are paused (and not stopped). Can be focused on just one sprite identifier if desired. Uses the {@link CB_AudioFileCache#resumeAll} method internally and returns its returning value. Internal usage only recommended. To resume a sprite, better use the {@link CB_AudioFileSprites#resumeSprite} method instead. * @function * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelaySkipping=CB_AudioFile#lastStopAt-CB_AudioFile#lastStartAt] - Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#resumeAll} method internally. * @param {string} [spriteId='_WITHOUT_SPRITE_ASSOCIATED'] - The identifier for the sprite. Internal usage only recommended. * @returns {array} Returns null if a sprite identifier was given but it could not be found. Otherwise, returns a numeric array containing all the return values of each internal call to the {@link CB_AudioFileCache#play} method. */ CB_AudioFileSprites.prototype.resumeAll = function(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, audioFiles, spriteId) { if (typeof(spriteId) === &quot;undefined&quot; || spriteId === null) { spriteId = &quot;_WITHOUT_SPRITE_ASSOCIATED&quot;; } else if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return null; } //if (typeof(this.sprites[spriteId]) === &quot;undefined&quot; || this.sprites[spriteId] === null) { return null; } var soundInstances = this.audioFileCache.resumeAll(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, audioFiles); if (typeof(this.spriteSoundInstances[spriteId]) !== &quot;undefined&quot;) { //Stores the sound instances used by the resume (if any): var soundInstancesLength = soundInstances.length; for (var x = 0; x &lt; soundInstancesLength; x++) { this.spriteSoundInstances[spriteId][this.spriteSoundInstances[spriteId].length] = soundInstances[x]; } } return soundInstances; } /** * Mutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileCache#muteAll} method internally and returns its returning value. * @function * @param {function} [onMute] - Used as the &quot;onMute&quot; parameter when calling the {@link CB_AudioFileCache#muteAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#muteAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#mute} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.muteAll = function(onMute, audioFiles) { return this.audioFileCache.muteAll(onMute, audioFiles); } /** * Unmutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileCache#unmuteAll} method internally and returns its returning value. * @function * @param {function} [onUnmute] - Used as the &quot;onUnmute&quot; parameter when calling the {@link CB_AudioFileCache#unmuteAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#unmuteAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#unmute} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.unmuteAll = function(onUnmute, audioFiles) { return this.audioFileCache.unmuteAll(onUnmute, audioFiles); } /** * Sets the same volume for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileCache#setVolumeAll} method internally and returns its returning value. * @function * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileCache#setVolumeAll} method internally. * @param {boolean} [forceSetVolumeProperty=false] - Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the {@link CB_AudioFileCache#setVolumeAll} method internally. * @param {function} [onSetVolume] - Used as the &quot;onSetVolume&quot; parameter when calling the {@link CB_AudioFileCache#setVolumeAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#setVolumeAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setVolume} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.setVolumeAll = function(volume, forceSetVolumeProperty, onSetVolume, audioFiles) { return this.audioFileCache.setVolumeAll(volume, forceSetVolumeProperty, onSetVolume, audioFiles); } /** * Tries to change the audio API for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. Uses the {@link CB_AudioFileCache#setAudioAPIAll} method internally and returns its returning value. * @function * @param {array|string} preferredAPIs - Used as the &quot;preferredAPIs&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK} [callbackOk] - Used as the &quot;callbackOk&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @param {CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR} [callbackError] - Used as the &quot;callbackError&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @param {boolean} [mandatory=false] - Used as the &quot;mandatory&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @param {string} [forceReload=false] - Used as the &quot;forceReload&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileCache#setAudioAPIAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setAudioAPI} method that were performed (which should be the same number as the {@link CB_AudioFile} objects in the &quot;audioFiles&quot; parameter). */ CB_AudioFileSprites.prototype.setAudioAPIAll = function(preferredAPIs, callbackOk, callbackError, mandatory, forceReload, audioFiles) { return this.audioFileCache.setAudioAPIAll(preferredAPIs, callbackOk, callbackError, mandatory, forceReload, audioFiles); } /** * Tells whether any of the {@link CB_AudioFile} objects is playing or not. Uses the {@link CB_AudioFileCache#isPlaying} method internally and returns its returning value. * @function * @returns {boolean} Returns whether any of the {@link CB_AudioFile} objects is playing or not. */ CB_AudioFileSprites.prototype.isPlaying = function() { return this.audioFileCache.isPlaying(); } /** * Tells the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). Uses the {@link CB_AudioFileCache#getAudioFilesFreeNumber} method internally and returns its returning value. * @function * @returns {integer} Returns the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). */ CB_AudioFileSprites.prototype.getAudioFilesFreeNumber = function() { return this.audioFileCache.getAudioFilesFreeNumber(); } /** * Gets an array with all the {@link CB_AudioFile} objects. Uses the {@link CB_AudioFileCache#getAudioFiles} method internally and returns its returning value. * @function * @param {boolean} [copy=false] - Used as the &quot;copy&quot; parameter when calling the {@link CB_AudioFileCache#getAudioFiles} method internally. * @returns {array} Returns an array with all the {@link CB_AudioFile} objects. */ CB_AudioFileSprites.prototype.getAudioFiles = function(copy) { return this.audioFileCache.getAudioFiles(copy); } /** * Gets an array with the free {@link CB_AudioFile} objects (the objects which are available and ready to use). Uses the {@link CB_AudioFileCache#getAudioFilesFree} method internally and returns its returning value. * @function * @returns {array} Returns an array with the free {@link CB_AudioFile} objects (the objects which are available and ready to use). */ CB_AudioFileSprites.prototype.getAudioFilesFree = function() { return this.audioFileCache.getAudioFilesFree(); } /** * Gets an array with the busy {@link CB_AudioFile} objects (the objects which are not available and ready to use). Uses the {@link CB_AudioFileCache#getAudioFilesBusy} method internally and returns its returning value. * @function * @returns {array} Returns an array with the busy {@link CB_AudioFile} objects (the objects which are not available and ready to use). */ CB_AudioFileSprites.prototype.getAudioFilesBusy = function() { return this.audioFileCache.getAudioFilesBusy(); } /** * Tells the number of {@link CB_AudioFile} objects created. Uses the {@link CB_AudioFileCache#getAudioFilesNumber} method internally and returns its returning value. * @function * @param {boolean} [real=false] - Used as the &quot;real&quot; parameter when calling the {@link CB_AudioFileCache#getAudioFilesNumber} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects created. */ CB_AudioFileSprites.prototype.getAudioFilesNumber = function(real) { return this.audioFileCache.getAudioFilesNumber(real); } /** * Tells the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the {@link CB_AudioFile} objects. Uses the {@link CB_AudioFileCache#getDuration} method internally and returns its returning value. * @function * @param {boolean} [maximum=false] - Used as the &quot;maximum&quot; parameter when calling the {@link CB_AudioFileCache#getDuration} method internally. * @returns {number} Returns the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the {@link CB_AudioFile} objects. */ CB_AudioFileSprites.prototype.getDuration = function(maximum) { return this.audioFileCache.getDuration(maximum); } /** * Returns a number representing the percentage of the loading progress for the audio file sprites object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Uses the {@link CB_AudioFileCache#getProgress} method internally and returns its returning value. * @function * @param {boolean} [countLoadedObjects=false] - Used as the &quot;countLoadedObjects&quot; parameter when calling the {@link CB_AudioFileCache#getProgress} method internally. * @param {boolean} [alsoUncheckedAndCheckingObjects=false] - Used as the &quot;alsoUncheckedAndCheckingObjects&quot; parameter when calling the {@link CB_AudioFileCache#getProgress} method internally. * @returns {number} Returns a number representing the percentage of the loading progress for the audio file sprites object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFileSprites.prototype.getProgress = function(countLoadedObjects, alsoUncheckedAndCheckingObjects) { return this.audioFileCache.getProgress(countLoadedObjects, alsoUncheckedAndCheckingObjects); } /** * Gets the current status of the audio file sprites object. Uses the {@link CB_AudioFileCache#getStatus} method internally and returns its returning value. * @function * @returns {number} Returns the current status of the audio file sprites object. It is a number, which should match the value of the {@link CB_AudioFileCache.UNLOADED} (still unloaded), {@link CB_AudioFileCache.LOADING} (loading), {@link CB_AudioFileCache.UNCHECKED} (not checked by calling the {@link CB_AudioFileCache#checkPlayingAll} method yet), {@link CB_AudioFileCache.CHECKING} (being checked by the {@link CB_AudioFileCache#checkPlayingAll} method), {@link CB_AudioFileCache.LOADED} (loaded), {@link CB_AudioFileCache.FAILED} (failed loading or failed to play or by any other reason) or {@link CB_AudioFileCache.ABORTED} (aborted because it was destroyed with the &quot;destructor&quot; method) property. */ CB_AudioFileSprites.prototype.getStatus = function() { return this.audioFileCache.getStatus(); } /** * Gets the current status of the audio file sprites, as a string. Uses the {@link CB_AudioFileCache#getStatusString} method internally and returns its returning value. * @function * @returns {string} Returns the current status of the audio file sprites, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the {@link CB_AudioFileCache#status} property not recognized as any possible status). */ CB_AudioFileSprites.prototype.getStatusString = function() { return this.audioFileCache.getStatusString(); } × Search results Close "},"CrossBase_audiovisual_audio_CB_AudioFileSpritesPool.js.html":{"id":"CrossBase_audiovisual_audio_CB_AudioFileSpritesPool.js.html","title":"Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js /** * @file Audio sprites pool management. Contains the {@link CB_AudioFileSpritesPool} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Object whose property names the identifiers of each sprite (a case-sensitive string) and their value is a {@link CB_AudioFileSprites.DATA_OBJECT} object. * @example * { * &quot;sprites_group_id_1&quot; : CB_AudioFileSprites.DATA_OBJECT, * &quot;sprites_group_id_2&quot; : CB_AudioFileSprites.DATA_OBJECT, * &quot;sprites_group_id_3&quot; : CB_AudioFileSprites.DATA_OBJECT, * ... * } * @memberof CB_AudioFileSpritesPool * @typedef {Object} CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT * @property {CB_AudioFileSprites.DATA_OBJECT} spritesGroupId - Being the name of each property the unique identifier of a sprites group which will use a future internally-created {@link CB_AudioFileSprites} object, the value will always be the {@link CB_AudioFileSprites.DATA_OBJECT} that the {@link CB_AudioFileSprites} object will use to be created (received by its constructor). Some of the missing properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) will use the value set on the properties of the main {@link CB_AudioFileSpritesPool.DATA_OBJECT} object (if any) used by the {@link CB_AudioFileSpritesPool} object. If a function in the &quot;onError&quot; parameter is given, it will always be wrapped so the main error function set on the {@link CB_AudioFileSpritesPool#onError} parameter will always be called (if any) through the {@link CB_AudioFileSpritesPool#errorFunction} method. */ /** * Object with the desired data and options for the audio sprites. It is almost identical to the {@link CB_AudioFileSprites.DATA_OBJECT} but adding a &quot;spritesGroups&quot; property. * @memberof CB_AudioFileSpritesPool * @typedef {Object} CB_AudioFileSpritesPool.DATA_OBJECT * @property {CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} [spritesGroups] - Object with the desired sprites groups, containing the {@link CB_AudioFileSprites.DATA_OBJECT} objects which will be used to create the {@link CB_AudioFileSprites} objects internally. Each group will have a {@link CB_AudioFileSprites} object. It will be used as the first parameter to call the {@link CB_AudioFileSpritesPool#insertSpritesGroups} method internally. Some of the missing properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) of the {@link CB_AudioFileSprites.DATA_OBJECT} objects given will use the value set on the other properties of this object (if any). * @property {string} [id=&quot;&quot;] - Desired identifier for the object. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#id} property. * @property {array} [preferredAPIs={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS}] - Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#preferredAPIs} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;preferredAPIs&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {array} [preferredFormats={@link CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS}] - Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#preferredFormats} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;preferredFormats&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {integer} [minimumAudioFiles={@link CB_AudioFileCache.minimumAudioFiles_DEFAULT}] - Minimum {@link CB_AudioFile} objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#minimumAudioFiles} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;minimumAudioFiles&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {integer} [maximumAudioFiles={@link CB_AudioFileCache.maximumAudioFiles_DEFAULT}] - Maximum {@link CB_AudioFile} objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the {@link CB_AudioFileCache#minimumAudioFiles} property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#maximumAudioFiles} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;maximumAudioFiles&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {integer} [minimumAudioFilesFree=parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.25 + 0.5)] - New {@link CB_AudioFile} objects will be created internally when the number of free {@link CB_AudioFile} objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the {@link CB_AudioFileSpritesPool#minimumAudioFiles} by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#minimumAudioFilesFree} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;minimumAudioFilesFree&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {integer} [newAudioFilesWhenNeeded=Math.min(parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.1 + 0.5), 1)] - Number of new {@link CB_AudioFile} objects to create internally when the minimum limit of free {@link CB_AudioFile} objects ({@link CB_AudioFileSpritesPool#minimumAudioFilesFree}) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the {@link CB_AudioFileSpritesPool#minimumAudioFiles} by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#newAudioFilesWhenNeeded} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;newAudioFilesWhenNeeded&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {integer} [retries={@link CB_AudioFileCache.retries_DEFAULT}] - Number of retries to try to load a {@link CB_AudioFile} object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#retries} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;retries&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {boolean} [checkManually={@link CB_AudioFileCache.checkManually_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#checkManually} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManually&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {boolean} [checkManuallyOnNeededCreated={@link CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when creates a new {@link CB_AudioFile} object needed. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#checkManuallyOnNeededCreated} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnNeededCreated&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {boolean} [checkManuallyOnPlayingFailed={@link CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#checkManuallyOnPlayingFailed} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnPlayingFailed&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {boolean} [checkManuallyOnCheckingFailed={@link CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT}] - Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#checkManuallyOnCheckingFailed} property. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnCheckingFailed&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. * @property {function} [onLoad] - Desired function to be called once the pool has been loaded. The first and unique parameter will be an integer with the {@link CB_AudioFile} objects that still need to be checked, if any, being &quot;this&quot; the current {@link CB_AudioFileSpritesPool} object. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#onLoad} property. * @property {function} [onError] - Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current {@link CB_AudioFileSpritesPool} object. If a valid value is given, this will be added to the {@link CB_AudioFileSpritesPool#onError} property. If a function is set, it will always be called through the {@link CB_AudioFileSpritesPool#errorFunction} method whenever the &quot;onError&quot; event of an internally-created {@link CB_AudioFileSprites} object is fired. * @property {boolean} [disableAutoLoad=false] - If set to true, it will not create automatically the {@link CB_AudioFile} objects by calling the {@link CB_AudioFileCache#createAudioFiles} method internally. Internal usage only recommended. If the {@link CB_AudioFileSprites.DATA_OBJECT} object (defined in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;disableAutoLoad&quot; property, it will use the value of this property instead when creating its {@link CB_AudioFileSprites} object internally. */ /** * The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @class * @classdesc Class to manage many audio sprites stored in different groups, each with one {@link CB_AudioFileSprites} object (used internally). * @param {CB_AudioFileSpritesPool.DATA_OBJECT} [dataObject] - Object with the desired data and options for the groups of audio sprites. Each group will have a {@link CB_AudioFileSprites} object. Some of its properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) will be used as the default value to create internally the {@link CB_AudioFileSprites} objects when the value is not given in the {@link CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} object (set as the value of the {@link CB_AudioFileSpritesPool.DATA_OBJECT#spritesGroups} property). * @returns {CB_AudioFileSpritesPool} Returns a new {@link CB_AudioFileSpritesPool} object. * @todo Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). * @todo Method getCopy and static method filterProperties (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ var CB_AudioFileSpritesPool = function(dataObject) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_AudioFileSpritesPool)) { return new CB_AudioFileSpritesPool(dataObject); } //Properties and variables: /** * Stores the identifier for the audio file sprites pool object. * @var * @readonly * @type {string} * @default */ this.id = &quot;&quot;; /** * Stores an array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Internal usage only recommended. * @var * @readonly * @type {array} * @default CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS */ this.preferredAPIs = undefined; /** * Stores an array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. Internal usage only recommended. * @var * @readonly * @type {array} * @default CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS */ this.preferredFormats = undefined; /** * Minimum {@link CB_AudioFile} objects to create internally for each {@link CB_AudioFileSprites} object. It must be an integer being 1 the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default CB_AudioFileCache.minimumAudioFiles_DEFAULT */ this.minimumAudioFiles = undefined; /** * Maximum {@link CB_AudioFile} objects that are to be created internally for each {@link CB_AudioFileSprites} object. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the {@link CB_AudioFileCache#minimumAudioFiles} property, allowing 1 minimum. Internal usage only recommended. * @var * @readonly * @type {integer|null} * @default CB_AudioFileCache.maximumAudioFiles_DEFAULT */ this.maximumAudioFiles = undefined; /** * New {@link CB_AudioFile} objects will be created internally for each {@link CB_AudioFileSprites} object when the number of free {@link CB_AudioFile} objects reaches this limit. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.25 + 0.5) */ this.minimumAudioFilesFree = undefined; /** * Number of new {@link CB_AudioFile} objects to create internally for each {@link CB_AudioFileSprites} object when the minimum limit of free {@link CB_AudioFile} objects ({@link CB_AudioFileCache#minimumAudioFilesFree}) is reached. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default Math.min(parseInt({@link CB_AudioFileCache#minimumAudioFiles} * 0.1 + 0.5), 1) */ this.newAudioFilesWhenNeeded = undefined; /** * Number of retries to try to load a {@link CB_AudioFile} object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. Internal usage only recommended. * @var * @readonly * @type {integer} * @default CB_AudioFileCache.retries_DEFAULT */ this.retries = undefined; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually). Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManually_DEFAULT */ this.checkManually = undefined; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when creates a new {@link CB_AudioFile} object needed. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT */ this.checkManuallyOnNeededCreated = undefined; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT */ this.checkManuallyOnPlayingFailed = undefined; /** * Tells whether the {@link CB_AudioFile} objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT */ this.checkManuallyOnCheckingFailed = undefined; /** * If set to true, it will not create automatically the {@link CB_AudioFile} objects by calling the {@link CB_AudioFileCache#createAudioFiles} method internally. Internal usage only recommended. * @var * @readonly * @type {boolean} * @default false */ this.disableAutoLoad = undefined; /** * Desired function to be called once the pool has been loaded. The first and unique parameter will be an integer with the {@link CB_AudioFile} objects that still need to be checked, if any, being &quot;this&quot; the current {@link CB_AudioFileSpritesPool} object. * @var * @readonly * @type {function} * @default */ this.onLoad = undefined; /** * Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current {@link CB_AudioFileSpritesPool} object. If a function is set, it will always be called through the {@link CB_AudioFileSpritesPool#errorFunction} method whenever the &quot;onError&quot; event of an internally-created {@link CB_AudioFileSprites} object is fired. * @var * @readonly * @type {function} * @default */ this.onError = undefined; //Function to call if not all AudioFiles can be loaded. /** * Stores the internally-created {@link CB_AudioFileSprites} objects, using the name of each property as their group ID and the value being the {@link CB_AudioFileSprites} object itself. Internal usage only recommended. * @var * @readonly * @type {Object} * @default */ this.audioFileSprites = {}; //Object with the CB_AudioFileSprites objects. //Internal properties: this._aborted = false; this._checkSpritesGroupsLoadedTimeout = null; this._checkPlayingAllInterval; this._checkPlayingAllPerforming = false; this._setAudioAPIAllInterval; this._setAudioAPIAllPerforming = false; this._errorFunctionExecuted = false; //Calls the constructor of the object when creates an instance: return this._init(dataObject); } //Static properties and constants: /** * Status value for audio file sprites pool which is unloaded. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default 0 */ CB_AudioFileSpritesPool.UNLOADED = 0; //Status value for unloaded cache. /** * Status value for an audio file sprites pool which is loading. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.LOADING = 1; //Status value for loading cache. /** * Status value for an audio file sprites pool which has not been checked yet. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.UNCHECKED = 2; //STatus value for an unchecked cache. /** * Status value for an audio file sprites pool which is being checked currently. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.CHECKING = 3; //Status value for checking a cache. /** * Status value for an audio file sprites pool which has been loaded. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.LOADED = 4; //Status value for loaded cache. /** * Status value for an audio file sprites pool which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.FAILED = 5; //Status value for failed to load cache. /** * Status value for an audio file sprites pool which has been aborted. This will happen when the audio file sprites pool has been destroyed with the {@link CB_AudioFileSpritesPool#destructor} method. Can be used to compare the value returned by the {@link CB_AudioFileSpritesPool#getStatus} method. Recommended for internal usage only. * @constant * @type {integer} * @default */ CB_AudioFileSpritesPool.ABORTED = 6; //Status value for aborted cache. //Constructor: CB_AudioFileSpritesPool.prototype._init = function(dataObject) { /* FORMAT: dataObject = { [id : String,] [onLoad : Function,] [onError : Function,] [preferredAPIs : Array&lt;String&gt;,] [preferredFormats : Array&lt;String&gt;,] [minimumAudioFiles : Integer,] [maximumAudioFiles : Integer,] [minimumAudioFilesFree : Integer,] [newAudioFilesWhenNeeded : Integer,] [retries : Integer,] [checkManually : Boolean,] [checkManuallyOnNeededCreated : Boolean,] [checkManuallyOnPlayingFailed : Boolean,] [checkManuallyOnCheckingFailed : Boolean,] [disableAutoLoad : Boolean,] spritesGroups : { &quot;sprites_group_id&quot; : CB_AudioFileSprites.DATA_OBJECT [, ...] } }; */ //Tries to load the data (if any): this.load(dataObject); //Returns the object: return this; } /** * Destroys the audio file sprites pool object (removing all sprites, etc.), including the internal audio file sprites objects, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of all the {@link CB_AudioFileCache} objects as ABORTED ({@link CB_AudioFileCache.ABORTED} value). Internally, calls the {@link CB_AudioFileSprites#destructor} method of all the internally-created {@link CB_AudioFileSprites} objects. * @function * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling internally the {@link CB_AudioFileSprites#destructor} method of all the internally-created {@link CB_AudioFileSprites} objects. * @param {boolean} [preventAbortedStatus=false] - If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not set the {@link CB_AudioFileSpritesPool#_aborted} property to true}. Used as the &quot;preventAbortedStatus&quot; parameter when calling internally the {@link CB_AudioFileSprites#destructor} method of all the internally-created {@link CB_AudioFileSprites} objects. */ CB_AudioFileSpritesPool.prototype.destructor = function(stopSounds, preventAbortedStatus) { clearInterval(this._checkPlayingAllInterval); clearInterval(this._setAudioAPIAllInterval); clearTimeout(this._checkSpritesGroupsLoadedTimeout); //Destroys the CB_AudioFileSprites objects: for (var audioFileSpritesObject in this.audioFileSprites) { this.audioFileSprites[audioFileSpritesObject].destructor(stopSounds, preventAbortedStatus); } //Resets properties to their default value: this.preferredAPIs = undefined; this.preferredFormats = undefined; this.minimumAudioFiles = undefined; this.maximumAudioFiles = undefined; this.minimumAudioFilesFree = undefined; this.newAudioFilesWhenNeeded = undefined; this.retries = undefined; this.checkManually = undefined; this.checkManuallyOnNeededCreated = undefined; this.checkManuallyOnPlayingFailed = undefined; this.checkManuallyOnCheckingFailed = undefined; this.disableAutoLoad = undefined; this.onLoad = undefined; this.onError = undefined; this.audioFileSprites = {}; if (!preventAbortedStatus) { this._aborted = true; } } /** * Loads the audio file sprites pool with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. * @function * @param {CB_AudioFileSpritesPool.DATA_OBJECT} dataObject - Object with the desired data and options for the audio file sprites. * @returns {CB_AudioFileSpritesPool|null} If a &quot;dataObject&quot; is given, it returns the current {@link CB_AudioFileSpritesPool} object. Otherwise, it returns null. */ CB_AudioFileSpritesPool.prototype.load = function(dataObject) { if (typeof(dataObject) === &quot;undefined&quot; || dataObject === null) { return null; } //Destroys all previous data (if any): this.destructor(true, true); //Also stops all sounds. this._aborted = false; //Sanitizes the given data: dataObject.id = CB_trim(dataObject.id); //Sets the new data: if (dataObject.id !== &quot;&quot;) { this.id = dataObject.id; } if (typeof(dataObject.preferredAPIs) !== &quot;undefined&quot;) { this.preferredAPIs = dataObject.preferredAPIs; } if (typeof(dataObject.preferredFormats) !== &quot;undefined&quot;) { this.preferredFormats = dataObject.preferredFormats; } if (typeof(dataObject.minimumAudioFiles) !== &quot;undefined&quot;) { this.minimumAudioFiles = dataObject.minimumAudioFiles; } if (typeof(dataObject.maximumAudioFiles) !== &quot;undefined&quot;) { this.maximumAudioFiles = dataObject.maximumAudioFiles; } if (typeof(dataObject.minimumAudioFilesFree) !== &quot;undefined&quot;) { this.minimumAudioFilesFree = dataObject.minimumAudioFilesFree; } if (typeof(dataObject.newAudioFilesWhenNeeded) !== &quot;undefined&quot;) { this.newAudioFilesWhenNeeded = dataObject.newAudioFilesWhenNeeded; } if (typeof(dataObject.retries) !== &quot;undefined&quot;) { this.retries = dataObject.retries; } if (typeof(dataObject.checkManually) !== &quot;undefined&quot;) { this.checkManually = dataObject.checkManually; } if (typeof(dataObject.checkManuallyOnNeededCreated) !== &quot;undefined&quot;) { this.checkManuallyOnNeededCreated = dataObject.checkManuallyOnNeededCreated; } if (typeof(dataObject.checkManuallyOnPlayingFailed) !== &quot;undefined&quot;) { this.checkManuallyOnPlayingFailed = dataObject.checkManuallyOnPlayingFailed; } if (typeof(dataObject.checkManuallyOnCheckingFailed) !== &quot;undefined&quot;) { this.checkManuallyOnCheckingFailed = dataObject.checkManuallyOnCheckingFailed; } if (typeof(dataObject.disableAutoLoad) !== &quot;undefined&quot;) { this.disableAutoLoad = dataObject.disableAutoLoad; } if (typeof(dataObject.onLoad) !== &quot;undefined&quot;) { this.onLoad = dataObject.onLoad; } if (typeof(dataObject.onError) !== &quot;undefined&quot;) { this.onError = dataObject.onError; } //Inserts the CB_AudioFileSprites objects: if (typeof(dataObject.spritesGroups) !== &quot;undefined&quot; &amp;&amp; dataObject.spritesGroups !== null) { this.removeSpritesGroups(); this.insertSpritesGroups(dataObject.spritesGroups); } return this; } //Checks whether all CB_AudioFileSprites objects are loaded or not: CB_AudioFileSpritesPool.prototype._checkSpritesGroupsLoaded = function() { clearTimeout(this._checkSpritesGroupsLoadedTimeout); var allLoaded = true; var x; for (var audioFileSpritesObject in this.audioFileSprites) { x++; if (!this.audioFileSprites[audioFileSpritesObject].audioFileCache.checkManually &amp;&amp; this.audioFileSprites[audioFileSpritesObject].getStatus() !== CB_AudioFileCache.LOADED) { allLoaded = false; break; } else if (this.audioFileSprites[audioFileSpritesObject].audioFileCache.checkManually &amp;&amp; this.audioFileSprites[audioFileSpritesObject].getStatus() !== CB_AudioFileCache.UNCHECKED &amp;&amp; this.audioFileSprites[audioFileSpritesObject].getStatus() !== CB_AudioFileCache.LOADED) { allLoaded = false; break; } } if (x === 0) { allLoaded = false; } var that = this; if (this.getStatus() === CB_AudioFileSpritesPool.LOADING || this.getStatus() === CB_AudioFileSpritesPool.UNCHECKED) { if (!allLoaded) { this._checkSpritesGroupsLoadedTimeout = setTimeout(function() { that._checkSpritesGroupsLoaded.call(that); }, 100); } else { if (typeof(this.onLoad) === &quot;function&quot;) { var objectsNeedChecking = 0; var audioFiles; var audioFilesLength; var x; for (var audioFileSpritesObject in this.audioFileSprites) { audioFiles = this.audioFileSprites[audioFileSpritesObject].getAudioFiles(false); audioFilesLength = audioFiles.length; for (x = 0; x &lt; audioFilesLength; x++) { if (audioFiles[x].getStatus() === CB_AudioFile.UNCHECKED) { objectsNeedChecking++; } } } this.onLoad.call(this, objectsNeedChecking); } } } } /** * Removes all the sprites groups ({@link CB_AudioFileSprites} objects) by clearing the {@link CB_AudioFileSpritesPool#audioFileSprites} property. * @function */ CB_AudioFileSpritesPool.prototype.removeSpritesGroups = function() { this.audioFileSprites = {}; } /** * Inserts the given sprites groups. * @function * @param {CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT} sprites - Object with the desired sprites groups. * @returns {integer} Returns the number of sprites groups inserted. */ CB_AudioFileSpritesPool.prototype.insertSpritesGroups = function(spritesGroups) { var inserted = 0; var that = this; if (typeof(spritesGroups) !== &quot;undefined&quot; &amp;&amp; spritesGroups !== null) { clearTimeout(this._checkSpritesGroupsLoadedTimeout); for (var spritesGroupId in spritesGroups) { //Inserts the sprite: if (this.insertSpritesGroup(spritesGroupId, spritesGroups[spritesGroupId], true)) { inserted++; } } this._checkSpritesGroupsLoadedTimeout = setTimeout(function() { that._checkSpritesGroupsLoaded.call(that); }, 100); } return inserted; } /** * Inserts the given sprites group to the audio file sprites pool object. * @function * @param {string} spritesGroupId - The identifier for the sprites group. * @param {CB_AudioFileSprites.DATA_OBJECT} [dataObject] - Object with the data of the sprites group. Optional but recommended. * @param {boolean} [avoidCheckingLoaded=false] - If set to true, it will not check whether all sprites groups has been loaded after inserting the desired one. This is done internally by the {@link CB_AudioFileSpritesPool#_checkSpritesGroupsLoaded} method which will fire the {@link CB_AudioFileSpritesPool#onLoad} function (if any). * @returns {boolean} Returns true if the sprites group has been inserted or false otherwise. */ CB_AudioFileSpritesPool.prototype.insertSpritesGroup = function(spritesGroupId, dataObject, avoidCheckingLoaded) { if (typeof(spritesGroupId) === &quot;undefined&quot; || spritesGroupId === null) { return false; } if (typeof(dataObject) === &quot;undefined&quot; || dataObject === null) { dataObject = {}; } if (avoidCheckingLoaded) { clearTimeout(this._checkSpritesGroupsLoadedTimeout); } var dataObjectCopy = {}; dataObjectCopy.id = spritesGroupId; dataObjectCopy.preferredAPIs = dataObject.preferredAPIs; dataObjectCopy.preferredFormats = dataObject.preferredFormats; dataObjectCopy.URIs = dataObject.URIs; dataObjectCopy.minimumAudioFiles = dataObject.minimumAudioFiles; dataObjectCopy.maximumAudioFiles = dataObject.maximumAudioFiles; dataObjectCopy.minimumAudioFilesFree = dataObject.minimumAudioFilesFree; dataObjectCopy.newAudioFilesWhenNeeded = dataObject.newAudioFilesWhenNeeded; dataObjectCopy.retries = dataObject.retries; dataObjectCopy.checkManually = dataObject.checkManually; dataObjectCopy.checkManuallyOnNeededCreated = dataObject.checkManuallyOnNeededCreated; dataObjectCopy.checkManuallyOnPlayingFailed = dataObject.checkManuallyOnPlayingFailed; dataObjectCopy.checkManuallyOnCheckingFailed = dataObject.checkManuallyOnCheckingFailed; dataObjectCopy.disableAutoLoad = dataObject.disableAutoLoad; dataObjectCopy.onLoad = dataObject.onLoad; dataObjectCopy.onError = dataObject.onError; dataObjectCopy.sprites = dataObject.sprites; if (typeof(dataObjectCopy.preferredAPIs) === &quot;undefined&quot; &amp;&amp; typeof(this.preferredAPIs) !== &quot;undefined&quot;) { dataObjectCopy.preferredAPIs = this.preferredAPIs; } if (typeof(dataObjectCopy.preferredFormats) === &quot;undefined&quot; &amp;&amp; typeof(this.preferredFormats) !== &quot;undefined&quot;) { dataObjectCopy.preferredFormats = this.preferredFormats; } if (typeof(dataObjectCopy.minimumAudioFiles) === &quot;undefined&quot; &amp;&amp; typeof(this.minimumAudioFiles) !== &quot;undefined&quot;) { dataObjectCopy.minimumAudioFiles = this.minimumAudioFiles; } if (typeof(dataObjectCopy.maximumAudioFiles) === &quot;undefined&quot; &amp;&amp; typeof(this.maximumAudioFiles) !== &quot;undefined&quot;) { dataObjectCopy.maximumAudioFiles = this.maximumAudioFiles; } if (typeof(dataObjectCopy.minimumAudioFilesFree) === &quot;undefined&quot; &amp;&amp; typeof(this.minimumAudioFilesFree) !== &quot;undefined&quot;) { dataObjectCopy.minimumAudioFilesFree = this.minimumAudioFilesFree; } if (typeof(dataObjectCopy.newAudioFilesWhenNeeded) === &quot;undefined&quot; &amp;&amp; typeof(this.newAudioFilesWhenNeeded) !== &quot;undefined&quot;) { dataObjectCopy.newAudioFilesWhenNeeded = this.newAudioFilesWhenNeeded; } if (typeof(dataObjectCopy.retries) === &quot;undefined&quot; &amp;&amp; typeof(this.retries) !== &quot;undefined&quot;) { dataObjectCopy.retries = this.retries; } if (typeof(dataObjectCopy.checkManually) === &quot;undefined&quot; &amp;&amp; typeof(this.checkManually) !== &quot;undefined&quot;) { dataObjectCopy.checkManually = this.checkManually; } if (typeof(dataObjectCopy.checkManuallyOnNeededCreated) === &quot;undefined&quot; &amp;&amp; typeof(this.checkManuallyOnNeededCreated) !== &quot;undefined&quot;) { dataObjectCopy.checkManuallyOnNeededCreated = this.checkManuallyOnNeededCreated; } if (typeof(dataObjectCopy.checkManuallyOnPlayingFailed) === &quot;undefined&quot; &amp;&amp; typeof(this.checkManuallyOnPlayingFailed) !== &quot;undefined&quot;) { dataObjectCopy.checkManuallyOnPlayingFailed = this.checkManuallyOnPlayingFailed; } if (typeof(dataObjectCopy.checkManuallyOnCheckingFailed) === &quot;undefined&quot; &amp;&amp; typeof(this.checkManuallyOnCheckingFailed) !== &quot;undefined&quot;) { dataObjectCopy.checkManuallyOnCheckingFailed = this.checkManuallyOnCheckingFailed; } if (typeof(dataObjectCopy.disableAutoLoad) === &quot;undefined&quot; &amp;&amp; typeof(this.disableAutoLoad) !== &quot;undefined&quot;) { dataObjectCopy.disableAutoLoad = this.disableAutoLoad; } //Wraps the error function: var that = this; var onErrorOld = dataObjectCopy.onError; dataObjectCopy.onError = function(error) { if (typeof(onErrorOld) === &quot;function&quot;) { onErrorOld.call(this, error); } setTimeout(function() { that.errorFunction.call(that, error); }, 100); }; this._errorFunctionExecuted = false; //Allows the execution of the error function again. this.audioFileSprites[spritesGroupId] = new CB_AudioFileSprites(dataObjectCopy); if (!avoidCheckingLoaded) { this._checkSpritesGroupsLoadedTimeout = setTimeout(function() { that._checkSpritesGroupsLoaded.call(that); }, 100); } return true; } /** * Removes a sprites group by its ID. * @function * @param {string} spritesGroupId - The identifier for the sprites group. * @param {boolean} [destroy=false] - If set to true, it will call the {@link CB_AudioFileSprites#destructor} method of the {@link CB_AudioFileSprites} object which belongs to the desired sprites group. * @param {boolean} [stopSounds=false] - If the &quot;destroy&quot; parameter is set to false, this parameter will be ignored. Used as the &quot;stopSound&quot; parameter when calling internally the {@link CB_AudioFileSprites#destructor} method of the {@link CB_AudioFileSprites} object which belongs to the desired sprites group. * @param {boolean} [preventAbortedStatus=false] - If the &quot;destroy&quot; parameter is set to false, this parameter will be ignored. Used as the &quot;preventAbortedStatus&quot; parameter when calling internally the {@link CB_AudioFileSprites#destructor} method of the {@link CB_AudioFileSprites} object which belongs to the desired sprites group. * @returns {boolean} Returns true if the sprites group has been deleted or false otherwise. */ CB_AudioFileSpritesPool.prototype.removeSpritesGroup = function(spritesGroupId, destroy, stopSounds, preventAbortedStatus) { if (typeof(this.audioFileSprites[spritesGroupId]) !== &quot;undefined&quot; &amp;&amp; this.audioFileSprites[spritesGroupId] !== null) { if (destroy) { this.audioFileSprites[spritesGroupId].destructor(stopSounds, preventAbortedStatus); } this.audioFileSprites[spritesGroupId] = null; var audioFileSprites = {}; for (spritesGroupId in this.audioFileSprites) { if (typeof(this.audioFileSprites[spritesGroupId]) !== &quot;undefined&quot; &amp;&amp; this.audioFileSprites[spritesGroupId] !== null) { audioFileSprites[spritesGroupId] = this.audioFileSprites[spritesGroupId]; } } this.audioFileSprites = audioFileSprites; return true; } return false; } /** * Returns a sprites group (the {@link CB_AudioFileSprites} object) by its ID. * @function * @param {string} spritesGroupId - The identifier for the sprites group. * @param {boolean} [withoutChecking=false] - If set to true and the sprites group cannot be found, the method will return undefined (or whatever is stored by the given ID) instead of null. * @returns {CB_AudioFileSprites|undefined|*|null} Returns null if the &quot;withoutChecking&quot; parameter is set to true and the sprites group cannot be found. Otherwise, it will return what is stored internally by the given ID which can be a {@link CB_AudioFileSprites} object if found or undefined (or whatever is stored by the given ID) if not found. */ CB_AudioFileSpritesPool.prototype.getSpritesGroup = function(spritesGroupId, withoutChecking) { //return this.audioFileSprites[spritesGroupId]; if (typeof(this.audioFileSprites[spritesGroupId]) !== &quot;undefined&quot; || withoutChecking) { return this.audioFileSprites[spritesGroupId]; } return null; } /** * Returns an object with the sprites groups (all the internally-created {@link CB_AudioFileSprites} objects), being the name of each property their group ID and the value being the {@link CB_AudioFileSprites} object itself. Internally, it just returns the {@link CB_AudioFileSpritesPool#audioFileSprites} property. * @function * @returns {Object} Returns an object with the sprites groups (all the internally-created {@link CB_AudioFileSprites} objects), being the name of each property their group ID and the value being the {@link CB_AudioFileSprites} object itself. Internally, it just returns the {@link CB_AudioFileSpritesPool#audioFileSprites} property. */ CB_AudioFileSpritesPool.prototype.getSpritesGroups = function() { return this.audioFileSprites; } /** * Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). Internally, uses the {@link CB_AudioFileSprites#getSprites} method. * @function * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, the returning object will also contain a property called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; whose value will be an empty object (unless the &quot;orderBySpritesGroup&quot; parameter is set to true and the property existed before in the object stored in the {@link CB_AudioFileSprites#sprites} property and had a value which is not an empty object). If set to false and the &quot;orderBySpritesGroup&quot; parameter is also set to false, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property. If set to false and the &quot;orderBySpritesGroup&quot; parameter is set to true, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property unless the property existed before in the object stored in the {@link CB_AudioFileSprites#sprites} property. * @param {boolean} [orderBySpritesGroup=false] - If set to false, it will return a {@link CB_AudioFileSprites.SPRITES_OBJECT} object whose properties will be the ID of each sprite (each sprite ID should be unique) and their value will be a {@link CB_AudioFileSprites.SPRITE_OBJECT} object. If set to true, it will return an object whose properties will be the ID of each sprites group and the value will be a {@link CB_AudioFileSprites.SPRITES_OBJECT} object which will include its sprites. * @returns {CB_AudioFileSprites.SPRITES_OBJECT|Object} If the &quot;orderBySpritesGroup&quot; is set to false, it will return a {@link CB_AudioFileSprites.SPRITES_OBJECT} object whose properties will be the ID of each sprite (each sprite ID should be unique) and their value will be a {@link CB_AudioFileSprites.SPRITE_OBJECT} object. If the &quot;orderBySpritesGroup&quot; is set to true, it will return an object whose properties will be the ID of each sprites group and the value will be a {@link CB_AudioFileSprites.SPRITES_OBJECT} object which will include its sprites. */ CB_AudioFileSpritesPool.prototype.getSprites = function(includeWithoutSpriteAssociated, orderBySpritesGroup) { var sprites = {}; if (!orderBySpritesGroup) { if (includeWithoutSpriteAssociated) { sprites[&quot;_WITHOUT_SPRITE_ASSOCIATED&quot;] = {}; } var spritesLoop; var spriteId; for (var spritesGroupId in this.audioFileSprites) { spritesLoop = this.audioFileSprites[spritesGroupId].getSprites(false); for (spriteId in spritesLoop) { sprites[spriteId] = spritesLoop[spriteId]; } } } else { for (var spritesGroupId in this.audioFileSprites) { sprites[spritesGroupId] = this.audioFileSprites[spritesGroupId].getSprites(includeWithoutSpriteAssociated); } } return sprites; } /** * Returns the sound instances (their ID) used (stored in the {@link CB_AudioFileSprites#spriteSoundInstances} property of each {@link CB_AudioFileSprites} object). * @function * @param {boolean} [oneDimension=false] - If set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the {@link CB_AudioFileSprites#spriteSoundInstances} property of each {@link CB_AudioFileSprites} object (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated) which belongs to that sprites group. Otherwise, if it is set to true, it will return a numeric array whose values are the sound instance IDs. * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, it will also return the sound instance identifiers which are not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#getSoundInstancesId} method internally. Only used when the &quot;oneDimension&quot; parameter is set to true. * @returns {Object|array} Returns the sound instances (their ID) used (stored in the {@link CB_AudioFileSprites#spriteSoundInstances} property). If the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the {@link CB_AudioFileSprites#spriteSoundInstances} property of each {@link CB_AudioFileSprites} object (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated) which belongs to that sprites group. If the &quot;oneDimension&quot; parameter is set to true, it will return a numeric array whose values are the sound instance identifiers (if the &quot;includeWithoutSpriteAssociated&quot; parameter it set to true, it will also include the sound instances which are not associated to any sprite). */ CB_AudioFileSpritesPool.prototype.getSoundInstancesId = function(oneDimension, includeWithoutSpriteAssociated) { var soundInstances; if (!oneDimension) { soundInstances = {}; for (var spritesGroupId in this.audioFileSprites) { soundInstances[spritesGroupId] = this.audioFileSprites[spritesGroupId].getSoundInstancesId(false, includeWithoutSpriteAssociated); } } else { soundInstances = []; var soundInstancesSpritesGroup; var soundInstancesSpritesGroupLength; var y = 0; var x = 0; for (var spritesGroupId in this.audioFileSprites) { soundInstancesSpritesGroup = this.audioFileSprites[spritesGroupId].getSoundInstancesId(true, includeWithoutSpriteAssociated); soundInstancesSpritesGroupLength = soundInstancesSpritesGroup.length; for (x = 0; x &lt; soundInstancesSpritesGroupLength; x++) { soundInstances[y++] = soundInstancesSpritesGroup[x]; } } } return soundInstances; } /** * Object returned by the {@link CB_AudioFileSpritesPool#getAudioFilesUsed} method. Each property names will be the the ID of each sprites group and their value will be a {@link CB_AudioFileSprites.getAudioFilesUsed_OBJECT} object. * @memberof CB_AudioFileSpritesPool * @typedef {Object} CB_AudioFileSpritesPool.getAudioFilesUsed_OBJECT * @property {CB_AudioFileSpritesPool.getAudioFilesUsed_OBJECT} spriteId - Each property names will be the the ID of each sprites group and their value will be a {@link CB_AudioFileSprites.getAudioFilesUsed_OBJECT} object. */ /** * Returns the {@link CB_AudioFile} objects used by all the sounds instances of all the sprites groups. * @function * @param {boolean} [oneDimension=false] - If set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the an object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the {@link CB_AudioFile} objects used. Otherwise, if set to true, it will return a numeric array with the {@link CB_AudioFile} objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite). * @param {boolean} [includeWithoutSpriteAssociated=false] - If set to true, it will also return the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsed} method internally. * @param {boolean} [avoidCancelled=false] - If set to true, it will not return the {@link CB_AudioFile} objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesUsed} method internally. * @returns {CB_AudioFileSprites.getAudioFilesUsed_OBJECT|array} Returns the {@link CB_AudioFile} objects used by all the sounds instances of all the sprites groups. If the &quot;oneDimension&quot; parameter is set to false, it will return a {@link CB_AudioFileSpritesPool.getAudioFilesUsed_OBJECT} object whose property names will be the ID of each sprites group and their value will be a {@link CB_AudioFileSprites.getAudioFilesUsed_OBJECT} object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the {@link CB_AudioFile} objects used. Otherwise, if the &quot;oneDimension&quot; parameter set to true, it will return a numeric array with the {@link CB_AudioFile} objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the {@link CB_AudioFile} objects whose sound instance ID is not associated to any sprite). */ CB_AudioFileSpritesPool.prototype.getAudioFilesUsed = function(oneDimension, includeWithoutSpriteAssociated, avoidCancelled) { var audioFiles; if (!oneDimension) { audioFiles = {}; for (var spritesGroupId in this.audioFileSprites) { audioFiles[spritesGroupId] = this.audioFileSprites[spritesGroupId].getAudioFilesUsed(false, includeWithoutSpriteAssociated, avoidCancelled); } } else { audioFiles = []; var audioFilesSpritesGroup; var audioFilesSpritesGroupLength; var y = 0; var x = 0; for (var spritesGroupId in this.audioFileSprites) { audioFilesSpritesGroup = this.audioFileSprites[spritesGroupId].getAudioFilesUsed(true, includeWithoutSpriteAssociated, avoidCancelled); audioFilesSpritesGroupLength = audioFilesSpritesGroup.length; for (x = 0; x &lt; audioFilesSpritesGroupLength; x++) { audioFiles[y++] = audioFilesSpritesGroup[x]; } } } return audioFiles; } /** * Callback that is used when finishes all iterations after looping through the items. Being &quot;this&quot; an array with all the items. * @memberof CB_AudioFileSpritesPool * @callback CB_AudioFileSpritesPool.executeFunctionAll_ON_FINISH_CALLBACK * @param {array} array - An array with all the items which were being looped. * @param {integer} itemsAffected - The number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null). * @param {integer} delayMaximum - The maximum &quot;delay&quot; used. */ /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAllSprites}. * @function CB_AudioFileSpritesPool#executeAllSprites * @see {@link CB_AudioFileSpritesPool#executeFunctionAllSprites} */ /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAllSprites}. * @function CB_AudioFileSpritesPool#forEachSprite * @see {@link CB_AudioFileSpritesPool#executeFunctionAllSprites} */ /** * Executes a desired function for all the {@link CB_AudioFile} objects used by all the sound instances currently created of each sprite group. It calls the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Used as the &quot;functionEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - Used as the &quot;delayBetweenEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. Note that each call to the {@link CB_AudioFileSprites#executeFunctionAllSprites} method will be performed sequentially one after the other, without adding a delay. * @param {boolean} [includeWithoutSpriteAssociated=false] - Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. * @param {boolean} [avoidCancelled=false] - Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. * @param {boolean} [delayBetweenEachAffectsFirst=false] - Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAllSprites} method internally. Internal usage only recommended. Note that each call to the {@link CB_AudioFileSprites#executeFunctionAllSprites} method will be performed sequentially one after the other, without adding a delay. * @param {CB_AudioFileSpritesPool.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array containing all the items which were looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer} It will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_AudioFile} objects used by the sound instances that belong to the sprites of each sprites group). Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about implementing a &quot;returnSetTimeoutsArray&quot; or similar (as in {@link CB_AudioFileSprites#executeFunctionAllSprites}). * @todo Think about consider executing only one by one (now it will loop {@link CB_AudioFile} objects from different sprites groups simultaneously). */ CB_AudioFileSpritesPool.prototype.executeFunctionAllSprites = CB_AudioFileSpritesPool.prototype.executeAllSprites = CB_AudioFileSpritesPool.prototype.forEachSprite = function(functionEach, delayBetweenEach, includeWithoutSpriteAssociated, avoidCancelled, delayBetweenEachAffectsFirst, functionFinish) { var spritesGroups = 0; for (var spritesGroupId in this.audioFileSprites) { spritesGroups++; } //Counts the number of sprites groups. var functionFinishLoopTimes = 0; var functionFinishLoop = function(array, itemsAffected, delay) { functionFinishLoopTimes++; for (var x = 0; x &lt; itemsAffected.length; x++) { arrayAllItems[arrayAllItems.length] = itemsAffected[x]; } //If it is the last time, calls the finish function: if (spritesGroups === functionFinishLoopTimes &amp;&amp; typeof(functionFinish) === &quot;function&quot;) { functionFinish.call(arrayAllItems, arrayAllItems, performed, delay); } }; var arrayAllItems = []; var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].executeFunctionAllSprites(functionEach, delayBetweenEach, includeWithoutSpriteAssociated, avoidCancelled, false, delayBetweenEachAffectsFirst, functionFinishLoop); //The desired delay (if any) will only start affecting after the first call. } return performed; } /** * Cleans the arrays of the {@link CB_AudioFile} objects (taking off the undefined or null ones) which is in the {@link CB_AudioFileCache#audioFiles} property used by each {@link CB_AudioFileSprites} object, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Uses the {@link CB_AudioFileSprites#clearAudioFiles} method internally. Internal usage only recommended. * @function * @param {boolean} [avoidCallingCheckCacheLoaded=false] - Used as the &quot;avoidCallingCheckCacheLoaded&quot; parameter when calling the {@link CB_AudioFileSprites#clearAudioFiles} method internally. * @returns {array} Returns an object whose each property name is the sprites group ID and each value is the returning value of calling internally the {@link CB_AudioFileSprites#clearAudioFiles} method. */ CB_AudioFileSpritesPool.prototype.clearAudioFiles = function(avoidCallingCheckCacheLoaded) { var audioFiles = {}; for (var spritesGroupId in this.audioFileSprites) { audioFiles[spritesGroupId] = this.audioFileSprites[spritesGroupId].clearAudioFiles(avoidCallingCheckCacheLoaded); } return audioFiles; } /** * Tries to purge the audio file cache of each {@link CB_AudioFileSprites} object until it reaches a desired number of {@link CB_AudioFile} objects internally (set in the {@link CB_AudioFileCache#audioFiles} property), by removing and destroying some of the current {@link CB_AudioFile} objects. Note that the desired number is for each {@link CB_AudioFileSprites} object and not a global number. For performance purposes. Uses the {@link CB_AudioFileSprites#purge} method internally. * @function * @param {integer} desiredNumber - Used as the &quot;desiredNumber&quot; parameter when calling the {@link CB_AudioFileSprites#purge} method internally. Note that the desired number is for each {@link CB_AudioFileSprites} object and not a global number. * @param {boolean} [setAsMinimumAudioFiles=false] - Used as the &quot;setAsMinimumAudioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#purge} method internally. * @param {boolean} [includePlaying=false] - Used as the &quot;includePlaying&quot; parameter when calling the {@link CB_AudioFileSprites#purge} method internally. * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling the {@link CB_AudioFileSprites#purge} method internally. * @param {array} [statuses=Array({@link CB_AudioFile.LOADING}, {@link CB_AudioFile.UNCHECKED}, {@link CB_AudioFile.CHECKING}, {@link CB_AudioFile.LOADED})] - Used as the &quot;statuses&quot; parameter when calling the {@link CB_AudioFileSprites#purge} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects removed. */ CB_AudioFileSpritesPool.prototype.purge = function(desiredNumber, setAsMinimumAudioFiles, includePlaying, stopSounds, statuses) { var objectsRemoved = 0; for (var spritesGroupId in this.audioFileSprites) { objectsRemoved += this.audioFileSprites[spritesGroupId].purge(desiredNumber, setAsMinimumAudioFiles, includePlaying, stopSounds, statuses); } return objectsRemoved; } /** * Tells whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property of any {@link CB_AudioFileSprites} object) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. Uses the {@link CB_AudioFileSprites#isAudioFileFree} method internally. * @function * @param {string} id - Used as the &quot;id&quot; parameter when calling the {@link CB_AudioFileSprites#isAudioFileFree} method internally. * @returns {boolean} Returns whether a desired {@link CB_AudioFile} object is free (it is in the {@link CB_AudioFileCache#audioFilesFree} property of any {@link CB_AudioFileSprites} object) or not, by its identifier. A free {@link CB_AudioFile} object is an object which is not being used and it is available to be used. */ CB_AudioFileSpritesPool.prototype.isAudioFileFree = function(id) { for (var spritesGroupId in this.audioFileSprites) { if (this.audioFileSprites[spritesGroupId].isAudioFileFree(id)) { return true; } } return false; } /** * Clears the sound instances (created by the {@link CB_AudioFileCache#play} method) which have been cancelled. Uses the {@link CB_AudioFileSprites#clearSoundInstances} method internally. * @function * @param {boolean} [clearWithObjectAssociated=false] - Used as the &quot;clearWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#clearSoundInstances} method internally. * @returns {integer} Returns the number of cleared sound instances. */ CB_AudioFileSpritesPool.prototype.clearSoundInstances = function(clearWithObjectAssociated) { var cleared = 0; for (var spritesGroupId in this.audioFileSprites) { cleared += this.audioFileSprites[spritesGroupId].clearSoundInstances(clearWithObjectAssociated); } return cleared; } /** * Cancels (to prevent they start playing) or enables all sound instances (created by the {@link CB_AudioFileCache#play} method). Uses the {@link CB_AudioFileSprites#cancelSoundInstances} method internally. * @function * @param {boolean} [cancel=false] - Used as the &quot;cancel&quot; parameter when calling the {@link CB_AudioFileSprites#cancelSoundInstances} method internally. * @param {boolean} [affectWithObjectAssociated=false] - Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#cancelSoundInstances} method internally. * @returns {integer} Returns the number of sound instances modified. */ CB_AudioFileSpritesPool.prototype.cancelSoundInstances = function(cancel, affectWithObjectAssociated) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].cancelSoundInstances(cancel, affectWithObjectAssociated); } return performed; } /** * Cancels (to prevent it starts playing) or enables a sound instance (created by the {@link CB_AudioFileCache#play} method), by its identifier. Uses the {@link CB_AudioFileSprites#cancelSoundInstance} method internally. * @function * @param {integer} soundInstanceId - Used as the &quot;soundInstanceId&quot; parameter when calling the {@link CB_AudioFileSprites#cancelSoundInstance} method internally. * @param {boolean} [cancel=false] - Used as the &quot;cancel&quot; parameter when calling the {@link CB_AudioFileSprites#cancelSoundInstance} method internally. * @param {boolean} [affectWithObjectAssociated=false] - Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the {@link CB_AudioFileSprites#cancelSoundInstance} method internally. * @returns {boolean} Returns true if the sound instance has been modified or false otherwise. */ CB_AudioFileSpritesPool.prototype.cancelSoundInstance = function(soundInstanceId, cancel, affectWithObjectAssociated) { for (var spritesGroupId in this.audioFileSprites) { if (this.audioFileSprites[spritesGroupId].cancelSoundInstance(soundInstanceId, cancel, affectWithObjectAssociated)) { return true; } } return false; } /** * Gets the {@link CB_AudioFile} object associated to a given sound instance ID (created by the {@link CB_AudioFileCache#play} method), if any, or null otherwise. Uses the {@link CB_AudioFileSprites#getAudioFileBySoundInstanceId} method internally. * @function * @param {integer} soundInstanceId - Used as the &quot;soundInstanceId&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFileBySoundInstanceId} method internally. * @param {boolean} [avoidCancelled=false] - Used as the &quot;avoidCancelled&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFileBySoundInstanceId} method internally. * @returns {CB_AudioFile|null} Returns the {@link CB_AudioFile} object associated to a given sound instance ID, if any, or null otherwise. */ CB_AudioFileSpritesPool.prototype.getAudioFileBySoundInstanceId = function(soundInstanceId, avoidCancelled) { var audioFile; for (var spritesGroupId in this.audioFileSprites) { audioFile = this.audioFileSprites[spritesGroupId].getAudioFileBySoundInstanceId(soundInstanceId, avoidCancelled); if (typeof(audioFile) !== &quot;undefined&quot; &amp;&amp; audioFile !== null) { return audioFile; } } return null; } /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAll}. * @function CB_AudioFileSpritesPool#executeAll * @see {@link CB_AudioFileSpritesPool#executeFunctionAll} */ /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAll}. * @function CB_AudioFileSpritesPool#forEach * @see {@link CB_AudioFileSpritesPool#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing {@link CB_AudioFile} objects or on the desired ones (if provided). Uses the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @function * @param {CB_Arrays.CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Used as the &quot;functionEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - Used as the &quot;delayBetweenEach&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. Note that each call to the {@link CB_AudioFileSprites#executeFunctionAll} method will be performed sequentially one after the other, without adding a delay. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. * @param {boolean} [returnArrayOfSetTimeoutsArray=false] - If it is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed. Otherwise, if it is set to true, it will return a numeric array and each value (which will belong to each sprites group) will be another numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} of that sprites group. * @param {boolean} [delayBetweenEachAffectsFirst=false] - Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the {@link CB_AudioFileSprites#executeFunctionAll} method internally. Note that each call to the {@link CB_AudioFileSprites#executeFunctionAll} method will be performed sequentially one after the other, without adding a delay. * @param {CB_AudioFileSpritesPool.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array containing all the items which were looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnArrayOfSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed. Otherwise, if the &quot;returnArrayOfSetTimeoutsArray&quot; is set to true, it will return a numeric array and each value will be another numeric array with a {@link CB_AudioFileCache.executeFunctionAll_OBJECT} object for each {@link CB_AudioFile} given. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about consider executing only one by one (now it will loop {@link CB_AudioFile} objects from different sprites groups simultaneously). */ CB_AudioFileSpritesPool.prototype.executeFunctionAll = CB_AudioFileSpritesPool.prototype.executeAll = CB_AudioFileSpritesPool.prototype.forEach = function(functionEach, delayBetweenEach, audioFiles, returnArrayOfSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { var spritesGroups = 0; for (var spritesGroupId in this.audioFileSprites) { spritesGroups++; } //Counts the number of sprites groups. var functionFinishLoopTimes = 0; var functionFinishLoop = function(array, itemsAffected, delay) { functionFinishLoopTimes++; for (var x = 0; x &lt; itemsAffected.length; x++) { arrayAllItems[arrayAllItems.length] = itemsAffected[x]; } //If it is the last time, calls the finish function: if (spritesGroups === functionFinishLoopTimes &amp;&amp; typeof(functionFinish) === &quot;function&quot;) { functionFinish.call(arrayAllItems, arrayAllItems, performed, delay); } }; var arrayAllItems = []; if (returnArrayOfSetTimeoutsArray) { var arrayOfSetTimeoutsObjects = []; for (var spritesGroupId in this.audioFileSprites) { arrayOfSetTimeoutsObjects[arrayOfSetTimeoutsObjects.length] = this.audioFileSprites[spritesGroupId].executeFunctionAll(functionEach, delayBetweenEach, audioFiles, true, delayBetweenEachAffectsFirst, functionFinishLoop); //The desired delay (if any) will only start affecting after the first call. } return arrayOfSetTimeoutsObjects; } else { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].executeFunctionAll(functionEach, delayBetweenEach, audioFiles, false, delayBetweenEachAffectsFirst, functionFinishLoop); //The desired delay (if any) will only start affecting after the first call. } return performed; } } /** * Destroys all the {@link CB_AudioFile} objects and frees memory, by calling {@link CB_AudioFile#destructor}(stopSounds, false, true). Uses the {@link CB_AudioFileSprites#destroyAll} method internally. * @function * @param {boolean} [stopSounds=false] - Used as the &quot;stopSounds&quot; parameter when calling the {@link CB_AudioFileSprites#destroyAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#destructor} has been called. */ CB_AudioFileSpritesPool.prototype.destroyAll = function(stopSounds) { var destroyed = 0; for (var spritesGroupId in this.audioFileSprites) { destroyed += this.audioFileSprites[spritesGroupId].destroyAll(stopSounds); } return destroyed; } /** * Callback function used by the {@link CB_AudioFileSpritesPool#checkPlayingAll} method that will be called when all the process was performed successfully. * @memberof CB_AudioFileSpritesPool * @callback CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_OK * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that can be played. * @param {integer} uncheckedObjects - The number of {@link CB_AudioFile} objects that needed to be checked before calling this method. */ /** * Callback function used by the {@link CB_AudioFileSpritesPool#checkPlayingAll} method that will be called when not all was performed successfully. * @memberof CB_AudioFileSpritesPool * @callback CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR * @param {Object} errorsObject - Object whose property names are the ID of each sprites group or &quot;GENERAL_ERROR&quot; if the error is not related to any sprites group and their value will be a {@link CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR_OBJECT} object. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that can be played). * @param {integer|undefined} uncheckedObjects - The number of {@link CB_AudioFile} objects that needed to be checked before calling this method (it will be undefined if it could not be determined). */ /** * An object with errors, used by the {@link CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR} callback (used by the {@link CB_AudioFileSpritesPool#checkPlayingAll} method). * @memberof CB_AudioFileSpritesPool * @typedef {Object} CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR_OBJECT * @property {string} error - A string describing the error (if it was possible to be determined). * @property {integer} checked - The number of {@link CB_AudioFile} objects that can be played. * @property {integer|undefined} needed - The number of {@link CB_AudioFile} objects that needed to be checked before calling this method (it will be undefined if it could not be determined). */ /** * Checks whether each {@link CB_AudioFile} object whose {@link CB_AudioFile#getStatus} method returns the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) can be played or not. After checking, if the audio can be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.LOADED}. Otherwise, if it cannot be played, the status of the {@link CB_AudioFile} object will get the value of {@link CB_AudioFile.FAILED}. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). It will call the {@link CB_AudioFileCache#clearAudioFiles} method internally after finishing each call to the {@link CB_AudioFileSprites#checkPlayingAll} method. Uses the {@link CB_AudioFileSprites#checkPlayingAll} method internally. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). * @function * @param {CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_OK} [callbackOk] - A function which will be called if all the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returned the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) could finally be checked successfully and all can be played, being &quot;this&quot; the {@link CB_AudioFileSpritesPool} object itself. * @param {CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR} [callbackError] - A function which will be called if not all the {@link CB_AudioFile} objects whose {@link CB_AudioFile#getStatus} method returned the &quot;unchecked&quot; value (which belongs to the value of the {@link CB_AudioFile#UNCHECKED} property) could finally be checked successfully and any cannot be played, being &quot;this&quot; the {@link CB_AudioFileSpritesPool} object itself. This function will be called immediately if the method was previously called and it is still running currently. * @param {boolean} [ignoreQueue=false] - Used as the &quot;ignoreQueue&quot; parameter when calling the {@link CB_AudioFileSprites#checkPlayingAll} method internally. * @param {boolean} [ignoreStatus=false] - If it is set to false and the sprites pool object is loaded (the {@link CB_AudioFileSpritesPool#getStatus} method returns the value set in the {@link CB_AudioFileSpritesPool.LOADED} property), it will exit returning an error. Otherwise, if it is set to true, it will ignore the current sprites pool object status. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose status belonged to the &quot;unchecked&quot; value (the value of the {@link CB_AudioFile#UNCHECKED} property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of audio sprites pool is neither loaded (the {@link CB_AudioFileSpritesPool#getStatus} method does not returns the value set in the {@link CB_AudioFileSpritesPool.LOADED} property) nor unchecked (the {@link CB_AudioFileSpritesPool#status} method does not return the value set in the {@link CB_AudioFileSpritesPool.UNCHECKED} property). */ CB_AudioFileSpritesPool.prototype.checkPlayingAll = function(callbackOk, callbackError, ignoreQueue, ignoreStatus) { var errorMessage = &quot;&quot;; if (this._checkPlayingAllPerforming) { errorMessage = &quot;Method checkPlayingAll is being processed. Cannot be called again until it finishes.&quot;; } else if (!ignoreStatus &amp;&amp; this.getStatus() !== CB_AudioFileSpritesPool.LOADED &amp;&amp; this.getStatus() !== CB_AudioFileSpritesPool.UNCHECKED) { errorMessage = &quot;Sprites pool is not loaded.&quot;; } if (errorMessage !== &quot;&quot;) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call ( this, { &quot;GENERAL_ERROR&quot; : { &quot;error&quot; : errorMessage, &quot;checked&quot; : 0 } }, 0, undefined ); } return 0; } this._checkPlayingAllPerforming = true; clearInterval(this._checkPlayingAllInterval); var uncheckedObjects = 0; var failed = 0; var succeeded = 0; var needed = 0; var objectsChecked = 0; var errorsChecking = {}; for (var spritesGroupId in this.audioFileSprites) { uncheckedObjects += this.audioFileSprites[spritesGroupId].checkPlayingAll ( function(performedActions) //callbackOk: { objectsChecked += performedActions; succeeded++; }, function(error, performedActions, needed) //callbackError: { objectsChecked += performedActions; failed++; errorsChecking[spritesGroupId] = {}; errorsChecking[spritesGroupId].error = error; errorsChecking[spritesGroupId].checked = performedActions; errorsChecking[spritesGroupId].needed = needed; }, ignoreQueue //ignoreQueue. ); needed++; } var that = this; this._checkPlayingAllInterval = setInterval ( function() { if (succeeded &gt;= needed) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that, objectsChecked, uncheckedObjects); } clearInterval(that._checkPlayingAllInterval); that._checkPlayingAllPerforming = false; } else if (succeeded + failed &gt;= needed) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, errorsChecking, objectsChecked, uncheckedObjects); } clearInterval(that._checkPlayingAllInterval); that._checkPlayingAllPerforming = false; } } , 100); return uncheckedObjects; } /** * Tries to play all the {@link CB_AudioFile} objects by calling their {@link CB_AudioFile#play} method internally. If a {@link CB_AudioFile} object cannot be played and it is determined necessary, it will try to reload it internally (by calling the {@link CB_AudioFileCache#removeAudioFile} method). Uses the {@link CB_AudioFileSprites#playAll} method internally. * @function * @param {number} [startAt=0 | {@link CB_AudioFile_API.WAAPI#lastStartAt} | {@link CB_AudioFile_API.SM2#lastStartAt} | {@link CB_AudioFile_API.ACMP#lastStartAt} | {@link CB_AudioFile_API.AAPI#lastStartAt} | stopAt] - Used as the &quot;startAt&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {number} [stopAt={@link CB_AudioFile_API.WAAPI#getDuration}() | {@link CB_AudioFile_API.SM2#getDuration}() | {@link CB_AudioFile_API.ACMP#getDuration}() | {@link CB_AudioFile_API.AAPI#getDuration}()] - Used as the &quot;stopAt&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {number} [volume=CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {boolean} [avoidDelayedPlay=false] - Used as the &quot;avoidDelayedPlay&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @param {boolean} [includingPlaying=false] - Used as the &quot;includingPlaying&quot; parameter when calling the {@link CB_AudioFileSprites#playAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). */ CB_AudioFileSpritesPool.prototype.playAll = function(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop, includingPlaying) { var played = 0; for (var spritesGroupId in this.audioFileSprites) { played += this.audioFileSprites[spritesGroupId].playAll(startAt, stopAt, loop, volume, avoidDelayedPlay, allowedRecursiveDelay, onPlayStart, onStop, includingPlaying); } return played; } /** * Tries to stops all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#stop} method internally. Uses the {@link CB_AudioFileSprites#stopAll} method internally. * @function * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#stopAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#stop} method that were performed. */ CB_AudioFileSpritesPool.prototype.stopAll = function(audioFiles) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].stopAll(audioFiles); } return performed; } /** * Plays silently and stops all {@link CB_AudioFile} objects after a desired time. It can be useful for some clients which need the {@link CB_AudioFile#play} method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls {@link CB_AudioFileCache#playAll}(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the {@link CB_AudioFileCache#stopAll} method. Uses the {@link CB_AudioFileSprites#playAndStopAll} method internally. * @function * @param {boolean} [includingPlaying=false] - Used as the &quot;includingPlaying&quot; parameter when calling the {@link CB_AudioFileSprites#playAndStopAll} method internally. * @param {number} [delayBeforeStop=100] - Used as the &quot;delayBeforeStop&quot; parameter when calling the {@link CB_AudioFileSprites#playAndStopAll} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects whose {@link CB_AudioFile#play} method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). */ CB_AudioFileSpritesPool.prototype.playAndStopAll = function(includingPlaying, delayBeforeStop) { var played = 0; for (var spritesGroupId in this.audioFileSprites) { played += this.audioFileSprites[spritesGroupId].playAndStopAll(includingPlaying, delayBeforeStop); } return played; } /** * Tries to pause all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are being played, by calling their {@link CB_AudioFile#pause} method internally. Uses the {@link CB_AudioFileSprites#pauseAll} method internally. * @function * @param {function} [onPause] - Used as the &quot;onPause&quot; parameter when calling the {@link CB_AudioFileSprites#pauseAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#pauseAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#pause} method that were performed. */ CB_AudioFileSpritesPool.prototype.pauseAll = function(onPause, audioFiles) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].pauseAll(onPause, audioFiles); } return performed; } /** * Resumes all the existing {@link CB_AudioFile} objects or the desired ones (if provided), which are paused (and not stopped). Can be focused on just one sprite ID if desired. Uses the {@link CB_AudioFileSprites#resumeAll} method internally. Internal usage only recommended. To resume a sprite, better use the {@link CB_AudioFileSprites#resumeSprite} method instead. * @function * @param {boolean} [loop={@link CB_AudioFile#loop}] - Used as the &quot;loop&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelay={@link CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT}] - Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {boolean} [allowedRecursiveDelaySkipping=stopAt-startAt] - Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {function} [onPlayStart] - Used as the &quot;onPlayStart&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {function} [onStop] - Used as the &quot;onStop&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#resumeAll} method internally. * @param {string} [spriteId='_WITHOUT_SPRITE_ASSOCIATED'] - Used as the &quot;spriteId&quot; when calling the {@link CB_AudioFileSprites#resumeAll} method internally. Internal usage only recommended. * @returns {Object} Returns an object whose property names will be the ID of each sprites group and their value will be the returning value of the internal call to the {@link CB_AudioFileSprites#resumeAll} method. */ CB_AudioFileSpritesPool.prototype.resumeAll = function(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, audioFiles, spriteId) { var soundInstances = {}; for (var spritesGroupId in this.audioFileSprites) { soundInstances[spritesGroupId] = this.audioFileSprites[spritesGroupId].resumeAll(loop, allowedRecursiveDelay, allowedRecursiveDelaySkipping, onPlayStart, onStop, audioFiles, spriteId); } return soundInstances; } /** * Mutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileSprites#muteAll} method internally. * @function * @param {function} [onMute] - Used as the &quot;onMute&quot; parameter when calling the {@link CB_AudioFileSprites#muteAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#muteAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#mute} method that were performed. */ CB_AudioFileSpritesPool.prototype.muteAll = function(onMute, audioFiles) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].muteAll(onMute, audioFiles); } return performed; } /** * Unmutes all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileSprites#unmuteAll} method internally. * @function * @param {function} [onUnmute] - Used as the &quot;onUnmute&quot; parameter when calling the {@link CB_AudioFileSprites#unmuteAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#unmuteAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#unmute} method that were performed. */ CB_AudioFileSpritesPool.prototype.unmuteAll = function(onUnmute, audioFiles) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].unmuteAll(onUnmute, audioFiles); } return performed; } /** * Sets the same volume for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). Uses the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @function * @param {number} [volume={@link CB_Speaker.getVolume()} | {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME}] - Used as the &quot;volume&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @param {boolean} [forceSetVolumeProperty=false] - Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @param {function} [onSetVolume] - Used as the &quot;onSetVolume&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#setVolumeAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setVolume} method that were performed internally. */ CB_AudioFileSpritesPool.prototype.setVolumeAll = function(volume, forceSetVolumeProperty, onSetVolume, audioFiles) { var performed = 0; for (var spritesGroupId in this.audioFileSprites) { performed += this.audioFileSprites[spritesGroupId].setVolumeAll(volume, forceSetVolumeProperty, onSetVolume, audioFiles); } return performed; } /** * Callback function used by the {@link CB_AudioFileSpritesPool#setAudioAPIAll} method that will be called when all the process was performed successfully. * @memberof CB_AudioFileSpritesPool * @callback CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_OK * @param {integer} objectsChangedAPI - The number of {@link CB_AudioFile} objects that actually changed its audio API. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that ended with a desired audio API, including those ones which were already using it. * @param {integer} actionsNeeded - The total number of {@link CB_AudioFile} objects that were considered to perform the action (it will be undefined if it could not be determined). */ /** * Callback function used by the {@link CB_AudioFileCache#setAudioAPIAll} method that will be called when any error happened. * @memberof CB_AudioFileSpritesPool * @callback CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR * @param {Object} errorsObject - Object whose property names are the ID of each sprites group or &quot;GENERAL_ERROR&quot; if the error is not related to any sprites group and their value will be a {@link CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR_OBJECT} object each. * @param {integer} errorsHappened - The number of errors that happened, which could be greater than 1 if more than one internal call to the {@link CB_AudioFile#setAudioAPI} method failed. * @param {integer} objectsChangedAPI - The number of {@link CB_AudioFile} objects that actually changed its audio API. * @param {integer} performedActions - The number of {@link CB_AudioFile} objects that ended with a desired audio API, including those ones which were already using it. * @param {integer|undefined} actionsNeeded - The total number of {@link CB_AudioFile} objects that were considered to perform the action (it will be undefined if it could not be determined). */ /** * Object used by the {@link CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR} callback. Unless it belongs to a general error, its information will only be regarding a certain sprites group. * @memberof CB_AudioFileSpritesPool * @typedef {Object} CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR_OBJECT * @property {string} error - A string describing the error, if it was possible to be determined. * @property {integer} errors - The number of errors that happened, which could be greater than 1 if more than one internal call to the {@link CB_AudioFile#setAudioAPI} method failed. * @property {integer} changed - The number of objects that actually changed its audio API. * @property {integer} performed - The number of {@link CB_AudioFile} objects that ended with a desired audio API, including those ones which were already using it. * @property {integer|undefined} needed - The total number of {@link CB_AudioFile} objects that were considered to perform the action (it will be undefined if it could not be determined). */ /** * Tries to change the audio API for all the existing {@link CB_AudioFile} objects or the desired ones (if provided). This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. Uses the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @function * @param {array|string} preferredAPIs - Used as the &quot;preferredAPIs&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_OK} [callbackOk] - Function that will be called when all the process was performed successfully, being &quot;this&quot; the {@link CB_AudioFileSpritesPool} object. * @param {CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR} [callbackError] - Function that will be called when any error happened, being &quot;this&quot; the {@link CB_AudioFileSpritesPool} object. This function will be called immediately if the method was previously called and it is still running currently. * @param {boolean} [mandatory=false] - Used as the &quot;mandatory&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {string} [forceReload=false] - Used as the &quot;forceReload&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @param {array} [audioFiles={@link CB_AudioFileCache#audioFiles}] - Used as the &quot;audioFiles&quot; parameter when calling the {@link CB_AudioFileSprites#setAudioAPIAll} method internally. * @returns {integer} Returns the number of calls to the {@link CB_AudioFile#setAudioAPI} method that were performed. */ CB_AudioFileSpritesPool.prototype.setAudioAPIAll = function(preferredAPIs, callbackOk, callbackError, mandatory, forceReload, audioFiles, ignoreStatus) { var errorMessage = &quot;&quot;; if (this._setAudioAPIAllPerforming) { errorMessage = &quot;Method setAudioAPIAll is being processed. Cannot be called again until it finishes.&quot;; } else if (!ignoreStatus &amp;&amp; this.getStatus() !== CB_AudioFileSpritesPool.LOADED) { errorMessage = &quot;Sprites pool is not loaded.&quot;; } if (errorMessage !== &quot;&quot;) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call ( this, { &quot;GENERAL_ERROR&quot; : { &quot;error&quot; : errorMessage, &quot;errors&quot; : 1, &quot;changed&quot; : 0, &quot;performed&quot; : 0, &quot;needed&quot; : undefined } }, 1, 0, 0, undefined ); } return 0; } this._setAudioAPIAllPerforming = true; clearInterval(this._setAudioAPIAllInterval); var performedReturn = 0; var failed = 0; var succeeded = 0; var needed = 0; var objectsChanged = 0; var errorsChecking = {}; var errors = 0; var performed = 0; var neededTotal = 0; for (var spritesGroupId in this.audioFileSprites) { performedReturn += this.audioFileSprites[spritesGroupId].setAudioAPIAll ( preferredAPIs, //preferredAPIs. function(objectsChangedAPI, performedActions, actionsNeeded) //callbackOk: { objectsChanged += objectsChangedAPI; performed += performedActions; actionsNeeded = parseInt(actionsNeeded); //It could be undefined. neededTotal += actionsNeeded; succeeded++; }, function(error, errorsHappened, objectsChangedAPI, performedActions, actionsNeeded) //callbackError: { failed++; actionsNeeded = parseInt(actionsNeeded); //It could be undefined. errors += errorsHappened; objectsChanged += objectsChangedAPI; performed += performedActions; neededTotal += actionsNeeded; errorsChecking[spritesGroupId] = {}; errorsChecking[spritesGroupId].error = error; errorsChecking[spritesGroupId].errors = errorsHappened; errorsChecking[spritesGroupId].changed = objectsChangedAPI; errorsChecking[spritesGroupId].performed = performedActions; errorsChecking[spritesGroupId].needed = actionsNeeded; }, mandatory, //mandatory. forceReload, //forceReload. audioFiles //audioFiles ); needed++; } var that = this; this._setAudioAPIAllInterval = setInterval ( function() { if (succeeded &gt;= needed) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk.call(that, objectsChanged, performed, neededTotal); } clearInterval(that._setAudioAPIAllInterval); that._setAudioAPIAllPerforming = false; } else if (succeeded + failed &gt;= needed) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(that, errorsChecking, errors, objectsChanged, performed, neededTotal); } clearInterval(that._setAudioAPIAllInterval); that._setAudioAPIAllPerforming = false; } } , 100); return performedReturn; } /** * Tells whether any of the {@link CB_AudioFile} objects is playing or not. Uses the {@link CB_AudioFileSprites#isPlaying} method internally. * @function * @returns {boolean} Returns whether any of the {@link CB_AudioFile} objects is playing or not. */ CB_AudioFileSpritesPool.prototype.isPlaying = function() { for (var spritesGroupId in this.audioFileSprites) { if (this.audioFileSprites[spritesGroupId].isPlaying()) { return true; } } return false; } /** * Tells the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). Uses the {@link CB_AudioFileSprites#getAudioFilesFreeNumber} method internally. * @function * @returns {integer} Returns the current number of free {@link CB_AudioFile} objects (the number of objects which are available and ready to use). */ CB_AudioFileSpritesPool.prototype.getAudioFilesFreeNumber = function() { var number = 0; for (var spritesGroupId in this.audioFileSprites) { number += this.audioFileSprites[spritesGroupId].getAudioFilesFreeNumber(); } return number; } /** * Gets an object with arrays or a one-dimension array with all the {@link CB_AudioFile} objects. Uses the {@link CB_AudioFileSprites#getAudioFiles} method internally. * @function * @param {boolean} [copy=false] - Used as the &quot;copy&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFiles} method internally. * @param {boolean} [oneDimension=false] - If it is set to true, the method will return an array with all the {@link CB_AudioFile} objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with all the {@link CB_AudioFile} objects that belong to that sprites group. * @returns {Object|array} If the &quot;oneDimension&quot; parameter is set to true, returns an array with all the {@link CB_AudioFile} objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with all the {@link CB_AudioFile} objects that belong to that sprites group. */ CB_AudioFileSpritesPool.prototype.getAudioFiles = function(copy, oneDimension) { var audioFiles; if (!oneDimension) { audioFiles = {}; for (var spritesGroupId in this.audioFileSprites) { audioFiles[spritesGroupId] = this.audioFileSprites[spritesGroupId].getAudioFiles(copy); } } else { audioFiles = []; var audioFilesSpritesGroup; var audioFilesSpritesGroupLength; var y = 0; var x = 0; for (var spritesGroupId in this.audioFileSprites) { audioFilesSpritesGroup = this.audioFileSprites[spritesGroupId].getAudioFiles(copy); audioFilesSpritesGroupLength = audioFilesSpritesGroup.length; for (x = 0; x &lt; audioFilesSpritesGroupLength; x++) { audioFiles[y++] = audioFilesSpritesGroup[x]; } } } return audioFiles; } /** * Gets an object with arrays or a one-dimension array with the free {@link CB_AudioFile} objects (the objects which are available and ready to use). Uses the {@link CB_AudioFileSprites#getAudioFilesFree} method internally. * @function * @param {boolean} [oneDimension=false] - If it is set to true, the method will return an array with the free {@link CB_AudioFile} objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with the free {@link CB_AudioFile} objects that belong to that sprites group. * @returns {Object|array} If the &quot;oneDimension&quot; parameter is set to true, returns an array with the free {@link CB_AudioFile} objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with the free {@link CB_AudioFile} objects that belong to that sprites group. */ CB_AudioFileSpritesPool.prototype.getAudioFilesFree = function(oneDimension) { var audioFiles; if (!oneDimension) { audioFiles = {}; for (var spritesGroupId in this.audioFileSprites) { audioFiles[spritesGroupId] = this.audioFileSprites[spritesGroupId].getAudioFilesFree(); } } else { audioFiles = []; var audioFilesSpritesGroup; var audioFilesSpritesGroupLength; var y = 0; var x = 0; for (var spritesGroupId in this.audioFileSprites) { audioFilesSpritesGroup = this.audioFileSprites[spritesGroupId].getAudioFilesFree(); audioFilesSpritesGroupLength = audioFilesSpritesGroup.length; for (x = 0; x &lt; audioFilesSpritesGroupLength; x++) { audioFiles[y++] = audioFilesSpritesGroup[x]; } } } return audioFiles; } /** * Gets an object with arrays or a one-dimension array with the busy {@link CB_AudioFile} objects (the objects which are not available and ready to use). Uses the {@link CB_AudioFileSprites#getAudioFilesBusy} method internally. * @function * @param {boolean} [oneDimension=false] - If it is set to true, the method will return an array with the busy {@link CB_AudioFile} objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with the busy {@link CB_AudioFile} objects that belong to that sprites group. * @returns {Object|array} If the &quot;oneDimension&quot; parameter is set to true, returns an array with the busy {@link CB_AudioFile} objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with the busy {@link CB_AudioFile} objects that belong to that sprites group. */ CB_AudioFileSpritesPool.prototype.getAudioFilesBusy = function(oneDimension) { var audioFiles; if (!oneDimension) { audioFiles = {}; for (var spritesGroupId in this.audioFileSprites) { audioFiles[spritesGroupId] = this.audioFileSprites[spritesGroupId].getAudioFilesBusy(); } } else { audioFiles = []; var audioFilesSpritesGroup; var audioFilesSpritesGroupLength; var y = 0; var x = 0; for (var spritesGroupId in this.audioFileSprites) { audioFilesSpritesGroup = this.audioFileSprites[spritesGroupId].getAudioFilesBusy(); audioFilesSpritesGroupLength = audioFilesSpritesGroup.length; for (x = 0; x &lt; audioFilesSpritesGroupLength; x++) { audioFiles[y++] = audioFilesSpritesGroup[x]; } } } return audioFiles; } /** * Tells the number of {@link CB_AudioFile} objects created. Uses the {@link CB_AudioFileSprites#getAudioFilesNumber} method internally. * @function * @param {boolean} [real=false] - Used as the &quot;real&quot; parameter when calling the {@link CB_AudioFileSprites#getAudioFilesNumber} method internally. * @returns {integer} Returns the number of {@link CB_AudioFile} objects created. */ CB_AudioFileSpritesPool.prototype.getAudioFilesNumber = function(real) { var number = 0; for (var spritesGroupId in this.audioFileSprites) { number += this.audioFileSprites[spritesGroupId].getAudioFilesNumber(real); } return number; } /** * Returns a number representing the percentage of the loading progress for the audio sprites pool object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Uses the {@link CB_AudioFileSprites#getProgress} method internally. * @function * @param {boolean} [countLoadedObjects=false] - Used as the &quot;countLoadedObjects&quot; parameter when calling the {@link CB_AudioFileSprites#getProgress} method internally. * @param {boolean} [alsoUncheckedAndCheckingObjects=false] - Used as the &quot;alsoUncheckedAndCheckingObjects&quot; parameter when calling the {@link CB_AudioFileSprites#getProgress} method internally. * @returns {number} Returns a number representing the percentage of the loading progress for the audio sprites pool object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. */ CB_AudioFileSpritesPool.prototype.getProgress = function(countLoadedObjects, alsoUncheckedAndCheckingObjects) { var progress = 0; var spritesGroups = 0; for (var spritesGroupId in this.audioFileSprites) { progress += this.audioFileSprites[spritesGroupId].getProgress(countLoadedObjects, alsoUncheckedAndCheckingObjects); spritesGroups++; } if (spritesGroups !== 0) { progress /= spritesGroups; } return progress; } /** * Gets the current status of the audio file sprites pool object. Uses the {@link CB_AudioFileSprites#getStatus} method internally. * @function * @returns {number} Returns the current status of the audio file sprites pool object. It is a number, affected by the returning value of the {@link CB_AudioFileSprites#getStatus} method of each {@link CB_AudioFileSprites} object used internally, which should match the value of the {@link CB_AudioFileCache.UNLOADED} (still unloaded), {@link CB_AudioFileCache.LOADING} (loading), {@link CB_AudioFileCache.UNCHECKED} (not checked by calling the {@link CB_AudioFileCache#checkPlayingAll} method yet), {@link CB_AudioFileCache.CHECKING} (being checked by the {@link CB_AudioFileCache#checkPlayingAll} method), {@link CB_AudioFileCache.LOADED} (loaded), {@link CB_AudioFileCache.FAILED} (failed loading or failed to play or by any other reason) or {@link CB_AudioFileCache.ABORTED} (aborted because it was destroyed with the &quot;destructor&quot; method) property. */ CB_AudioFileSpritesPool.prototype.getStatus = function() { var status = null; var allLoaded = false; var loaded = 0; var anyUnloaded = false; var anyLoading = false; var anyUnchecked = false; var anyChecking = false; var anyFailed = false; var anyAborted = false; for (var audioFileSpritesObject in this.audioFileSprites) { if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.UNLOADED) { anyUnloaded = true; } else if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.LOADING) { anyLoading = true; } else if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.UNCHECKED) { anyUnchecked = true; } else if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.CHECKING) { anyChecking = true; } else if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.FAILED) { anyFailed = true; } else if (this.audioFileSprites[audioFileSpritesObject].getStatus() === CB_AudioFileCache.ABORTED) { anyAborted = true; } else { loaded++; } } if (anyUnloaded) { status = CB_AudioFileSpritesPool.UNLOADED; } else if (anyLoading) { status = CB_AudioFileSpritesPool.LOADING; } else if (anyUnchecked) { status = CB_AudioFileSpritesPool.UNCHECKED; } else if (anyChecking) { status = CB_AudioFileSpritesPool.CHECKING; } else if (anyFailed) { status = CB_AudioFileSpritesPool.FAILED; } else if (anyAborted) { status = CB_AudioFileSpritesPool.ABORTED; } if (status === null) { if (loaded &gt; 0) { status = CB_AudioFileSpritesPool.LOADED; } else if (this._aborted) { status = CB_AudioFileSpritesPool.ABORTED; } else { status = CB_AudioFileSpritesPool.UNLOADED; } } return status; } /** * Gets the current status of the audio file sprites pool object, as a string. * @function * @returns {string} Returns the current status of the audio file sprites pool object, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a returning value from the {@link CB_AudioFileSpritesPool#getStatus} method not recognized as any possible status). */ CB_AudioFileSpritesPool.prototype.getStatusString = function() { var status = this.getStatus(); var statuses = [ &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; ]; if (typeof(statuses[status]) !== &quot;undefined&quot;) { return statuses[status]; } else { return &quot;UNKNOWN (&quot; + status + &quot;)&quot;; } } /** * Calls the error function which should be set in the {@link CB_AudioFileSprites#onError} property (if any), being &quot;this&quot; the {@link CB_AudioFileSpritesPool} object itself. Internal usage only recommended. * @function * @param {string} [message] - The message describing the error that will be sent to the set {@link CB_AudioFileSprites#onError} function (if any) as the first and unique parameter. * @param {boolean} [ignorePreviousExecution=false] - If it is set to false, the function set in the {@link CB_AudioFileSprites#onError} property (if any) will only be called if it was not executed previously. * @returns {boolean} Returns true if the {@link CB_AudioFileSprites#onError} function could be called or false otherwise. */ CB_AudioFileSpritesPool.prototype.errorFunction = function(message, ignorePreviousExecution) { if (ignorePreviousExecution || !this._errorFunctionExecuted) { if (typeof(this.onError) === &quot;function&quot;) { this._errorFunctionExecuted = true; this.onError.call(this, message); return true; } } return false; } × Search results Close "},"CrossBase_audiovisual_image_CB_GraphicSprites.js.html":{"id":"CrossBase_audiovisual_image_CB_GraphicSprites.js.html","title":"Source: CrossBase/audiovisual/image/CB_GraphicSprites.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/image/CB_GraphicSprites.js /** * @file Group of graphic sprites management (2D or 3D). Contains the {@link CB_GraphicSprites} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * An object with the information that belongs to a sub-sprite (data which belongs to a certain source) used by a graphic sprite. * @example { id: &quot;my_subsprite_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, zIndex: 1, disabled: false, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] } } * @memberof CB_GraphicSprites * @typedef {Object} CB_GraphicSprites.SUBSPRITE_OBJECT * @property {string|*} [id='CB_GraphicSprites.subSprite_' + CB_GraphicSprites._idSubSpriteUnique++] - Identifier of the sub-sprite. It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @property {*} [src=this.parent.src|&quot;&quot;] - Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. If not provided, as default it will use the value from the sprite that it belongs to. * @property {string} [srcType=this.parent.srcType|{@link CB_GraphicSprites.SRC_TYPES.DEFAULT}] - Type of the source of origin. If not provided, as default it will use the value from the sprite that it belongs to. It should point to a property of the {@link CB_GraphicSprites.SRC_TYPES} object. You can use other values of the {@link CB_GraphicSprites.SRC_TYPES} object or create new ones. * @property {number} [srcLeft=this.parent.srcLeft|{@link CB_GraphicSprites.LEFT_SOURCE_DEFAULT}] - Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [srcTop=this.parent.srcTop|{@link CB_GraphicSprites.TOP_SOURCE_DEFAULT}] - Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [srcWidth=this.parent.srcWidth|{@link CB_GraphicSprites.WIDTH_SOURCE_DEFAULT}] - Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [srcHeight=this.parent.srcHeight|{@link CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT}] - Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [left={@link CB_GraphicSprites.LEFT_DEFAULT}] - Left (horizontal) position in the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). * @property {number} [top={@link CB_GraphicSprites.TOP_DEFAULT}] - Top (vertical) position in the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). * @property {number} [width=this.parent.width|{@link CB_GraphicSprites.WIDTH_DEFAULT}] - Width of the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [height=this.parent.height|{@link CB_GraphicSprites.HEIGHT_DEFAULT}] - Height of the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. * @property {number} [zIndex=this.parent.zIndex|{@link CB_GraphicSprites.ZINDEX_DEFAULT}] - The z-index for the destiny (inside the sprite). Only numeric values which are not zero (0) are allowed. If not provided, as default it will use the value from the sprite that it belongs to. To change the value of this property, use the &quot;setZIndex&quot; method of the sub-sprite or the {@link CB_GraphicSprites#setZIndexSubSprite} method (which will call the {@link CB_GraphicSpritesScene#updateSubSpritesByZIndex} method internally). * @property {boolean} [disabled=this.parent.disabled|false] - Tells whether this sub-sprite is disabled or not. Regardless its value, it will be considered disabled if its sprite parent is also disabled. If not provided, as default it will use the value from the sprite that it belongs to. * @property {object} [data=CB_combineJSON(this.parent.data, this.data)||this.parent.data||{ 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } }] - Object with any additional data desired which can be any kind. If not provided, missing properties as default will use the value from the sprite that it belongs to. It will always have a &quot;that&quot; property pointing to the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. * @property {boolean} [byReference=false] - If set to true, when inserting the sub-sprite, the same sub-sprite itself ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) will be inserted internally directly without making a copy of itself. * @property {CB_GraphicSprites.SPRITE_OBJECT} parent - Read-only property pointing to its parent ({@link CB_GraphicSprites.SPRITE_OBJECT} object). * @property {CB_GraphicSprites} container - Read-only property pointing to the {@link CB_GraphicSprites} object which contains it. * @property {boolean} isSubSprite - Read-only property which is always set to true to help identify this type of object. * @property {'subSprite'} type - Read-only property indicating the type of object (always &quot;subSprite&quot;). * @property {integer} position - Read-only property indicating the position of this sub-sprite in the array which is set the &quot;subSprites&quot; property of the sprite parent ({@link CB_GraphicSprites.SPRITE_OBJECT} object). * @property {integer} positionByZIndex - Read-only property indicating the position of this sub-sprite in the array which is set the &quot;subSpritesByZIndex&quot; property of the sprite parent ({@link CB_GraphicSprites.SPRITE_OBJECT} object). * @property {integer} time - Property which stores the time in milliseconds when its parent sprite was started being pointed for the last time (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which was obtained calling the {@link CB_Device.getTiming} function internally). Note that the parent could being not pointed anymore. If it has never being pointed before, it will be set to 0. It normally has the same value as the &quot;time&quot; property of its parent object but they can be modified independently. * @property {function} setTime - Read-only property which is a method that updates the &quot;time&quot; property of the sub-sprite (calls {@link CB_GraphicSprites#setTime} internally and returns its returning value). With only one parameter which belongs to the &quot;time&quot; parameter of the {@link CB_GraphicSprites#setTime} method. * @property {function} getTime - Read-only property which is a method that returns the &quot;time&quot; property of the sub-sprite (calls {@link CB_GraphicSprites#getTime} internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the {@link CB_GraphicSprites#getTime} method. If the &quot;time&quot; property of the sub-sprite is not found, it will use the &quot;time&quot; property from its sprite parent. * @property {function} getTimeElapsed - Read-only property which is a method that returns how many milliseconds elapsed since the sprite was or will be pointed (checking its &quot;time&quot; property), comparing with the time given in milliseconds (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can be obtained calling the {@link CB_Device.getTiming} function) or with the current one if none is given (calls {@link CB_GraphicSprites#getTimeElapsed} internally and returns its returning value). With only one parameter which belongs to the &quot;timeToCompare&quot; parameter of the {@link CB_GraphicSprites#getTimeElapsed} method. If the &quot;time&quot; property of the sub-sprite is not found, it will use the &quot;time&quot; property from its sprite parent. * @property {function} getZIndex - Read-only property which is a method that returns the z-index (&quot;z-index&quot; property) of the sub-sprite (calls {@link CB_GraphicSprites#getZIndexSubSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the {@link CB_GraphicSprites#getZIndexSubSprite} method. * @property {function} setZIndex - Read-only property which is a method to set the z-index (&quot;z-index&quot; property) of the sub-sprite (calls {@link CB_GraphicSprites#setZIndexSubSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;zIndex&quot; parameter of the {@link CB_GraphicSprites#setZIndexSubSprite} method. * @property {function} isDisabled - Read-only property which is a method that tells whether the sub-sprite is disabled or not (calls {@link CB_GraphicSprites#isDisabledSubSprite} internally and returns its returning value). With no parameters. A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). * @property {function} setDisabled - Read-only property which is a method to disable or enable the sub-sprite (calls {@link CB_GraphicSprites#setDisabledSubSprite} internally and returns its returning value). With three parameters (&quot;disabled&quot;, &quot;affectParents&quot; and &quot;affectParentsChildren&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#setDisabledSubSprite} method. */ /** * An object with the information that belongs to a certain graphic sprite, being able to contain more than one source used by this graphic sprite (inside sub-sprites). * @example { //'my_sprite_1': id: &quot;my_sprite_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, disabled: false, data: { datum_1 : &quot;value_1&quot;, datum_2 : 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] } * @memberof CB_GraphicSprites * @typedef {Object} CB_GraphicSprites.SPRITE_OBJECT * @property {string|*} [id='CB_GraphicSprites.sprite_' + CB_GraphicSprites._idSpriteUnique++] - Identifier of the sprite. It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @property {*} [src=this.parent.src|&quot;&quot;] - Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. If not provided, as default it will use the value from the sprites group that it belongs to. * @property {string} [srcType=this.parent.srcType|{@link CB_GraphicSprites.SRC_TYPES.DEFAULT}] - Type of the source of origin. If not provided, as default it will use the value from the sprites group that it belongs to. It should point to a property of the {@link CB_GraphicSprites.SRC_TYPES} object. You can use other values of the {@link CB_GraphicSprites.SRC_TYPES} object or create new ones. * @property {number} [srcLeft=this.parent.srcLeft|{@link CB_GraphicSprites.LEFT_SOURCE_DEFAULT}] - Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [srcTop=this.parent.srcTop|{@link CB_GraphicSprites.TOP_SOURCE_DEFAULT}] - Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [srcWidth=this.parent.srcWidth|{@link CB_GraphicSprites.WIDTH_SOURCE_DEFAULT}] - Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [srcHeight=this.parent.srcHeight|{@link CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT}] - Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [left={@link CB_GraphicSprites.LEFT_DEFAULT}] - Left (horizontal) position in the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). * @property {number} [top={@link CB_GraphicSprites.TOP_DEFAULT}] - Top (vertical) position in the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). * @property {number} [width=this.parent.width|{@link CB_GraphicSprites.WIDTH_DEFAULT}] - Width of the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [height=this.parent.height|{@link CB_GraphicSprites.HEIGHT_DEFAULT}] - Height of the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. * @property {number} [zIndex=this.parent.zIndex|{@link CB_GraphicSprites.ZINDEX_DEFAULT}] - The z-index for the destiny (inside the sprites group). Only numeric values which are not zero (0) are allowed. If not provided, as default it will use the value from the sprites group that it belongs to. To change the value of this property, use the &quot;setZIndex&quot; method of the sprite or the {@link CB_GraphicSprites#setZIndexSprite} method (which will call the {@link CB_GraphicSpritesScene#updateSpritesByZIndex} method internally). * @property {boolean} [disabled=this.parent.disabled|false] - Tells whether this sprite is disabled or not. Regardless its value, it will be considered disabled if its sprites group parent is also disabled. If not provided, as default it will use the value from the sprites group that it belongs to. * @property {object} [data=CB_combineJSON(this.parent.data, this.data)||this.parent.data||{ 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } }] - Object with any additional data desired which can be any kind. If not provided, missing properties as default will use the value from the sprites group that it belongs to. It will always have a &quot;that&quot; property pointing to the {@link CB_GraphicSprites.SPRITE_OBJECT} object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. * @property {array} [subSprites=[]] - Numeric array containing {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects with the sub-sprites that this sprite uses. * @property {array} subSpritesByZIndex - Read-only property containing a numeric array of all the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects of the sprite ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sub-sprite is set with its &quot;setZIndex&quot; method (or when calling the {@link CB_GraphicSprites#setZIndexSubSprite} method) or when inserting/removing sub-sprites through the {@link CB_GraphicSprites#insertSubSprites}, {@link CB_GraphicSprites#insertSubSprite}, {@link CB_GraphicSprites#removeSubSprite} or {@link CB_GraphicSprites#removeSubSpriteById} methods. * @property {boolean} [byReference=false] - If set to true, when inserting the sprite, its &quot;subSprites&quot; property will use exactly the object given for that property (without making a copy) and the same sprite itself ({@link CB_GraphicSprites.SPRITE_OBJECT} object) will be inserted internally directly without making a copy of itself. * @property {CB_GraphicSprites.SPRITES_OBJECT} parent - Read-only property pointing to its parent ({@link CB_GraphicSprites.SPRITES_OBJECT} object). * @property {CB_GraphicSprites} container - Read-only property pointing to the {@link CB_GraphicSprites} object which contains it. * @property {boolean} isSprite - Read-only property which is always set to true to help identify this type of object. * @property {'sprite'} type - Read-only property indicating the type of object (always &quot;sprite&quot;). * @property {integer} position - Read-only property indicating the position of this sprite in the array which is set the &quot;sprites&quot; property of the sprites group parent ({@link CB_GraphicSprites.SPRITES_OBJECT} object). * @property {integer} positionByZIndex - Read-only property indicating the position of this sprite in the array which is set the &quot;spritesByZIndex&quot; property of the sprites group parent ({@link CB_GraphicSprites.SPRITES_OBJECT} object). * @property {integer} time - Property which stores the time in milliseconds when the sprite was started being pointed for the last time (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which was obtained calling the {@link CB_Device.getTiming} function internally). Note that it could being not pointed anymore. If it has never being pointed before, it will be set to 0. * @property {function} setTime - Read-only property which is a method that updates the &quot;time&quot; property of the sprite (calls {@link CB_GraphicSprites#setTime} internally and returns its returning value). With only one parameter which belongs to the &quot;time&quot; parameter of the {@link CB_GraphicSprites#setTime} method. * @property {function} getTime - Read-only property which is a method that returns the &quot;time&quot; property of the sprite (calls {@link CB_GraphicSprites#getTime} internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the {@link CB_GraphicSprites#getTime} method. * @property {function} getTimeElapsed - Read-only property which is a method that returns how many milliseconds elapsed since the sprite was or will be pointed (checking its &quot;time&quot; property), comparing with the time given in milliseconds (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can be obtained calling the {@link CB_Device.getTiming} function) or with the current one if none is given (calls {@link CB_GraphicSprites#getTimeElapsed} internally and returns its returning value). With only one parameter which belongs to the &quot;timeToCompare&quot; parameter of the {@link CB_GraphicSprites#getTimeElapsed} method. * @property {function} removeAll - Read-only property which is a method that removes all the internal sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects) from the sprite which are in the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#removeSubSprites} internally and returns its returning value). With no parameters. * @property {function} removeSubSprites - Alias for the &quot;removeAll&quot; method. * @property {function} insertSubSprites - Read-only property which is a method that inserts the given sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects) in the sprite, adding them to the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#insertSubSprites} internally and returns its returning value). With only one parameter which belongs to the &quot;subSprites&quot; parameter of the {@link CB_GraphicSprites#insertSubSprites} method. * @property {function} remove - Read-only property which is a method that removes an internal sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) by its index (position in the &quot;subSprites&quot; array) from the sprite, removing it from the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#removeSubSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;index&quot; parameter of the {@link CB_GraphicSprites#removeSubSprite} method. * @property {function} removeById - Read-only property which is a method that removes an internal sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) by its identifier from the sprite, removing it from the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#removeSubSpriteById} internally and returns its returning value). With only one parameter which belongs to the &quot;id&quot; parameter of the {@link CB_GraphicSprites#removeSubSpriteById} method. * @property {function} insert - Read-only property which is a method that inserts a given sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) in the sprite, adding it to the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#insertSubSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;subSprite&quot; parameter of the {@link CB_GraphicSprites#insertSubSprite} method. * @property {function} getAll - Read-only property which is a method that returns all the internal sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects) in the sprite, getting them from the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#getAll} internally and returns its returning value). With two parameters (&quot;orderedByZIndex&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#getAll} method. * @property {function} getSubSprites - Alias for the &quot;getAll&quot; method. * @property {function} get - Read-only property which is a method that returns a sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) by its index (position in the &quot;subSprites&quot; array) from the sprite, getting it from the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#getSubSprite} internally and returns its returning value). With two parameters (&quot;index&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#getSubSprite} method. * @property {function} getById - Read-only property which is a method that returns a sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) by its identifier from the sprite, getting it from the &quot;subSprites&quot; property (calls {@link CB_GraphicSprites#getSubSpriteById} internally and returns its returning value). With two parameters (&quot;id&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#getSubSpriteById} method. * @property {function} getIndexById - Read-only property which is a method that returns the index (position in the &quot;subSprites&quot; array) of a sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) by its identifier (calls {@link CB_GraphicSprites#getSubSpriteIndexById} internally and returns its returning value). With only one parameter which belongs to the &quot;id&quot; parameter of the {@link CB_GraphicSprites#getSubSpriteIndexById} method. * @property {function} executeFunctionAll - Read-only property which is a method that executes the desired function for each sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects which are in the &quot;subSprites&quot; property) in the sprite (calls {@link CB_GraphicSprites#executeFunctionAllSubSprites} internally and returns its returning value). With five parameters (&quot;functionEach&quot;, &quot;orderedByZIndex&quot;, &quot;delayBetweenEach&quot;, &quot;returnSetTimeoutsArray&quot;, &quot;delayBetweenEachAffectsFirst&quot; and &quot;functionFinish&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#executeFunctionAllSubSprites} method. * @property {function} executeAll - Alias for the &quot;executeFunctionAll&quot; method. * @property {function} forEach - Alias for the &quot;executeFunctionAll&quot; method. * @property {function} getZIndex - Read-only property which is a method that returns the z-index (&quot;z-index&quot; property) of the sprite (calls {@link CB_GraphicSprites#getZIndexSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the {@link CB_GraphicSprites#getZIndexSprite} method. * @property {function} setZIndex - Read-only property which is a method to set the z-index (&quot;z-index&quot; property) of the sprite (calls {@link CB_GraphicSprites#setZIndexSprite} internally and returns its returning value). With only one parameter which belongs to the &quot;zIndex&quot; parameter of the {@link CB_GraphicSprites#setZIndexSprite} method. * @property {function} isDisabled - Read-only property which is a method that tells whether the sprite is disabled or not (calls {@link CB_GraphicSprites#isDisabledSprite} internally and returns its returning value). With no parameters. A sprite is considered disabled if its sprites group parent is also disabled. * @property {function} setDisabled - Read-only property which is a method to disable or enable the sprite (calls {@link CB_GraphicSprites#setDisabledSprite} internally and returns its returning value). With four parameters (&quot;disabled&quot;, &quot;affectSubSprites&quot;, &quot;affectParent&quot; and &quot;affectParentChildren&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#setDisabledSprite} method. * @property {function} getPointer - Read-only property which is a method that gets the current position of the pointer. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). Internally, it uses the {@link CB_GraphicSprites#pointer} property. Calls {@link CB_GraphicSprites#getPointer} internally and returns its returning value. With no parameters. * @property {function} getCurrentPosition - Alias for the &quot;getPointer&quot; method. * @property {function} getPointerPrevious - Read-only property which is a method that gets the previous position of the pointer. Internally, it uses the {@link CB_GraphicSprites#pointerPrevious} property. Calls {@link CB_GraphicSprites#getPointerPrevious} internally and returns its returning value. With no parameters. * @property {function} getPreviousPosition - Alias for the &quot;getPointerPrevious&quot; method. * @property {function} setPointer - Read-only property which is a method that sets the pointer to the desired position (if possible). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will also reset the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). Calls {@link CB_GraphicSprites#setPointer} internally and returns the sprite (a {@link CB_GraphicSprites.SPRITE_OBJECT} object) which is being currently pointed (by the pointer set in the {@link CB_GraphicSprites#pointer} property). With two parameters (&quot;position&quot; and &quot;loop&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#setPointer} method. * @property {function} setCurrentPosition - Alias for the &quot;setPointer&quot; method. * @property {function} getCurrent - Read-only property which is a method that gets the sprite (a {@link CB_GraphicSprites.SPRITE_OBJECT} object) which is being currently pointed (by the pointer set in the {@link CB_GraphicSprites#pointer} property). Calls {@link CB_GraphicSprites#getCurrent} internally and returns its returning value. With no parameters. * @property {function} current - Alias for the &quot;getCurrent&quot; method. * @property {function} now - Alias for the &quot;getCurrent&quot; method. * @property {function} getPrevious - Read-only property which is a method that gets the sprite which was previously pointed if any or returns null otherwise. It does not modify the {@link CB_GraphicSprites#pointer} property. Calls {@link CB_GraphicSprites#getPrevious} internally and returns its returning value. With no parameters. * @property {function} setPrevious - Read-only property which is a method that makes the pointer to go back to the previous position (if possible) and returns the sprite located there (if any). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will update also the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). Calls {@link CB_GraphicSprites#setPrevious} internally and returns its returning value. With only one parameter which belongs to the &quot;loop&quot; parameter of the {@link CB_GraphicSprites#setPrevious} method. * @property {function} previous - Alias for the &quot;setPrevious&quot; method. * @property {function} setNext - Read-only property which is a method that makes the pointer to advance to the next position (if possible) and returns the sprite located there (if any). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will also update the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). Calls {@link CB_GraphicSprites#setNext} internally and returns its returning value. With only one parameter which belongs to the &quot;loop&quot; parameter of the {@link CB_GraphicSprites#setNext} method. * @property {function} next - Alias for the &quot;setNext&quot; method. * @property {function} setPropertyCascade - Read-only property which is a method that sets the desired value of a given property name to the sprite itself and all of its sub-sprites (if any). Calls {@link CB_GraphicSprites#setPropertyCascade} internally and returns its returning value. With two parameters (&quot;propertyName&quot; and &quot;value&quot;) which belong to the parameters with the same name of the {@link CB_GraphicSprites#setPropertyCascade} method. */ /** * An object with the information that belongs to a group of graphic sprites. * @example { //'my_sprites_1': id: &quot;my_sprites_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, sprites: [ //'my_sprite_1': { id: &quot;my_sprite_1&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_2': { id: &quot;my_sprite_2&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_3&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_4&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] } * @memberof CB_GraphicSprites * @typedef {Object} CB_GraphicSprites.SPRITES_OBJECT * @property {string|*} [id='CB_GraphicSprites_' + CB_GraphicSprites._idUnique++] - Identifier of the group of graphic sprites (also used as the {@link CB_GraphicSprites.id} property for the {@link CB_GraphicSprites} object). It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @property {*} [src=&quot;&quot;] - Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. * @property {string} [srcType={@link CB_GraphicSprites.SRC_TYPES.DEFAULT}] - Type of the source of origin. It should point to a property of the {@link CB_GraphicSprites.SRC_TYPES} object. You can use other values of the {@link CB_GraphicSprites.SRC_TYPES} object or create new ones. * @property {number} [srcLeft={@link CB_GraphicSprites.LEFT_SOURCE_DEFAULT}] - Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.LEFT_SOURCE_DEFAULT}. * @property {number} [srcTop={@link CB_GraphicSprites.TOP_SOURCE_DEFAULT}] - Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.TOP_SOURCE_DEFAULT}. * @property {number} [srcWidth={@link CB_GraphicSprites.WIDTH_SOURCE_DEFAULT}] - Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.WIDTH_SOURCE_DEFAULT}. * @property {number} [srcHeight={@link CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT}] - Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT}. * @property {number} [left={@link CB_GraphicSprites.LEFT_DEFAULT}] - Left (horizontal) position in the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.LEFT_DEFAULT}. * @property {number} [top={@link CB_GraphicSprites.TOP_DEFAULT}] - Top (vertical) position in the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.TOP_DEFAULT}. * @property {number} [width={@link CB_GraphicSprites.WIDTH_DEFAULT}] - Width of the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.WIDTH_DEFAULT}. * @property {number} [height={@link CB_GraphicSprites.HEIGHT_DEFAULT}] - Height of the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from {@link CB_GraphicSprites.HEIGHT_DEFAULT}. * @property {number} [zIndex={@link CB_GraphicSprites.ZINDEX_DEFAULT}] - The z-index for the destiny (only numeric values which are not zero (0) are allowed). Also used as the {@link CB_GraphicSprites.zIndex} property for the {@link CB_GraphicSprites} object. If not provided, as default it will use the value from {@link CB_GraphicSprites.ZINDEX_DEFAULT}. To change the value of this property, use the {@link CB_GraphicSprites#setZIndex} method (which will call the {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally if there is a {@link CB_GraphicSpritesScene} parent object). * @property {boolean} [disabled=false] - Tells whether this sprites group (and the {@link CB_GraphicSprites} object itself) is disabled or not. If not provided, as default it will be false (which means it is enabled). * @property {object} [data={ 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } }] - Object with any additional data desired which can be any kind. It will always have a &quot;that&quot; property pointing to the {@link CB_GraphicSprites.SPRITES_OBJECT} object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. * @property {array} [sprites=[]] - Numeric array containing {@link CB_GraphicSprites.SPRITE_OBJECT} objects with all the sprites that will be used. Recommended at least to provide one {@link CB_GraphicSprites.SPRITE_OBJECT} object in the first index. * @property {array} spritesByZIndex - Read-only property containing a numeric array of all the {@link CB_GraphicSprites.SPRITE_OBJECT} objects ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sprite is set with its &quot;setZIndex&quot; method (or when calling the {@link CB_GraphicSprites#setZIndexSprite} method) or when inserting/removing sprites through the {@link CB_GraphicSprites#insertSprites}, {@link CB_GraphicSprites#insertSprite}, {@link CB_GraphicSprites#removeSprite} or {@link CB_GraphicSprites#removeSpriteById} methods. * @property {boolean} [byReference_DEFAULT=false] - Default value to use as the &quot;byReference&quot; parameter for the constructor and for the {@link CB_GraphicSprites#insertSprites} method. If a boolean value is not provided, it will be parsed to boolean (resulting undefined to be false). * @property {*} [parent=undefined|{@link CB_GraphicSpritesScene}] - Property pointing to or containing its parent (also used as the {@link CB_GraphicSprites.parent} property for the {@link CB_GraphicSprites} object). It could be a {@link CB_GraphicSpritesScene} object. * @property {CB_GraphicSprites} container - Read-only property pointing to the {@link CB_GraphicSprites} object which contains it. * @property {boolean} isSpritesGroup - Read-only property which is always set to true to help identify this type of object. * @property {'spritesGroup'} type - Read-only property indicating the type of object (always &quot;spritesGroup&quot;). * @property {integer} [position=undefined] - Read-only property indicating the position of this {@link CB_GraphicSprites} object in the array which is set the &quot;items&quot; property inside the {@link CB_GraphicSpritesScene#spritesGroups} object which is in the {@link CB_GraphicSpritesScene} object parent (if any). * @property {integer} [positionByZIndex=undefined] - Read-only property indicating the position of this {@link CB_GraphicSprites} object in the array which is set the &quot;itemsByZIndex&quot; property inside the {@link CB_GraphicSpritesScene#spritesGroups} object which is in the {@link CB_GraphicSpritesScene} object parent (if any). */ /** * Class to manage a group of graphic sprites (2D or 3D). * @class * @classdesc Class to manage a group of graphic sprites (2D or 3D). * @param {CB_GraphicSprites.SPRITES_OBJECT} [spritesGroup] - Object with the desired sprites. The information will be used for the {@link CB_GraphicSprites#spritesGroup} property. Used as the &quot;spritesGroup&quot; parameter when calling the {@link CB_GraphicSprites#insertSprites} method internally. * @param {boolean} [byReference=!!{@link CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT}] - This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects) or sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). The value will be stored in the {@link CB_GraphicSprites#byReference_DEFAULT} property. If a boolean value is not provided, it will use the value of the {@link CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT} property of the given {@link CB_GraphicSprites.SPRITES_OBJECT} object (parsed to boolean). * @returns {CB_GraphicSprites} Returns a new {@link CB_GraphicSprites} object. * @todo Think about a &quot;createCopy&quot; parameter on different the insert methods (to insert sprites groups/graphic sprites objects, etc.) so it will make a copy of the object to avoid using/modifying the original one. If the &quot;createCopy&quot; is set to false, it should always use the object as reference (using/modifying it). * @todo Think about a method to remove a sprite when the same sprite is received by parameter. The same with sub-sprites, receiving the sub-sprite by parameter. The same to remove the sprites group object, receiving a sprites group object by parameter. Only remove them if they match exactly. */ var CB_GraphicSprites = function(spritesGroup, byReference) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_GraphicSprites)) { return new CB_GraphicSprites(spritesGroup, byReference); } //Properties and variables: /** * Identifier of the sprites group object (the &quot;id&quot; property of the {@link CB_GraphicSprites.SPRITES_OBJECT} stored in the {@link CB_GraphicSprites#spritesGroup} property) and the {@link CB_GraphicSprites} object itself (same one). It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @var * @readonly * @type {string|*} * @default 'CB_GraphicSprites_' + CB_GraphicSprites._idUnique++ */ this.id = &quot;&quot;; /** * Property pointing to or containing its parent. It could be a {@link CB_GraphicSpritesScene} object. It is the same as the &quot;parent&quot; property of the {@link CB_GraphicSprites.SPRITES_OBJECT} stored in the {@link CB_GraphicSprites#spritesGroup} property. * @var * @readonly * @type {*} * @default */ this.parent = undefined; /** * Z-index of the sprites group object (the &quot;zIndex&quot; property of the {@link CB_GraphicSprites.SPRITES_OBJECT} stored in the {@link CB_GraphicSprites#spritesGroup} property) and the {@link CB_GraphicSprites} object itself (same one). To change the value of this property, use the {@link CB_GraphicSprites#setZIndex} method (which will call the {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally if there is a {@link CB_GraphicSpritesScene} parent object). Only numeric values which are not zero (0) are allowed. * @var * @readonly * @type {number} * @default CB_GraphicSprites.ZINDEX_DEFAULT */ this.zIndex = CB_GraphicSprites.ZINDEX_DEFAULT; /** * Object with information about the sprites. * @var * @readonly * @type {CB_GraphicSprites.SPRITES_OBJECT} * @default */ this.spritesGroup = {}; /** * Pointer with the position of the current sprite (belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array). * @var * @readonly * @type {integer} * @default */ this.pointer = -1; /** * Keeps the previous value of the {@link CB_GraphicSprites#pointer} property (if any). * @var * @readonly * @type {integer} * @default */ this.pointerPrevious = -1; /** * Stores the time in milliseconds when the current sprite was started being pointed (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which will be obtained calling the {@link CB_Device.getTiming} function internally). * @var * @readonly * @type {integer} * @default */ this.time = 0; /** * This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects) or sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). * @var * @type {boolean} * @default */ this.byReference_DEFAULT = false; //Calls the constructor of the object when creates an instance: return this._init(spritesGroup, byReference); } //Constants: /** * Property which is always set to true to help identify this type of object. * @constant * @type {boolean} * @default */ CB_GraphicSprites.prototype.isSprites = true; /** * Indicates the type of object (always &quot;sprites&quot;). * @constant * @type {string} * @default */ CB_GraphicSprites.prototype.type = &quot;sprites&quot;; /** * Object with some &quot;srcType&quot;. Each property of this object belong to one source type, having an integer as value which represents it. You can define more source types here. * @constant * @type {object} * @default */ CB_GraphicSprites.SRC_TYPES = { IMAGE: 0, TEXT: 1, SEGMENT: 2, PIXEL: 3, RECTANGLE: 4, CIRCLE: 5, ARC: 6, ELLIPSE: 7, TRIANGLE: 8, BEZIER_CURVE: 9, QUADRATIC_BEZIER_CURVE: 10, BITMAP: 11, MAP: 12 } /** * Default &quot;srcType&quot;, the type of the original source. * @constant * @type {integer} * @default */ CB_GraphicSprites.SRC_TYPES.DEFAULT = CB_GraphicSprites.SRC_TYPES.IMAGE; /** * Default width (&quot;srcWidth&quot;) of the original source. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.WIDTH_SOURCE_DEFAULT = 32; /** * Default height (&quot;srcHeight&quot;) of the original source. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT = 32; /** * Default left (&quot;srcLeft&quot;, horizontal position) in the original source. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.LEFT_SOURCE_DEFAULT = 0; /** * Default top (&quot;srcTop&quot;, vertical position) in the original source. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.TOP_SOURCE_DEFAULT = 0; /** * Default &quot;width&quot; of the destiny. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.WIDTH_DEFAULT = CB_GraphicSprites.WIDTH_SOURCE_DEFAULT; /** * Default &quot;height&quot; of the destiny. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.HEIGHT_DEFAULT = CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT; /** * Default &quot;left&quot; (horizontal position) in the destiny. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.LEFT_DEFAULT = 0; /** * Default &quot;top&quot; (vertical position) in the destiny. Unit agnostic. * @constant * @type {number} * @default */ CB_GraphicSprites.TOP_DEFAULT = 0; /** * Default &quot;zIndex&quot; in the destiny. * @constant * @type {number} * @default */ CB_GraphicSprites.ZINDEX_DEFAULT = 1; //Variables: CB_GraphicSprites._idUnique = 0; //Counter to make the sprites group id unique. CB_GraphicSprites._idSpriteUnique = 0; //Counter to make the sprite id unique. CB_GraphicSprites._idSubSpriteUnique = 0; //Counter to make the sub-sprite id unique. //Constructor: CB_GraphicSprites.prototype._init = function(spritesGroup, byReference) { this.insertSprites(spritesGroup, byReference); //Inserts the given sprites group. return this; } /** * Destroys the graphic sprites object (removing all the sprites and their sub-sprites, etc.) and frees memory. * @function */ CB_GraphicSprites.prototype.destructor = function() { //Resets properties to their default value: this.removeSprites(); } /** * Alias for {@link CB_GraphicSprites#removeSprites}. * @function CB_GraphicSprites#removeAll * @see {@link CB_GraphicSprites#removeSprites} */ /** * Alias for {@link CB_GraphicSprites#removeSprites}. * @function CB_GraphicSprites#removeSpritesGroup * @see {@link CB_GraphicSprites#removeSprites} */ /** * Alias for {@link CB_GraphicSprites#removeSprites}. * @function CB_GraphicSprites#removeSpritesAll * @see {@link CB_GraphicSprites#removeSprites} */ /** * Removes all the sprites by clearing the {@link CB_GraphicSprites#spritesGroup} property. * @function */ CB_GraphicSprites.prototype.removeSprites = CB_GraphicSprites.prototype.removeSpritesAll = CB_GraphicSprites.prototype.removeSpritesGroup = CB_GraphicSprites.prototype.removeAll = function() { this.spritesGroup = {}; this.pointer = this.pointerPrevious = -1; } /** * Alias for {@link CB_GraphicSprites#insertSprites}. * @function CB_GraphicSprites#insertSpritesGroup * @see {@link CB_GraphicSprites#insertSprites} */ /** * Adds the desired group of graphic sprites. Calls the {@link CB_GraphicSprites#insertSprite} and {@link CB_GraphicSprites#updateSpritesByZIndex} methods internally. * @function * @param {CB_GraphicSprites.SPRITES_OBJECT} [spritesGroup] - Object with the desired sprites. They will be stored in the {@link CB_GraphicSprites#spritesGroup} property. * @param {boolean} [byReference=!!{@link CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT}] - This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects) or sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). The value will be stored in the {@link CB_GraphicSprites#byReference_DEFAULT} property. If a boolean value is not provided, it will use the value of the {@link CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT} property of the given {@link CB_GraphicSprites.SPRITES_OBJECT} object (parsed to boolean). * @returns {CB_GraphicSprites.SPRITES_OBJECT} Returns the {@link CB_GraphicSprites#spritesGroup} property after updating it. */ CB_GraphicSprites.prototype.insertSprites = CB_GraphicSprites.prototype.insertSpritesGroup = function(spritesGroup, byReference) { //Sets the properties (sanitizing them): this.byReference_DEFAULT = (byReference === true || byReference === false) ? byReference : !!spritesGroup.byReference_DEFAULT; this.spritesGroup = this.spritesGroup || {}; spritesGroup = spritesGroup || {}; this.spritesGroup.isSpritesGroup = true; this.spritesGroup.type = &quot;spritesGroup&quot;; this.spritesGroup.container = this; this.parent = this.spritesGroup.parent = spritesGroup.parent; this.id = this.spritesGroup.id = spritesGroup.id = spritesGroup.id || &quot;CB_GraphicSprites_&quot; + CB_GraphicSprites._idUnique++; this.spritesGroup.src = spritesGroup.src = spritesGroup.src || !isNaN(spritesGroup.src) &amp;&amp; spritesGroup.src !== null ? spritesGroup.src : &quot;&quot;; this.spritesGroup.srcType = spritesGroup.srcType = spritesGroup.srcType || CB_GraphicSprites.SRC_TYPES.DEFAULT; spritesGroup.srcLeft = parseFloat(spritesGroup.srcLeft); this.spritesGroup.srcLeft = spritesGroup.srcLeft = !isNaN(spritesGroup.srcLeft) ? spritesGroup.srcLeft : parseFloat(CB_GraphicSprites.LEFT_SOURCE_DEFAULT) || 0; spritesGroup.left = parseFloat(spritesGroup.left); this.spritesGroup.left = spritesGroup.left = !isNaN(spritesGroup.left) ? spritesGroup.left : parseFloat(CB_GraphicSprites.LEFT_DEFAULT) || 0; spritesGroup.srcTop = parseFloat(spritesGroup.srcTop); this.spritesGroup.srcTop = spritesGroup.srcTop = !isNaN(spritesGroup.srcTop) ? spritesGroup.srcTop : parseFloat(CB_GraphicSprites.TOP_SOURCE_DEFAULT) || 0; spritesGroup.top = parseFloat(spritesGroup.top); this.spritesGroup.top = spritesGroup.top = !isNaN(spritesGroup.top) ? spritesGroup.top : parseFloat(CB_GraphicSprites.TOP_DEFAULT) || 0; spritesGroup.srcWidth = parseFloat(spritesGroup.srcWidth); this.spritesGroup.srcWidth = spritesGroup.srcWidth = !isNaN(spritesGroup.srcWidth) ? spritesGroup.srcWidth : parseFloat(CB_GraphicSprites.WIDTH_SOURCE_DEFAULT) || 0; spritesGroup.width = parseFloat(spritesGroup.width); this.spritesGroup.width = spritesGroup.width = !isNaN(spritesGroup.width) ? spritesGroup.width : CB_GraphicSprites.WIDTH_DEFAULT; spritesGroup.srcHeight = parseFloat(spritesGroup.srcHeight); this.spritesGroup.srcHeight = spritesGroup.srcHeight = !isNaN(spritesGroup.srcHeight) ? spritesGroup.srcHeight : parseFloat(CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT) || 0; spritesGroup.height = parseFloat(spritesGroup.height); this.spritesGroup.height = spritesGroup.height = !isNaN(spritesGroup.height) ? spritesGroup.height : parseFloat(CB_GraphicSprites.HEIGHT_DEFAULT) || 0; this.zIndex = spritesGroup.zIndex = parseFloat(spritesGroup.zIndex); this.spritesGroup.disabled = !!spritesGroup.disabled; this.spritesGroup.zIndex = spritesGroup.zIndex = !isNaN(spritesGroup.zIndex) ? spritesGroup.zIndex : parseFloat(CB_GraphicSprites.ZINDEX_DEFAULT) || 0; this.spritesGroup.data = typeof(spritesGroup.data) === &quot;object&quot; &amp;&amp; spritesGroup.data !== null ? CB_copyObject(spritesGroup.data, false) : {}; //Accepts any object but not other values. this.spritesGroup.data.that = this.spritesGroup; this.spritesGroup.data.getThis = function() { return this.that; }; spritesGroup.sprites = CB_isArray(spritesGroup.sprites) ? spritesGroup.sprites : []; //Inserts the given sprites, one by one: var spritesGroupLength = spritesGroup.sprites.length; for (var x = 0; x &lt; spritesGroupLength; x++) { this.insertSprite(spritesGroup.sprites[x], true); } //Updates the array with the sprites ordered by z-index: this.updateSpritesByZIndex(); //Returns the sprites: return this.spritesGroup; } /** * Updates (sorts again) the &quot;spritesByZIndex&quot; property (which is an array with the sprites ordered by z-index, whose data comes from the array in the &quot;sprites&quot; property of the {@link CB_GraphicSprites#spritesGroup} object) of the {@link CB_GraphicSprites#spritesGroup} object. * @function * @returns {array} Returns the &quot;spritesByZIndex&quot; array of the {@link CB_GraphicSprites#spritesGroup} object after updating it. Returns null if the property could not be obtained or updated. */ CB_GraphicSprites.prototype.updateSpritesByZIndex = function() { this.spritesGroup.sprites = this.spritesGroup.sprites || null; if (this.spritesGroup.sprites) { var spritesGroupLength = this.spritesGroup.sprites.length; if (spritesGroupLength) { var elementIndex = null; this.spritesGroup.spritesByZIndex = []; for (var x = 0; x &lt; spritesGroupLength; x++) { elementIndex = CB_GraphicSpritesScene._choosePositionByZIndex(this.spritesGroup.spritesByZIndex, this.spritesGroup.sprites[x]); this.spritesGroup.spritesByZIndex = CB_Arrays.insertElement(this.spritesGroup.spritesByZIndex, elementIndex, this.spritesGroup.sprites[x]); this.spritesGroup.sprites[x].positionByZIndex = elementIndex; } return this.spritesGroup.spritesByZIndex; } } return null; } /** * Alias for {@link CB_GraphicSprites#removeSprite}. * @function CB_GraphicSprites#remove * @see {@link CB_GraphicSprites#removeSprite} */ /** * Removes a sprite by its index (its position in the {@link CB_GraphicSprites#spritesGroup.sprites} array). Calls the {@link CB_GraphicSprites#updateSpritesByZIndex} method internally. * @function * @param {integer} [index=0] - The index where the sprite is located (its position in the {@link CB_GraphicSprites#spritesGroup.sprites} array). * @returns {boolean} Returns true if the sprite has been deleted or false otherwise. */ CB_GraphicSprites.prototype.removeSprite = CB_GraphicSprites.prototype.remove = function(index) { var removed = false; var spritesLeft = CB_Arrays.removeElementByPosition(this.spritesGroup.sprites, index, function() { removed = true; }); if (removed) { this.spritesGroup.sprites = spritesLeft; //Keeps the pointer if the position is valid or sets to the last position if the position was greater than the current limit or uses the first position otherwise: this.setPointer(this.getPointer()); //Updates the array with the sprites ordered by z-index: this.updateSpritesByZIndex(); } return removed; } /** * Alias for {@link CB_GraphicSprites#removeSpriteById}. * @function CB_GraphicSprites#removeById * @see {@link CB_GraphicSprites#removeSpriteById} */ /** * Removes a sprite by its identifier. Calls the {@link CB_GraphicSprites#updateSpritesByZIndex} method internally. * @function * @param {string|*} [id=undefined] - The identifier of the sprite. * @returns {boolean} Returns true if the sprite has been deleted or false otherwise. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSprites.prototype.removeSpriteById = CB_GraphicSprites.prototype.removeById = function(id) { var removed = false; var spritesLeft = CB_Arrays.removeDuplicated(this.spritesGroup.sprites, function(value, position, array) { if (value &amp;&amp; value.id === id) { removed = true; return true; }; return false; }, true); if (removed) { this.spritesGroup.sprites = spritesLeft; //Keeps the pointer if the position is valid or sets to the last position if the position was greater than the current limit or uses the first position otherwise: this.setPointer(this.getPointer()); //Updates the array with the sprites ordered by z-index: this.updateSpritesByZIndex(); } return removed; } /** * Alias for {@link CB_GraphicSprites#insertSprite}. * @function CB_GraphicSprites#insert * @see {@link CB_GraphicSprites#insertSprite} */ /** * Adds the desired graphic sprite. Calls {@link CB_GraphicSprites#insertSubSprites} internally. If a sprite with the same identifier already exists, it will be replaced by the new one in its same position. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite] - Object with the desired sprite. It will be stored inside the {@link CB_GraphicSprites#spritesGroup} property. * @param {boolean} [avoidUpdatingSpritesByZIndex=false] - If set to true, it will not call the {CB_GraphicSprites#updateSpritesByZIndex} method internally. Internal usage recommended only. * @returns {CB_GraphicSprites.SPRITE_OBJECT} Returns the {@link CB_GraphicSprites.SPRITE_OBJECT} object which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). */ CB_GraphicSprites.prototype.insertSprite = CB_GraphicSprites.prototype.insert = function(sprite, avoidUpdatingSpritesByZIndex) { //Sets the properties (sanitizing them): this.spritesGroup = this.spritesGroup || {}; sprite = sprite || {}; if (sprite.byReference !== true &amp;&amp; sprite.byReference !== false) { sprite.byReference = this.byReference_DEFAULT; } sprite = sprite.byReference ? sprite : CB_copyObject(sprite); sprite.isSprite = true; sprite.type = &quot;sprite&quot;; sprite.container = this; sprite.parent = this.spritesGroup; sprite.time = !isNaN(parseInt(sprite.time)) ? parseInt(sprite.time) : 0; sprite.id = sprite.id || &quot;CB_GraphicSprites.sprite_&quot; + CB_GraphicSprites._idSpriteUnique++; sprite.src = sprite.src || !isNaN(sprite.src) &amp;&amp; sprite.src !== null ? sprite.src : this.spritesGroup.src || !isNaN(this.spritesGroup.src) &amp;&amp; this.spritesGroup.src !== null ? this.spritesGroup.src : &quot;&quot;; sprite.srcType = sprite.srcType || this.spritesGroup.srcType || CB_GraphicSprites.SRC_TYPES.DEFAULT; sprite.srcLeft = parseFloat(sprite.srcLeft); sprite.srcLeft = !isNaN(sprite.srcLeft) ? sprite.srcLeft : parseFloat(this.spritesGroup.srcLeft); sprite.srcLeft = !isNaN(sprite.srcLeft) ? sprite.srcLeft : parseFloat(CB_GraphicSprites.LEFT_SOURCE_DEFAULT) || 0; sprite.left = parseFloat(sprite.left); //sprite.left = !isNaN(sprite.left) ? sprite.left : parseFloat(this.spritesGroup.left); sprite.left = !isNaN(sprite.left) ? sprite.left : parseFloat(CB_GraphicSprites.LEFT_DEFAULT) || 0; sprite.srcTop = parseFloat(sprite.srcTop); sprite.srcTop = !isNaN(sprite.srcTop) ? sprite.srcTop : parseFloat(this.spritesGroup.srcTop); sprite.srcTop = !isNaN(sprite.srcTop) ? sprite.srcTop : parseFloat(CB_GraphicSprites.TOP_SOURCE_DEFAULT) || 0; sprite.top = parseFloat(sprite.top); //sprite.top = !isNaN(sprite.top) ? sprite.top : parseFloat(this.spritesGroup.top); sprite.top = !isNaN(sprite.top) ? sprite.top : parseFloat(CB_GraphicSprites.TOP_DEFAULT) || 0; sprite.srcWidth = parseFloat(sprite.srcWidth); sprite.srcWidth = !isNaN(sprite.srcWidth) ? sprite.srcWidth : parseFloat(this.spritesGroup.srcWidth); sprite.srcWidth = !isNaN(sprite.srcWidth) ? sprite.srcWidth : parseFloat(CB_GraphicSprites.WIDTH_SOURCE_DEFAULT) || 0; sprite.width = parseFloat(sprite.width); sprite.width = !isNaN(sprite.width) ? sprite.width : parseFloat(this.spritesGroup.width); sprite.width = !isNaN(sprite.width) ? sprite.width : parseFloat(CB_GraphicSprites.WIDTH_DEFAULT) || 0; sprite.srcHeight = parseFloat(sprite.srcHeight); sprite.srcHeight = !isNaN(sprite.srcHeight) ? sprite.srcHeight : parseFloat(this.spritesGroup.srcHeight); sprite.srcHeight = !isNaN(sprite.srcHeight) ? sprite.srcHeight : parseFloat(CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT) || 0; sprite.height = parseFloat(sprite.height); sprite.height = !isNaN(sprite.height) ? sprite.height : parseFloat(this.spritesGroup.height); sprite.height = !isNaN(sprite.height) ? sprite.height : parseFloat(CB_GraphicSprites.HEIGHT_DEFAULT) || 0; sprite.zIndex = parseFloat(sprite.zIndex); sprite.zIndex = !isNaN(sprite.zIndex) ? sprite.zIndex : parseFloat(this.spritesGroup.zIndex); sprite.zIndex = !isNaN(sprite.zIndex) ? sprite.zIndex : parseFloat(CB_GraphicSprites.ZINDEX_DEFAULT) || 0; sprite.disabled = !!sprite.disabled || !!this.spritesGroup.disabled; if (!sprite.disabled &amp;&amp; this.isDisabled()) { this.setDisabled(false); } //If it is enabled and its sprites group parent is not, all the sprites group must be enabled. sprite.data = typeof(sprite.data) === &quot;object&quot; &amp;&amp; sprite.data !== null ? sprite.data : this.spritesGroup.data; if (typeof(this.spritesGroup.data) === &quot;object&quot; &amp;&amp; this.spritesGroup.data !== null) { sprite.data = CB_combineJSON(this.spritesGroup.data, sprite.data); } //Combine objects. sprite.data = typeof(sprite.data) === &quot;object&quot; &amp;&amp; sprite.data !== null ? CB_copyObject(sprite.data, false) : {}; sprite.data.that = sprite; sprite.data.getThis = function() { return this.that; }; sprite.subSprites = CB_isArray(sprite.subSprites) ? (sprite.byReference ? sprite.subSprites : CB_Arrays.copy(sprite.subSprites)) : []; //Inserts the methods: sprite.removeAll = sprite.removeSubSprites = function() { return CB_GraphicSprites.prototype.removeSubSprites.call(this.container, sprite); } sprite.insertSubSprites = function(subSprites) { return CB_GraphicSprites.prototype.insertSubSprites.call(this.container, subSprites, sprite); } sprite.remove = function(index) { return CB_GraphicSprites.prototype.removeSubSprite.call(this.container, index, sprite); } sprite.removeById = function(id) { return CB_GraphicSprites.prototype.removeSubSpriteById.call(this.container, id, sprite); } sprite.insert = function(subSprite) { return CB_GraphicSprites.prototype.insertSubSprite.call(this.container, subSprite, sprite); } sprite.getAll = sprite.getSubSprites = function(orderedByZIndex, returnValueOnFail) { return CB_GraphicSprites.prototype.getSubSprites.call(this.container, sprite, orderedByZIndex, returnValueOnFail); } sprite.get = function(index, returnValueOnFail) { return CB_GraphicSprites.prototype.getSubSprite.call(this.container, index, sprite, returnValueOnFail); } sprite.getById = function(id, returnValueOnFail) { return CB_GraphicSprites.prototype.getSubSpriteById.call(this.container, id, sprite, returnValueOnFail); } sprite.getIndexById = function(id) { return CB_GraphicSprites.prototype.getSubSpriteIndexById.call(this.container, id, sprite); } sprite.executeFunctionAll = sprite.executeAll = sprite.forEach = function(functionEach, orderedByZIndex, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { return CB_GraphicSprites.prototype.executeFunctionAllSubSprites.call(this.container, functionEach, orderedByZIndex, delayBetweenEach, sprite, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish); } sprite.getZIndex = function(returnValueOnFail) { return CB_GraphicSprites.prototype.getZIndexSprite.call(this.container, sprite, returnValueOnFail); } sprite.setZIndex = function(zIndex) { return CB_GraphicSprites.prototype.setZIndexSprite.call(this.container, sprite, zIndex); } sprite.isDisabled = function() { return CB_GraphicSprites.prototype.isDisabledSprite.call(this.container, sprite); } sprite.setDisabled = function(disabled, affectSubSprites, affectParent, affectParentChildren) { return CB_GraphicSprites.prototype.setDisabledSprite.call(this.container, sprite, disabled, affectSubSprites, affectParent, affectParentChildren); } sprite.setTime = function(time) { return CB_GraphicSprites.prototype.setTime.call(this, time, false, false); } sprite.getTime = function(returnValueOnFail) { return CB_GraphicSprites.prototype.getTime.call(this, returnValueOnFail); } sprite.getTimeElapsed = function(timeToCompare) { return CB_GraphicSprites.prototype.getTimeElapsed.call(this, timeToCompare); } sprite.getPointer = sprite.getCurrentPosition = function() { return CB_GraphicSprites.prototype.getPointer.call(this.container); } sprite.getPointerPrevious = sprite.getPreviousPosition = function() { return CB_GraphicSprites.prototype.getPointerPrevious.call(this.container); } sprite.setPointer = sprite.setCurrentPosition = function(position, loop) { CB_GraphicSprites.prototype.setPointer.call(this.container, position, loop); return this.getCurrent(); } sprite.getCurrent = sprite.current = sprite.now = function() { return CB_GraphicSprites.prototype.getCurrent.call(this.container); } sprite.setNext = sprite.next = function(loop) { return CB_GraphicSprites.prototype.setNext.call(this.container, loop); } sprite.setPrevious = sprite.previous = function(loop) { return CB_GraphicSprites.prototype.setPrevious.call(this.container, loop); } sprite.getPrevious = function() { return CB_GraphicSprites.prototype.getPrevious.call(this.container); } sprite.setPropertyCascade = function(propertyName, value) { return CB_GraphicSprites.prototype.setPropertyCascade.call(this, propertyName, value, false); } //Inserts the given sub-sprites, one by one: this.insertSubSprites(sprite.subSprites, sprite); //Inserts the sprite: this.spritesGroup.sprites = this.spritesGroup.sprites || []; ////CB_Arrays.copy(this.spritesGroup.sprites); var position = this.getSpriteIndexById(sprite.id); //If there is a sprite with the same ID, it will be replaced by the new one (in the same position): position = position !== -1 ? position : this.spritesGroup.sprites.length; sprite.position = position; this.spritesGroup.sprites[position] = sprite; //If desired, updates the array with the sprites ordered by z-index: if (!avoidUpdatingSpritesByZIndex) { this.updateSpritesByZIndex(); } this.spritesGroup.sprites = this.spritesGroup.sprites; //Keeps the pointer if the position is valid or sets to the last position if the position was greater than the current limit or uses the first position otherwise: this.setPointer(this.getPointer()); //Returns the sprite: return sprite; } /** * Alias for {@link CB_GraphicSprites#removeSubSprites}. * @function CB_GraphicSprites#removeSubSpritesAll * @see {@link CB_GraphicSprites#removeSubSprites} */ /** * Removes all the sub-sprites from a given sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object) by clearing its &quot;subSprites&quot; property (leaving an empty array). * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {boolean} Returns true if the sub-sprites have been deleted or false otherwise. */ CB_GraphicSprites.prototype.removeSubSprites = CB_GraphicSprites.prototype.removeSubSpritesAll = function(sprite) { var removed = false; sprite = sprite || this.getCurrent(); if (sprite) { if (this.spritesGroup &amp;&amp; this.spritesGroup.sprites) { var spritesLength = this.spritesGroup.sprites.length; for (var x = 0; x &lt; spritesLength; x++) { if (this.spritesGroup.sprites[x] === sprite) { this.spritesGroup.sprites[x].subSprites = []; this.spritesGroup.sprites[x].subSpritesByZIndex = []; removed = true; break; } //Just removes one. } } } return removed; } /** * Adds the given sub-sprites to the desired sprite. Calls the {@link CB_GraphicSprites#insertSubSprite} and {@link CB_GraphicSprites#updateSubSpritesByZIndex} methods internally. * @function * @param {array} subSprites - Numeric array with the desired sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). They will be stored inside the given sprite. * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - Object with the desired sprite. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {array} Returns an array with the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects which have been inserted (they could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). */ CB_GraphicSprites.prototype.insertSubSprites = function(subSprites, sprite) { //Sets the properties (sanitizing them): sprite = sprite || this.getCurrent(); subSprites = CB_isArray(subSprites) ? subSprites : []; //Inserts the given sub-sprites, one by one: var subSpritesInserted = []; var subSpritesLength = subSprites.length; for (var x = 0; x &lt; subSpritesLength; x++) { subSpritesInserted[subSpritesInserted.length] = this.insertSubSprite(subSprites[x], sprite, true); } //Updates the array with the sub-sprites ordered by z-index: this.updateSubSpritesByZIndex(sprite); return subSpritesInserted; } /** * Updates (sorts again) the &quot;subSpritesByZIndex&quot; property (which is an array with the sub-sprites ordered by z-index, whose data comes from the array in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object)) of the desired sprite. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {array} Returns the &quot;subSpritesByZIndex&quot; array after updating it. Returns null if the property could not be obtained or updated. */ CB_GraphicSprites.prototype.updateSubSpritesByZIndex = function(sprite) { sprite = sprite || this.getCurrent(); if (sprite &amp;&amp; sprite.subSprites) { var subSpritesLength = sprite.subSprites.length; if (subSpritesLength) { var elementIndex = null; sprite.subSpritesByZIndex = []; for (var x = 0; x &lt; subSpritesLength; x++) { indexElement = CB_GraphicSpritesScene._choosePositionByZIndex(sprite.subSpritesByZIndex, sprite.subSprites[x]); sprite.subSpritesByZIndex = CB_Arrays.insertElement(sprite.subSpritesByZIndex, indexElement, sprite.subSprites[x]); sprite.subSprites[x].positionByZIndex = indexElement; } return sprite.subSpritesByZIndex; } } return null; } /** * Removes a sub-sprite from a given sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object) by its index (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object). Calls the {@link CB_GraphicSprites#updateSubSpritesByZIndex} method internally. * @function * @param {integer} [index=0] - The index where the sub-sprite is located (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object). * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {boolean} Returns true if the sub-sprite has been deleted or false otherwise. */ CB_GraphicSprites.prototype.removeSubSprite = function(index, sprite) { var removed = false; if (this.spritesGroup &amp;&amp; this.spritesGroup.sprites) { sprite = sprite || this.getCurrent(); if (sprite) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (index &lt; 0) { index *= -1; } //It must be a positive integer. var subSpritesLeft = null; var spritesLength = this.spritesGroup.sprites.length; for (var x = 0; x &lt; spritesLength; x++) { if (this.spritesGroup.sprites[x] === sprite) { removed = false; subSpritesLeft = CB_Arrays.removeElementByPosition(this.spritesGroup.sprites[x].subSprites, index, function() { removed = true; }); if (removed) { this.spritesGroup.sprites[x].subSprites = subSpritesLeft; //Updates the array with the sub-sprites ordered by z-index: this.updateSubSpritesByZIndex(sprite); break; //Just removes it from one. } } } } } return removed; } /** * Removes a sub-sprite from a given sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object) by its identifier. Calls the {@link CB_GraphicSprites#updateSubSpritesByZIndex} method internally. * @function * @param {string|*} [id=undefined] - The identifier of the sprite. * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent] - Object with the sprite whose sub-sprites we want to remove. * @returns {boolean} Returns true if the sub-sprite has been deleted or false otherwise. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSprites.prototype.removeSubSpriteById = function(id, sprite) { var removed = false; if (this.spritesGroup &amp;&amp; this.spritesGroup.sprites) { sprite = sprite || this.getCurrent(); if (sprite) { var subSpritesLeft = null; var spritesLength = this.spritesGroup.sprites.length; for (var x = 0; x &lt; spritesLength; x++) { if (this.spritesGroup.sprites[x] === sprite) { removed = false; subSpritesLeft = CB_Arrays.removeDuplicated(this.spritesGroup.sprites[x].subSprites, function(value, position, array) { if (value &amp;&amp; value.id === id) { removed = true; return true; }; return false; }, true); if (removed) { this.spritesGroup.sprites[x].subSprites = subSpritesLeft; //Updates the array with the sub-sprites ordered by z-index: this.updateSubSpritesByZIndex(sprite); break; //Just removes it from one. } } } } } return removed; } /** * Adds the given sub-sprite to the desired sprite. If a sub-sprite with the same identifier already exists, it will be replaced by the new one in its same position. * @function * @param {CB_GraphicSprites.SUBSPRITE_OBJECT} subSprite - Object with the desired sub-sprite. It will be stored inside the given sprite. * @param {CB_GraphicSprites.SPRITE_OBJECT} sprite - Object with the desired sprite. * @param {boolean} [avoidUpdatingSubSpritesByZIndex=false] - If set to true, it will not call the {CB_GraphicSprites#updateSubSpritesByZIndex} method internally. Internal usage recommended only. * @returns {CB_GraphicSprites.SUBSPRITE_OBJECT} Returns the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). */ CB_GraphicSprites.prototype.insertSubSprite = function(subSprite, sprite, avoidUpdatingSubSpritesByZIndex) { //Sets the properties (sanitizing them): this.spritesGroup = this.spritesGroup || {}; sprite = sprite || {}; subSprite = subSprite || {}; if (sprite.byReference !== true &amp;&amp; sprite.byReference !== false) { sprite.byReference = this.byReference_DEFAULT; } subSprite = subSprite.byReference ? subSprite : CB_copyObject(subSprite); sprite.isSubSprite = true; subSprite.type = &quot;subSprite&quot;; subSprite.container = this; subSprite.parent = sprite; subSprite.time = !isNaN(parseInt(subSprite.time)) ? parseInt(subSprite.time) : !isNaN(parseInt(sprite.time)) ? parseInt(sprite.time) : 0; subSprite.id = subSprite.id || &quot;CB_GraphicSprites.subSprite_&quot; + CB_GraphicSprites._idSubSpriteUnique++; subSprite.src = subSprite.src || !isNaN(subSprite.src) &amp;&amp; subSprite.src !== null ? subSprite.src : sprite.src || !isNaN(sprite.src) &amp;&amp; sprite.src !== null ? sprite.src : this.spritesGroup.src || !isNaN(this.spritesGroup.src) &amp;&amp; this.spritesGroup.src !== null ? this.spritesGroup.src : &quot;&quot;; subSprite.srcType = subSprite.srcType || sprite.srcType || this.spritesGroup.srcType || CB_GraphicSprites.SRC_TYPES.DEFAULT; subSprite.srcLeft = parseFloat(subSprite.srcLeft); subSprite.srcLeft = !isNaN(subSprite.srcLeft) ? subSprite.srcLeft : parseFloat(sprite.srcLeft); subSprite.srcLeft = !isNaN(subSprite.srcLeft) ? subSprite.srcLeft : parseFloat(this.spritesGroup.srcLeft); subSprite.srcLeft = !isNaN(subSprite.srcLeft) ? subSprite.srcLeft : parseFloat(CB_GraphicSprites.LEFT_SOURCE_DEFAULT) || 0; subSprite.left = parseFloat(subSprite.left); //subSprite.left = !isNaN(subSprite.left) ? subSprite.left : parseFloat(sprite.left); //subSprite.left = !isNaN(subSprite.left) ? subSprite.left : parseFloat(this.spritesGroup.left); subSprite.left = !isNaN(subSprite.left) ? subSprite.left : parseFloat(CB_GraphicSprites.LEFT_DEFAULT) || 0; subSprite.srcTop = parseFloat(subSprite.srcTop); subSprite.srcTop = !isNaN(subSprite.srcTop) ? subSprite.srcTop : parseFloat(sprite.srcTop); subSprite.srcTop = !isNaN(subSprite.srcTop) ? subSprite.srcTop : parseFloat(this.spritesGroup.srcTop); subSprite.srcTop = !isNaN(subSprite.srcTop) ? subSprite.srcTop : parseFloat(CB_GraphicSprites.TOP_SOURCE_DEFAULT) || 0; subSprite.top = parseFloat(subSprite.top); //subSprite.top = !isNaN(subSprite.top) ? subSprite.top : parseFloat(sprite.top); //subSprite.top = !isNaN(subSprite.top) ? subSprite.top : parseFloat(this.spritesGroup.top); subSprite.top = !isNaN(subSprite.top) ? subSprite.top : parseFloat(CB_GraphicSprites.TOP_DEFAULT) || 0; subSprite.srcWidth = parseFloat(subSprite.srcWidth); subSprite.srcWidth = !isNaN(subSprite.srcWidth) ? subSprite.srcWidth : parseFloat(sprite.srcWidth); subSprite.srcWidth = !isNaN(subSprite.srcWidth) ? subSprite.srcWidth : parseFloat(this.spritesGroup.srcWidth); subSprite.srcWidth = !isNaN(subSprite.srcWidth) ? subSprite.srcWidth : parseFloat(CB_GraphicSprites.WIDTH_SOURCE_DEFAULT) || 0; subSprite.width = parseFloat(subSprite.width); subSprite.width = !isNaN(subSprite.width) ? subSprite.width : parseFloat(sprite.width); subSprite.width = !isNaN(subSprite.width) ? subSprite.width : parseFloat(this.spritesGroup.width); subSprite.width = !isNaN(subSprite.width) ? subSprite.width : parseFloat(CB_GraphicSprites.WIDTH_DEFAULT) || 0; subSprite.srcHeight = parseFloat(subSprite.srcHeight); subSprite.srcHeight = !isNaN(subSprite.srcHeight) ? subSprite.srcHeight : parseFloat(sprite.srcHeight); subSprite.srcHeight = !isNaN(subSprite.srcHeight) ? subSprite.srcHeight : parseFloat(this.spritesGroup.srcHeight); subSprite.srcHeight = !isNaN(subSprite.srcHeight) ? subSprite.srcHeight : parseFloat(CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT) || 0; subSprite.height = parseFloat(subSprite.height); subSprite.height = !isNaN(subSprite.height) ? subSprite.height : parseFloat(sprite.height); subSprite.height = !isNaN(subSprite.height) ? subSprite.height : parseFloat(this.spritesGroup.height); subSprite.height = !isNaN(subSprite.height) ? subSprite.height : parseFloat(CB_GraphicSprites.HEIGHT_DEFAULT) || 0; subSprite.zIndex = parseFloat(subSprite.zIndex); subSprite.zIndex = !isNaN(subSprite.zIndex) ? subSprite.zIndex : parseFloat(sprite.zIndex); subSprite.zIndex = !isNaN(subSprite.zIndex) ? subSprite.zIndex : parseFloat(this.spritesGroup.zIndex); subSprite.zIndex = !isNaN(subSprite.zIndex) ? subSprite.zIndex : parseFloat(CB_GraphicSprites.ZINDEX_DEFAULT) || 0; subSprite.disabled = !!subSprite.disabled || !!sprite.disabled || !!this.spritesGroup.disabled; if (!subSprite.disabled &amp;&amp; this.isDisabledSprite(sprite)) { this.setDisabled(false); } //If it is enabled but its sprite parent is not, all the sprites group must be enabled. subSprite.data = typeof(subSprite.data) === &quot;object&quot; &amp;&amp; subSprite.data !== null ? subSprite.data : sprite.data; if (typeof(sprite.data) === &quot;object&quot; &amp;&amp; sprite.data !== null) { subSprite.data = CB_combineJSON(sprite.data, subSprite.data); } //Combine objects. subSprite.data = typeof(subSprite.data) === &quot;object&quot; &amp;&amp; subSprite.data !== null ? subSprite.data : this.spritesGroup.data; if (typeof(this.spritesGroup.data) === &quot;object&quot; &amp;&amp; this.spritesGroup.data !== null) { subSprite.data = CB_combineJSON(this.spritesGroup.data, subSprite.data); } //Combine objects. subSprite.data = typeof(subSprite.data) === &quot;object&quot; &amp;&amp; subSprite.data !== null ? CB_copyObject(subSprite.data, false) : {}; subSprite.data.that = subSprite; subSprite.data.getThis = function() { return this.that; }; //Inserts the methods: subSprite.getZIndex = function(returnValueOnFail) { return CB_GraphicSprites.prototype.getZIndexSubSprite.call(this.container, subSprite, returnValueOnFail); } subSprite.setZIndex = function(zIndex) { return CB_GraphicSprites.prototype.setZIndexSubSprite.call(this.container, subSprite, zIndex); } subSprite.isDisabled = function() { return CB_GraphicSprites.prototype.isDisabledSubSprite.call(this.container, subSprite); } subSprite.setDisabled = function(disabled, affectParents, affectParentsChildren) { return CB_GraphicSprites.prototype.setDisabledSubSprite.call(this.container, subSprite, disabled, affectParents, affectParentsChildren); } subSprite.setTime = function(time) { return CB_GraphicSprites.prototype.setTime.call(this, time, false, false); } subSprite.getTime = function(returnValueOnFail) { return CB_GraphicSprites.prototype.getTime.call(this, returnValueOnFail, true); } subSprite.getTimeElapsed = function(timeToCompare) { return CB_GraphicSprites.prototype.getTimeElapsed.call(this, timeToCompare, true); } //Inserts the sub-sprite: sprite.subSprites = CB_isArray(sprite.subSprites) ? (sprite.byReference ? sprite.subSprites : CB_Arrays.copy(sprite.subSprites)) : []; var position = this.getSubSpriteIndexById(subSprite.id, sprite); //If there is a sub-sprite with the same ID, it will be replaced by the new one (in the same position). position = position !== -1 ? position : sprite.subSprites.length; subSprite.position = position; sprite.subSprites[position] = subSprite; //If desired, updates the array with the sub-sprites ordered by z-index: if (!avoidUpdatingSubSpritesByZIndex) { this.updateSubSpritesByZIndex(sprite); } //Returns the sub-sprite: return subSprite; } /** * Gets the sprites group object (the internal {@link CB_GraphicSprites.SPRITES_OBJECT} object, if any). * @function * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites.SPRITES_OBJECT|*} Returns a {@link CB_GraphicSprites.SPRITES_OBJECT} object with all the sprites or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSpritesGroup = function(returnValueOnFail) { return this.spritesGroup || returnValueOnFail; } /** * Alias for {@link CB_GraphicSprites#getSprites}. * @function CB_GraphicSprites#getAll * @see {@link CB_GraphicSprites#getSprites} */ /** * Alias for {@link CB_GraphicSprites#getSprites}. * @function CB_GraphicSprites#getSpritesAll * @see {@link CB_GraphicSprites#getSprites} */ /** * Gets all the sprites (the &quot;sprites&quot; property of the internal {@link CB_GraphicSprites.SPRITES_OBJECT} object, if any). * @function * @param {boolean} [orderedByZIndex=false] - If set to true, it will return the sprites sorted by their z-index (ascending order). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {array|*} Returns an array with all the {@link CB_GraphicSprites.SPRITE_OBJECT} objects or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSprites = CB_GraphicSprites.prototype.getSpritesAll = CB_GraphicSprites.prototype.getAll = function(orderedByZIndex, returnValueOnFail) { if (this.spritesGroup) { if (!orderedByZIndex) { return (this.spritesGroup.sprites) ? this.spritesGroup.sprites : returnValueOnFail; } else { return (this.spritesGroup.spritesByZIndex) ? this.spritesGroup.spritesByZIndex : returnValueOnFail; } } return returnValueOnFail; } /** * Alias for {@link CB_GraphicSprites#getSprite}. * @function CB_GraphicSprites#get * @see {@link CB_GraphicSprites#getSprite} */ /** * Gets a desired sprite object through its index (its position in the {@link CB_GraphicSprites#spritesGroup.sprites} array). Faster than getting it through its identifier with the {@link CB_GraphicSprites#getSpriteById} method. * @function * @param {integer} [index=0] - The index where the desired sprite must be located (its position in the {@link CB_GraphicSprites#spritesGroup.sprites} array). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites.SPRITE_OBJECT|*} Returns a {@link CB_GraphicSprites.SPRITE_OBJECT} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSprite = CB_GraphicSprites.prototype.get = function(index, returnValueOnFail) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (index &lt; 0) { index *= -1; } //It must be a positive integer. return this.spritesGroup &amp;&amp; this.spritesGroup.sprites &amp;&amp; this.spritesGroup.sprites[index] ? this.spritesGroup.sprites[index] : returnValueOnFail; } /** * Alias for {@link CB_GraphicSprites#getSpriteById}. * @function CB_GraphicSprites#getById * @see {@link CB_GraphicSprites#getSpriteById} */ /** * Gets a desired sprite object through its identifier. Slower than getting it through its index with the {@link CB_GraphicSprites#getSprite} method. * @function * @param {string|*} [id=undefined] - The identifier of the sprite that we want to get. * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites.SPRITE_OBJECT|*} Returns a {@link CB_GraphicSprites.SPRITE_OBJECT} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSpriteById = CB_GraphicSprites.prototype.getById = function(id, returnValueOnFail) { var index = this.getSpriteIndexById(id); return index !== -1 ? this.spritesGroup.sprites[index] : returnValueOnFail; } /** * Alias for {@link CB_GraphicSprites#getSpriteIndexById}. * @function CB_GraphicSprites#getIndexById * @see {@link CB_GraphicSprites#getSpriteIndexById} */ /** * Gets the index (the position in the {@link CB_GraphicSprites#spritesGroup.sprites} array) of a desired sprite by its identifier. * @function * @param {string|*} [id=undefined] - The identifier of the sprite whose index we want to get. * @returns {integer} Returns the index (the position in the {@link CB_GraphicSprites#spritesGroup.sprites} array) of the desired sprite or -1 if not found. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSprites.prototype.getSpriteIndexById = CB_GraphicSprites.prototype.getIndexById = function(id) { if (this.spritesGroup &amp;&amp; this.spritesGroup.sprites) { var spritesLength = this.spritesGroup.sprites.length; for (var x = 0; x &lt; spritesLength; x++) { if (this.spritesGroup.sprites[x].id === id) { return x; } } } return -1; } /** * Gets an array with all the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects of a given {@link CB_GraphicSprites.SPRITE_OBJECT} object. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite and its sub-sprites. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {boolean} [orderedByZIndex=false] - If set to true, it will return the sub-sprites sorted by their z-index (ascending order). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {array|*} Returns an array with all the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSubSprites = function(sprite, orderedByZIndex, returnValueOnFail) { sprite = sprite || this.getCurrent(); if (sprite) { if (!orderedByZIndex) { return sprite.subSprites ? sprite.subSprites : returnValueOnFail; } else { return sprite.subSpritesByZIndex ? sprite.subSpritesByZIndex : returnValueOnFail; } } return returnValueOnFail; } /** * Gets a desired sub-sprite object through its index (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object). Faster than getting it through its identifier with the {@link CB_GraphicSprites#getSubSpriteById} method. * @function * @param {integer} [index=0] - The index where the desired sub-sprite must be located (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object). * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite and its sub-sprites. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites.SUBSPRITE_OBJECT|*} Returns a {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSubSprite = function(index, sprite, returnValueOnFail) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (index &lt; 0) { index *= -1; } //It must be a positive integer. sprite = sprite || this.getCurrent(); return sprite &amp;&amp; sprite.subSprites &amp;&amp; sprite.subSprites[index] ? sprite.subSprites[index] : returnValueOnFail; } /** * Gets a desired sub-sprite object through its identifier from the given {@link CB_GraphicSprites.SPRITE_OBJECT} object. Slower than getting it through its index with the {@link CB_GraphicSprites#getSubSprite} method. * @function * @param {string|*} [id=undefined] - The identifier of the sub-sprite that we want to get. * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite and its sub-sprites. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites.SUBSPRITE_OBJECT|*} Returns a {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getSubSpriteById = function(id, sprite, returnValueOnFail) { sprite = sprite || this.getCurrent(); var index = this.getSubSpriteIndexById(id, sprite); return index !== -1 ? sprite.subSprites[index] : returnValueOnFail; } /** * Gets the index (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object) of a desired sub-sprite by its identifier. * @function * @param {string|*} [id=undefined] - The identifier of the sub-sprite whose index we want to get. * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite and its sub-sprites. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {integer} Returns the index (its position in the array which is in the &quot;subSprites&quot; property of the given {@link CB_GraphicSprites.SPRITE_OBJECT} object) of the desired sub-sprite or -1 if not found. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSprites.prototype.getSubSpriteIndexById = function(id, sprite) { sprite = sprite || this.getCurrent(); if (sprite &amp;&amp; sprite.subSprites) { var subSpritesLength = sprite.subSprites.length; for (var x = 0; x &lt; subSpritesLength; x++) { if (sprite.subSprites[x].id === id) { return x; } } } return -1; } /** * Alias for {@link CB_GraphicSprites#executeFunctionAll}. * @function CB_GraphicSprites#executeAll * @see {@link CB_GraphicSprites#executeFunctionAll} */ /** * Alias for {@link CB_GraphicSprites#executeFunctionAll}. * @function CB_GraphicSprites#forEach * @see {@link CB_GraphicSprites#executeFunctionAll} */ /** * Alias for {@link CB_GraphicSprites#executeFunctionAll}. * @function CB_GraphicSprites#forEachSprite * @see {@link CB_GraphicSprites#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects) or on the desired ones (if provided). Calls the {@link CB_Arrays.executeFunctionAll} function internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Function that will be called for each sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object). As the first parameter it receives the {@link CB_GraphicSprites.SPRITE_OBJECT} object of the &quot;sprites&quot; being looped, as the second parameter the position of this {@link CB_GraphicSprites.SPRITE_OBJECT} object in the &quot;sprites&quot; array provided (or, if not provided, in the array returned by the {@link CB_GraphicSprites#getSprites} method), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the {@link CB_GraphicSprites.SPRITE_OBJECT} object itself. * @param {boolean} [orderedByZIndex=false] - If set to true, it will loop the sprites sorted by their z-index (ascending order). * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each {@link CB_GraphicSprites.SPRITE_OBJECT} object). * @param {array} [sprites={@link CB_GraphicSprites#getSprites}()] - A numeric array containing the sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects) that we want to loop. It should contain only {@link CB_GraphicSprites.SPRITE_OBJECT} objects which are already in the current {@link CB_GraphicSprites} object. If not provided, it will use all the {@link CB_GraphicSprites.SPRITE_OBJECT} objects contained in the {@link CB_GraphicSprites} object. * @param {boolean} [returnSetTimeoutsArray=false] - Defines whether we want the method to return an integer or a numeric array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call. Returning an array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call is only useful when the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). * @param {boolean} [delayBetweenEachAffectsFirst=false] - If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_GraphicSprites.SPRITE_OBJECT} objects given in the &quot;sprites&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_Arrays.executeFunctionAll_OBJECT} object for each {@link CB_GraphicSprites.SPRITE_OBJECT} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about only allowing {@link CB_GraphicSprites.SPRITE_OBJECT} objects (in the &quot;sprites&quot; parameter) which are already in the {@link CB_GraphicSprites} (identify them by their ID), to avoid problems. */ CB_GraphicSprites.prototype.executeFunctionAll = CB_GraphicSprites.prototype.executeAll = CB_GraphicSprites.prototype.forEachSprite = CB_GraphicSprites.prototype.forEach = function(functionEach, orderedByZIndex, delayBetweenEach, sprites, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { return CB_Arrays.executeFunctionAll(CB_isArray(sprites) ? sprites : this.getSprites(orderedByZIndex, []), functionEach, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish); } /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAllSubSprites}. * @function CB_AudioFileSpritesPool#executeAllSubSprites * @see {@link CB_AudioFileSpritesPool#executeFunctionAllSubSprites} */ /** * Alias for {@link CB_AudioFileSpritesPool#executeFunctionAllSubSprites}. * @function CB_AudioFileSpritesPool#forEachSubSprite * @see {@link CB_AudioFileSpritesPool#executeFunctionAllSubSprites} */ /** * Performs a desired action, using the provided function, on all the existing sub-sprites ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects) from a given sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object). Calls the {@link CB_Arrays.executeFunctionAll} function internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Function that will be called for each sub-sprite ({@link CB_GraphicSprites.SUBSPRITE_OBJECT} object) from the given sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object). As the first parameter it receives the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object of the sub-sprites being looped, as the second parameter the position of this {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object in the &quot;subSprites&quot; property of the sprite ({@link CB_GraphicSprites.SPRITE_OBJECT} object) provided (which is an array), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object itself. * @param {boolean} [orderedByZIndex=false] - If set to true, it will loop the sub-sprites sorted by their z-index (ascending order). * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object). * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite and its sub-sprites. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {boolean} [returnSetTimeoutsArray=false] - Defines whether we want the method to return an integer or a numeric array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call. Returning an array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call is only useful when the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). * @param {boolean} [delayBetweenEachAffectsFirst=false] - If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the existing {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects in the given {@link CB_GraphicSprites.SPRITE_OBJECT} object). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_Arrays.executeFunctionAll_OBJECT} object for each {@link CB_GraphicSprites.SUBSPRITE_OBJECT}. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about only allowing {@link CB_GraphicSprites.SPRITE_OBJECT} objects (in the &quot;sprite&quot; parameter) which are already in the {@link CB_GraphicSprites.SPRITE_OBJECT} (identify them by their ID), to avoid problems. */ CB_GraphicSprites.prototype.executeFunctionAllSubSprites = CB_GraphicSprites.prototype.executeAllSubSprites = CB_GraphicSprites.prototype.forEachSubSprite = function(functionEach, orderedByZIndex, delayBetweenEach, sprite, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { return CB_Arrays.executeFunctionAll(this.getSubSprites(sprite, orderedByZIndex, []), functionEach, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish); } /** * Alias for {@link CB_GraphicSprites#getPointerPrevious}. * @function CB_GraphicSprites#getPreviousPosition * @see {@link CB_GraphicSprites#getPointerPrevious} */ /** * Gets the previous position of the pointer. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). Internally, it uses the {@link CB_GraphicSprites#pointerPrevious} property. * @function * @returns {integer} Returns the position where the pointer was previously pointing to. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). If not found, returns -1 by default. */ CB_GraphicSprites.prototype.getPointerPrevious = CB_GraphicSprites.prototype.getPreviousPosition = function() { return this.pointerPrevious === 0 || parseInt(this.pointerPrevious) &amp;&amp; this.pointerPrevious &gt; 0 ? this.pointerPrevious : -1; } /** * Alias for {@link CB_GraphicSprites#getPointer}. * @function CB_GraphicSprites#getCurrentPosition * @see {@link CB_GraphicSprites#getPointer} */ /** * Gets the current position of the pointer. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). Internally, it uses the {@link CB_GraphicSprites#pointer} property. * @function * @returns {integer} Returns the position where the pointer is currently pointing to. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). If not found, returns zero (0) by default. */ CB_GraphicSprites.prototype.getPointer = CB_GraphicSprites.prototype.getCurrentPosition = function() { return parseInt(this.pointer) &amp;&amp; this.pointer &gt; 0 ? this.pointer : 0; } /** * Alias for {@link CB_GraphicSprites#setPointer}. * @function CB_GraphicSprites#setCurrentPosition * @see {@link CB_GraphicSprites#setPointer} */ /** * Sets the pointer to the desired position (if possible). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will also reset the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). * @function * @param {integer} [position=0|CB_GraphicSprites#spritesGroup.sprites.length-1|position%CB_GraphicSprites#spritesGroup.sprites.length] - The position that we want the pointer to use. The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). * @param {boolean} [loop=false] - If set to false and the &quot;position&quot; given is greater than the current number of sprites, the &quot;position&quot; used will be the one which belongs to the last sprite. If set to false and the &quot;position&quot; given is lower than zero, the &quot;position&quot; used will be zero (the first position). Otherwise, if set to true and the &quot;position&quot; given is greater than the current number of sprites or lower than zero, it will modify the given &quot;position&quot; making it cycle (from the end to the beginning) treating always the &quot;position&quot; as a positive number. This parameter is ignored when the given &quot;position&quot; has not reached the limit. * @returns {integer} Returns the position where the pointer is currently pointing to. It belongs to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite). */ CB_GraphicSprites.prototype.setPointer = CB_GraphicSprites.prototype.setCurrentPosition = function(position, loop) { if (this.spritesGroup &amp;&amp; this.spritesGroup.sprites &amp;&amp; this.spritesGroup.sprites.length) { position = position || 0; if (loop) { if (position &lt; 0) { position = position * -1; } //Converts it to a positive number. position %= this.spritesGroup.sprites.length; } else if (position &lt; 0) { position = 0; } else if (position &gt;= this.spritesGroup.sprites.length) { position = this.spritesGroup.sprites.length - 1; } if (this.pointer !== position) { this.pointerPrevious = this.pointer; this.pointer = position; this.setTime(undefined, true, true); } //Updates the pointer and &quot;resets&quot; the time. } return this.pointer || 0; } /** * Gets the sprite (a {@link CB_GraphicSprites.SPRITE_OBJECT} object) which was previously pointed (by the previous value of the pointer set in the {@link CB_GraphicSprites#pointer} property, whose value is now in the {@link CB_GraphicSprites#pointerPrevious} property). * @function * @returns {CB_GraphicSprites.SPRITE_OBJECT|null} Returns the {@link CB_GraphicSprites.SPRITE_OBJECT} object which was previously pointed by the pointer (by the previous value of the pointer set in the {@link CB_GraphicSprites#pointer} property, whose value is now in the {@link CB_GraphicSprites#pointerPrevious} property). Returns null if not found. */ CB_GraphicSprites.prototype.getPrevious = function() { if (this.pointerPrevious === 0 || parseInt(this.pointerPrevious) &amp;&amp; this.pointerPrevious &gt; 0) { return this.getSprite(this.pointerPrevious, null); } else { return null; } } /** * Alias for {@link CB_GraphicSprites#getCurrent}. * @function CB_GraphicSprites#now * @see {@link CB_GraphicSprites#getCurrent} */ /** * Alias for {@link CB_GraphicSprites#getCurrent}. * @function CB_GraphicSprites#current * @see {@link CB_GraphicSprites#getCurrent} */ /** * Gets the sprite (a {@link CB_GraphicSprites.SPRITE_OBJECT} object) which is being currently pointed (by the pointer set in the {@link CB_GraphicSprites#pointer} property). * @function * @returns {CB_GraphicSprites.SPRITE_OBJECT|null} Returns the {@link CB_GraphicSprites.SPRITE_OBJECT} object which is currently pointed by the pointer (set in the {@link CB_GraphicSprites#pointer} property). Returns null if not found. */ CB_GraphicSprites.prototype.getCurrent = CB_GraphicSprites.prototype.current = CB_GraphicSprites.prototype.now = function() { return this.getSprite(this.getPointer(), null); } /** * Alias for {@link CB_GraphicSprites#setPrevious}. * @function CB_GraphicSprites#previous * @see {@link CB_GraphicSprites#setPrevious} */ /** * Makes the pointer to go back to the previous position (if possible) and returns the sprite located there (if any). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will update also the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). * @function * @param {boolean} [loop=false] - If set to false and the previous position is lower than zero, it will return null. Otherwise, if set to true and the position is lower than zero, it will modify the position making it cycle (from the beginning to the end). This parameter is ignored when the position has not reached the limit. * @returns {CB_GraphicSprites.SPRITE_OBJECT|null} Makes it to point to the previous {@link CB_GraphicSprites.SPRITE_OBJECT} object (making it the current one) and returns it. Returns null if it cannot be found. */ CB_GraphicSprites.prototype.setPrevious = CB_GraphicSprites.prototype.previous = function(loop) { var pointer = this.getPointer() - 1; if (pointer &lt; 0) { if (loop &amp;&amp; this.spritesGroup &amp;&amp; this.spritesGroup.sprites &amp;&amp; this.spritesGroup.sprites.length) { pointer = this.spritesGroup.sprites.length + pointer; } else { return null; } } var sprite = this.getSprite(pointer, null); if (sprite !== null &amp;&amp; this.pointer !== pointer) { this.pointerPrevious = this.pointer; this.pointer = pointer; this.setTime(undefined, true, true); } //Updates the pointer and &quot;resets&quot; the time. return sprite; } /** * Alias for {@link CB_GraphicSprites#setNext}. * @function CB_GraphicSprites#next * @see {@link CB_GraphicSprites#setNext} */ /** * Makes the pointer to advance to the next position (if possible) and returns the sprite located there (if any). The position should belong to an index of the {@link CB_GraphicSprites#spritesGroup.sprites} array where a {@link CB_GraphicSprites.SPRITE_OBJECT} object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the {@link CB_GraphicSprites#pointer} property (if possible). If the position was updated, it will also update the {@link CB_GraphicSprites#time} property (setting the current time in milliseconds). * @function * @param {boolean} [loop=false] - If set to false and the next position is greater than the current number of sprites, it will return null. Otherwise, if set to true and the position is greater than the current number of sprites, it will modify the position making it cycle (from the end to the beginning). This parameter is ignored when the position has not reached the limit. * @returns {CB_GraphicSprites.SPRITE_OBJECT|null} Makes it to point to the next {@link CB_GraphicSprites.SPRITE_OBJECT} object (making it the current one) and returns it. Returns null if it cannot be found. */ CB_GraphicSprites.prototype.setNext = CB_GraphicSprites.prototype.next = function(loop) { var pointer = this.getPointer() + 1; if (loop &amp;&amp; this.spritesGroup &amp;&amp; this.spritesGroup.sprites &amp;&amp; this.spritesGroup.sprites.length) { pointer %= this.spritesGroup.sprites.length; } var sprite = this.getSprite(pointer, null); if (sprite !== null &amp;&amp; this.pointer !== pointer) { this.pointerPrevious = this.pointer; this.pointer = pointer; this.setTime(undefined, true, true); } //Updates the pointer and &quot;resets&quot; the time. return sprite; } /** * Gets the z-index (&quot;zIndex&quot; property) of the sprites group object (and the {@CB_GraphicSprites} object itself). * @function * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the sprites group object (and the {@CB_GraphicSprites} object itself). If not found, returns the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getZIndex = function(returnValueOnFail) { return parseFloat(this.zIndex) || CB_GraphicSprites.ZINDEX_DEFAULT || returnValueOnFail; } /** * Sets the desired z-index (&quot;zIndex&quot; property) of the sprites group object (and the {@CB_GraphicSprites} object itself). If there is a {@link CB_GraphicSpritesScene} parent object (set in the {@link CB_GraphicSprites.parent} property), it will also call its {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally. * @function * @param {number} [zIndex=parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||1] - The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or 1 otherwise. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the sprites group object (and the {@CB_GraphicSprites} object itself) after setting it (it could have been sanitized). */ CB_GraphicSprites.prototype.setZIndex = function(zIndex) { this.zIndex = parseFloat(zIndex) || CB_GraphicSprites.ZINDEX_DEFAULT || 1; if (this.spritesGroup) { this.spritesGroup.zIndex = this.zIndex; } //If there is a parent (CB_GraphicSpritesScene object), updates the array with its CB_GraphicSprites ordered by z-index: if (this.parent &amp;&amp; typeof(this.parent.updateGraphicSpritesByZIndex) === &quot;function&quot;) { this.parent.updateGraphicSpritesByZIndex.call(this.parent); } return this.zIndex; } /** * Gets the z-index (&quot;zIndex&quot; property) of a given sprite object. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the given sprite. If not found, returns the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getZIndexSprite = function(sprite, returnValueOnFail) { sprite = sprite || this.getCurrent(); return sprite &amp;&amp; parseFloat(sprite.zIndex) ? sprite.zIndex : CB_GraphicSprites.ZINDEX_DEFAULT || returnValueOnFail; } /** * Sets the desired z-index (&quot;zIndex&quot;) of the given sprite object. Calls the {@link CB_GraphicSprites#updateSpritesByZIndex} method internally. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {number} [zIndex=parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||1] - The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or 1 otherwise. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the given sprite after setting it (it could have been sanitized). */ CB_GraphicSprites.prototype.setZIndexSprite = function(sprite, zIndex) { sprite = sprite || this.getCurrent(); if (sprite &amp;&amp; sprite.parent) { sprite.zIndex = parseFloat(zIndex) || CB_GraphicSprites.ZINDEX_DEFAULT || 1; //Updates the array with the sprites ordered by z-index: this.updateSpritesByZIndex(); } return sprite.zIndex; } /** * Gets the z-index (&quot;zIndex&quot; property) of a given sub-sprite object. * @function * @param {CB_GraphicSprites.SUBSPRITE_OBJECT} subSprite - The {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object which contains the sub-sprite. * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the given sub-sprite. If not found, returns the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSprites.prototype.getZIndexSubSprite = function(subSprite, returnValueOnFail) { return subSprite &amp;&amp; parseFloat(subSprite.zIndex) ? subSprite.zIndex : CB_GraphicSprites.ZINDEX_DEFAULT || returnValueOnFail; } /** * Sets the desired z-index (&quot;zIndex&quot;) of the given sub-sprite object. Calls the {@link CB_GraphicSprites#updateSubSpritesByZIndex} method internally. * @function * @param {CB_GraphicSprites.SUBSPRITE_OBJECT} sprite - The {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object which contains the sub-sprite. * @param {number} [zIndex=parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||0] - The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the {@link CB_GraphicSprites.ZINDEX_DEFAULT} property of evaluates to true or 1 otherwise. * @returns {number} Returns the z-index (&quot;zIndex&quot;) of the given sub-sprite after setting it (it could have been sanitized). */ CB_GraphicSprites.prototype.setZIndexSubSprite = function(subSprite, zIndex) { if (subSprite &amp;&amp; subSprite.parent) { subSprite.zIndex = parseFloat(zIndex) || CB_GraphicSprites.ZINDEX_DEFAULT || 1; //Updates the array with the sub-sprites ordered by z-index: this.updateSubSpritesByZIndex(subSprite.parent); } return subSprite.zIndex; } /** * Tells whether the sprites group object (and the {@CB_GraphicSprites} object itself) is disabled or not. Internally, it checks the &quot;{@link CB_GraphicSprites.spritesGroup}.disabled&quot; property. * @function * @returns {boolean} Returns whether the sprites group object (and the {@link CB_GraphicSprites} object itself) is disabled or not. */ CB_GraphicSprites.prototype.isDisabled = function() { return !!this.getSpritesGroup({}).disabled; } /** * Sets whether the sprites group object (and the {@CB_GraphicSprites} object itself) is disabled or enabled. Internally, it edits the &quot;{@link CB_GraphicSprites.spritesGroup}.disabled&quot; property. * @function * @param {boolean} [disabled=false] - Set to true to disable it or false to enable it. * @param {boolean} [affectChildren=disabled] - If this parameter is set to true, it will also modify the &quot;disabled&quot; property of all the sprites and their sub-sprites. By default, it is false if the &quot;disabled&quot; parameter is set to false or it is true otherwise. */ CB_GraphicSprites.prototype.setDisabled = function(disabled, affectChildren) { disabled = !!disabled; if (typeof(affectChildren) === &quot;undefined&quot; || affectChildren === null) { affectChildren = disabled; } this.spritesGroup = this.spritesGroup || {}; this.spritesGroup.disabled = disabled; if (affectChildren) { this.executeFunctionAll(function() { if (this.setDisabled &amp;&amp; typeof(this.setDisabled) === &quot;function&quot;) { this.setDisabled(disabled, true, false, false); } }); } } /** * Tells whether the given sprite is disabled or not. Internally, it checks its &quot;disabled&quot; property and also the &quot;{@link CB_GraphicSprites.spritesGroup}.disabled&quot; property (calling the {@link CB_GraphicSprites#isDisabled} method internally). A sprite is considered disabled if its sprites group parent is also disabled. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @returns {boolean} Returns whether the sprite is disabled or not. A sprite is considered disabled if its sprites group parent is also disabled. */ CB_GraphicSprites.prototype.isDisabledSprite = function(sprite) { sprite = sprite || this.getCurrent() || {}; return !!sprite.disabled || this.isDisabled(); } /** * Sets a given sprite disabled or enabled. Internally, it edits its &quot;disabled&quot; property. * @function * @param {CB_GraphicSprites.SPRITE_OBJECT} [sprite=CB_GraphicSprites#getCurrent()] - The {@link CB_GraphicSprites.SPRITE_OBJECT} object which contains the sprite. If not provided, it will use the {@link CB_GraphicSprites.SPRITE_OBJECT} object which the pointer (set in the {@link CB_GraphicSprites#pointer} property) is currently pointing to (using the returning value of the {@link CB_GraphicSprites#getCurrent} method internally). * @param {boolean} [disabled=false] - Set to true to disable it or false to enable it. * @param {boolean} [affectSubSprites=disabled] - If this parameter is set to true, it will also modify the &quot;disabled&quot; property of all the sub-sprites of the given sprite. This parameter will be ignored if the &quot;affectParent&quot; parameter is set to true (as all existing sprites and sub-sprites in the {@link CB_GraphicSprites} object will be affected anyway). By default, it is false if the &quot;disabled&quot; parameter is set to false or it is true otherwise. * @param {boolean} [affectParent=affectParentChildren|!disabled] - If this parameter is set to true, it will also modify the &quot;disabled&quot; property of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object). By default, it is true if either the &quot;affectParentChildren&quot; parameter is set to true or the &quot;disabled&quot; parameter is set to false and it is false otherwise. * @param {boolean} [affectParentChildren=!disabled] - Defines whether to also affect the sprites and sub-sprites of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object) or not. If it is set to true and the &quot;affectParent&quot; is also set to true, it will also modify the &quot;disabled&quot; property of all the existing sprites and sub-sprites in the {@link CB_GraphicSprites} object. This parameter is ignored if the &quot;affectParent&quot; parameter is set to false. By default, it is false if the &quot;disabled&quot; parameter is set to true or it is false otherwise. */ CB_GraphicSprites.prototype.setDisabledSprite = function(sprite, disabled, affectSubSprites, affectParent, affectParentChildren) { disabled = !!disabled; if (typeof(affectParentChildren) === &quot;undefined&quot; || affectParentChildren === null) { affectParentChildren = !disabled; } if (typeof(affectParent) === &quot;undefined&quot; || affectParent === null) { affectParent = affectParentChildren || !disabled; } sprite = sprite || this.getCurrent(); if (sprite) { sprite.disabled = disabled; if (typeof(affectSubSprites) === &quot;undefined&quot; || affectSubSprites === null) { affectSubSprites = disabled; } if (affectSubSprites) { if (typeof(sprite.executeFunctionAll) === &quot;function&quot;) { sprite.executeFunctionAll(function() { if (this.setDisabled &amp;&amp; typeof(this.setDisabled) === &quot;function&quot;) { this.setDisabled(disabled, false, false); } }); } } if (affectParent &amp;&amp; sprite &amp;&amp; sprite.parent) { return this.setDisabled(disabled, affectParentChildren); //Disables/enables the sprites group parent (and also its children). } } } /** * Tells whether the given sub-sprite is disabled or not. Internally, it checks its &quot;disabled&quot; property and also whether its sprite parent is disabled (calling the {@link CB_GraphicSprites#isDisabledSprite} method internally, for its sprite parent). A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). * @function * @param {CB_GraphicSprites.SUBSPRITE_OBJECT} subSprite - The {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object which contains the sub-sprite. * @returns {boolean} Returns whether the sub-sprite is disabled or not. A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). */ CB_GraphicSprites.prototype.isDisabledSubSprite = function(subSprite) { subSprite = subSprite || {}; return !!subSprite.disabled || this.isDisabledSprite(subSprite.parent || {}); } /** * Sets a given sub-sprite disabled or enabled. Internally, it edits its &quot;disabled&quot; property. * @function * @param {CB_GraphicSprites.SUBSPRITE_OBJECT} subSprite - The {@link CB_GraphicSprites.SUBSPRITE_OBJECT} object which contains the sub-sprite. * @param {boolean} [disabled=false] - Set to true to disable it or false to enable it. * @param {boolean} [affectParents=affectParentsChildren|!disabled] - If this parameter is set to true, it will also modify the &quot;disabled&quot; property of the sprite parent and of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object). By default, it is true if either the &quot;affectParentChildren&quot; parameter is set to true or the &quot;disabled&quot; parameter is set to false and it is false otherwise. * @param {boolean} [affectParentsChildren=!disabled] - Defines whether to also affect the sprites and sub-sprites of the sprite parent and its sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object) or not. If it is set to true and the &quot;affectParents&quot; is also set to true, it will also modify the &quot;disabled&quot; property of all the existing sprites and sub-sprites in the {@link CB_GraphicSprites} object. This parameter is ignored if the &quot;affectParents&quot; parameter is set to false. By default, it is false if the &quot;disabled&quot; parameter is set to true or it is false otherwise. */ CB_GraphicSprites.prototype.setDisabledSubSprite = function(subSprite, disabled, affectParents, affectParentsChildren) { disabled = !!disabled; if (typeof(affectParentsChildren) === &quot;undefined&quot; || affectParentsChildren === null) { affectParentsChildren = !disabled; } if (typeof(affectParents) === &quot;undefined&quot; || affectParents === null) { affectParents = affectParentsChildren || !disabled; } if (subSprite) { subSprite.disabled = disabled; if (affectParents &amp;&amp; subSprite.parent) { return this.setDisabledSprite(subSprite.parent, disabled, affectParentsChildren, true, affectParentsChildren); } } } /** * Sets (updates) the time in milliseconds when the current sprite or a sub-sprite started being pointed. * @function * @param {number} [time=CB_Device.getTiming()] - The time that we want to set, in milliseconds (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can be obtained calling the {@link CB_Device.getTiming} function). It must be a positive number (or zero). If not provided, it will use the current time (by calling the {@link CB_Device.getTiming} function internally). * @param {boolean} [updateTimeCurrentSprite=false] - If set to true, it will also update the &quot;time&quot; property of the {@link CB_GraphicSprites.SPRITE_OBJECT} object which is currently pointed by the pointer (set in the {@link CB_GraphicSprites#pointer} property). * @param {boolean} [updateTimeCurrentSpriteSubSprites=false] - If set to true and the &quot;updateTimeCurrentSprite&quot; is set to true, it will also update the &quot;time&quot; property of the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects that belong to the sprite which is currently pointed by the pointer (set in the {@link CB_GraphicSprites#pointer} property). This parameter is ignored if the &quot;updateTimeCurrentSprite&quot; parameter is set to false. * @returns {number} Returns the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can be obtained calling the {@link CB_Device.getTiming} function). */ CB_GraphicSprites.prototype.setTime = function(time, updateTimeCurrentSprite, updateTimeCurrentSpriteSubSprites) { time = parseFloat(time); time = !isNaN(time) &amp;&amp; time &gt;= 0 ? time : CB_Device.getTiming(); this.time = time; if (updateTimeCurrentSprite) { var sprite = this.getSprite(this.getPointer(), null); if (sprite !== null) { sprite.time = time; if (updateTimeCurrentSpriteSubSprites) { sprite.forEach(function() { this.time = time; }); } } } return this.time; } /** * Gets the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which was obtained calling the {@link CB_Device.getTiming} function internally). * @function * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @param {boolean} [parentTimeFallback=false] - If the &quot;time&quot; property of &quot;this&quot; is not found, it will try to get the &quot;time&quot; property of &quot;this.time&quot; before returning &quot;returnValueOnFail&quot;. * @returns {number} Returns the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which was obtained calling the {@link CB_Device.getTiming} function internally). If it could not be found, it will return &quot;returnValueOnFail&quot;. */ CB_GraphicSprites.prototype.getTime = function(returnValueOnFail, parentTimeFallback) { if (parentTimeFallback) { returnValueOnFail = this.parent.time || returnValueOnFail; } return this.time || returnValueOnFail; } /** * Tells how many milliseconds elapsed since the current sprite or a sub-sprite was or will be pointed (checking the {@link CB_GraphicSprites#time} property), comparing with the time given in milliseconds (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can be obtained calling the {@link CB_Device.getTiming} function) or with the current one if none is given. * @function * @param {number} [timeToCompare=CB_Device.getTiming()] - The time (time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin} which can obtained calling the {@link CB_Device.getTiming} function) that we want to compare to (normally, it will be a newer time than the one stored in the {@link CB_GraphicSprites#time} property). It must be a positive number (or zero). If not provided, it will use the current time (by calling the {@link CB_Device.getTiming} function internally). * @param {boolean} [parentTimeFallback=false] - If the &quot;time&quot; property of &quot;this&quot; is not found, it will try to get the &quot;time&quot; property of &quot;this.time&quot; before using &quot;returnValueOnFail&quot;. * @returns {number} Returns how many milliseconds elapsed since the current sprite or a sub-sprite was or will be pointed, comparing with the time given (in milliseconds) or with the current one if none was given. This is just the given &quot;timeToCompare&quot; minus the returning value of calling the {@link CB_GraphicSprites#getTime} method. */ CB_GraphicSprites.prototype.getTimeElapsed = function(timeToCompare, parentTimeFallback) { timeToCompare = parseFloat(timeToCompare); timeToCompare = !isNaN(timeToCompare) &amp;&amp; timeToCompare &gt;= 0 ? timeToCompare : CB_Device.getTiming(); return timeToCompare - this.getTime(timeToCompare, parentTimeFallback); } /** * Sets the desired value of a given property name to the {@link CB_GraphicSprites.SPRITES_OBJECT} object as well to its children elements ({@link CB_GraphicSprites.SPRITE_OBJECT} and {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). * @function * @param {number} propertyName - The name of the property we want to affect. * @param {*} [value=undefined] - The value desired for the given property. * @param {boolean} [onlyCurrent=false] - If set to true, it will only affect the current sprite and its sub-sprites (and also the {@link CB_GraphicSprites.SPRITES_OBJECT} object). * @returns {integer} Returns the number of elements affected (counting the {@link CB_GraphicSprites.SPRITES_OBJECT} object). */ CB_GraphicSprites.prototype.setPropertyCascade = function(propertyName, value, onlyCurrent) { if (!propertyName) { return; } if (this.spritesGroup) { this.spritesGroup[propertyName] = value; } else { this[propertyName] = value; } var affected = 1; if (onlyCurrent) { var currentSprite = this.getCurrent(); if (currentSprite !== null) { currentSprite[propertyName] = value; affected++; currentSprite.forEach(function(subSprite) { subSprite[propertyName] = value; affected++; }); } } else { this.forEach ( function(element) { element[propertyName] = value; affected++; if (typeof(element.forEach) === &quot;function&quot;) { element.forEach(function(subElement) { subElement[propertyName] = value; affected++; }); } } ); } return affected; } /** * Gets a new copy of this object with the same attributes (all sub-objects will be a copy, they will not the same reference). * @function * @param {boolean} [avoidCopyingPointer=false] - If set to true, it will not copy the {@link CB_GraphicSprites#pointer} property of the object. * @param {boolean} [avoidCopyingTimes=false] - If set to true, it will not copy neither the {@link CB_GraphicSprites#time} property property of the object nor the &quot;time&quot; property of each of its sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects). * @param {boolean} [clearReferences=false] - If set to true, it will not copy neither the &quot;container&quot; nor the &quot;parent&quot; nor the &quot;data.that&quot; nor the &quot;data.getThis&quot; properties of any element. Useful to be able to stringify the object preventing the &quot;TypeError: cyclic object value&quot; error. When set to true, calls the {@link CB_GraphicSprites.clearReferences} function internally. If set to true and the &quot;filterProperties&quot; parameter is also set to true, the {@link CB_GraphicSprites.filterProperties} will always be called before calling the {@link CB_GraphicSprites.clearReferences} function. * @param {boolean} [filterProperties=false] - If set to true, it will call the {@link CB_GraphicSprites.filterProperties} function internally to filter the properties that we do not want to keep (using the given &quot;propertiesToKeepObject&quot; as the parameter to call it). When set to true, calls the {@link CB_GraphicSprites.filterProperties} function internally. If set to true and the &quot;clearReferences&quot; parameter is also set to true, the {@link CB_GraphicSprites.filterProperties} will always be called before calling the {@link CB_GraphicSprites.clearReferences} function. * @param {CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE} [propertiesToKeepObject=CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES] - The object with the properties that we want to keep. Only used when the &quot;filterProperties&quot; parameter is set to true, as the &quot;propertiesToKeepObject&quot; when calling the {@link CB_GraphicSprites.filterProperties} function internally. * @returns {CB_GraphicSprites} Returns a copy of this object with the same attributes (all sub-objects will be a copy, not the same reference). */ CB_GraphicSprites.prototype.getCopy = function(avoidCopyingPointer, avoidCopyingTimes, clearReferences, filterProperties, propertiesToKeepObject) { var spritesGroupCopy = CB_copyObject(this.spritesGroup); var newCopy = new CB_GraphicSprites(spritesGroupCopy, false); //If desired, sets the same pointer: if (!avoidCopyingPointer) { newCopy.pointer = this.pointer; newCopy.pointerPrevious = this.pointerPrevious; } //If desired, sets the same times: if (!avoidCopyingTimes) { newCopy.time = this.time; } CB_GraphicSprites._copyNeededProperties(newCopy, this) //Copies the needed properties from the original element. CB_GraphicSprites._copyNeededProperties(newCopy.spritesGroup, this.spritesGroup) //Copies the needed properties from the original element. this.forEach ( function(sprite, index) { //If desired, sets the same times: if (!avoidCopyingTimes) { newCopy.get(index).time = this.time; } CB_GraphicSprites._copyNeededProperties(newCopy.get(index), sprite) //Copies the needed properties from the original element. sprite.forEach ( function(subSprite, subSpriteIndex) { CB_GraphicSprites._copyNeededProperties(sprite.get(index).get(subSpriteIndex), subSprite) //Copies the needed properties from the original element. //If desired, sets the same times: if (!avoidCopyingTimes) { sprite.get(subSpriteIndex).time = this.time; } } ); } ); //Sets the same parent and positions: newCopy.parent = this.parent; newCopy.position = this.position; newCopy.positionByZIndex = this.positionByZIndex; //If we want to, filters the properties keeping just the desired ones: if (filterProperties) { newCopy = CB_GraphicSprites.filterProperties(newCopy, propertiesToKeepObject); } //If we want to, clears the references: if (clearReferences) { CB_GraphicSprites.clearReferences(newCopy); } return newCopy; } CB_GraphicSprites._copyNeededPropertiesData = { spritesScene: [&quot;id&quot;], spritesGroups: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;], sprites: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;zIndex&quot;, &quot;pointer&quot;, &quot;pointerPrevious&quot;, &quot;pointer&quot;, &quot;pointerPrevious&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;_attributes&quot;], spritesGroup: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;disabled&quot;], sprite: [&quot;id&quot;, &quot;byReference&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;disabled&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;_timeDisappeared&quot;, &quot;_usingRelativePosition&quot;, &quot;_clearPreviousFirstPerformed&quot;, &quot;_widthOriginal&quot;, &quot;_heightOriginal&quot;, &quot;_leftOriginal&quot;, &quot;_topOriginal&quot;, &quot;_attributes&quot;], subSprite: [&quot;id&quot;, &quot;byReference&quot;, &quot;time&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;disabled&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;_timeDisappeared&quot;, &quot;_usingRelativePosition&quot;, &quot;_attributes&quot;] }; CB_GraphicSprites._copyNeededProperties = function(element, elementOriginal) { if (!element.type || element.type !== elementOriginal.type) { return; } if (!CB_isArray(CB_GraphicSprites._copyNeededPropertiesData[element.type])) { return; } for (var x = CB_GraphicSprites._copyNeededPropertiesData[element.type].length; x &gt;= 0; x--) { propertyName = CB_GraphicSprites._copyNeededPropertiesData[element.type][x]; element[propertyName] = elementOriginal[propertyName]; } return element; } /** * Clears the &quot;container&quot;, the &quot;parent&quot; and the &quot;data.that&quot; properties (sets to null) of the given object and its sub-objects (works recursively, internally). * @function * @param {*} element - The object whose properties we want to clear. It can be different kinds ({@link CB_GraphicSpritesScene}, {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT}, {@link CB_GraphicSprites}, {@link CB_GraphicSprites.SPRITES_OBJECT}, {@link CB_GraphicSprites.SPRITE_OBJECT}, {@link CB_GraphicSprites.SUBSPRITE_OBJECT}, etc.). * @returns {*} Returns the same object with the the &quot;container&quot;, the &quot;parent&quot;, &quot;data.that&quot; and the &quot;data.getThis&quot; properties cleared (set to null), if possible. */ CB_GraphicSprites.clearReferences = function(element) { if (typeof(element) !== &quot;object&quot; || element === null) { return element; } if (typeof(element.forEach) === &quot;function&quot;) { element.forEach.call ( element, function(subElement) { CB_GraphicSprites.clearReferences(subElement); } ); } if (element.container) { element.container = null; } if (element.parent) { element.container = null; } if (element.data) { if (element.data.that) { element.data.that = null; } if (element.data.getThis) { element.data.getThis = null; } } return element; } /** * Object used to know what properties keep when calling the {@link CB_GraphicSprites.filterProperties} function (type used for its &quot;propertiesToKeepObject&quot; parameter). Its properties must have the name that matches the value returned by the &quot;type&quot; property of each element, being their value an array of strings with the name of the properties we want to keep. The property names which start with a &quot;_&quot; symbol will not considered inherited from the element's parent and will always be copied. The other properties (which do not start with the &quot;_&quot; symbol) will only be copied when the element contains a value which is different from the same property of its parent. * @memberof CB_GraphicSprites * @typedef {Object} CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE * @property {array} [spritesScene] Array of strings with the name of the properties to keep for the {@link CB_GraphicSpritesScene} objects. If no provided, no properties will be kept for this kind of element. * @property {array} [spritesGroups] Array of strings with the name of the properties to keep for the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} objects. If no provided, no properties will be kept for this kind of element. * @property {array} [sprites] Array of strings with the name of the properties to keep for the {@link CB_GraphicSprites} objects. If no provided, no properties will be kept for this kind of element. * @property {array} [spritesGroup] Array of strings with the name of the properties to keep for the {@link CB_GraphicSprites.SPRITES_OBJECT} objects. If no provided, no properties will be kept for this kind of element. * @property {array} [sprite] Array of strings with the name of the properties to keep for the {@link CB_GraphicSprites.SPRITE_OBJECT} objects. If no provided, no properties will be kept for this kind of element. * @property {array} [subSprite] Array of strings with the name of the properties to keep for the {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects. If no provided, no properties will be kept for this kind of element. */ /** * Object used as the default value for the &quot;propertiesToKeepObject&quot; parameter if not provided when calling the {@link CB_GraphicSprites.filterProperties} function. * @constant * @type {CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE} * @default */ CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES = { spritesScene: [&quot;id&quot;, &quot;spritesGroups&quot;], spritesGroups: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;data&quot;, &quot;spritesGroups&quot;, &quot;items&quot;], sprites: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;spritesGroup&quot;, &quot;zIndex&quot;, &quot;pointer&quot;, &quot;pointerPrevious&quot;, &quot;time&quot;, &quot;pointer&quot;, &quot;pointerPrevious&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;_attributes&quot;], spritesGroup: [&quot;id&quot;, &quot;byReference_DEFAULT&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;data&quot;, &quot;disabled&quot;, &quot;sprites&quot;], sprite: [&quot;id&quot;, &quot;byReference&quot;, &quot;time&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;data&quot;, &quot;disabled&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;subSprites&quot;, &quot;_timeDisappeared&quot;, &quot;_usingRelativePosition&quot;, &quot;_clearPreviousFirstPerformed&quot;, &quot;_widthOriginal&quot;, &quot;_heightOriginal&quot;, &quot;_leftOriginal&quot;, &quot;_topOriginal&quot;, &quot;_attributes&quot;], subSprite: [&quot;id&quot;, &quot;byReference&quot;, &quot;time&quot;, &quot;src&quot;, &quot;srcType&quot;, &quot;srcLeft&quot;, &quot;left&quot;, &quot;srcTop&quot;, &quot;top&quot;, &quot;srcWidth&quot;, &quot;width&quot;, &quot;srcHeight&quot;, &quot;height&quot;, &quot;zIndex&quot;, &quot;data&quot;, &quot;disabled&quot;, &quot;position&quot;, &quot;positionByZIndex&quot;, &quot;_timeDisappeared&quot;, &quot;_usingRelativePosition&quot;, &quot;_attributes&quot;] }; //Object to detect type of elements in an array according to the property name they belong to (which contains the array): CB_GraphicSprites.filterProperties_types = { &quot;spritesGroups&quot;: &quot;spritesGroup&quot;, &quot;items&quot;: &quot;sprites&quot;, &quot;sprites&quot;: &quot;sprite&quot;, &quot;subSprites&quot;: &quot;subSprite&quot; }; /** * Gets a new object with the properties filtered of a given element and its sub-elements, keeping only the ones that are in the given &quot;propertiesToKeepObject&quot; (works recursively, internally). * @function * @param {*} element - The object whose properties we want to clear. It can be different kinds ({@link CB_GraphicSpritesScene}, {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT}, {@link CB_GraphicSprites}, {@link CB_GraphicSprites.SPRITES_OBJECT}, {@link CB_GraphicSprites.SPRITE_OBJECT}, {@link CB_GraphicSprites.SUBSPRITE_OBJECT}, etc.). * @param {CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE} [propertiesToKeepObject=CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES] - The object with the properties that we want to keep. * @returns {*} Returns a new object with the properties filtered of a given element and its sub-elements, keeping only the ones that are in the given &quot;propertiesToKeepObject&quot;. If no valid &quot;element&quot; is provided, returns null. * @todo Implement a boolean property and when it is true it will not keep the properties whose values are the default ones (for example, if &quot;byReference&quot; property is false it will not be kept as it is its default value). So the output can be reduced this way. */ CB_GraphicSprites.filterProperties = function(element, propertiesToKeepObject) { if (typeof(element) !== &quot;object&quot; || element === null) { return null; } propertiesToKeepObject = (typeof(propertiesToKeepObject) === &quot;object&quot; &amp;&amp; propertiesToKeepObject !== null) ? propertiesToKeepObject : CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES; if (element.type === &quot;spritesGroup&quot;) { element.isSpritesGroup = true; } else if (element.type === &quot;sprites&quot;) { element.isSprites = true; } else if (element.type === &quot;sprite&quot;) { element.isSprite = true; } else if (element.type === &quot;subSprite&quot;) { element.isSubSprite = true; } var newObject = {}; for (var propertyName in element) { if (propertiesToKeepObject[element.type] &amp;&amp; CB_Arrays.indexOf(propertiesToKeepObject[element.type], propertyName) !== -1) { //If the property starts with &quot;_&quot;, or there is no parent or the value of the property of the parent is different from the value of the current element, copies the value: if (propertyName.charAt(0) === &quot;_&quot; || !element.parent || element._avoidParent || element.parent &amp;&amp; element.parent[propertyName] !== element[propertyName]) //The hidden properties (which start with &quot;_&quot;) are not inherited. { if (element.isSpritesScene &amp;&amp; propertyName === &quot;spritesGroups&quot;) { element.spritesGroups.type = &quot;spritesGroups&quot;; element._avoidParent = true; //It will not let it inherit from its parent. newObject.spritesGroups = CB_GraphicSprites.filterProperties(element.spritesGroups, propertiesToKeepObject); element._avoidParent = undefined; } else if (element.isSpritesGroups &amp;&amp; (propertyName === &quot;spritesGroups&quot; || propertyName === &quot;items&quot;) || element.isSpritesGroup &amp;&amp; propertyName === &quot;sprites&quot; || element.isSprite &amp;&amp; propertyName === &quot;subSprites&quot;) { var type = CB_GraphicSprites.filterProperties_types[propertyName]; var currentElement = null; newObject[propertyName] = []; if (CB_isArray(element[propertyName])) { for (var x = 0; x &lt; element[propertyName].length; x++) { element[propertyName][x].type = type; element[propertyName][x]._avoidParent = true; //It will not let it inherit from its parent. newObject[propertyName][x] = CB_GraphicSprites.filterProperties(element[propertyName][x], propertiesToKeepObject); element[propertyName][x]._avoidParent = undefined; } } } else if (element.isSprites &amp;&amp; propertyName === &quot;spritesGroup&quot;) { element.spritesGroup.type = &quot;spritesGroup&quot;; element._avoidParent = true; //It will not let it inherit from its parent. newObject.spritesGroup = CB_GraphicSprites.filterProperties(element.spritesGroup, propertiesToKeepObject); element._avoidParent = undefined; } else if (propertyName === &quot;data&quot; &amp;&amp; element.data) { newObject.data = {}; for (var dataPropertyName in element.data) { if (dataPropertyName === &quot;that&quot; || dataPropertyName === &quot;getThis&quot;) { continue; } newObject.data[dataPropertyName] = element.data[dataPropertyName]; } } else { newObject[propertyName] = element[propertyName]; } } } } propertyName = element.isSprites ? &quot;sprites&quot; : element.isSprite ? &quot;subSprites&quot; : &quot;&quot;; if (propertyName !== &quot;&quot; &amp;&amp; CB_Arrays.indexOf(propertiesToKeepObject[element.type], propertyName) !== -1 &amp;&amp; typeof(element.forEach) === &quot;function&quot;) { newObject[propertyName] = []; element.forEach.call ( element, function(subElement) { //subElement._avoidParent = true; //It will not let it inherit from its parent. newObject[propertyName][newObject[propertyName].length] = CB_GraphicSprites.filterProperties(subElement, propertiesToKeepObject); //subElement._avoidParent = undefined; } ); } return newObject; } × Search results Close "},"CrossBase_CrossBase.js.html":{"id":"CrossBase_CrossBase.js.html","title":"Source: CrossBase/CrossBase.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/CrossBase.js /** * @file Main CrossBase module file. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ //Credits of the module: var CB_CrossBaseCredits = &quot;[CB] - CrossBase module by Joan Alba Maldonado&lt;br /&gt;&quot; + &quot;[CB] -- Array.* polyfills by Mozilla Foundation (MDN)&lt;br /&gt;&quot; + &quot;[CB] -- JSON 3 by Kit Cambridge&lt;br /&gt;&quot; + &quot;[CB] -- bluebird by Petka Antonov&lt;br /&gt;&quot; + &quot;[CB] -- BrowserDetect by Peter-Paul Koch&lt;br /&gt;&quot; + &quot;[CB] -- performance.now polyfill by Paul Irish, Aaron Levine and Joan Alba Maldonado&lt;br /&gt;&quot; + &quot;[CB] -- requestAnimationFrame polyfill by Erik Moller (fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavic, Darius Bacon, Tim Hall and Joan Alba Maldonado)&lt;br /&gt;&quot; + &quot;[CB] -- typedarray.js polyfill by Linden Research, Inc. and Joshua Bell&lt;br /&gt;&quot; + &quot;[CB] -- Base64Binary by Daniel Guerrero&lt;br /&gt;&quot; + &quot;[CB] -- localStorage polyfill by Morten Houmøller Nygaard&lt;br /&gt;&quot; + &quot;[CB] -- lz-string (including base64-string) by pieroxy&lt;br /&gt;&quot; + &quot;[CB] -- Canbox by Robert Inglin&lt;br /&gt;&quot; + &quot;[CB] -- ExplorerCanvas by Google Inc.&lt;br /&gt;&quot; + &quot;[CB] -- SLCanvas by David Anson and Jon Davis&lt;br /&gt;&quot; + &quot;[CB] -- FlashCanvas by Tim Cameron Ryan and Shinya Muramatsu&lt;br /&gt;&quot; + &quot;[CB] -- canvas-text by Fabien Ménager&lt;br /&gt;&quot; + &quot;[CB] -- Detect-zoom by yonran (maintained by tombigel)&lt;br /&gt;&quot; + &quot;[CB] -- AudioContext-MonkeyPatch by Chris Wilson&lt;br /&gt;&quot; + &quot;[CB] -- WAAPISim by g200kg&lt;br /&gt;&quot; + &quot;[CB] -- timbre.js and subcollider.js by mohayonao&lt;br /&gt;&quot; + &quot;[CB] -- Band.js by Cody Lundquist and various contributors&lt;br /&gt;&quot; + &quot;[CB] -- jsfx by Egon Elbre&lt;br /&gt;&quot; + &quot;[CB] -- SoundManager 2 by Scott Schiller&lt;br /&gt;&quot; + &quot;[CB] -- fetch-ie8 by Cam Song&lt;br /&gt;&quot; + &quot;[CB] -- SockJS-client by Marek, Bryce Kahle, Michael Bridgen, Luigi Pinca and others&lt;br /&gt;&quot; + &quot;[CB] -- Pressure.js by Stuart Yamartino&lt;br /&gt;&quot; + &quot;[CB] -- Hammer.js by Jorik Tangelder&lt;br /&gt;&quot; + &quot;[CB] -- Hammer Time by Alexander Schmitz and other contributors&lt;br /&gt;&quot; + &quot;[CB] -- wii-js by Ryan McGrath&lt;br /&gt;&quot; + &quot;[CB] -- gamepad-plus by Chris Van Wiemeersch (MozVR)&lt;br /&gt;&quot; + &quot;[CB] -- NoSleep.js by Rich Tibbett&lt;br /&gt;&quot;; //CrossBase constants and variables: /** * Keeps the name of the CrossBase module. * @constant * @type {string} * @default */ var CB_BASE_NAME = &quot;CrossBase&quot;; /** Property that contains an object with the options for the main script. * @namespace CB_Configuration.CrossBase */ CB_Configuration[CB_BASE_NAME] = { /** * Path to the CrossBase module, relative to the CrossBrowdy folder. * @memberof CB_Configuration.CrossBase * @constant * @type {string} * @default {@link CB_BASE_NAME} + &quot;/&quot; */ SCRIPT_PATH: CB_BASE_NAME + &quot;/&quot;, /** * Defines whether to have in mind possible [iframes]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} that could contain the script or not. Used by some functions of {@link CB_Client}, {@link CB_Events}, etc. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ MIND_IFRAMES: true, /** * Defines whether to allow to extend the DOM if needed or not. If set to true and some methods (as for example [Array.indexOf]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf}, [Array.lastIndexOf]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf}, [Array.isArray]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray}, [Array.forEach]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach}, [NodeList.forEach]{@link https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach}, [HTMLCollection.forEach]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach}, etc.) are not supported natively, they will be added. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ EXTEND_DOM: false, /** * Defines whether to use high precision in the CB_Device.getTime (returning '[window.performance.timing.navigationStart]{@link https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/navigationStart} + [window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}()', where '[window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}' could be polyfilled) or not (returning '[Date.now]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now}()', where '[Date.now]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now}' could be polyfilled). * @memberof CB_Configuration.CrossBase * @constant * @type {string} * @default */ CB_Device_getTime_HIGH_PRECISION: true, /** * Defines whether to use cache for the function {@link CB_Elements.id} by default. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Elements_id_USE_CACHE: true, /** * Defines whether to use cache for the {@link CB_Elements.tag} function by default. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Elements_tag_USE_CACHE: true, /** * Defines whether to use cache for the function {@link CB_Elements.classes} by default. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Elements_classes_USE_CACHE: true, /** * Default language to use for {@link CB_Client} when no language can be detected (very strange case!). * @memberof CB_Configuration.CrossBase * @constant * @type {string} * @default */ CB_Client_language_DEFAULT: &quot;en&quot;, /** * Default value for the &quot;allowNavigatorLanguages&quot; parameter for {@link CB_Client.getLanguage} and {@link CB_Client.getLanguages} functions. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Client_allowNavigatorLanguages_DEFAULT: false, /** * Tells whether the {@link CB_Client.getLanguage} and {@link CB_Client.getLanguages} functions will use the accepted languages detected by PHP (if any) as the first option by default or not. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Client_PHPAcceptedLanguagesFirst_DEFAULT: true, /** * Defines whether the URL for the proxy (defined in {@link CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL}) is relative to the main script folder or not. If it is relative, the &quot;onCall&quot; event of the CrossBase module will append the value of the &quot;scriptPathGiven&quot; parameter at the beginning. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Net_XHR_PROXY_URL_RELATIVE: true, /** * Defines whether we want to prevent the Firefox bug that affects [SockJS library]{@link https://github.com/sockjs/sockjs-client/} (see {@link https://github.com/sockjs/sockjs-client/issues/18}) or not. Used by {@link CB_Keyboard}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Net_Sockets_PREVENT_FIREFOX_ESC_BUG: true, /** * Defines whether to allow Nintendo Wii codes (from the Wiimote) set in the {@link CB_Keyboard.extended.WII} object to be defined in the key aliases even if they use codes which belong to other keys. Used by {@link CB_Keyboard}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Keyboard_extended_WII_allowDuplicateKeyAliases: true, /** * Defines whether to allow Sony Playstation 4 codes set in the {@link CB_Keyboard.extended.PS4CB_Keyboard.extended.PS4} object to be defined in the key aliases even if they use codes which belong to other keys. Used by {@link CB_Keyboard}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Keyboard_extended_PS4_allowDuplicateKeyAliases: false, /** * Defines whether to allow Smart TV codes (from the remote control) and virtual key codes set in the {@link CB_Keyboard.extended.VK} object to be defined in the key aliases even if they use codes which belong to other keys. Used by {@link CB_Keyboard}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Keyboard_extended_VK_allowDuplicateKeyAliases: true, /** * Defines whether to allow Samsung TV key codes (from the remote control) set in the {@link CB_Keyboard.extended.SAMSUNG_TV} object to be defined in the key aliases even if they use codes which belong to other keys. Used by {@link CB_Keyboard}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Keyboard_extended_SAMSUNG_TV_allowDuplicateKeyAliases: false, /** * Default value for the &quot;avoidProprietary&quot; proprietary when calling different functions of the {@link CB_Controllers} static class, as the {@link CB_Controllers.getButtonsDown}, the {@link CB_Controllers.isButtonDown} and the {@link CB_Controllers.getGamePads} functions, etc. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_Controllers_avoidProprietary_DEFAULT: false, /** * Allowed width margin of the total screen available to consider whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. Used by the {@link CB_Screen.isFullScreen} function. * @memberof CB_Configuration.CrossBase * @constant * @type {float} * @default */ CB_Screen_isFullScreen_ALLOWED_WIDTH_MARGIN_PERCENTAGE: 3.9, /** * Allowed height margin of the total screen available to consider whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. Used by the {@link CB_Screen.isFullScreen} function. * @memberof CB_Configuration.CrossBase * @constant * @type {float} * @default */ CB_Screen_isFullScreen_ALLOWED_HEIGHT_MARGIN_PERCENTAGE: 3.5, /** * Defines whether to allow using &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}) emulation (it will use [WAAPISim]{@link https://github.com/g200kg/WAAPISim} if needed) or not. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ WAAPI_EMULATION_ALLOWED: true, /** * Default volume for CB_Speaker (from 0 to 100). * @memberof CB_Configuration.CrossBase * @constant * @type {integer} * @default */ CB_Speaker_DEFAULT_VOLUME: 100, /** * Milliseconds that a file is played (with volume set to 0) automatically when an audio file is loaded. Needed for some web clients which cannot find out the duration otherwise. Used by {@link CB_AudioFile}. * @memberof CB_Configuration.CrossBase * @constant * @type {integer} * @default */ CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS: 500, /** * Milliseconds to wait before declaring a sound as failed if it cannot be loaded before. Used by {@link CB_AudioFile_API.SM2}. * @memberof CB_Configuration.CrossBase * @constant * @type {integer} * @default */ CB_AudioFile_ONLOAD_TIMEOUT_MS: 15000, /** * Tells whether CB_AudioFile[&quot;AAPI&quot;] uses [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} (instead of [timeupdate]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/timeupdate_event} event) to detect when the given &quot;stopAt&quot; is reached. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_AudioFile_AAPI_USE_TIMEOUT_TO_DETECT_STOPAT: true, /** * Default value for maximum delay (in milliseconds) to wait for a sound to start playing or start next loop (if the time expires, the sound will never be played). Used by {@link CB_AudioFile_API.WAAPI}, {@link CB_AudioFile_API.AAPI}, {@link CB_AudioFile_API.SM2}, {@link CB_AudioFile_API.ACMP} and {@link CB_AudioFileCache}. * @memberof CB_Configuration.CrossBase * @constant * @type {integer} * @default */ CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT: 150, /** * Tells whether to mute or not the audio files when they load or are checking. Note: Audio cache does not work properly on BlackBerry PlayBook's default browser if the sounds are muted when load or are checking. Used by {@link CB_AudioFile}, {@link CB_AudioFile_API.WAAPI}, {@link CB_AudioFile_API.AAPI}, {@link CB_AudioFile_API.SM2}, {@link CB_AudioFile_API.ACMP} and {@link CB_AudioFileCache}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default !(navigator.userAgent.indexOf(&quot;PlayBook&quot;) !== -1 &amp;&amp; navigator.userAgent.indexOf(&quot;Tablet OS&quot;) !== -1) */ CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING: !(navigator.userAgent.indexOf(&quot;PlayBook&quot;) !== -1 &amp;&amp; navigator.userAgent.indexOf(&quot;Tablet OS&quot;) !== -1), //Audio cache does not work properly on BlackBerry PlayBook's default browser if the sounds are muted when load or are checking. /** * Defines whether to use {@link CB_Speaker._volume} as default volume. Used by {@link CB_AudioFile}, {@link CB_AudioFile_API.WAAPI}, {@link CB_AudioFile_API.AAPI}, {@link CB_AudioFile_API.SM2}, {@link CB_AudioFile_API.ACMP} and {@link CB_AudioFileCache}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT: true, /** * Defines whether to use {@link CB_Speaker._volume} as maximum volume. Used by {@link CB_AudioFile}, {@link CB_AudioFile_API.WAAPI}, {@link CB_AudioFile_API.AAPI}, {@link CB_AudioFile_API.SM2} and {@link CB_AudioFile_API.ACMP}. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM: false, /** * Array with the default desired canvas emulation methods by order of preference. Used by {@link CB_Canvas}. * @memberof CB_Configuration.CrossBase * @constant * @type {array} * @default */ CB_Canvas_PREFERRED_EMULATION_METHODS: [ &quot;FLASH&quot;, //FlashCanvas. &quot;VML&quot;, //ExplorerCanvas. &quot;DHTML&quot;, //Canbox. &quot;SILVERLIGHT&quot; //SLCanvas. ], /** * Value by default when the &quot;allowEmulation&quot; parameter is not provided in the {@link CB_AudioDetector.getPreferredAPI}, the {@link CB_AudioDetector.getSupportedAPIs} or the {@link CB_AudioDetector.isAPISupported} function. * @memberof CB_Configuration.CrossBase * @constant * @type {boolean} * @default */ CB_AudioDetector_allowEmulation_DEFAULT: false, /** * Array with the default preferred audio APIs by order of preference. Used by {@link CB_AudioFileCache} and {@link CB_AudioDetector}. Possible audio APIs are &quot;WAAPI&quot; ([HTML5 Web Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API}), &quot;SM2&quot; ([SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}), &quot;ACMP&quot; ([Apache Cordova Media Plugin]{@link https://github.com/apache/cordova-plugin-media}) or &quot;AAPI&quot; ([HTML5 Audio API]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}). Note: since Internet Explorer 9 works better with SM2 than with AAPI, if it is detected then the default value will be: [ &quot;WAAPI&quot;, &quot;SM2&quot;, &quot;ACMP&quot;, &quot;AAPI&quot; ] * @memberof CB_Configuration.CrossBase * @constant * @type {array} * @default [&quot;WAAPI&quot;, &quot;AAPI&quot;, &quot;ACMP&quot;, &quot;SM2&quot;] */ CB_AudioFileCache_PREFERRED_AUDIO_APIS: navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1 ? [ &quot;WAAPI&quot;, //HTML5 Web Audio API. &quot;AAPI&quot;, //HTML5 Audio API. &quot;ACMP&quot;, //Apache Cordova Media Plugin. &quot;SM2&quot; //SoundManager 2. ] : [ &quot;WAAPI&quot;, &quot;SM2&quot;, &quot;ACMP&quot;, &quot;AAPI&quot; ], //IE9 have works better with SM2 than with AAPI. /** * Array with the default preferred audio formats by order of preference. Used by {@link CB_AudioFileCache} and {@link CB_AudioDetector}. NOTE: some web clients do not support to specify codecs so it is better to also provide strings without codecs. * @memberof CB_Configuration.CrossBase * @constant * @type {array} * @default */ CB_AudioFileCache_PREFERRED_AUDIO_FORMATS: [ 'audio/ogg; codecs=&quot;vorbis&quot;', //audio/ogg with Vorbis codec. 'audio/ogg; codecs=&quot;speex&quot;', //audio/ogg with Speex codec. 'audio/ogg; codecs=&quot;flac&quot;', //audio/ogg with FLAC codec. 'audio/ogg', //audio/ogg is for .oga, .ogg. 'audio/mpeg; codecs=&quot;mp3&quot;', //audio/mpeg with MP3 codec (?). 'audio/mpeg', //audio/mpeg is for .mp1, .mp2, .mp3, .mpg, .mpeg. 'audio/mp4; codecs=&quot;mp4a.40.5&quot;', //audio/mp4 with mp4a.40.5 codec. 'audio/mp4; codecs=&quot;mp4a.40.2&quot;', //audio/mp4 with mp4a.40.2 codec. 'audio/mp4; codecs=&quot;mp4a.40.05&quot;', //audio/mp4 with mp4a.40.05 codec. 'audio/mp4; codecs=&quot;mp4a.40.02&quot;', //audio/mp4 with mp4a.40.02 codec. 'audio/mp4; codecs=&quot;mp4a.69&quot;', //audio/mp4 with mp4a.69 codec. 'audio/mp4; codecs=&quot;mp4a.6B&quot;', //audio/mp4 with mp4a.6B codec. 'audio/mp4; codecs=&quot;mp4a.67&quot;', //audio/mp4 with mp4a.67 codec. 'audio/mp4; codecs=&quot;mp4a.a6&quot;', //audio/mp4 with mp4a.a6 codec. 'audio/mp4; codecs=&quot;mp4a.a5&quot;', //audio/mp4 with mp4a.a5 codec. 'audio/mp4; codecs=&quot;aac51&quot;', //audio/mp4 with aac51 codec. 'audio/mp4; codecs=&quot;ac-3&quot;', //audio/mp4 with ac-3 codec. 'audio/mp4; codecs=&quot;ec-3&quot;', //audio/mp4 with ec-3 codec. 'audio/mp4', //audio/mp4 is for .mp4, .m4a. 'audio/aac; codecs=&quot;aac&quot;', //audio.aac with AAC codec (?). 'audio/aac; codecs=&quot;mp4a.40.5&quot;', //audio/aac with mp4a.40.5 codec (?). 'audio/aac; codecs=&quot;vorbis&quot;', //audio.aac with Vorbis codec (?). 'audio/aac', //audio/acc is for .aac. 'audio/x-aac; codecs=&quot;aac&quot;', 'audio/x-aac', 'audio/x-m4b; codecs=&quot;aac&quot;', 'audio/x-m4b', 'audio/x-m4p; codecs=&quot;aac&quot;', 'audio/x-m4p', 'audio/webm; codecs=&quot;vorbis&quot;', //audio/webm with Vorbis codec. 'audio/webm', //audio/webm is for .webm. 'audio/3gpp; codecs=&quot;samr&quot;', //audio/3gpp with SAMR codec. 'audio/3gpp', //audio/3gpp is for .3gpp. 'audio/wav; codecs=&quot;1&quot;', //audio/wav with 1 codec (?). 'audio/wav', //audio/wav is for .wav. 'audio/x-wav; codecs=&quot;1&quot;', //audio/x-wav with 1 codec (?). 'audio/x-wav', //audio/x-wav is for .wav. 'audio/x-pn-wav; codecs=&quot;1&quot;', //audio/x-pn-wav with 1 codec (?). 'audio/x-pn-wav', //audio/x-pn-wav is for .wav 'audio/wave; codecs=&quot;1&quot;', //audio/wave with 1 codec (?). 'audio/wave', //audio/wave is for .wav. 'audio/x-wave; codecs=&quot;1&quot;', //audio/x-wave with 1 codec (?). 'audio/x-wave' //audio/x-wave is for .wav. ] }; /** * URL for the proxy to prevent cross-domain issues through AJAX, used by {@link CB_Net.XHR.callProxy} function. Can be relative to the main script folder or not, depending on {@link CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL_RELATIVE}. &lt;br /&gt; NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy. Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. * @memberof CB_Configuration.CrossBase * @name CB_Net_XHR_PROXY_URL * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;net/proxy/CB_proxy.php&quot; */ CB_Configuration[CB_BASE_NAME].CB_Net_XHR_PROXY_URL = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;net/proxy/CB_proxy.php&quot;; CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [WAAPISim]{@link https://github.com/g200kg/WAAPISim} or not. * @memberof CB_Configuration.CrossBase * @name needsWAAPISim * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsWAAPISim = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { var waapisimForceSim = window.waapisimForceSim || undefined; CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn = //Note: copied from waapisim.js //TODO: see what IE versions are compatible. (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1) &amp;&amp; ( typeof(waapisimForceSim) !== &quot;undefined&quot; &amp;&amp; waapisimForceSim || ( typeof(window.AudioContext) !== &quot;undefined&quot; &amp;&amp; typeof(window.AudioContext.prototype.createOscillator) === &quot;undefined&quot; //Be careful! Pale Moon browser does not have createOscillator method. &amp;&amp; (typeof(waapisimForceSimWhenLackOsc) === &quot;undefined&quot; || (typeof(waapisimForceSimWhenLackOsc) !== &quot;undefined&quot; &amp;&amp; waapisimForceSimWhenLackOsc)) ) || ( typeof(window.webkitAudioContext) !== &quot;undefined&quot; &amp;&amp; typeof(window.webkitAudioContext.prototype.createOscillator) === &quot;undefined&quot; //Be careful! Pale Moon browser does not have createOscillator method. &amp;&amp; (typeof(waapisimForceSimWhenLackOsc) === &quot;undefined&quot; || (typeof(waapisimForceSimWhenLackOsc) !== &quot;undefined&quot; &amp;&amp; waapisimForceSimWhenLackOsc)) ) || typeof(window.AudioContext) === &quot;undefined&quot; &amp;&amp; typeof(window.webkitAudioContext) === &quot;undefined&quot; ); return CB_Configuration[CB_BASE_NAME].needsWAAPISimLastReturn; } } CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn = null; //Cache to return always the same result. CB_Configuration[CB_BASE_NAME]._supportsCanvasElement = null; CB_Configuration[CB_BASE_NAME]._supportsCanvas = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn !== null) { return CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { CB_Configuration[CB_BASE_NAME]._supportsCanvasElement = CB_Configuration[CB_BASE_NAME]._supportsCanvasElement || document.createElement(&quot;canvas&quot;); //If canvas is supported: if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement !== null) { if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext !== null) { try //Uses try-catch to avoid some problems with some web clients (as BeZilla / Bon Echo 2.0.0.22Pre on Haiku OS): { //If fillText exists: if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext(&quot;2d&quot;)) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext(&quot;2d&quot;) !== null) { CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn = true; //Canvas is supported. return CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn; } } catch(E) { CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn = false; return CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn; } } } CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn = false; //If we arrived here, canvas is not supported. return CB_Configuration[CB_BASE_NAME]._supportsCanvasLastReturn; } } CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [Canbox]{@link https://github.com/robertinglin/CanBox} or not. * @memberof CB_Configuration.CrossBase * @name needsCanbox * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsCanbox = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { //We need it only if canvas is not already supported by the web client (and it is not IE5/5.5 since it doesn't support Canbox): //CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn = (typeof(document.createElement(&quot;canvas&quot;).getContext) === &quot;undefined&quot; &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1); CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn = (!CB_Configuration[CB_BASE_NAME]._supportsCanvas() &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1); return CB_Configuration[CB_BASE_NAME].needsCanboxLastReturn; } } CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [ExplorerCanvas]{@link https://github.com/arv/explorercanvas} or not. * @memberof CB_Configuration.CrossBase * @name needsExplorerCanvas * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsExplorerCanvas = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { //We need it only if canvas is not already supported by the web client and the web client is IE 6, 7, 8 or 9 (IE9 doesn't support canvas in quirks mode and IE5/5.5 doesn't support ExplorerCanvas): //CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn = (typeof(document.createElement(&quot;canvas&quot;).getContext) === &quot;undefined&quot; &amp;&amp; navigator.userAgent.indexOf('MSIE') !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 7&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 8&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 9&quot;) !== -1)); CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn = (!CB_Configuration[CB_BASE_NAME]._supportsCanvas() &amp;&amp; navigator.userAgent.indexOf('MSIE') !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 7&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 8&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 9&quot;) !== -1)); return CB_Configuration[CB_BASE_NAME].needsExplorerCanvasLastReturn; } } //CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [SLCanvas]{@link https://slcanvas.codeplex.com/} or not. * @memberof CB_Configuration.CrossBase * @name needsSLCanvas * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsSLCanvas = function() { return !CB_Configuration[CB_BASE_NAME]._supportsCanvas(); /* //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { //We need it only if canvas is not already supported by the web client: //CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn = (typeof(document.createElement(&quot;canvas&quot;).getContext) === &quot;undefined&quot;);// &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1); CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn = !CB_Configuration[CB_BASE_NAME]._supportsCanvas();// &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1); return CB_Configuration[CB_BASE_NAME].needsSLCanvasLastReturn; } */ } CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [FlashCanvas]{@link https://github.com/everlaat/flashcanvas} or not. * @memberof CB_Configuration.CrossBase * @name needsFlashCanvas * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsFlashCanvas = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { //We need it only if ActiveXObject is available (it has to be IE) and it is not compatible with canvas: CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn = (typeof(window.ActiveXObject) !== &quot;undefined&quot; &amp;&amp; typeof(window.CanvasRenderingContext2D) === &quot;undefined&quot;); return CB_Configuration[CB_BASE_NAME].needsFlashCanvasLastReturn; } } CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn = null; //Cache to return always the same result. /** * Detects whether the web client needs [canvas-text]{@link https://github.com/PhenX/canvas-text} or not. * @memberof CB_Configuration.CrossBase * @name needsCanvasText * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsCanvasText = function() { //If the last result is in the cache, we return again the same result: if (typeof(CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn !== null) { return CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn; } //...otherwise (it is the first time), we calculate if we need it or not: else { //CB_Configuration[CB_BASE_NAME]._supportsCanvasElement = CB_Configuration[CB_BASE_NAME]._supportsCanvasElement || document.createElement(&quot;canvas&quot;); //If canvas is supported: //if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement !== null) //{ //if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext !== null) //{ if (CB_Configuration[CB_BASE_NAME]._supportsCanvas()) { try //Uses try-catch to avoid some problems with some web clients (as BeZilla / Bon Echo 2.0.0.22Pre on Haiku OS). { //If fillText exists: if (typeof(CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext(&quot;2d&quot;).fillText) !== &quot;undefined&quot; &amp;&amp; CB_Configuration[CB_BASE_NAME]._supportsCanvasElement.getContext(&quot;2d&quot;).fillText !== null) { CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn = false; //We don't need canvas-text. return CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn; } else { CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn = true; return CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn; } } catch(E) { CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn = true; return CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn; } } //} //} CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn = false; return CB_Configuration[CB_BASE_NAME].needsCanvasTextLastReturn; } } /** * Detects whether the web client needs [timbre.js]{@link https://mohayonao.github.io/timbre.js/} (including [subcollider.js]{@link https://github.com/mohayonao/subcollider}) or not. * @function * @memberof CB_Configuration.CrossBase * @name needsTimbreJS * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsTimbreJS = function() { //TODO: see what IE versions are compatible. return (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1); } /** * Detects whether the web client needs [jsfx]{@link https://github.com/loov/jsfx} or not. * @memberof CB_Configuration.CrossBase * @name needsJsfx * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsJsfx = function() { //TODO: see what IE versions are compatible. return (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1); } /** * Detects whether the web client needs [Pressure.js]{@link https://pressurejs.com/} or not. * @memberof CB_Configuration.CrossBase * @name needsPressureJS * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsPressureJS= function() { //TODO: see what IE versions are compatible. return (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1); } /** * Detects whether the web client needs [Hammer.js]{@link http://hammerjs.github.io/} or not. * @memberof CB_Configuration.CrossBase * @name needsHammerJS * @function * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsHammerJS = function() { //TODO: see what IE versions are compatible. return (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 9&quot;) === -1); } /** * Detects whether the web client needs [gamepad-plus]{@link https://github.com/MozVR/gamepad-plus} or not. * @memberof CB_Configuration.CrossBase * @name needsGamepadPlus * @function * @returns {boolean} * @todo Find a better way for this as old Firefox versions can only detect GamePad API support when the events are fired, so we cannot relay on navigator.getGamepads/navigator.webkitGetGamepads/navigator.webkitGamepads. */ CB_Configuration[CB_BASE_NAME].needsGamepadPlus = function() { //TODO: Find a better way for this as old Firefox versions can only detect GamePad API support when the events are fired, so we cannot relay on navigator.getGamepads/navigator.webkitGetGamepads/navigator.webkitGamepads. return !!(typeof(navigator) === &quot;object&quot; &amp;&amp; navigator !== null &amp;&amp; (navigator.getGamepads || navigator.webkitGetGamepads || navigator.webkitGamepads)); } /** * Detects whether the web client needs [NoSleep.js]{@link https://github.com/richtr/NoSleep.js} or not. * @function * @memberof CB_Configuration.CrossBase * @name needsSleepJS * @returns {boolean} */ CB_Configuration[CB_BASE_NAME].needsSleepJS = function() { return (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 6&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 7&quot;) === -1 &amp;&amp; navigator.appVersion.indexOf(&quot;MSIE 8&quot;) === -1); } //SockJS parameters: /** * Directory that contains the [SockJS library]{@link https://github.com/sockjs/sockjs-client/} files. * @memberof CB_Configuration.CrossBase * @name SOCKJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;net/sockets/SockJS/&quot; */ CB_Configuration[CB_BASE_NAME].SOCKJS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;net/sockets/SockJS/&quot;; /** * The script file path for the [SockJS library]{@link https://github.com/sockjs/sockjs-client/}. As the newer [SockJS library]{@link https://github.com/sockjs/sockjs-client/} versions do not work in old Internet Explorer versions (6, 7 or 8), if they are detected it will use the [SockJS library]{@link https://github.com/sockjs/sockjs-client/} 0.3.4 version instead. * @memberof CB_Configuration.CrossBase * @name SOCKJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration[CB_BASE_NAME].SOCKJS_PATH} + SOCKJS_SCRIPT_FILE, where &quot;SOCKJS_SCRIPT_FILE&quot; is sockjs-0.3.4.min.js (SockJS 0.3.4), sockjs-1.1.1.min.js (SockJS 1.1.1) or sockjs.min.js (last version) depending on the client detected. */ CB_Configuration[CB_BASE_NAME].SOCKJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].SOCKJS_PATH; if (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 7&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 8&quot;) !== -1) { CB_Configuration[CB_BASE_NAME].SOCKJS_PATH_SCRIPT_FILE += &quot;sockjs-0.3.4.min.js&quot;; } else if (navigator.appVersion.indexOf(&quot;MSIE 9&quot;) !== -1) { CB_Configuration[CB_BASE_NAME].SOCKJS_PATH_SCRIPT_FILE += &quot;sockjs-1.1.1.min.js&quot;; } else { CB_Configuration[CB_BASE_NAME].SOCKJS_PATH_SCRIPT_FILE += &quot;sockjs.min.js&quot;; } //Intel XDK parameters: /** * Defines whether to load or not intelxdk.js (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). * @memberof CB_Configuration.CrossBase * @name INTELXDKJS_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDKJS_LOAD = false; //CB_Configuration[CB_BASE_NAME].needsIntelXDKJS(); /** * Directory that contains the &quot;intelxdk.js&quot; file (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). * @memberof CB_Configuration.CrossBase * @name INTELXDKJS_PATH * @constant * @type {string} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDKJS_PATH = &quot;../&quot;; /** * The script file path for intelxdk.js (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). * @memberof CB_Configuration.CrossBase * @name INTELXDKJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.INTELXDKJS_PATH} + &quot;intelxdk.js&quot; */ CB_Configuration[CB_BASE_NAME].INTELXDKJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].INTELXDKJS_PATH + &quot;intelxdk.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.INTELXDKJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name INTELXDKJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDKJS_PATH_ABSOLUTE = false; /** * Defines whether to try to load or not init-dev.js (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). If set to true, the checker defined at {@link CB_Configuration.CrossBase.INTELXDK_INITDEVJS_LOAD_CHECKER} will finally decide whether to load it or not. * @memberof CB_Configuration.CrossBase * @name INTELXDK_INITDEVJS_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_LOAD = false; //CB_Configuration[CB_BASE_NAME].needsIntelXDKJS(); /** * Callback checker to determine whether init-dev.js (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}) is needed or not. Requires {@link CB_Configuration.CrossBase.INTELXDK_INITDEVJS_LOAD} set to true. * @memberof CB_Configuration.CrossBase * @name INTELXDK_INITDEVJS_LOAD_CHECKER * @constant * @type {CB_Modules.neededFile_LOAD_CHECKER} * @default false */ CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_LOAD_CHECKER = false; //function(currentPath, info) { return (typeof(dev) === &quot;undefined&quot; || dev === null || typeof(dev.initDeviceReady) !== &quot;function&quot;); }; /** * Directory that contains the &quot;init-dev.js&quot; (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). * @memberof CB_Configuration.CrossBase * @name INTELXDK_INITDEVJS_PATH * @constant * @type {string} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_PATH = &quot;../xdk/&quot;; /** * The script file path for init-dev.js file (used by [Intel XDK]{@link https://en.wikipedia.org/wiki/Intel_XDK}). * @memberof CB_Configuration.CrossBase * @name INTELXDK_INITDEVJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.INTELXDK_INITDEVJS_PATH} + &quot;init-dev.js&quot; */ CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_PATH + &quot;init-dev.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.INTELXDK_INITDEVJS_PATH} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name INTELXDK_INITDEVJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_PATH_ABSOLUTE = false; //PhoneGap parameters: /** * Defines whether to load or not phonegap.js (used by [Adobe PhoneGap]{@link https://phonegap.com/}). * @memberof CB_Configuration.CrossBase * @name PHONEGAPJS_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].PHONEGAPJS_LOAD = false; //CB_Configuration[CB_BASE_NAME].needsPhoneGapJS(); /** * Directory that contains the &quot;phonegap.js&quot; (used by [Adobe PhoneGap]{@link https://phonegap.com/}) file. * @memberof CB_Configuration.CrossBase * @name PHONEGAPJS_PATH * @constant * @type {string} * @default */ CB_Configuration[CB_BASE_NAME].PHONEGAPJS_PATH = &quot;../&quot;; /** * The script file path for phonegap.js (used by [Adobe PhoneGap]{@link https://phonegap.com/}). * @memberof CB_Configuration.CrossBase * @name PHONEGAPJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.PHONEGAPJS_PATH} + &quot;phonegap.js&quot; */ CB_Configuration[CB_BASE_NAME].PHONEGAPJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].PHONEGAPJS_PATH + &quot;phonegap.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.PHONEGAPJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name PHONEGAPJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].PHONEGAPJS_PATH_ABSOLUTE = false; //Apache Cordova parameters: /** * Defines whether to try to load or not cordova.js (used by [Apache Cordova]{@link https://cordova.apache.org/}). It should not be loaded together with phonegap.js, normally. If set to true, the checker defined at {@link CB_Configuration.CrossBase.CORDOVAJS_LOAD_CHECKER} will finally decide whether to load it or not. * @memberof CB_Configuration.CrossBase * @name CORDOVAJS_LOAD * @constant * @type {boolean} * @default !{@link CB_Configuration.CrossBase.PHONEGAPJS_LOAD} */ CB_Configuration[CB_BASE_NAME].CORDOVAJS_LOAD = !CB_Configuration[CB_BASE_NAME].PHONEGAPJS_LOAD &amp;&amp; window.location &amp;&amp; window.location.protocol !== &quot;http:&quot; &amp;&amp; window.location.protocol !== &quot;https:&quot;; //CB_Configuration[CB_BASE_NAME].needsCordovaJS(); /** * Callback checker to determine whether cordova.js (used by [Apache Cordova]{@link https://cordova.apache.org/}) is needed or not. Requires {@link CB_Configuration.CrossBase.CORDOVAJS_LOAD} set to true. * @memberof CB_Configuration.CrossBase * @name CORDOVAJS_LOAD_CHECKER * @constant * @type {CB_Modules.neededFile_LOAD_CHECKER} * @default function(currentPath, info) { return (typeof(window.cordova) === &quot;undefined&quot;); } */ CB_Configuration[CB_BASE_NAME].CORDOVAJS_LOAD_CHECKER = function(currentPath, info) { return (typeof(window.cordova) === &quot;undefined&quot;); }; /** * Directory that contains the &quot;cordova.js&quot; file (used by [Apache Cordova]{@link https://cordova.apache.org/}). * @memberof CB_Configuration.CrossBase * @name CORDOVAJS_PATH * @constant * @type {string} * @default */ CB_Configuration[CB_BASE_NAME].CORDOVAJS_PATH = &quot;../&quot;; /** * The script file path for the cordova.js file (used by [Apache Cordova]{@link https://cordova.apache.org/}). * @memberof CB_Configuration.CrossBase * @name CORDOVAJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.CORDOVAJS_PATH} + &quot;cordova.js&quot; */ CB_Configuration[CB_BASE_NAME].CORDOVAJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].CORDOVAJS_PATH + &quot;cordova.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.CORDOVAJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name CORDOVAJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].CORDOVAJS_PATH_ABSOLUTE = false; //localStorage polyfill parameters: /** * Defines whether to load or not [localStorage polyfill]{@link https://github.com/mortzdk/localStorage}. * @memberof CB_Configuration.CrossBase * @name LOCALSTORAGE_POLYFILL_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_LOAD = true; /** * Directory that contains the [localStorage polyfill]{@link https://github.com/mortzdk/localStorage} files. * @memberof CB_Configuration.CrossBase * @name LOCALSTORAGE_POLYFILL_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;general/localStorage/&quot; */ CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;general/localStorage/&quot;; /** * Directory that contains the SWF for [localStorage polyfill]{@link https://github.com/mortzdk/localStorage}. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;swfURL&quot; parameter (URL &quot;GET&quot; parameter) of the library when the localStorage script file is attached. * @memberof CB_Configuration.CrossBase * @name LOCALSTORAGE_POLYFILL_PATH_SWF * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH} + &quot;localStorage.swf&quot; */ CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SWF_FILE = CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH + &quot;localStorage.swf&quot;; //CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SWF_FILE = &quot;localStorage.swf&quot;; /** * The script file path for [localStorage polyfill]{@link https://github.com/mortzdk/localStorage}. * @memberof CB_Configuration.CrossBase * @name LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH} + &quot;localStorage.min.js?swfURL=&quot; + CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SWF_FILE */ CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH + &quot;localStorage.min.js?swfURL=&quot; + CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SWF_FILE; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name LOCALSTORAGE_POLYFILL_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_ABSOLUTE = false; //WAAPISim parameters: /** * Defines whether to load or not [WAAPISim]{@link https://github.com/g200kg/WAAPISim}. * @memberof CB_Configuration.CrossBase * @name WAAPISIM_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.WAAPI_EMULATION_ALLOWED} &amp;&amp; {@link CB_Configuration.CrossBase.needsWAAPISim}() */ CB_Configuration[CB_BASE_NAME].WAAPISIM_LOAD = CB_Configuration[CB_BASE_NAME].WAAPI_EMULATION_ALLOWED &amp;&amp; CB_Configuration[CB_BASE_NAME].needsWAAPISim(); /** * Directory that contains the [WAAPISim]{@link https://github.com/g200kg/WAAPISim} files (script and SWF). * @memberof CB_Configuration.CrossBase * @name WAAPISIM_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/audio/WAAPISim/&quot; */ CB_Configuration[CB_BASE_NAME].WAAPISIM_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/WAAPISim/&quot;; /** * The script file path for the [WAAPISim]{@link https://github.com/g200kg/WAAPISim} script file. * @memberof CB_Configuration.CrossBase * @name WAAPISIM_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.WAAPISIM_PATH} + &quot;waapisim.min.js&quot; */ CB_Configuration[CB_BASE_NAME].WAAPISIM_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].WAAPISIM_PATH + &quot;waapisim.min.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.WAAPISIM_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name WAAPISIM_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].WAAPISIM_PATH_ABSOLUTE = false; //timbre.js (including subcollider.js) parameters: /** * Defines whether to load or not [timbre.js]{@link https://mohayonao.github.io/timbre.js/}. * @memberof CB_Configuration.CrossBase * @name TIMBREJS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsTimbreJS}() */ CB_Configuration[CB_BASE_NAME].TIMBREJS_LOAD = CB_Configuration[CB_BASE_NAME].needsTimbreJS(); /** * Directory that contains the [timbre.js]{@link https://mohayonao.github.io/timbre.js/} files (script and SWF). * @memberof CB_Configuration.CrossBase * @name TIMBREJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/audio/timbre.js/&quot; */ CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/timbre.js/&quot;; /** * The script file path for [timbre.js]{@link https://mohayonao.github.io/timbre.js/}. * @memberof CB_Configuration.CrossBase * @name TIMBREJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.TIMBREJS_PATH} + &quot;timbre.js&quot; */ CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH + &quot;timbre.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.TIMBREJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name TIMBREJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH_ABSOLUTE = false; /** * Defines whether to load or not [subcollider.js]{@link https://github.com/mohayonao/subcollider}. * @memberof CB_Configuration.CrossBase * @name SUBCOLLIDERJS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.TIMBREJS_LOAD} */ CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_LOAD = CB_Configuration[CB_BASE_NAME].TIMBREJS_LOAD; /** * Directory that contains the [subcollider.js]{@link https://github.com/mohayonao/subcollider} script. * @memberof CB_Configuration.CrossBase * @name SUBCOLLIDERJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.TIMBREJS_PATH} + &quot;subcollider/&quot; */ CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_PATH = CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH + &quot;subcollider/&quot;; /** * The script file path for [subcollider.js]{@link https://github.com/mohayonao/subcollider}. * @memberof CB_Configuration.CrossBase * @name SUBCOLLIDERJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SUBCOLLIDERJS_PATH} + &quot;subcollider.js&quot; */ CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_PATH + &quot;subcollider.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.SUBCOLLIDERJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name SUBCOLLIDERJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_PATH_ABSOLUTE = false; //Band.js parameters: /** * Defines whether to load or not [Band.js]{@link https://github.com/meenie/band.js/}. * @memberof CB_Configuration.CrossBase * @name BANDJS_LOAD * @constant * @type {boolean} * @default typeof(window.AudioContext) !== &quot;undefined&quot; || typeof(window.webkitAudioContext) !== &quot;undefined&quot; */ CB_Configuration[CB_BASE_NAME].BANDJS_LOAD = typeof(window.AudioContext) !== &quot;undefined&quot; || typeof(window.webkitAudioContext) !== &quot;undefined&quot;; /** * Directory that contains the [Band.js]{@link https://github.com/meenie/band.js/} files. * @memberof CB_Configuration.CrossBase * @name BANDJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/audio/band.js/&quot; */ CB_Configuration[CB_BASE_NAME].BANDJS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/band.js/&quot;; /** * The script file path for [Band.js]{@link https://github.com/meenie/band.js/}. * @memberof CB_Configuration.CrossBase * @name BANDJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.BANDJS_PATH} + &quot;band.min.js&quot; */ CB_Configuration[CB_BASE_NAME].BANDJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].BANDJS_PATH + &quot;band.min.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.BANDJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name BANDJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].BANDJS_PATH_ABSOLUTE = false; //SoundManager 2 parameters: /** * Defines whether to load or not [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}. * @memberof CB_Configuration.CrossBase * @name SM2_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].SM2_LOAD = true; /** * Directory that contains the [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} files. * @memberof CB_Configuration.CrossBase * @name SM2_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/audio/soundmanager2/&quot; */ CB_Configuration[CB_BASE_NAME].SM2_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/soundmanager2/&quot;; /** * The script file path for [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}. * @memberof CB_Configuration.CrossBase * @name SM2_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SM2_PATH} + &quot;script/soundmanager2-nodebug-jsmin.js&quot; */ CB_Configuration[CB_BASE_NAME].SM2_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].SM2_PATH + &quot;script/soundmanager2-nodebug-jsmin.js&quot;; /** * Directory that contains the SWF's for [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;url&quot; parameter of the library when [soundManager.setup]{@link http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-url * @memberof CB_Configuration.CrossBase * @name SM2_PATH_SWF * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SM2_PATH} + &quot;swf/&quot; */ CB_Configuration[CB_BASE_NAME].SM2_PATH_SWF = CB_Configuration[CB_BASE_NAME].SM2_PATH + &quot;swf/&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.SM2_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name SM2_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].SM2_PATH_ABSOLUTE = false; /** * Object with the required formats for [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}. If the format is required and the web client doesn't support it, [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} will use [Flash]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player}. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-audioformats * @memberof CB_Configuration.CrossBase * @name SM2_AUDIO_FORMATS_REQUIRED * @constant * @type {Object} * @property {boolean} mp3=false - Defines MP3 format as required. * @property {boolean} mp4=false - Defines MP4 format as required. * @property {boolean} ogg=false - Defines OGG format as required. * @property {boolean} opus=false - Defines OPUS format as required. * @property {boolean} wav=false - Defines WAV format as required. * @default */ CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED = { &quot;mp3&quot; : false, &quot;mp4&quot; : false, &quot;ogg&quot; : false, &quot;opus&quot; : false, &quot;wav&quot; : false }; /** * Defines whether to use or not high performance mode in [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} (may cause a flash object to be visible). Belongs to the &quot;useHighPerformance&quot; parameter of the library when [soundManager.setup]{@link http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-highperformance * @memberof CB_Configuration.CrossBase * @name SM2_USE_HIGH_PERFORMANCE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].SM2_USE_HIGH_PERFORMANCE = true; /** * Milliseconds to wait after loading [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/} to define it as not supported if there is no response. Belongs to the &quot;flashLoadTimeout&quot; parameter of the library when [soundManager.setup]{@link http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-flashloadtimeout * @memberof CB_Configuration.CrossBase * @name SM2_TIMEOUT_MS * @constant * @type {integer} * @default */ CB_Configuration[CB_BASE_NAME].SM2_TIMEOUT_MS = 6000; //CB_Configuration[CB_BASE_NAME].SM2_USE_FAST_POLLING = true; //Defines whether to use fast polling (useFastPolling) in [SoundManager 2]{@link http://schillmania.com/projects/soundmanager2/}. //jsfx parameters: /** * Defines whether to load or not [jsfx]{@link https://github.com/loov/jsfx}. * @memberof CB_Configuration.CrossBase * @name JSFX_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsJsfx}() */ CB_Configuration[CB_BASE_NAME].JSFX_LOAD = CB_Configuration[CB_BASE_NAME].needsJsfx(); /** * Directory that contains the [jsfx]{@link https://github.com/loov/jsfx} files. * @memberof CB_Configuration.CrossBase * @name JSFX_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/audio/jsfx/&quot; */ CB_Configuration[CB_BASE_NAME].JSFX_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/jsfx/&quot;; /** * The script file path for [jsfx]{@link https://github.com/loov/jsfx}. * @memberof CB_Configuration.CrossBase * @name JSFX_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.JSFX_PATH} + &quot;jsfx.js&quot; */ CB_Configuration[CB_BASE_NAME].JSFX_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].JSFX_PATH + &quot;jsfx.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.JSFX_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name JSFX_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].JSFX_PATH_ABSOLUTE = false; //NoSleep.js parameters: /** * Defines whether to load or not [NoSleep.js]{@link https://github.com/richtr/NoSleep.js}. * @memberof CB_Configuration.CrossBase * @name NOSLEEP_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsSleepJS}() */ CB_Configuration[CB_BASE_NAME].NOSLEEP_LOAD = CB_Configuration[CB_BASE_NAME].needsSleepJS(); /** * Directory that contains the [NoSleep.js]{@link https://github.com/richtr/NoSleep.js} files. * @memberof CB_Configuration.CrossBase * @name NOSLEEP_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/NoSleep/&quot; */ CB_Configuration[CB_BASE_NAME].NOSLEEP_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/NoSleep/&quot;; /** * The script file path for [NoSleep.js]{@link https://github.com/richtr/NoSleep.js}. * @memberof CB_Configuration.CrossBase * @name NOSLEEP_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.NOSLEEP_PATH} + &quot;NoSleep.min.js&quot; */ CB_Configuration[CB_BASE_NAME].NOSLEEP_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].NOSLEEP_PATH + &quot;NoSleep.min.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.NOSLEEP_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name NOSLEEP_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].NOSLEEP_PATH_ABSOLUTE = false; //Pressure.js parameters: /** * Defines whether to load or not [Pressure.js]{@link https://pressurejs.com/}. * @memberof CB_Configuration.CrossBase * @name PRESSUREJS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsPressureJS}() */ CB_Configuration[CB_BASE_NAME].PRESSUREJS_LOAD = CB_Configuration[CB_BASE_NAME].needsPressureJS(); /** * Directory that contains the [Pressure.js]{@link https://pressurejs.com/} files. * @memberof CB_Configuration.CrossBase * @name PRESSUREJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;input/pressure.js/&quot; */ CB_Configuration[CB_BASE_NAME].PRESSUREJS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/pressure.js/&quot;; /** * The script file path for [Pressure.js]{@link https://pressurejs.com/}. * @memberof CB_Configuration.CrossBase * @name PRESSUREJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.PRESSUREJS_PATH} + &quot;pressure.min.js&quot; */ CB_Configuration[CB_BASE_NAME].PRESSUREJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].PRESSUREJS_PATH + &quot;pressure.min.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.PRESSUREJS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name PRESSUREJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].PRESSUREJS_PATH_ABSOLUTE = false; //Hammer.js and Hammer Time parameters: /** * Defines whether to load or not [Hammer.js]{@link http://hammerjs.github.io/} and [Hammer Time]{@link https://github.com/hammerjs/hammer-time}. * @memberof CB_Configuration.CrossBase * @name HAMMERJS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsHammerJS}() */ CB_Configuration[CB_BASE_NAME].HAMMERJS_LOAD = CB_Configuration[CB_BASE_NAME].needsHammerJS(); /** * Directory that contains the [Hammer.js]{@link http://hammerjs.github.io/} and [Hammer Time]{@link https://github.com/hammerjs/hammer-time} files. * @memberof CB_Configuration.CrossBase * @name HAMMERJS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;input/hammer.js/&quot; */ CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/hammer.js/&quot;; /** * The script file path for [Hammer.js]{@link http://hammerjs.github.io/}. * @memberof CB_Configuration.CrossBase * @name HAMMERJS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.HAMMERJS_PATH} + &quot;hammer.min.js&quot; */ CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH + &quot;hammer.min.js&quot;; /** * The script file path for [Hammer Time]{@link https://github.com/hammerjs/hammer-time}. * @memberof CB_Configuration.CrossBase * @name HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.HAMMERJS_PATH} + &quot;hammer-time/hammer-time.min.js&quot; */ CB_Configuration[CB_BASE_NAME].HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH + &quot;hammer-time/hammer-time.min.js&quot;; /** * Defines whether the paths defined in {@link CB_Configuration.CrossBase.HAMMERJS_PATH_SCRIPT_FILE} and {@link CB_Configuration.CrossBase.HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name HAMMERJS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH_ABSOLUTE = false; //wii-js parameters: /** * Defines whether to load or not [wii-js]{@link https://github.com/ryanmcgrath/wii-js}. * @memberof CB_Configuration.CrossBase * @name WII_JS_LOAD * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].WII_JS_LOAD = true; /** * Directory that contains the [wii-js]{@link https://github.com/ryanmcgrath/wii-js} script. * @memberof CB_Configuration.CrossBase * @name WII_JS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;input/controllers/wii-js/&quot; */ CB_Configuration[CB_BASE_NAME].WII_JS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/controllers/wii-js/&quot;; /** * The script file path for [wii-js]{@link https://github.com/ryanmcgrath/wii-js}. * @memberof CB_Configuration.CrossBase * @name WII_JS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.WII_JS_PATH} + &quot;wii.min.js&quot; */ CB_Configuration[CB_BASE_NAME].WII_JS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].WII_JS_PATH + &quot;wii.min.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.WII_JS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name WII_JS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].WII_JS_PATH_ABSOLUTE = false; //gamepad-plus parameters: /** * Defines whether to load or not [gamepad-plus]{@link https://github.com/MozVR/gamepad-plus}. * @memberof CB_Configuration.CrossBase * @name GAMEPAD_PLUS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsGamepadPlus}() */ CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_LOAD = CB_Configuration[CB_BASE_NAME].needsGamepadPlus(); /** * Directory that contains the [gamepad-plus]{@link https://github.com/MozVR/gamepad-plus} files. * @memberof CB_Configuration.CrossBase * @name GAMEPAD_PLUS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;input/controllers/gamepad-plus/&quot; */ CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/controllers/gamepad-plus/&quot;; /** * The script file path for [gamepad-plus]{@link https://github.com/MozVR/gamepad-plus}. * @memberof CB_Configuration.CrossBase * @name GAMEPAD_PLUS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.GAMEPAD_PLUS_PATH} + &quot;gamepads.js&quot; */ CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_PATH + &quot;gamepads.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.GAMEPAD_PLUS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name GAMEPAD_PLUS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_PATH_ABSOLUTE = false; //Canbox parameters: /** * Defines whether to load or not [Canbox]{@link https://github.com/robertinglin/CanBox}. * @memberof CB_Configuration.CrossBase * @name CANBOX_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsCanbox}() */ CB_Configuration[CB_BASE_NAME].CANBOX_LOAD = CB_Configuration[CB_BASE_NAME].needsCanbox(); /** * Directory that contains the [Canbox]{@link https://github.com/robertinglin/CanBox} files. * @memberof CB_Configuration.CrossBase * @name CANBOX_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/canvas/canbox/&quot; */ CB_Configuration[CB_BASE_NAME].CANBOX_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/canvas/canbox/&quot;; /** * The script file path for [Canbox]{@link https://github.com/robertinglin/CanBox}. * @memberof CB_Configuration.CrossBase * @name CANBOX_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.CANBOX_PATH} + &quot;canbox.0.2.1.js&quot; */ CB_Configuration[CB_BASE_NAME].CANBOX_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].CANBOX_PATH + &quot;canbox.0.2.1.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.CANBOX_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name CANBOX_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].CANBOX_PATH_ABSOLUTE = false; //FlashCanvas parameters: /** * Defines whether to load or not [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsFlashCanvas}() */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_LOAD = CB_Configuration[CB_BASE_NAME].needsFlashCanvas(); /** * Defines whether to allow to run [FlashCanvas]{@link https://github.com/everlaat/flashcanvas} locally or not (because the &quot;.swf&quot; file folder needs to be added to 'trusted files' in Flash global configuration to work locally in some operating systems). * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT = false; /** * Directory that contains the [FlashCanvas]{@link https://github.com/everlaat/flashcanvas} files. * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/canvas/FlashCanvas/pro/&quot; */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/canvas/FlashCanvas/pro/&quot;; /** * The script file path for [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.FLASHCANVAS_PATH} + &quot;bin/flashcanvas.js&quot; */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH + &quot;bin/flashcanvas.js&quot;; /** * Directory that contains the SWF's for [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;swfPath&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_PATH_SWF * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.FLASHCANVAS_PATH} + &quot;bin/&quot; */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_SWF = CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH + &quot;bin/&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.FLASHCANVAS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_ABSOLUTE = false; /** * Disables the context menu when the right mouse button is clicked on any canvas using [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}' SWF. Belongs to the &quot;disableContextMenu&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_DISABLE_CONTEXT_MENU * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_DISABLE_CONTEXT_MENU = false; /** * Uses turbo mode to speed up [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. Belongs to the &quot;turbo&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_TURBO_MODE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_TURBO_MODE = true; /** * Maximum size for the image cache used by [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. Belongs to the &quot;imageCacheSize&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config * @memberof CB_Configuration.CrossBase * @name FLASHCANVAS_IMAGE_CACHE_SIZE * @constant * @type {integer} * @default */ CB_Configuration[CB_BASE_NAME].FLASHCANVAS_IMAGE_CACHE_SIZE = 100; //SLCanvas parameters: /** * Defines whether to load or not [SLCanvas]{@link https://slcanvas.codeplex.com/}. * @memberof CB_Configuration.CrossBase * @name SLCANVAS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsSLCanvas}() */ CB_Configuration[CB_BASE_NAME].SLCANVAS_LOAD = CB_Configuration[CB_BASE_NAME].needsSLCanvas(); /** * Directory that contains the [SLCanvas]{@link https://slcanvas.codeplex.com/} files. * @memberof CB_Configuration.CrossBase * @name SLCANVAS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/canvas/slcanvas/&quot; */ CB_Configuration[CB_BASE_NAME].SLCANVAS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/canvas/slcanvas/&quot;; /** * The script file path for [SLCanvas]{@link https://slcanvas.codeplex.com/}. * @memberof CB_Configuration.CrossBase * @name SLCANVAS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SLCANVAS_PATH} + &quot;slcanvas.js&quot; */ CB_Configuration[CB_BASE_NAME].SLCANVAS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].SLCANVAS_PATH + &quot;slcanvas.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.SLCANVAS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name SLCANVAS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].SLCANVAS_PATH_ABSOLUTE = false; //ExplorerCanvas parameters: /** * Defines whether to load or not [ExplorerCanvas]{@link https://github.com/arv/explorercanvas}. * @memberof CB_Configuration.CrossBase * @name EXCANVAS_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsExplorerCanvas}() */ CB_Configuration[CB_BASE_NAME].EXCANVAS_LOAD = CB_Configuration[CB_BASE_NAME].needsExplorerCanvas(); /** * Directory that contains the [ExplorerCanvas]{@link https://github.com/arv/explorercanvas} files. * @memberof CB_Configuration.CrossBase * @name EXCANVAS_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot; */ CB_Configuration[CB_BASE_NAME].EXCANVAS_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot;; /** * The script file path for [ExplorerCanvas]{@link https://github.com/arv/explorercanvas}. * @memberof CB_Configuration.CrossBase * @name EXCANVAS_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.EXCANVAS_PATH} + &quot;excanvas.js&quot; */ CB_Configuration[CB_BASE_NAME].EXCANVAS_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].EXCANVAS_PATH + &quot;excanvas.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.EXCANVAS_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name EXCANVAS_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].EXCANVAS_PATH_ABSOLUTE = false; //canvas-text parameters: /** * Defines whether to load or not [canvas-text]{@link https://github.com/PhenX/canvas-text}. * @memberof CB_Configuration.CrossBase * @name CANVAS_TEXT_LOAD * @constant * @type {boolean} * @default {@link CB_Configuration.CrossBase.needsCanvasText}() */ CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_LOAD = CB_Configuration[CB_BASE_NAME].needsCanvasText(); /** * Directory that contains the [canvas-text]{@link https://github.com/PhenX/canvas-text} files. * @memberof CB_Configuration.CrossBase * @name CANVAS_TEXT_PATH * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.SCRIPT_PATH} + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot; */ CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH = CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot;; /** * The script file path for [canvas-text]{@link https://github.com/PhenX/canvas-text}. * @memberof CB_Configuration.CrossBase * @name CANVAS_TEXT_PATH_SCRIPT_FILE * @constant * @type {string} * @default {@link CB_Configuration.CrossBase.CANVAS_TEXT_PATH} + &quot;canvas.text.js&quot; */ CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH_SCRIPT_FILE = CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH + &quot;canvas.text.js&quot;; /** * Defines whether the path defined in {@link CB_Configuration.CrossBase.CANVAS_TEXT_PATH_SCRIPT_FILE} is either absolute or relative to the CrossBrowdy script path. * @memberof CB_Configuration.CrossBase * @name CANVAS_TEXT_PATH_ABSOLUTE * @constant * @type {boolean} * @default */ CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH_ABSOLUTE = false; //Applies the options set by the user (if any): CB_applyOptions(CB_BASE_NAME, this); //Module basic configuration: CB_Modules.modules[CB_BASE_NAME] = { //Name of the module: &quot;name&quot; : CB_BASE_NAME, //Status (UNKNOWN, UNLOADED, LOADING, LOADED, READY or FAILED): &quot;status&quot; : CB_Modules.STATUSES.UNLOADED, //Function to call as soon as the module is called (before loading its scripts): &quot;onCall&quot; : function(scriptPathGiven) { if (CB_Configuration[CB_BASE_NAME].CB_Net_XHR_PROXY_URL_RELATIVE) { CB_Configuration[CB_BASE_NAME].CB_Net_XHR_PROXY_URL = scriptPathGiven + CB_Configuration[CB_BASE_NAME].CB_Net_XHR_PROXY_URL; } if (CB_Configuration[CB_BASE_NAME].FLASHCANVAS_LOAD) { CB_prepareFlashCanvas(scriptPathGiven); } CB_Modules.setStatus(&quot;CrossBase&quot;, CB_Modules.STATUSES.LOADED); }, //Callback function to call when the module has been loaded successfully: &quot;onLoad&quot; : function(scriptPathGiven) { var checkReadyFunction = function() { var loopAgain = true; if (CB_Configuration[CB_BASE_NAME].SM2_LOAD &amp;&amp; !CB_startSoundManager2Called) { CB_startSoundManager2(scriptPathGiven); } if (typeof(detectZoom) !== &quot;undefined&quot; &amp;&amp; detectZoom !== null &amp;&amp; detectZoom &amp;&amp; typeof(detectZoom.device) !== &quot;undefined&quot; &amp;&amp; detectZoom.device !== null &amp;&amp; detectZoom.device &amp;&amp; typeof(detectZoom.device) === &quot;function&quot;) { if (typeof(BrowserDetect) !== &quot;undefined&quot; &amp;&amp; BrowserDetect !== null &amp;&amp; typeof(BrowserDetect.browser) !== &quot;undefined&quot; &amp;&amp; BrowserDetect.browser !== null) { if (CB_soundManager2Loaded || !CB_Configuration[CB_BASE_NAME].SM2_LOAD) //If SM2 has been loaded or we don't need it: { if (window.localStorage) //Needed for safe use of localStorage polyfill. { if (CB_initializeStaticObjects()) //Initializes all static objects (returns false until it loads totally). { CB_Modules.setStatus(&quot;CrossBase&quot;, CB_Modules.STATUSES.READY); loopAgain = false; } } } } } if (loopAgain) { setTimeout(checkReadyFunction, 1); } }; checkReadyFunction(); }, //Callback function to call when the module is ready: &quot;onReady&quot; : null, //Callback function to call when module has not been loaded successfully: //&quot;onFail&quot; =&gt; null, //Needed files: //Following files doesn't support IE5.0: // detect_zoom.js, CB_others.js, CB_events.js, CB_Screen.js, CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_SCRIPT_FILE, // CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH_SCRIPT_FILE, CB_Configuration[CB_BASE_NAME].SM2_PATH_SCRIPT_FILE &quot;neededFiles&quot; : { //Format: &quot;needed_file&quot; : { load: needs_to_be_loaded, [mandatory: needed_to_begin_CrossBrowdy], [absolutePath: relative_to_CrossBrowdy_path_or_absolute], [loadChecker: function that will be called and return true if the file needs to be loaded], [id: file_identifier_string], [requires: array_with_required_ids_of_files_required] } //Mandatory files: &quot;CrossBase/general/others/BrowserDetect.js&quot; : { load: true, mandatory: true }, //BrowserDetect by Peter-Paul Koch. &quot;CrossBase/general/others/performanceAndrequestAnimationFrame.js&quot; : { load: true, mandatory: true, id: &quot;performanceAndrequestAnimationFrame&quot; }, //performance.now polyfill by Paul Irish, Aaron Levine and Joan Alba Maldonado, requestAnimationFrame polyfill by Erik Moller (fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavic, Darius Bacon, Tim Hall and Joan Alba Maldonado). &quot;CrossBase/general/others/typedarray.js&quot; : { load: true, mandatory: true, id: &quot;typedarray&quot; }, //typedarray.js polyfill by Linden Research, Inc. and Joshua Bell and Joshua Bell. &quot;CrossBase/general/others/base64-binary.js&quot; : { load: true, mandatory: true }, //Base64Binary by Daniel Guerrero. &quot;CrossBase/general/lz-string/lz-string.min.js&quot; : { load: true, mandatory: true }, //lz-string (including base64-string) by pieroxy. &quot;CrossBase/general/lz-string/base64-string.js&quot; : { load: true, mandatory: true }, //lz-string (including base64-string) by pieroxy. &quot;CrossBase/general/bluebird/bluebird.min.js&quot; : { load: typeof(window.Promise) === &quot;undefined&quot;, mandatory: true }, //bluebird by Petka Antonov. &quot;CrossBase/general/JSON3/json3.min.js&quot; : { load: true, mandatory: true, id: &quot;json3&quot; }, //JSON3 by Kit Cambridge. &quot;CrossBase/audiovisual/image/detect_zoom/detect_zoom.js&quot; : { load: true, mandatory: true }, //Detect-zoom by yonran (maintained by tombigel). &quot;CrossBase/audiovisual/audio/AudioContextMonkeyPatch/AudioContextMonkeyPatch.js&quot; : { load: true, mandatory: true }, //AudioContext-MonkeyPatch by Chris Wilson. &quot;CrossBase/general/CB_others.js&quot; : { load: true, mandatory: true }, //Other functions (such as trim(), etc). &quot;CrossBase/general/CB_Arrays.js&quot; : { load: true, mandatory: true }, //Arrays functions. &quot;CrossBase/general/CB_Client.js&quot; : { load: true, mandatory: true }, //Functions related with the client (browser, WebView, etc.). &quot;CrossBase/general/CB_data.js&quot; : { load: true, mandatory: true }, //Functions related with data (cookies, URL parameters, etc.). &quot;CrossBase/general/CB_Elements.js&quot; : { load: true, mandatory: true }, //Elements functions. &quot;CrossBase/general/CB_Events.js&quot; : { load: true, mandatory: true }, //Event functions. &quot;CrossBase/general/CB_Collisions.js&quot; : { load: true, mandatory: true }, //Collisions detection. &quot;CrossBase/device/CB_Device.js&quot; : { load: true, mandatory: true }, //CB_Device static class. &quot;CrossBase/audiovisual/image/CB_Screen.js&quot; : { load: true, mandatory: true }, //CB_Screen static class. &quot;CrossBase/audiovisual/image/CB_GraphicSprites.js&quot; : { load: true, mandatory: true }, //CB_GraphicSprites class. &quot;CrossBase/audiovisual/image/CB_GraphicSpritesScene.js&quot; : { load: true, mandatory: true }, //CB_GraphicSpritesScene class. &quot;CrossBase/audiovisual/image/canvas/CB_Canvas.js&quot; : { load: true, mandatory: true }, //CB_Canvas class. &quot;CrossBase/input/CB_Keyboard.js&quot; : { load: true, mandatory: true }, //CB_Keyboard static class. &quot;CrossBase/input/CB_Mouse.js&quot; : { load: true, mandatory: true }, //CB_Mouse static class. &quot;CrossBase/input/CB_Touch.js&quot; : { load: true, mandatory: true }, //CB_Touch static class. &quot;CrossBase/input/CB_Pointer.js&quot; : { load: true, mandatory: true }, //CB_Pointer static class. &quot;CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js&quot; : { load: true, mandatory: true, requires: [&quot;performanceAndrequestAnimationFrame&quot;] }, //CB_Controllers_Proprietary_WII.js static class. &quot;CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js&quot; : { load: true, mandatory: true, requires: [&quot;performanceAndrequestAnimationFrame&quot;] }, //CB_Controllers_Proprietary_WII_U.js static class. &quot;CrossBase/input/controllers/CB_Controllers.js&quot; : { load: true, mandatory: true }, //CB_Controllers static class. &quot;CrossBase/net/fetch/fetch-ie8/fetch.js&quot; : { load: typeof(window.fetch) === &quot;undefined&quot;, mandatory: true }, //fetch-ie8 by Cam Song. &quot;CrossBase/net/CB_Net.js&quot; : { load: true, mandatory: true }, //CB_Net. &quot;CrossBase/net/fetch/CB_Net_Fetch.js&quot; : { load: true, mandatory: true }, //CB_Net.Fetch static class. &quot;CrossBase/net/XHR/CB_Net_XHR.js&quot; : { load: true, mandatory: true }, //CB_Net.XHR static class (AJAX). &quot;CrossBase/net/sockets/CB_Net_Sockets.js&quot; : { load: true, mandatory: true }, //CB_Net.Sockets static class. &quot;CrossBase/net/REST/CB_Net_REST.js&quot; : { load: true, mandatory: true }, //CB_Net.REST static class. &quot;CrossBase/audiovisual/audio/CB_AudioDetector.js&quot; : { load: true, mandatory: true }, //CB_AudioDetector static class. &quot;CrossBase/audiovisual/audio/CB_AudioFile.js&quot; : { load: true, mandatory: true }, //CB_AudioFile class. &quot;CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js&quot; : { load: true, mandatory: true }, //CB_AudioFile_API[&quot;WAAPI&quot;] class. &quot;CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js&quot; : { load: true, mandatory: true }, //CB_AudioFile_API[&quot;AAPI&quot;] class. &quot;CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js&quot; : { load: CB_Configuration[CB_BASE_NAME].SM2_LOAD, mandatory: true }, //CB_AudioFile_API[&quot;SM2&quot;] class. //&quot;CrossBase/audiovisual/audio/CB_AudioFile_API_IXDKPP.js&quot; : { load: true, mandatory: true }, //CB_AudioFile_API[&quot;IXDKPP&quot;] class. &quot;CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js&quot; : { load: true, mandatory: true }, //CB_AudioFile_API[&quot;ACMP&quot;] class. &quot;CrossBase/audiovisual/audio/CB_AudioFileCache.js&quot; : { load: true, mandatory: true }, //CB_AudioFileCache class. &quot;CrossBase/audiovisual/audio/CB_AudioFileSprites.js&quot; : { load: true, mandatory: true }, //CB_AudioFileSprites class. &quot;CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js&quot; : { load: true, mandatory: true }, //CB_AudioFileSpritesPool class. &quot;CrossBase/audiovisual/audio/CB_Speaker.js&quot; : { load: true, mandatory: true }, //CB_Speaker static class. &quot;CrossBase/general/PHP/PHP_detector.php&quot; : { load: true, mandatory: true }, //Dynamic filepath: &quot;VALUEOF_CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE&quot; : { load: true, mandatory: true }, //localStorage polyfill by Morten Houmøller Nygaard. &quot;VALUEOF_CB_Configuration.CrossBase.SOCKJS_PATH_SCRIPT_FILE&quot; : { load: true, mandatory: true, requires: [&quot;json3&quot;] }, //SockJS-client by Marek, Bryce Kahle, Michael Bridgen, Luigi Pinca and others. //Optional files: &quot;VALUEOF_CB_Configuration.CrossBase.CANBOX_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].CANBOX_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].CANBOX_PATH_ABSOLUTE }, //Canbox by Robert Inglin. &quot;VALUEOF_CB_Configuration.CrossBase.SLCANVAS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].SLCANVAS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].SLCANVAS_PATH_ABSOLUTE }, //SLCanvas by David Anson and Jon Davis. &quot;VALUEOF_CB_Configuration.CrossBase.FLASHCANVAS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].FLASHCANVAS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_ABSOLUTE }, //FlashCanvas by Tim Cameron Ryan and Shinya Muramatsu. &quot;VALUEOF_CB_Configuration.CrossBase.EXCANVAS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].EXCANVAS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].EXCANVAS_PATH_ABSOLUTE }, //ExplorerCanvas by Google Inc. &quot;VALUEOF_CB_Configuration.CrossBase.CANVAS_TEXT_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].CANVAS_TEXT_PATH_ABSOLUTE }, //canvas-text by Fabien Menager. &quot;VALUEOF_CB_Configuration.CrossBase.SM2_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].SM2_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].SM2_PATH_ABSOLUTE }, //SoundManager 2 by Scott Schiller. &quot;VALUEOF_CB_Configuration.CrossBase.NOSLEEP_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].NOSLEEP_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].NOSLEEP_PATH_ABSOLUTE }, //NoSleep.js by Rich Tibbett. &quot;VALUEOF_CB_Configuration.CrossBase.PHONEGAPJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].PHONEGAPJS_LOAD, mandatory: false, absolutePath: CB_Configuration[CB_BASE_NAME].PHONEGAPJS_PATH_ABSOLUTE }, //Script necessary for PhoneGap. &quot;VALUEOF_CB_Configuration.CrossBase.CORDOVAJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].CORDOVAJS_LOAD, loadChecker: CB_Configuration[CB_BASE_NAME].CORDOVAJS_LOAD_CHECKER, mandatory: false, absolutePath: CB_Configuration[CB_BASE_NAME].CORDOVAJS_PATH_ABSOLUTE }, //Script necessary for Apache Cordova. &quot;VALUEOF_CB_Configuration.CrossBase.INTELXDKJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].INTELXDKJS_LOAD, mandatory: false, absolutePath: CB_Configuration[CB_BASE_NAME].INTELXDKJS_PATH_ABSOLUTE }, //Script necessary for Intel XDK. &quot;VALUEOF_CB_Configuration.CrossBase.INTELXDK_INITDEVJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_LOAD, loadChecker: CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_LOAD_CHECKER, mandatory: false, absolutePath: CB_Configuration[CB_BASE_NAME].INTELXDK_INITDEVJS_PATH_ABSOLUTE }, //Script necessary for Intel XDK. &quot;VALUEOF_CB_Configuration.CrossBase.TIMBREJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].TIMBREJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].TIMBREJS_PATH_ABSOLUTE, id: &quot;timbrejs&quot;, requires: [&quot;typedarray&quot;] }, //timbre.js by mohayonao. &quot;VALUEOF_CB_Configuration.CrossBase.SUBCOLLIDERJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].SUBCOLLIDERJS_PATH_ABSOLUTE, requires: [&quot;timbrejs&quot;] }, //subcollider.js by mohayonao. &quot;VALUEOF_CB_Configuration.CrossBase.WAAPISIM_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].WAAPISIM_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].WAAPISIM_PATH_ABSOLUTE }, //WAAPISim by g200kg. &quot;VALUEOF_CB_Configuration.CrossBase.BANDJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].BANDJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].BANDJS_PATH_ABSOLUTE }, //Band.js by Cody Lundquist and various contributors. &quot;VALUEOF_CB_Configuration.CrossBase.JSFX_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].JSFX_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].JSFX_PATH_ABSOLUTE }, //jsfx by Egon Elbre. &quot;VALUEOF_CB_Configuration.CrossBase.PRESSUREJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].PRESSUREJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].PRESSUREJS_PATH_ABSOLUTE }, //Pressure.js by Stuart Yamartino. &quot;VALUEOF_CB_Configuration.CrossBase.HAMMERJS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].HAMMERJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH_ABSOLUTE }, //Hammer.js by Jorik Tangelder. &quot;VALUEOF_CB_Configuration.CrossBase.HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].HAMMERJS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].HAMMERJS_PATH_ABSOLUTE }, //Hammer Time by Alexander Schmitz and other contributors. &quot;VALUEOF_CB_Configuration.CrossBase.WII_JS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].WII_JS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].WII_JS_PATH_ABSOLUTE }, //wii-js by Ryan McGrath. &quot;VALUEOF_CB_Configuration.CrossBase.GAMEPAD_PLUS_PATH_SCRIPT_FILE&quot; : { load: CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_LOAD, mandatory: true, absolutePath: CB_Configuration[CB_BASE_NAME].GAMEPAD_PLUS_PATH_ABSOLUTE, requires: [&quot;performanceAndrequestAnimationFrame&quot;] } //gamepad-plus by Chris Van Wiemeersch (MozVR). //TODO: think about requiring xhr.js }, //Needed modules: &quot;neededModules&quot; : null, //Credits: &quot;credits&quot; : CB_CrossBaseCredits }; //Adds the credits to the default ones: CB_addCredits(CB_Modules.modules[&quot;CrossBase&quot;][&quot;credits&quot;]); //Function that initializes (builds) all static objects required (returns true when finishes totally): var CB_initializeStaticObjects_LOADED = { &quot;CB_Arrays&quot; : false, //CB_Arrays static class. &quot;CB_Elements&quot; : false, //CB_Elements static class. &quot;CB_Events&quot; : false, //CB_Events static class. &quot;CB_Client&quot; : false, //CB_Client static class. &quot;CB_Device&quot; : false, //CB_Device static class. &quot;CB_Net&quot; : false, //CB_Net static class. &quot;CB_Net.Fetch&quot; : false, //CB_Net.Fetch static class. &quot;CB_Net.XHR&quot; : false, //CB_Net.XHR static class. &quot;CB_Net.REST&quot; : false, //CB_Net.REST static class. &quot;CB_Net.Sockets&quot; : false, //CB_Net.Sockets static class. &quot;CB_Screen&quot; : false, //CB_Screen static class. &quot;CB_Collisions&quot; : false, //CB_Collisions static class. &quot;CB_Keyboard&quot; : false, //CB_Keyboard static class. &quot;CB_Mouse&quot; : false, //CB_Mouse static class. &quot;CB_Touch&quot; : false, //CB_Touch static class. &quot;CB_Pointer&quot; : false, //CB_Pointer static class. &quot;CB_Controllers&quot; : false, //CB_Controllers static class. &quot;CB_Speaker&quot; : false, //CB_Speaker static class. &quot;CB_AudioDetector&quot; : false //CB_AudioDetector static class. }; function CB_initializeStaticObjects(containerObject) { if (typeof(containerObject) === &quot;undefined&quot; || containerObject === null) { containerObject = CB_this || window; } var allIndexes = null; var allIndexesLength = null; var currentObject = null; for (var staticObject in CB_initializeStaticObjects_LOADED) { if (!CB_initializeStaticObjects_LOADED[staticObject]) { allIndexes = staticObject.split(&quot;.&quot;); allIndexesLength = allIndexes.length; currentObject = containerObject[allIndexes[0]]; for (var x = 1; x &lt; allIndexesLength; x++) { if (typeof(currentObject[allIndexes[x]]) !== &quot;undefined&quot; &amp;&amp; currentObject[allIndexes[x]] !== null) { currentObject = currentObject[allIndexes[x]]; } else { return false; } } if (currentObject &amp;&amp; typeof(currentObject.init) === &quot;function&quot;) { currentObject.init(); CB_initializeStaticObjects_LOADED[staticObject] = true; } else { return false; } } } return true; } //Function that prepares FlashCanvas options (it needs to be done before loading the FlashCanvas script): function CB_prepareFlashCanvas(scriptPathGiven) { document.createElement(&quot;canvas&quot;); //According to FlashCanvas web site: ensure that document.createElement(&quot;canvas&quot;) is executed before any canvas element appears. window.FlashCanvasOptions = { swfPath: scriptPathGiven + CB_Configuration[CB_BASE_NAME].FLASHCANVAS_PATH_SWF, disableContextMenu: CB_Configuration[CB_BASE_NAME].FLASHCANVAS_DISABLE_CONTEXT_MENU, turbo: CB_Configuration[CB_BASE_NAME].FLASHCANVAS_TURBO_MODE, imageCacheSize: CB_Configuration[CB_BASE_NAME].FLASHCANVAS_IMAGE_CACHE_SIZE }; } //Function that starts SoundManager 2: var CB_startSoundManager2Called = false; //Defines whether CB_startSoundManager2 function has been called or not. var CB_soundManager2Loaded = false; //Defines whether SoundManager 2 has been loaded successfully or not. var CB_soundManager2Supported = false; //Defines whether SoundManager 2 is supported or not. function CB_startSoundManager2(scriptPathGiven) { CB_startSoundManager2Called = true; var CB_soundManager2TimeoutFunction = function() { CB_soundManager2Loaded = true; //SoundManager 2 has been loaded succesfully (but is not supported). CB_soundManager2Supported = false; //SoundManager 2 is not supported. }; var CB_startSoundManager2Function = function() { if (typeof(soundManager) !== &quot;undefined&quot; &amp;&amp; soundManager !== null) { //If the browser can't play the formats required using HTML5, it will force to load Flash: soundManager.audioFormats = { 'mp3': { 'type': ['audio/mpeg; codecs=&quot;mp3&quot;', 'audio/mpeg', 'audio/mp3', 'audio/MPA', 'audio/mpa-robust'], 'required': CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED[&quot;mp3&quot;] }, 'mp4': { 'related': ['aac', 'm4a'], 'type': ['audio/mp4; codecs=&quot;mp4a.40.2&quot;', 'audio/aac', 'audio/x-m4a', 'audio/MP4A-LATM', 'audio/mpeg4-generic'], 'required': CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED[&quot;mp4&quot;] }, 'ogg': { 'type': ['audio/ogg; codecs=vorbis'], 'required': CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED[&quot;ogg&quot;] }, 'opus': { 'type': ['audio/ogg; codecs=opus', 'audio/opus'], 'required': CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED[&quot;opus&quot;] }, 'wav': { 'type': ['audio/wav; codecs=&quot;1&quot;', 'audio/wav', 'audio/wave', 'audio/x-wav'], 'required': CB_Configuration[CB_BASE_NAME].SM2_AUDIO_FORMATS_REQUIRED[&quot;wav&quot;] } }; soundManager.setup( { debugMode: false, flashLoadTimeout: CB_Configuration[CB_BASE_NAME].SM2_TIMEOUT_MS, useHighPerformance: CB_Configuration[CB_BASE_NAME].SM2_USE_HIGH_PERFORMANCE, //useFastPolling: CB_Configuration[CB_BASE_NAME].SM2_USE_FAST_POLLING, url: scriptPathGiven + CB_Configuration[CB_BASE_NAME].SM2_PATH_SWF, onready: function() { clearTimeout(CB_soundManager2Timeout); CB_soundManager2Loaded = true; //SoundManager 2 has been loaded succesfully (and is supported). CB_soundManager2Supported = true; //SoundManager 2 is supported. }, ontimeout: CB_soundManager2TimeoutFunction }); //Ensure start-up in case document.readyState and/or DOMContentLoaded are unavailable: soundManager.beginDelayedInit(); } else if (!CB_soundManager2Loaded) { setTimeout(CB_startSoundManager2Function, 1); } }; CB_startSoundManager2Function(); //Since ontimeout event of SoundManager 2 seems not working on some platforms using Intel XDK (and maybe other Cordova-based engines), we have our own onntimeout: var CB_soundManager2Timeout = setTimeout(CB_soundManager2TimeoutFunction, CB_Configuration[CB_BASE_NAME].SM2_TIMEOUT_MS); } × Search results Close "},"CrossBase_audiovisual_image_canvas_CB_Canvas.js.html":{"id":"CrossBase_audiovisual_image_canvas_CB_Canvas.js.html","title":"Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js /** * @file Canvas management (including emulation fallbacks). Contains the {@link CB_Canvas} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Class to manage a canvas. * @class * @classdesc Class to manage a canvas. For clients which do not support native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}, it provides [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} emulation with [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}, Microsoft Silverlight emulation with [SLCanvas]{@link https://slcanvas.codeplex.com/}, VML emulation with [ExplorerCanvas]{@link https://github.com/arv/explorercanvas} (reinforced with [canvas-text]{@link https://github.com/PhenX/canvas-text}) and DHTML (DOM elements) emulation with [CanBox]{@link https://github.com/robertinglin/CanBox}. NOTE: To make the VML emulation work without errors (using [ExplorerCanvas]{@link https://github.com/arv/explorercanvas}), it is recommended to always load [FlashCanvas]{@link https://github.com/everlaat/flashcanvas} (which already includes [ExplorerCanvas]{@link https://github.com/arv/explorercanvas}) in your HTML code (without using lazy-load, as [ExplorerCanvas]{@link https://github.com/arv/explorercanvas} does not support it). This is recommended even when we are not going to use [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} emulation with [FlashCanvas]{@link https://github.com/everlaat/flashcanvas}. This is an example (should be placed before loading the main &quot;CrossBrowdy&quot; script): &amp;lt;!-- Loads FlashCanvas (Flash emulation) before CrossBrowdy. Needed also to use ExplorerCanvas (VML emulation) without problems: --&amp;gt; &amp;lt;script type=&quot;text/javascript&quot; src=&quot;CrossBrowdy/CrossBase/audiovisual/image/canvas/FlashCanvas/pro/bin/flashcanvas.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!-- FlashCanvas/ExplorerCanvas do not support lazy load. --&amp;gt; * @param {string} canvasId - The desired ID for the canvas. * @param {('2d'|'webgl'|'experimental-webgl'|'webgl2'|'experimental-webgl2'|'bitmaprenderer')} [contextType='2d'] - The contextType desired by default. More information: [HTMLCanvasElement.getContext]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext}. Note that most emulation methods will only support &quot;2d&quot;. * @param {integer} [canvasWidth={@link CB_Canvas.WIDTH_DEFAULT}] - The desired width (horizontal size) in pixels for the canvas. * @param {integer} [canvasHeight={@link CB_Canvas.HEIGHT_DEFAULT}] - The desired height (vertical size) in pixels for the canvas. * @param {function} [onLoad] - Callback function that will be called when the canvas is finally loaded. It will not receive parameters, being &quot;this&quot; the {@link CB_Canvas} object itself. * @param {function} [onError] - Callback function that will be called when there is an error creating or loading the canvas. Being &quot;this&quot; the {@link CB_Canvas} object itself, the unique parameter received will be a string describing the error (if it could be determined). * @param {Element} [canvasParent=document.body] - The parent element desired to adopt the canvas. * @param {array} [alternativeCanvasEmulationPreferredOrder={@link CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS}] - Numeric array listing the desired alternative emulation methods for rendering the canvas, in order of preference. Supported emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. * @param {boolean} [forceFirstEmulationMethod=false] - If set to true, it will force to use the first alternative emulation method desired (even when this alternative emulation method could be not supported and even when native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} support could be supported). * @param {boolean} [addOtherMethods=true] - If set to true, it will add other alternative methods (if any is missing) at the end of the desired alternative emulation methods so they will also be checked and used if the previous ones are not finally used. The order they will be added will be the one used in the {@link CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS} constant. * @param {boolean} [allowFlashCanvasLocally={@link CB_Configuration.CrossBase.FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT}] - If set to true, it will allow to use [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} emulation (if needed) even when it is running locally. Uses the {@link CB_Client.isRunningLocally} function internally. * @returns {CB_Canvas} Returns a new {@link CB_Canvas} object. */ var CB_Canvas = function(canvasId, contextType, canvasWidth, canvasHeight, onLoad, onError, canvasParent, alternativeCanvasEmulationPreferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_Canvas)) { return new CB_Canvas(canvasId, contextType, canvasWidth, canvasHeight, canvasParent, alternativeCanvasEmulationPreferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally); } //Properties: this._parent = undefined; //The parents of the canvas. this._id = undefined; //The ID of the canvas element. this.canvas = undefined; //Canvas element itself. this.context = undefined; //Context of the canvas element. this._contextType = undefined; //Type of the context of the canvas element. this._supported = false; //Defines whether Canvas works. this._width = undefined; //Canvas width. this._height = undefined; //Canvas height. this._mode = &quot;NONE&quot;; //Stores the mode used for the canvas ('NONE', 'NORMAL', 'FLASH', 'SILVERLIGHT', 'VML' or 'DHTML'). this._ready = false; //Stores whether the canvas is ready to be used or not (useful for SLCanvas). this._loading = true; //Stores whether the canvas is loading or not (useful for SLCanvas). //Calls the constructor of the object when creates an instance: return this._init(canvasId, contextType, canvasWidth, canvasHeight, onLoad, onError, canvasParent, alternativeCanvasEmulationPreferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally); } /* //Static properties and functions: CB_Canvas._MODES = { &quot;NONE&quot; : 0, &quot;VML&quot; : 1, &quot;FLASH&quot; : 2, &quot;SILVERLIGHT&quot; : 3, &quot;DHTML&quot; : 4 }; //Defines rendering mode. CB_Canvas._MODES_STRING = [ &quot;NONE&quot;, &quot;VML&quot;, &quot;FLASH&quot;, &quot;SILVERLIGHT&quot;, &quot;DHTML&quot; ]; CB_Canvas.getModeString = function(mode) { if (typeof(CB_Canvas._MODES_STRING[mode]) !== &quot;undefined&quot;) { return CB_Canvas._MODES_STRING[mode]; } else { return &quot;UNKNOWN&quot;; } }; */ //Constants: /** * Default canvas width in pixels. * @constant * @type {integer} * @default */ CB_Canvas.WIDTH_DEFAULT = 320; //Default canvas width. /** * Default canvas height in pixels. * @constant * @type {integer} * @default */ CB_Canvas.HEIGHT_DEFAULT = 240; //Default canvas height. CB_Canvas.prototype._allowedContextTypes = [&quot;2d&quot;, &quot;webgl&quot;, &quot;experimental-webgl&quot;, &quot;webgl2&quot;, &quot;experimental-webgl2&quot;, &quot;bitmaprenderer&quot;]; //Allowed context types. //Constructor: CB_Canvas.prototype._init = function(canvasId, contextType, canvasWidth, canvasHeight, onLoad, onError, canvasParent, alternativeCanvasEmulationPreferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally) { //If they have not been sent, uses default parameters: if (typeof(canvasParent) === &quot;undefined&quot; || canvasParent === null) { canvasParent = document.body; } //Gets the best emulation method: alternativeCanvasEmulation = CB_Canvas.bestEmulation(alternativeCanvasEmulationPreferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally); //Defines the parent given: this._parent = canvasParent; //Defines the canvas element by using the ID given: this.setId(canvasId); this.set(this.getId(), canvasWidth, canvasHeight, onLoad, onError, alternativeCanvasEmulation, forceFirstEmulationMethod); //Detects whether Canvas works: if (this.isSupported()) { //Defines the canvas context: this.setContextType(contextType); this.getContext(this.getContextType()); } else { //There is no mode unless we are using Silverlight (since SLCanvas needs time to load): if (this._mode !== &quot;SILVERLIGHT&quot; &amp;&amp; !this._loading) { this._mode = &quot;NONE&quot;; //This will be changed when SLCanvas loads (if it does). } } return this; } /** * Tells whether the current client needs canvas emulation or not. Uses {@link CB_Client.supportsCanvas} internally. * @function * @returns {boolean} Returns whether the current client needs canvas emulation or not. */ CB_Canvas.needsEmulation = function() { return !CB_Client.supportsCanvas(); } /** * Calculates and returns the best alternative canvas emulation. * @function * @param {array|string} [preferredOrder={@link CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS}] - Numeric array listing the desired alternative emulation methods for rendering the canvas, in order of preference. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. It can also be a string with the unique desired canvas emulation method or with &quot;NO&quot; or &quot;NONE&quot; value (meaning no emulation method is desired and then the returning value will always be &quot;NONE&quot;). * @param {boolean} [forceFirstEmulationMethod=false] - If set to true, it will force to return the first alternative emulation method desired which is detected as supported without being too strict (even when this alternative emulation method could be not really supported and even when native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} support could be supported). * @param {boolean} [addOtherMethods=true] - If set to true, it will add other alternative methods (if any is missing) at the end of the desired alternative emulation methods so they will also be checked and used if the previous ones are not finally used. The order they will be added will be the one used in the {@link CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS} constant. * @param {boolean} [allowFlashCanvasLocally={@link CB_Configuration.CrossBase.FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT}] - If set to true, it will allow to use [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} emulation (if needed) even when it is running locally. Uses the {@link CB_Client.isRunningLocally} function internally. * @returns {'NONE'|'FLASH'|'SILVERLIGHT'|'VML'|'DHTML'} Returns &quot;NONE&quot; if no canvas emulation is needed/supported (and no emulation method is forced). Otherwise, it returns the best emulation method calculated (&quot;FLASH&quot;, &quot;SILVERLIGHT&quot;, &quot;VML&quot; or &quot;DHTML&quot;). */ CB_Canvas.bestEmulation = function(preferredOrder, forceFirstEmulationMethod, addOtherMethods, allowFlashCanvasLocally) { //If not given, sets the default parameters: if (typeof(addOtherMethods) === &quot;undefined&quot; || addOtherMethods === null) { addOtherMethods = true; } if (typeof(allowFlashCanvasLocally) === &quot;undefined&quot; || allowFlashCanvasLocally === null) { allowFlashCanvasLocally = CB_Configuration[CB_BASE_NAME].FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT; } //If we don't want to force emulation and we don't need any emulation, exits: if (!forceFirstEmulationMethod &amp;&amp; !CB_Canvas.needsEmulation()) { return &quot;NONE&quot;; } //Defines all allowed canvas emulation methods and the default order or preference (to use in case it was not provided): var allEmulationMethods = CB_Configuration[CB_BASE_NAME].CB_Canvas_PREFERRED_EMULATION_METHODS; //If not given, uses the default order of preference: if (typeof(preferredOrder) === &quot;undefined&quot; || preferredOrder === null) { //If we want to force the first emulation method, we exit returning the first one: //if (forceFirstEmulationMethod) { return allEmulationMethods[0]; } //We can be sure it is a valid one. preferredOrder = allEmulationMethods; //Uses the default order with all methods. addOtherMethods = false; //There is no need to add other methods since it contains all. } //...if the preferred order is not an array, we force it to be one: else if (!CB_isArray(preferredOrder)) { preferredOrder = [(preferredOrder+&quot;&quot;).toUpperCase()]; } //Parses it as a string and to upper case. //If the user doesn't want any emulation method, we exit: if (preferredOrder[0] === &quot;NO&quot; || preferredOrder[0] === &quot;NONE&quot;) { return &quot;NONE&quot;; } //If not all emulation methods has been given in the preferred order, adds them (at the end) if we wanted: if (addOtherMethods &amp;&amp; preferredOrder !== allEmulationMethods || preferredOrder[0] === &quot;AUTO&quot;) //We don't need to add them if already has all methods. { var allEmulationMethodsLength = allEmulationMethods.length; for (var x = 0; x &lt; allEmulationMethodsLength; x++) { //If the current emulation method of this loop is not in the given preferred order, we add it at the end of the array: if (CB_indexOf(preferredOrder, allEmulationMethods[x]) === -1) { preferredOrder[preferredOrder.length] = allEmulationMethods[x]; } } } //Check the emulation methods availability according to the preferred order given: var preferredOrderLength = preferredOrder.length; var chosenEmulationMethod = &quot;NONE&quot;; var currentEmulationMethod; for (x = 0; x &lt; preferredOrderLength; x++) { currentEmulationMethod = CB_trim(preferredOrder[x]).toUpperCase(); //If we want to force the first emulation method and it is available (not being strict): if (forceFirstEmulationMethod &amp;&amp; CB_Canvas.supportsEmulationMethod(currentEmulationMethod, false)) { chosenEmulationMethod = currentEmulationMethod; break; } //...otherwise, if the method is available (being strict): else if (CB_Canvas.supportsEmulationMethod(currentEmulationMethod, true)) { chosenEmulationMethod = currentEmulationMethod; break; } } //Returns the chosen emulation method (if any): return chosenEmulationMethod; } /** * Tells whether the current client is compatible with a given canvas emulation method or not. * @function * @param {string} emulationMethod - Emulation method we want to check. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. * @param {boolean} [strictMode=true] - If set to true, the compatibility will be checked more carefully. If set to false (not recommended), the method could return true even when sometimes the canvas emulation method is not totally supported by the current client. * @returns {boolean} Returns whether the current client is compatible with the given canvas emulation method or not. */ CB_Canvas.supportsEmulationMethod = function(emulationMethod, strictMode) { //If not given, uses the default parameters: if (typeof(strictMode) === &quot;undefined&quot; || strictMode === null) { strictMode = true; } emulationMethod = CB_trim(emulationMethod).toUpperCase(); var isAvailable = false; //If we want to try Flash (FlashCanvas): if (emulationMethod === &quot;FLASH&quot;) { //If FlashCanvas is present: var FlashCanvas = window.FlashCanvas || undefined; if (typeof(FlashCanvas) !== &quot;undefined&quot;) { //If we don't want to be strict, the method is supported: if (!strictMode) { isAvailable = true; } //...otherwise, if Flash is installed and version is 9 or newer: else if (CB_Client.supportsFlash() &amp;&amp; CB_Client.getFlashVersion()[0] &gt;= 9) { //If the script is not running locally or it is running but we allow running FlashCanvas anyway: if (!CB_Client.isRunningLocally() || CB_Client.isRunningLocally() &amp;&amp; allowFlashCanvasLocally) { isAvailable = true; } } } } //...otherwise, if we want to try SILVERLIGHT (SLCanvas): else if (emulationMethod === &quot;SILVERLIGHT&quot;) { //If SLCanvas is present: var slcanvas = window.slcanvas || undefined; if (typeof(slcanvas) !== &quot;undefined&quot;) { //If we don't want to be strict, the method is supported: if (!strictMode) { isAvailable = true; } //...otherwise, if Silverlight is installed: if (CB_Client.supportsSilverlight()) { isAvailable = true; } } } //...otherwise, if we want to try VML (ExplorerCanvas): else if (emulationMethod === &quot;VML&quot;) { //If ExplorerCanvas is present: var G_vmlCanvasManager = window.G_vmlCanvasManager || undefined; if (typeof(G_vmlCanvasManager) !== &quot;undefined&quot; &amp;&amp; G_vmlCanvasManager.initElement.toString().indexOf(&quot;macromedia&quot;) === -1) //We make sure that the object has not been created by FlashCanvas. { //If we don't want to be strict, the method is supported: if (!strictMode) { isAvailable = true; } //...otherwise, if we are not using Internet Explorer 5 (ExplorerCanvas doesn't work with IE5/IE5.5): if (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1) { isAvailable = true; } } } //...otherwise, if we want to try DHTML (Canbox): else if (emulationMethod === &quot;DHTML&quot;) { //If Canbox is present: var _CanboxManager = window._CanboxManager || undefined; if (typeof(_CanboxManager) !== &quot;undefined&quot;) { //If we don't want to be strict, the method is supported: if (!strictMode) { isAvailable = true; } //...otherwise, if we are not using Internet Explorer 5 (Canbox doesn't work with IE5/IE5.5): else if (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) === -1) { isAvailable = true; } } } return isAvailable; } /** * Sets the desired identifier (ID) of the canvas element. Since this method is called by the constructor already, it is not needed to be called unless the canvas element wants to be defined again through the {@link CB_Canvas#set} method. Note that changing the ID after the canvas has been set could lead to some problems when using certain emulation methods so it is not recommended. * @function * @param {string} canvasId - Identifier (ID) for the canvas element. */ CB_Canvas.prototype.setId = function(canvasId) { this._id = CB_trim(canvasId); if (typeof(this.canvas) !== &quot;undefined&quot; &amp;&amp; this.canvas !== null &amp;&amp; typeof(this.canvas.setAttribute) === &quot;function&quot;) { this.canvas.setAttribute(&quot;id&quot;, canvasId); } } /** * Returns the identifier (ID) of the canvas element. * @function * @returns {string} Returns the identifier (ID) of the canvas element. */ CB_Canvas.prototype.getId = function() { return this._id; } /** * Defines the canvas element. Since this method is called by the constructor already, it is not needed to be called unless the canvas element wants to be defined again. * @function * @param {string} canvasId - The desired ID for the canvas. * @param {integer} [canvasWidth={@link CB_Canvas.WIDTH_DEFAULT}] - The desired width (horizontal size) in pixels for the canvas. * @param {integer} [canvasHeight={@link CB_Canvas.HEIGHT_DEFAULT}] - The desired height (vertical size) in pixels for the canvas. * @param {function} [onLoad] - Callback function that will be called when the canvas is finally loaded. It will not receive parameters, being &quot;this&quot; the {@link CB_Canvas} object itself. * @param {function} [onError] - Callback function that will be called when there is an error creating or loading the canvas. Being &quot;this&quot; the {@link CB_Canvas} object itself, the unique parameter received will be a string describing the error (if it could be determined). * @param {string} [alternativeCanvasEmulation={@link CB_Canvas.bestEmulation}()] - Emulation method we want to use in the case that the native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} is not supported or if the &quot;forceEmulation&quot; parameter is set to true. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. * @param {boolean} [forceEmulation=false] - If set to true, it will force to use the emulation method defined in the &quot;alternativeCanvasEmulation&quot; parameter (even when this alternative emulation method could be not supported and even when native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} support could be supported). */ CB_Canvas.prototype.set = function(canvasId, canvasWidth, canvasHeight, onLoad, onError, alternativeCanvasEmulation, forceEmulation) { //If not given, sets the default parameters: if (typeof(canvasWidth) === &quot;undefined&quot; || canvasWidth === null || isNaN(canvasWidth)) { canvasWidth = CB_Canvas.WIDTH_DEFAULT; } if (typeof(canvasHeight) === &quot;undefined&quot; || canvasHeight === null || isNaN(canvasHeight)) { canvasHeight = CB_Canvas.HEIGHT_DEFAULT; } if (typeof(alternativeCanvasEmulation) === &quot;undefined&quot; || alternativeCanvasEmulation === null || CB_trim(alternativeCanvasEmulation).toUpperCase() === &quot;AUTO&quot;) { alternativeCanvasEmulation = CB_Canvas.bestEmulation(); } alternativeCanvasEmulation = CB_trim(alternativeCanvasEmulation).toUpperCase(); //Just in case there was a previous onload (action) listener before (used in SLCanvas), we kill it: if (typeof(this.canvas) !== &quot;undefined&quot; &amp;&amp; typeof(this.canvas.action) === &quot;function&quot;) { this.canvas.action = function() {}; } //The canvas is still not ready and it is loading: this._ready = false; this._loading = true; //If the element with the ID given exists, just takes it: this.canvas = CB_Elements.id(canvasId); //this._mode = &quot;unknown&quot;; //Mode is still unknown (unless we create the element later). this._mode = &quot;NORMAL&quot;; var needsEmulation = CB_Canvas.needsEmulation(); //If we are going to use DHTML emulation (forced or needed): if ((needsEmulation || forceEmulation) &amp;&amp; alternativeCanvasEmulation === &quot;DHTML&quot;) { //Canbox doesn't work with an existing &quot;canvas&quot; TAG, so we have to destroy it and create a DIV with that id: //CB_Elements.idRemove(canvasId); //Destroys the existing element. if (this.canvas !== null) { //this.canvas.outerHTML = this.canvas.outerHTML.replace(/canvas/g, &quot;div&quot;); CB_Elements.idRemove(canvasId); this.canvas = null; } //this.canvas = null; //We force to create a new element. } //If the element already exists, in determines the emulation mode (if any): if (typeof(this.canvas) !== &quot;undefined&quot; &amp;&amp; this.canvas !== null) { //this._mode = &quot;NORMAL&quot;; //If the element is using FlashCanvas (Flash) emulation: //var G_vmlCanvasManager = window.G_vmlCanvasManager || undefined; //if (this.canvas.innerHTML.indexOf(&quot;flashcanvas&quot;) !== -1) { this._mode = &quot;FLASH&quot;; } //...otherwise, if ExplorerCanvas (VML) is available, the element must be using it: //else if (typeof(G_vmlCanvasManager) !== &quot;undefined&quot;) { this._mode = &quot;VML&quot;; } } //...otherwise, it will try to create the element with the ID given: else { //Creates the canvas: var tagName = &quot;canvas&quot;; //By default, the tag name is &quot;canvas&quot;. if ((needsEmulation || forceEmulation) &amp;&amp; alternativeCanvasEmulation === &quot;DHTML&quot;) { tagName = &quot;div&quot;; } //If we are using DHTML emulation, it is better if the tag name is &quot;div&quot; (to make it work in web clients with canvas support). this.canvas = document.createElement(tagName); this.canvas.setAttribute(&quot;id&quot;, canvasId); this.canvas.innerHTML = &quot;CrossBrowdy canvas not supported! (no emulation)&quot;; this._parent.appendChild(this.canvas); this.canvas = CB_Elements.id(canvasId); } //If we need emulation: if (needsEmulation || forceEmulation) { //If the emulation method is available (it will be only if we need it), we apply it: if (CB_Canvas.supportsEmulationMethod(alternativeCanvasEmulation, false)) //Not being strict. { this._mode = alternativeCanvasEmulation; try { this.canvas.innerHTML = &quot;&quot;; } catch(E) {} //If we want to use Flash (FlashCanvas), inits the canvas properly: if (alternativeCanvasEmulation === &quot;FLASH&quot;) { this.canvas = FlashCanvas.initElement(this.get()); //Provides the canvas context with some methods (in case it needs it): this.prepareContext(); } //...otherwise, if we want to use Silverlight (SLCanvas), inits the canvas properly: else if (alternativeCanvasEmulation === &quot;SILVERLIGHT&quot;) { var that = this; var functionOnLoad = function(sender) { if (that.isSupported()) { that._mode = &quot;SILVERLIGHT&quot;; //Provides the canvas context with some methods (in case it needs it): that.prepareContext(); //The canvas is ready for use: that._ready = true; that._loading = false; //Calls the onLoad function (if any): if (typeof(onLoad) === &quot;function&quot;) { onLoad.call(that); } } else { //Calls the onError function (if any): //if (typeof(onError) === &quot;function&quot;) { onLoad.call(this); } if (typeof(onError) === &quot;function&quot;) { onError.call(that, &quot;'&quot; + alternativeCanvasEmulation + &quot;' canvas emulation failed.&quot;); } } }; var SLCanvasDiv = slcanvas.createCanvasDiv(canvasWidth, canvasHeight, functionOnLoad); CB_Elements.idRemove(canvasId); SLCanvasDiv.setAttribute(&quot;id&quot;, canvasId); //IE5/5+, IE6, IE7 and IE8 (I still have to check other newer IE versions) doesn't send keyboard events to the web client when a Silverlight object is clicked. So we have to put a transparent div over it that prevents to click it in order to not focus the Silverlight object: if (CB_Client.supportsSilverlight() &amp;&amp; navigator.userAgent.indexOf('MSIE') !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 7&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 8&quot;) !== -1)) { var SLCanvasDivForeground = document.createElement(&quot;div&quot;); SLCanvasDivForeground.style.position = &quot;absolute&quot;; SLCanvasDivForeground.style.padding = &quot;0px&quot;; SLCanvasDivForeground.style.filter = 'alpha(opacity=0)'; SLCanvasDivForeground.style.backgroundColor = &quot;#ffffff&quot;; SLCanvasDivForeground.style.border = &quot;0px&quot;; SLCanvasDivForeground.innerHTML = &quot;&quot;; //It will always check if the canvas is moved, in order to be always placed above it: setInterval( function() { if (SLCanvasDivForeground !== null &amp;&amp; SLCanvasDiv !== null) { SLCanvasDivForeground.style.top = CB_Elements.getTop(SLCanvasDiv) + &quot;px&quot;; SLCanvasDivForeground.style.left = CB_Elements.getLeft(SLCanvasDiv) + &quot;px&quot;; SLCanvasDivForeground.style.width = CB_Elements.getWidth(SLCanvasDiv) + &quot;px&quot;; SLCanvasDivForeground.style.height = CB_Elements.getHeight(SLCanvasDiv) + &quot;px&quot;; var zIndex = SLCanvasDiv.currentStyle.zIndex; if (typeof(zIndex) !== &quot;undefined&quot; &amp;&amp; zIndex !== null &amp;&amp; !isNaN(zIndex)) { zIndex++; } SLCanvasDivForeground.style.zIndex = zIndex; } }, 100); document.body.appendChild(SLCanvasDivForeground); } //Sets the new canvas: this.canvas = SLCanvasDiv; this._parent.appendChild(this.canvas); } //...otherwise, if we want to use VML (ExplorerCanvas), inits the canvas properly: else if (alternativeCanvasEmulation === &quot;VML&quot;) { this.canvas = G_vmlCanvasManager.initElement(this.get()); //Provides the canvas context with some methods (in case it needs it): this.prepareContext(); } //...otherwise, if we want to use DHTML (Canbox), inits the canvas properly: else if (alternativeCanvasEmulation === &quot;DHTML&quot;) { //try //{ this.canvas = _CanboxManager.initElement(this.get()); //} catch(E) {} //Provides the canvas context with some methods (in case it needs it): this.prepareContext(); } else { this.canvas.innerHTML = &quot;CrossBrowdy canvas not supported! (with &quot; + alternativeCanvasEmulation + &quot; emulation)&quot;; } } else { try { this.canvas.innerHTML = &quot;CrossBrowdy canvas not supported! (without emulation)&quot;; } catch(E) {} if (alternativeCanvasEmulation !== &quot;NONE&quot;) { this.canvas.innerHTML += &quot; - tried &quot; + alternativeCanvasEmulation + &quot; but failed&quot;; } } } //Defines canvas width and height: this.setWidth(canvasWidth); this.setHeight(canvasHeight); //If the canvas is supported (it worked) and we are not using SLCanvas (because it needs time to be ready): if (this.isSupported()) { //The canvas is ready and not loading anymore: this._ready = true; this._loading = false; //Calls the onLoad function (if any): if (typeof(onLoad) === &quot;function&quot;) { onLoad.call(this); } } //...otherwise, if we didn't used the Silverlight emulation method (SLCanvas): else if (alternativeCanvasEmulation !== &quot;SILVERLIGHT&quot;) { //If we are here it means that canvas is not supported and it is not loading anymore: this._loading = false; //Calls the onError function (if any): //if (typeof(onError) === &quot;function&quot;) { onLoad.call(this); } if (typeof(onError) === &quot;function&quot;) { onError.call(this, &quot;'&quot; + alternativeCanvasEmulation + &quot;' canvas emulation failed!&quot;); } } } /** * Alias for {@link CB_Canvas#prepareContext}. * @function CB_Canvas.prototype.normalizeContext * @see {@link CB_Canvas#prepareContext} */ /** * Provides the canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} with some methods and properties, in case it needs it (as some canvas emulation methods lack of some methods and properties). Since this method is called by the {@link CB_Canvas#set} method already (and this one is called by the constructor automatically), it is not needed to be called again normally. * @function * @param {RenderingContext|Object} [context={@link CB_Canvas#getContext}()] - The [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} object that we want to prepare (different type if a canvas emulation method is being used). If not defined, calls the {@link CB_Canvas#getContext} method internally. * @returns {RenderingContext|Object} Returns the canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} (different type if a canvas emulation method is being used). * @todo Add more methods and properties needed by some emulation methods. */ CB_Canvas.prototype.prepareContext = CB_Canvas.prototype.normalizeContext = function(context) { //Gets the context: if (typeof(context) === &quot;undefined&quot; || context === null) { context = this.getContext(); } //If the context is not defined or null, exits the function: if (typeof(context) === &quot;undefined&quot; || context === null) { return; } //Canbox doesn't support setTransform, so we create a fake function in order not to crash: try { if (typeof(context.setTransform) === &quot;undefined&quot;) { context.setTransform = function() {} } } catch(E) { CB_console(&quot;The 'setTransform' method could not be added to the given canvas context.&quot;); } try { //SLCanvas doesn't support font, so we create a fake function in order not to crash: if (typeof(context.font) === &quot;undefined&quot;) { context.font = &quot;10px sans-serif&quot;; } } catch(E) { CB_console(&quot;The 'font' property could not be added to the given canvas context.&quot;); } try { //SLCanvas doesn't support fillText, so we create a fake function in order not to crash: if (typeof(context.fillText) === &quot;undefined&quot;) { context.fillText = function() {} } } catch(E) { CB_console(&quot;The 'fillText' method could not be added to the given canvas context.&quot;); } try { //Internet Explorer 11 (and lower) does not support &quot;ellipse&quot; method, so we try to simulate it: if (typeof(context.drawEllipse) === &quot;undefined&quot;) { context.drawEllipse = this._context_drawEllipse; } } catch(E) { CB_console(&quot;The 'ellipse' method could not be added to the given canvas context.&quot;); } return context; } /** * Returns the canvas element (if any). * @function * @returns {Element|null} Returns the canvas element (if any). If not found, null will be returned. */ CB_Canvas.prototype.get = function() { return this.canvas || null; } /** * Defines and returns the canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext}. It could call the {@link CB_Canvas#prepareContext} method internally. * @function * @param {('2d'|'webgl'|'experimental-webgl'|'webgl2'|'experimental-webgl2'|'bitmaprenderer')} [contextType=CB_Canvas#._contextType|'2d'] - The [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} type desired. More information: [HTMLCanvasElement.getContext]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext}. Note that most emulation methods will only support &quot;2d&quot;. * @returns {RenderingContext|Object} Returns the canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} (different type if a canvas emulation method is being used). */ CB_Canvas.prototype.getContext = function(contextType) { //Defines 2D if any other context type has defined: if (typeof(contextType) === &quot;undefined&quot; || contextType === null) { contextType = this._contextType; if (typeof(contextType) === &quot;undefined&quot; || contextType === null) { contextType = &quot;2d&quot;; } } contextType = CB_trim(contextType).toLowerCase(); //If the context type inserted is not allowed, uses the &quot;2d&quot; type by default: //if (contextType === &quot;&quot; || contextType !== &quot;webgl&quot; &amp;&amp; contextType !== &quot;2d&quot;) if (CB_indexOf(CB_Canvas.prototype._allowedContextTypes, contextType) === -1) { contextType = &quot;2d&quot;; } if (typeof(this.get().getContext) === &quot;function&quot;) { try //Uses try-catch to avoid some problems with some web clients (as BeZilla / Bon Echo 2.0.0.22Pre on Haiku OS): { return this.context = this.prepareContext(this.get().getContext(contextType)); //////////////return this.context = this.get().getContext(contextType); } catch(E) { return this.context = null; } } else { return this.context = null; } } /** * Defines the desired canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} type. Internally, it only defines the {@link CB_Canvas#._contextType} property. * @function * @param {('2d'|'webgl'|'experimental-webgl'|'webgl2'|'experimental-webgl2'|'bitmaprenderer')} [contextType='2d'] - The [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} type desired. More information: [HTMLCanvasElement.getContext]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext}. Note that most emulation methods will only support &quot;2d&quot;. * @returns {string} Returns the context type just applied. */ CB_Canvas.prototype.setContextType = function(contextType) { contextType = CB_trim(contextType).toLowerCase(); //If the context type inserted is not allowed, uses the &quot;2d&quot; type by default: if (CB_indexOf(CB_Canvas.prototype._allowedContextTypes, contextType) === -1) { contextType = &quot;2d&quot;; } this._contextType = contextType; return this._contextType; } /** * Tells the current canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} type used. Internally, it returns the value of the {@link CB_Canvas#._contextType} property. * @function * @returns {string} Tells the current canvas [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} type used. More information: [HTMLCanvasElement.getContext]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext}. */ CB_Canvas.prototype.getContextType = function() { return this._contextType; } /** * Tells whether the canvas works or not. The internal test used could be not totally reliable. * @function * @returns {boolean} Returns whether the canvas works or not. The internal test used could be not totally reliable. */ CB_Canvas.prototype.isSupported = function() { //this._supported = (this.canvas &amp;&amp; this.canvas.getContext) ? true : false; //return this._supported; if (this.canvas &amp;&amp; this.canvas.getContext) { try //Uses try-catch to avoid some problems with some web clients (as BeZilla / Bon Echo 2.0.0.22Pre on Haiku OS): { this._supported = (typeof(this.canvas.getContext(&quot;2d&quot;)) !== &quot;undefined&quot; &amp;&amp; this.canvas.getContext(&quot;2d&quot;) !== null); } catch(E) { this._supported = false; } } return this._supported || false; } /** * Defines the desired canvas width. * @function * @param {integer} [canvasWidth={@link CB_Canvas.WIDTH_DEFAULT}] - The desired width (horizontal size) in pixels for the canvas. * @returns {number} Returns the canvas width (horizontal size) being used in pixels. It could return zero (0) if cannot be calculated. */ CB_Canvas.prototype.setWidth = function(canvasWidth) { //Is not defined or it is wrong, uses default size: if (typeof(canvasWidth) === &quot;undefined&quot; || canvasWidth === null || isNaN(canvasWidth)) { canvasWidth = CB_Canvas.WIDTH_DEFAULT; } //Detects if a percentage has been received: /* canvasWidth = canvasWidth.toString(); var isPercentage = false; if (canvasWidth.indexOf(&quot;%&quot;) !== -1) { isPercentage = true; } canvasWidth = canvasWidth.replace(&quot;%&quot;, &quot;&quot;); canvasWidth = canvasWidth.replace(&quot;px&quot;, &quot;&quot;); */ //Applies changes to the canvas: var canvas = this.get(); if (typeof(canvas) !== &quot;undefined&quot; &amp;&amp; canvas !== null) { //this._width = canvasWidth + (isPercentage ? &quot;%&quot; : &quot;&quot;); this._width = canvasWidth; //this.get().style.width = this._width + (isPercentage ? &quot;%&quot; : &quot;px&quot;); canvas.style.width = canvasWidth + &quot;px&quot;; canvas.setAttribute('width', canvasWidth); //this.get().setAttribute('width', canvasWidth); } return this.getWidth(); } /** * Tells the canvas width (horizontal size) being used in pixels. * @function * @returns {number} Returns the canvas width (horizontal size) being used in pixels. It could return zero (0) if cannot be calculated. */ CB_Canvas.prototype.getWidth = function() { return this._width || 0; } /** * Defines the desired canvas height. * @function * @param {integer} [canvasHeight={@link CB_Canvas.HEIGHT_DEFAULT}] - The desired height (vertical size) in pixels for the canvas. * @returns {number} Returns the canvas height (vertical size) being used in pixels. It could return zero (0) if cannot be calculated. */ CB_Canvas.prototype.setHeight = function(canvasHeight) { //Is not defined or it is wrong, uses default size: if (typeof(canvasHeight) === &quot;undefined&quot; || canvasHeight === null || isNaN(canvasHeight)) { canvasHeight = CB_Canvas.HEIGHT_DEFAULT; } //Detects if a percentage has been received: /* canvasHeight = canvasHeight.toString(); var isPercentage = false; if (canvasHeight.indexOf(&quot;%&quot;) !== -1) { isPercentage = true; } canvasHeight = canvasHeight.replace(&quot;%&quot;, &quot;&quot;); canvasHeight = canvasHeight.replace(&quot;px&quot;, &quot;&quot;); */ //Applies changes to the canvas: var canvas = this.get(); if (typeof(canvas) !== &quot;undefined&quot; &amp;&amp; canvas !== null) { //this._height = canvasHeight.toString() + (isPercentage ? &quot;%&quot; : &quot;&quot;); this._height = canvasHeight; //this.get().style.height = this._height + (isPercentage ? &quot;%&quot; : &quot;px&quot;); canvas.style.height = canvasHeight + &quot;px&quot;; canvas.setAttribute('height', canvasHeight); //this.get().setAttribute('height', this._height); } return this.getHeight(); } /** * Tells the canvas height (vertical size) being used in pixels. * @function * @returns {number} Returns the canvas height (vertical size) being used in pixels. It could return zero (0) if cannot be calculated. */ CB_Canvas.prototype.getHeight = function() { return this._height || 0; } /** * Tells the mode used to create the canvas. * @function * @returns {'NONE'|'NORMAL'|'FLASH'|'SILVERLIGHT'|'VML'|'DHTML'} Returns the mode used to create the canvas. Returns &quot;NONE&quot; if no method is used yet (possible when no method is supported at all or when it is still loading). Returns &quot;NORMAL&quot; if native [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} is used (no canvas emulation method). */ CB_Canvas.prototype.getMode = function() { return this._mode || &quot;NONE&quot;; } /** * Tells whether the canvas is ready to be used or not. Some canvas emulation methods can take some time until they are ready to be used. * @function * @returns {boolean} Returns whether the canvas is ready to be used or not. */ CB_Canvas.prototype.isReady = function() { return this._ready; } /** * Tells whether the canvas is loading or not. Some canvas emulation methods can take some time until they finish loading. * @function * @returns {boolean} Returns whether the canvas is loading or not. */ CB_Canvas.prototype.isLoading = function() { return this._loading; } /** * Alias for {@link CB_Canvas#clear}. * @function CB_Canvas.prototype.clearCanvas * @see {@link CB_Canvas#clear} */ /** * Clear the canvas entirely. * @function * @param {boolean} [keepTransform=false] - If set to true, it will [save]{@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save} and [restore]{@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore} the current transformation. * @param {string} [backgroundFillStyle] - The style used (color, gradient, pattern...) to fill the canvas background. If defined, it will be used as the value for the [fillStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle} property of the [context]{@link https://developer.mozilla.org/en-US/docs/Web/API/RenderingContext} object, internally. * @returns {boolean} Returns true if the action could be performed or false otherwise. */ CB_Canvas.prototype.clear = CB_Canvas.prototype.clearCanvas = function(keepTransform, backgroundFillStyle) { //Gets the context: var context = this.getContext(); //If the context is not defined or null, exits the function: if (typeof(context) === &quot;undefined&quot; || context === null) { return false; } //If defined, saves the current transform: if (keepTransform) { context.save(); context.setTransform(1, 0, 0, 1, 0, 0); } //this.get().width = this.get().width + 1; //+1 for WebKit compatibility. //this.get().width = this.get().width; context.clearRect(0, 0, this.getWidth(), this.getHeight()); if (typeof(backgroundFillStyle) !== &quot;undefined&quot; &amp;&amp; backgroundFillStyle !== null) { context.globalAlpha = 1; context.fillStyle = backgroundFillStyle; context.fillRect(0, 0, this.getWidth(), this.getHeight()); } /* else { context.clearRect(0, 0, this.getWidth(), this.getHeight()); } */ //If defined, restores the transform: if (keepTransform) { context.restore(); } return true; } /** * Disables anti-aliasing. Useful to work with image sprites (to avoid problems showing adjacent ones), for example. * @function * @param {boolean} [performTranslate=false] - If set to true, it will also call the [transform]{@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform} method. * @returns {boolean} Returns true if the action could be performed or false otherwise. */ CB_Canvas.prototype.disableAntiAliasing = function(performTranslate) { //Gets the context: var context = this.getContext(); //If the context is not defined or null, exits the function: if (typeof(context) === &quot;undefined&quot; || context === null) { return false; } if (performTranslate) { context.translate(0.5, 0.5); /*context.lineWidth = 0.5;*/ } context.khtmlImageSmoothingEnabled = false; context.oImageSmoothingEnabled = false; context.msImageSmoothingEnabled = false; context.webkitImageSmoothingEnabled = false; context.mozImageSmoothingEnabled = false; context.imageSmoothingEnabled = false; return true; } //Internet Explorer 11 (and lower) does not support &quot;ellipse&quot; method, so we try to simulate it: //* Solution by Steve Tranby. Source: https://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084 //TODO: Add parameters and modify their order to mimic (polyfill) the native ellipse function (https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse). CB_Canvas.prototype._context_drawEllipse = function drawEllipse(x, y, w, h) //NOTE: must be called being &quot;this&quot; the canvas context desired. { var kappa = .5522848; var ox = (w / 2) * kappa; //Control point offset horizontal. var oy = (h / 2) * kappa; //Control point offset vertical. var xe = x + w; //x-end. var ye = y + h; //y-end. var xm = x + w / 2; //x-middle. var ym = y + h / 2; //y-middle. this.beginPath(); this.moveTo(x, ym); this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y); this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym); this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye); this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym); //this.closePath(); // not used correctly, see comments (use to close off open path) //this.stroke(); }; //CB_CanvasFileLoaded = true; //This file has been loaded. //CB_filesNeeded[&quot;screen/canvas/CB_Canvas.js&quot;] = true; //This file has been loaded. × Search results Close "},"CrossBase_general_CB_Client.js.html":{"id":"CrossBase_general_CB_Client.js.html","title":"Source: CrossBase/general/CB_Client.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_Client.js /** * @file Web client (browser or engine) management. Contains the {@link CB_Client} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the current client. It will return itself if it is tried to be instantiated. It can use [BrowserDetect]{@link https://quirksmode.org/js/detect.html} ([source code rescued]{@link https://gist.github.com/mitchellhislop/2018348}). * @namespace * @todo Think about implementing a getDocumentParents function (similar to {@link CB_Client.getWindowParents}). * @todo Think about implementing &quot;onClose&quot; event (to fire when app/web is going to be closed). */ var CB_Client = function() { return CB_Client; }; { CB_Client.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Client.init = function() { //If this is the fist time: if (CB_Client.initialized) { return CB_Client; } //The object has been initialized: CB_Client.initialized = true; return CB_Client; } //Returns the most preferred language: CB_Client._getLanguagePreferred = function(allowNavigatorLanguages, PHPAcceptedLanguagesFirst) { return CB_Client._getLanguagesPreferred(allowNavigatorLanguages, PHPAcceptedLanguagesFirst)[0]; }; /** * Returns the most preferred language as a string. * @function * @param {boolean} [allowNavigatorLanguages={@link CB_Configuration.CrossBase.CB_Client_allowNavigatorLanguages_DEFAULT}] - Defines whether to allow using the [window.navigator.languages]{@link https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/languages} property (if not available, it will proceed normally). * @param {boolean} [PHPAcceptedLanguagesFirst={@link CB_Configuration.CrossBase.CB_Client_PHPAcceptedLanguagesFirst_DEFAULT}] - If it is set to true, it will try to return the accepted languages found out by [PHP]{@link https://en.wikipedia.org/wiki/PHP} (if [PHP]{@link https://en.wikipedia.org/wiki/PHP} is available) in [$_SERVER]{@link http://php.net/manual/en/reserved.variables.server.php}['HTTP_ACCEPT_LANGUAGE'] or it will proceed normally otherwise. * @returns {string} * @todo Use other back-end ways to calculate the language (using Node.js, for example). */ CB_Client.getLanguage = function(allowNavigatorLanguages, PHPAcceptedLanguagesFirst) { return CB_Client._getLanguagePreferred(allowNavigatorLanguages, PHPAcceptedLanguagesFirst); } //Returns the most preferred languages (an array): CB_Client._getLanguagesPreferred = function(allowNavigatorLanguages, PHPAcceptedLanguagesFirst) { if (typeof(PHPAcceptedLanguagesFirst) !== true &amp;&amp; PHPAcceptedLanguagesFirst !== false) { PHPAcceptedLanguagesFirst = CB_Configuration[CB_BASE_NAME].CB_Client_PHPAcceptedLanguagesFirst_DEFAULT; } if (PHPAcceptedLanguagesFirst &amp;&amp; typeof(CB_PHPAcceptedLanguages) !== &quot;undefined&quot; &amp;&amp; CB_isArray(CB_PHPAcceptedLanguages) &amp;&amp; CB_PHPAcceptedLanguages.length &gt; 0) { return CB_PHPAcceptedLanguages; } if (allowNavigatorLanguages !== true &amp;&amp; allowNavigatorLanguages !== false) { allowNavigatorLanguages = CB_Configuration[CB_BASE_NAME].CB_Client_allowNavigatorLanguages_DEFAULT; } if (allowNavigatorLanguages &amp;&amp; window.navigator.languages) { return window.navigator.languages; } var languages = []; if (window.navigator.language &amp;&amp; CB_indexOf(languages, window.navigator.language) === -1) { languages[languages.length] = window.navigator.language; } if (window.navigator.userLanguage &amp;&amp; CB_indexOf(languages, window.navigator.userLanguage) === -1) { languages[languages.length] = window.navigator.userLanguage; } if (window.navigator.browserLanguage &amp;&amp; CB_indexOf(languages, window.navigator.browserLanguage) === -1) { languages[languages.length] = window.navigator.browserLanguage; } if (window.navigator.systemLanguage &amp;&amp; CB_indexOf(languages, window.navigator.systemLanguage) === -1) { languages[languages.length] = window.navigator.systemLanguage; } if (languages.length &gt; 0) { return languages; } else { return [CB_Configuration[CB_BASE_NAME].CB_Client_language_DEFAULT]; } }; /** * Returns the most preferred languages as an array of strings. * @function * @param {boolean} [allowNavigatorLanguages={@link CB_Configuration.CrossBase.CB_Client_allowNavigatorLanguages_DEFAULT}] - Defines whether to allow using the [window.navigator.languages]{@link https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/languages} property (if not available, it will proceed normally). * @param {boolean} [PHPAcceptedLanguagesFirst={@link CB_Configuration.CrossBase.CB_Client_PHPAcceptedLanguagesFirst_DEFAULT}] - If it is set to true, it will try to return the accepted languages found out by [PHP]{@link https://en.wikipedia.org/wiki/PHP} (if [PHP]{@link https://en.wikipedia.org/wiki/PHP} is available) in [$_SERVER]{@link http://php.net/manual/en/reserved.variables.server.php}['HTTP_ACCEPT_LANGUAGE'] or it will proceed normally otherwise. * @returns {array} * @todo Use other back-end ways to calculate languages (using Node.js, for example). */ CB_Client.getLanguages = function(allowNavigatorLanguages, PHPAcceptedLanguagesFirst) { return CB_Client._getLanguagesPreferred(allowNavigatorLanguages, PHPAcceptedLanguagesFirst); } /** * Sets a function to execute when the [languagechange]{@link https://developer.mozilla.org/en-US/docs/Web/Events/languagechange} event is fired (only for some web clients) or removes it. * @function * @param {function|null} eventFunction - Function that represents the event listener that will be called when the event is fired. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether to also keep the previous listeners or remove them otherwise. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Client.onLanguageChanges = function(eventFunction, keepOldFunction, useCapture) { CB_Client._setEvent(&quot;languagechange&quot;, eventFunction, keepOldFunction, useCapture, window); } /** * Alias for {@link CB_Client.get}. * @function CB_Client.getBrowser * @see {@link CB_Client.get} */ /** * Returns the current web client (if possible) as a string. It uses [BrowserDetect]{@link https://quirksmode.org/js/detect.html} ([source code rescued]{@link https://gist.github.com/mitchellhislop/2018348}) internally. * @function * @returns {string} */ CB_Client.get = CB_Client.getBrowser = function() { return BrowserDetect.browser; } /** * Alias for {@link CB_Client.getVersion}. * @function CB_Client.getBrowserVersion * @see {@link CB_Client.getVersion} */ /** * Returns the current web client version (if possible) as a string. It uses [BrowserDetect]{@link https://quirksmode.org/js/detect.html} ([source code rescued]{@link https://gist.github.com/mitchellhislop/2018348}) internally. * @function * @returns {string} */ CB_Client.getVersion = CB_Client.getBrowserVersion = function() { return BrowserDetect.version + &quot;&quot;; } /** * Alias for {@link CB_Client.getVersionMain}. * @function CB_Client.getBrowserVersionMain * @see {@link CB_Client.getVersionMain} */ /** * Returns the current web client main version (first number), if possible, as an integer. It uses [BrowserDetect]{@link https://quirksmode.org/js/detect.html} ([source code rescued]{@link https://gist.github.com/mitchellhislop/2018348}) internally. * @function * @returns {integer} */ CB_Client.getVersionMain = CB_Client.getBrowserVersionMain = function() { return parseInt(CB_Client.getBrowserVersion().split(&quot;.&quot;)[0]); } CB_Client._getWindowParentsReturnCache; //Stores the return result in order to optimize the execution next times. /** * Returns all the [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} objects, parents and last son (main one) in an array (with the topmost parent in the highest index). Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @function * @returns {array} */ CB_Client.getWindowParents = function() { //If it is not the first time we execute this function, uses the cache to return always the same: if (typeof(CB_Client._getWindowParentsReturnCache) !== &quot;undefined&quot; &amp;&amp; CB_Client._getWindowParentsReturnCache !== null) { return CB_Client._getWindowParentsReturnCache; } var windowParents = [ window.self ]; try { if (typeof(window.parent) !== &quot;undefined&quot; &amp;&amp; window.parent !== null) { var currentParent = windowParents[0];//windowParents[windowParents.length - 1]; while (typeof(currentParent.parent) !== &quot;undefined&quot; &amp;&amp; currentParent !== currentParent.parent) { currentParent = currentParent.parent; windowParents[windowParents.length] = currentParent; } ///////windowBase = currentParent; } } catch(E) {} CB_Client._getWindowParentsReturnCache = windowParents; return windowParents; } CB_Client._getWindowBaseReturnCache; //Stores the return result in order to optimize the execution next times. /** * Returns the [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object of the first parent (the topmost one). Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @function * @returns {Object} */ CB_Client.getWindowBase = function() { //If it is not the first time we execute this function, uses the cache to return always the same: if (typeof(CB_Client._getWindowBaseReturnCache) !== &quot;undefined&quot; &amp;&amp; CB_Client._getWindowBaseReturnCache !== null) { return CB_Client._getWindowBaseReturnCache; } //By default, uses the current window object: var windowBase = window.self; //window; //Tries to get the topmost window (it can fail if it is not in the same domain or it is running locally): try { //If defined, we use window.top to get the topmost window: if (typeof(window.top) !== &quot;undefined&quot; &amp;&amp; window.top !== null) { windowBase = window.top; } //...otherwise, we get all the parents and chose the last one (which will be the topmost): else { var windowParents = CB_Client.getWindowParents(); windowBase = windowParents[windowParents.length - 1]; } } catch(E) {} CB_Client._getWindowBaseReturnCache = windowBase; return windowBase; } CB_Client._getWindowReturnCache; //Stores the return result in order to optimize the execution next times. /** * Returns the [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object (having in mind whether the script is running in one [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more, if we want). * @function * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to get and return the topmost [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @returns {Object} */ CB_Client.getWindow = function(mindIframes) { if (typeof(mindIframes) === &quot;undefined&quot; || mindIframes === null) { mindIframes = CB_Configuration[CB_BASE_NAME].MIND_IFRAMES; } //If it is not the first time we execute this function, uses the cache to return always the same: if (!mindIframes) { return window.self; } else if (typeof(CB_Client._getWindowReturnCache) !== &quot;undefined&quot; &amp;&amp; CB_Client._getWindowReturnCache !== null) { return CB_Client._getWindowReturnCache; } //Gets the window chosen (if we arrived here, it means we mind iframes): CB_Client._getWindowReturnCache = CB_Client.getWindowBase(); //Stores the window chosen in the cache: return CB_Client._getWindowReturnCache; } /** * Returns the [document]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/document} object of the first parent (the topmost one). Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @function * @returns {Object} */ CB_Client.getDocumentBase = function() { //By default, uses the current document object: var documentBase = document; //Tries to get the document object of the topmost window (it can fail if it is not in the same domain or it is running locally): try { documentBase = CB_Client.getWindowBase().document; } catch(E) {} return documentBase; } /** * Returns the [document]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/document} object (having in mind whether the script is running in one [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more, if we want). * @function * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to get and return the topmost [document]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/document} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @returns {Object} */ CB_Client.getDocument = function(mindIframes) { if (typeof(mindIframes) === &quot;undefined&quot; || mindIframes === null) { mindIframes = CB_Configuration[CB_BASE_NAME].MIND_IFRAMES; } var documentChosen = document; if (mindIframes) { documentChosen = CB_Client.getDocumentBase(); } return documentChosen; } /** * Tells whether the [canvas]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas} element is supported natively or not. * @function * @returns {boolean} */ CB_Client.supportsCanvas = function() { return CB_Configuration[CB_BASE_NAME]._supportsCanvas(); } CB_Client._supportsCSS3TransformReturnCache; /** * Tells whether [CSS3]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS3} [transform]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform} is supported natively or not. * @function * @returns {boolean} */ CB_Client.supportsCSS3Transform = function() { if (typeof(CB_Client._supportsCSS3TransformReturnCache) === &quot;undefined&quot; || CB_Client._supportsCSS3TransformReturnCache === null) { var documentBodyStyle = document.body.style; CB_Client._supportsCSS3TransformReturnCache = (typeof(documentBodyStyle.transform) !== &quot;undefined&quot; || typeof(documentBodyStyle.WebkitTransform) !== &quot;undefined&quot; || typeof(documentBodyStyle.MozTransform) !== &quot;undefined&quot; || typeof(documentBodyStyle.OTransform) !== &quot;undefined&quot; || typeof(documentBodyStyle.MsTransform) !== &quot;undefined&quot; || typeof(documentBodyStyle.KhtmlTransform) !== &quot;undefined&quot;); } return CB_Client._supportsCSS3TransformReturnCache; } /** * Function that tells whether [PHP]{@link https://en.wikipedia.org/wiki/PHP} is available or not. * @function * @returns {boolean} */ CB_Client.supportsPHP = function() { return (typeof(CB_supportedPHP) !== &quot;undefined&quot; &amp;&amp; CB_supportedPHP === &quot;YES&quot;); } /** * Returns the available version of [PHP]{@link https://en.wikipedia.org/wiki/PHP} (if any), as either an array of strings or as a string. * @function * @param {boolean} [asString=false] - If set to true, returns the version as a string. * @returns {array|string} */ CB_Client.getPHPVersion = function(asString) { return asString ? (CB_PHPVersion + &quot;&quot;) : (CB_PHPVersion + &quot;&quot;).split(&quot;.&quot;); } /** * Function that tells whether [Node.js]{@link https://en.wikipedia.org/wiki/Node.js} is available (checks the availability of [process.versions.node]{@link https://nodejs.org/api/process.html#process_process_versions}) or not. * @function * @returns {boolean} */ //* Source: Dan. B. @ http://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser CB_Client.supportsNodeJS = function() { return (typeof(process) === &quot;object&quot; &amp;&amp; process !== null &amp;&amp; typeof(process.versions) === &quot;object&quot; &amp;&amp; typeof(process.versions.node) !== &quot;undefined&quot;); } /** * Returns the available version of [Node.js]{@link https://en.wikipedia.org/wiki/Node.js} (if any), as either an array of strings or as a string. * @function * @param {boolean} [asString=false] - If set to true, returns the version as a string. * @returns {array|string} */ CB_Client.getNodeJSVersion = function(asString) { if (typeof(process) === &quot;object&quot; &amp;&amp; process !== null &amp;&amp; CB_isString(process.version)) { return asString ? process.version : process.version.replace(CB_regularExpressionString(&quot;-&quot;, true, true), &quot;.&quot;).split(&quot;.&quot;); } else { return asString ? &quot;0.0.0&quot; : [0, 0, 0]; } } /** * Function that tells whether [Microsoft Silverlight]{@link https://en.wikipedia.org/wiki/Microsoft_Silverlight} plugin is available or not. * @function * @returns {boolean} */ CB_Client.supportsSilverlight = function() { var isSilverlightInstalled = false; try { isSilverlightInstalled = !!(new ActiveXObject(&quot;AgControl.AgControl&quot;)); } catch(E) { if (navigator.plugins[&quot;Silverlight Plug-In&quot;]) { isSilverlightInstalled = true; } else { isSilverlightInstalled = false; } } return isSilverlightInstalled; } /** * Returns the available version of [Microsoft Silverlight]{@link https://en.wikipedia.org/wiki/Microsoft_Silverlight} plugin (if any), as either an array of strings or as a string. * @function * @param {boolean} [asString=false] - If set to true, returns the version as a string. * @returns {array|string} */ CB_Client.getSilverlightVersion = function(asString) { if (navigator.plugins[&quot;Silverlight Plug-In&quot;] &amp;&amp; navigator.plugins[&quot;Silverlight Plug-In&quot;].description &amp;&amp; CB_isString(navigator.plugins[&quot;Silverlight Plug-In&quot;].description) &amp;&amp; CB_trim(navigator.plugins[&quot;Silverlight Plug-In&quot;].description) !== &quot;&quot;) { return asString ? navigator.plugins[&quot;Silverlight Plug-In&quot;].description : navigator.plugins[&quot;Silverlight Plug-In&quot;].description.replace(CB_regularExpressionString(&quot;-&quot;, true, true), &quot;.&quot;).split(&quot;.&quot;); } else { return asString ? &quot;0.0.0&quot; : [0, 0, 0]; } } /** * Function that tells whether [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} plugin is available or not. * @function * @returns {boolean} */ CB_Client.supportsFlash = function() { var isFlashInstalled = false; if (&quot;ActiveXObject&quot; in window) { try { isFlashInstalled = !!(new ActiveXObject(&quot;ShockwaveFlash.ShockwaveFlash&quot;)); } catch(E) { isFlashInstalled = false; } } if (!isFlashInstalled &amp;&amp; typeof(navigator.mimeTypes) !== &quot;undefined&quot;) { var mime = navigator.mimeTypes['application/x-shockwave-flash'] if (typeof(mime) !== &quot;undefined&quot; &amp;&amp; mime !== null &amp;&amp; mime.enabledPlugin) { isFlashInstalled = true;//!!mime; } } if (!isFlashInstalled &amp;&amp; typeof(navigator.plugins) !== &quot;undefined&quot;) { var plugin = navigator.plugins[&quot;Shockwave Flash&quot;]; isFlashInstalled = !!plugin; } return isFlashInstalled; } /** * Returns the available version of [Adobe Flash (formerly Macromedia Flash)]{@link https://en.wikipedia.org/wiki/Adobe_Flash_Player} plugin, if any, as either an array of strings or as a string. * @function * @param {boolean} [asString=false] - If set to true, returns the version as a string. * @returns {array|string} */ CB_Client.getFlashVersion = function(asString) { var version = &quot;0.0.0&quot;; try { try { var axo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash.6'); try { axo.AllowScriptAccess = 'always'; } catch(E) { return asString ? '6.0.0' : '6.0.0'.split('.'); } } catch(E) {} version = new ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\\D+/g, ',').match(/^,?(.+),?$/)[1]; version = version.replace(CB_regularExpressionString(&quot;,&quot;, true, true), &quot;.&quot;); return asString ? version : version.split('.'); } catch(E) { try { if (navigator.mimeTypes[&quot;application/x-shockwave-flash&quot;].enabledPlugin) { version = (navigator.plugins[&quot;Shockwave Flash 2.0&quot;] || navigator.plugins[&quot;Shockwave Flash&quot;]).description.replace(/\\D+/g, &quot;,&quot;).match(/^,?(.+),?$/)[1]; version = version.replace(CB_regularExpressionString(&quot;,&quot;, true, true), &quot;.&quot;); return asString ? version : version.split('.'); } } catch(E) {} } return asString ? version : version.split('.'); } /** * Tells whether the script is running locally (using &quot;file:&quot; protocol) or not. * @function * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to check the protocol of the topmost [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @returns {boolean} */ CB_Client.isRunningLocally = function(mindIframes) { if (typeof(mindIframes) === &quot;undefined&quot; || mindIframes === null) { mindIframes = CB_Configuration[CB_BASE_NAME].MIND_IFRAMES; } var isRunningLocally = false; //We assume that the script is not running locally by default. var protocolUsed = &quot;&quot;; try { var windowObject = CB_Client.getWindow(mindIframes); if (typeof(windowObject.location) !== &quot;undefined&quot; &amp;&amp; typeof(windowObject.location.protocol) !== &quot;undefined&quot;) { protocolUsed = windowObject.location.protocol; } } catch(E) { if (typeof(window.location) !== &quot;undefined&quot; &amp;&amp; typeof(window.location.protocol) !== &quot;undefined&quot;) { protocolUsed = window.location.protocol; } } if (protocolUsed === &quot;file:&quot;) { isRunningLocally = true; } //else if (protocolUsed === &quot;http:&quot; || protocolUsed === &quot;https:&quot;) { isRunningLocally = false; } return isRunningLocally; } CB_Client._isRunningOnNWjsReturnCache = null; /** * Tells whether the script is running on [NW.js (formerly node-webkit)]{@link https://nwjs.io/} or not. * @function * @returns {boolean} */ //* Source: Kuf @ http://stackoverflow.com/questions/31968355/detect-if-web-app-is-running-in-nwjs CB_Client.isRunningOnNWjs = function() { if (typeof(CB_Client._isRunningOnNWjsReturnCache) !== &quot;undefined&quot; &amp;&amp; CB_Client._isRunningOnNWjsReturnCache !== null) { return CB_Client._isRunningOnNWjsReturnCache; } if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null) { return CB_Client._isRunningOnNWjsReturnCache = true; } try { return CB_Client._isRunningOnNWjsReturnCache = (typeof(require) === &quot;function&quot; &amp;&amp; (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.App || typeof(require(&quot;nw.gui&quot;)) !== &quot;undefined&quot;)); } catch(E) { return CB_Client._isRunningOnNWjsReturnCache = false; } } CB_Client._isRunningOnElctronReturnCache = null; /** * Tells whether the script is running on [Electron (Electron.js)]{@link https://electronjs.org/} or not. * @function * @returns {boolean} */ //* Source: cheton @ https://github.com/cheton/is-electron/blob/master/index.js CB_Client.isRunningOnElectron = function() { if (typeof(CB_Client._isRunningOnElectronReturnCache) !== &quot;undefined&quot; &amp;&amp; CB_Client._isRunningOnElectronReturnCache !== null) { return CB_Client._isRunningOnElectronReturnCache; } //if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null) { return CB_Client._isRunningOnElectronReturnCache = true; } try { return CB_Client._isRunningOnElectronReturnCache = (typeof(navigator) === &quot;object&quot; &amp;&amp; navigator !== null &amp;&amp; typeof(navigator.userAgent) === &quot;string&quot; &amp;&amp; navigator.userAgent.indexOf(&quot;Electron&quot;) !== -1); } catch(E) { return CB_Client._isRunningOnElectronReturnCache = false; } } /** * Exits and finishes the script. In a browser, it will try to close the window or at least abandon it redirecting to an empty one (or to a desired URL). In an app ([NW.js (formerly node-webkit)]{@link https://nwjs.io/}/[Electron (Electron.js)]{@link https://electronjs.org/}/[Apache Cordova]{@link https://cordova.apache.org/}/[Adobe PhoneGap]{@link https://phonegap.com/}/[Appcelerator Titanium SDK]{@link https://en.wikipedia.org/wiki/Appcelerator_Titanium}/[Appcelerator TideSDK (Titanium Desktop)]{@link https://github.com/appcelerator-archive/titanium_desktop}/[Weixin (WeChat)]{@link https://en.wikipedia.org/wiki/WeChat}/etc.), it will try to close the app. * @function * @param {boolean} [allowWindowCloseFallback=true] - Defines whether to allow using the [window.close]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/close} method as a fallback. * @param {boolean} [allowRedirectionFallback=true] - Defines whether to redirect the current client as a fallback (to the URL defined in the &quot;redirectionAddress&quot; parameter). * @param {boolean} [redirectionAddress='about:blank'] - Defines the URL where the current client will be redirected to in the case that the window cannot be closed. Only used if the &quot;allowRedirectionFallback&quot; parameter is set to true. * @todo Have in mind iframes (think about it). */ CB_Client.exit = function(allowWindowCloseFallback, allowRedirectionFallback, redirectionAddress) { if (typeof(allowRedirectionFallback) === &quot;undefined&quot; || allowRedirectionFallback === null) { allowRedirectionFallback = true; } if (typeof(allowWindowCloseFallback) === &quot;undefined&quot; || allowWindowCloseFallback === null) { allowWindowCloseFallback = true; } if (typeof(redirectionAddress) === &quot;undefined&quot; || redirectionAddress === null) { redirectionAddress = &quot;about:blank&quot;; } var useFallback = true; //Tries to use NW.js (node-webkit) if available to quit the app: if (CB_Client.isRunningOnNWjs()) { if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.App &amp;&amp; typeof(nw.App.closeAllWindows) === &quot;function&quot;) { try { nw.App.closeAllWindows(); useFallback = false; } catch(E) { useFallback = true; } } if (useFallback &amp;&amp; typeof(require) === &quot;function&quot;) { try { var gui = require(&quot;nw.gui&quot;); if (typeof(gui) !== &quot;undefined&quot; &amp;&amp; gui !== null &amp;&amp; gui.App) { if (typeof(gui.App.closeAllWindows) === &quot;function&quot;) { try { gui.App.closeAllWindows(); useFallback = false; } catch(E) { useFallback = true; } } if (useFallback &amp;&amp; typeof(gui.App.quit) === &quot;function&quot;) { try { gui.App.quit(); useFallback = false; } catch(E) { useFallback = true; } } } } catch(E) { useFallback = true; } } if (useFallback &amp;&amp; typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.App &amp;&amp; typeof(nw.App.quit) === &quot;function&quot;) { try { nw.App.quit(); useFallback = false; } catch(E) { useFallback = true; } } } //Tries to use Electron (Electron.js) if available to quit the app: if (CB_Client.isRunningOnElectron() &amp;&amp; typeof(require) === &quot;function&quot;) { try { var app = require('app'); app.on(&quot;window-all-closed&quot;, app.quit); app.quit(); useFallback = false; } catch(E) { useFallback = true; } } //If able, uses PhoneGap with navigator.app: if (typeof(navigator) !== &quot;undefined&quot; &amp;&amp; typeof(navigator.app) !== &quot;undefined&quot; &amp;&amp; typeof(navigator.app.exitApp) !== &quot;undefined&quot;) { try { navigator.app.exitApp(); useFallback = false; } catch(E) { useFallback = true; } } //If able uses PhoneGap with navigator.device: if (typeof(navigator) !== &quot;undefined&quot; &amp;&amp; typeof(navigator.device) !== &quot;undefined&quot; &amp;&amp; typeof(navigator.device.exitApp) !== &quot;undefined&quot;) { try { navigator.device.exitApp(); useFallback = false; } catch(E) { useFallback = true; } } //If able uses WeixinJSBridge (Weixin / Wechat JavaScript Bridge): if (typeof(WeixinJSBridge) !== &quot;undefined&quot; &amp;&amp; typeof(WeixinJSBridge.call) !== &quot;undefined&quot;) { //WeixinJSBridge.invoke(&quot;closeWindow&quot;, {}, function(e){}); try { WeixinJSBridge.call(&quot;closeWindow&quot;); useFallback = false; } catch(E) { useFallback = true; } } //If able uses Titanium/TideSDK: if (typeof(Ti) !== &quot;undefined&quot; &amp;&amp; typeof(Ti.App) !== &quot;undefined&quot; &amp;&amp; typeof(Ti.App.exit) !== &quot;undefined&quot;) { try { Ti.App.exit(); useFallback = false; } catch(E) { useFallback = true; } } //If we want to close using the fallback: if (useFallback) { //Uses redirection if it is allowed: if (allowRedirectionFallback) { setTimeout(function() { location.href = redirectionAddress; }, 200); //Lets a little bit time to process window.close() (if allowed). } //Uses window.close() if it is allowed: if (allowWindowCloseFallback) { try { //if (navigator.userAgent.indexOf('MSIE') !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1)) //{ //CB_Client.getWindow().opener = top; //CB_Client.getWindow().close(); //} //else //{ //var ventana = CB_Client.getWindow().open(&quot;&quot;, &quot;_self&quot;); //ventana.close(); //} var thisWindow = window.open(allowRedirectionFallback ? redirectionAddress : &quot;&quot;, &quot;_self&quot;, &quot;&quot;, &quot;true&quot;); thisWindow.opener = top; CB_windowCloseEncapsulated = thisWindow.close; CB_windowCloseEncapsulated(); //if (navigator.userAgent.indexOf('MSIE') !== -1 &amp;&amp; (navigator.appVersion.indexOf(&quot;MSIE 5&quot;) !== -1 || navigator.appVersion.indexOf(&quot;MSIE 6&quot;) !== -1)) //{ //window.opener = top; //window.close(); //} //var thisWindow = window.parent.open(allowRedirectionFallback ? redirectionAddress : location.href, &quot;_self&quot;); //window.parent.close(); //else //{ //var thisWindow = CB_Client.getWindow(true).open(allowRedirectionFallback ? redirectionAddress : &quot;&quot;, &quot;_self&quot;, &quot;&quot;, &quot;true&quot;); //thisWindow.opener = CB_Client.getWindow().top; //CB_windowCloseEncapsulated = thisWindow.close; //CB_windowCloseEncapsulated(); //} } catch(E) { try { var thisWindow = window.open(allowRedirectionFallback ? redirectionAddress : location.href, &quot;_self&quot;); thisWindow.close(); } catch(E) { try { window.opener = top; window.close(); } catch(E) { try { window.opener = window; window.close(); } catch(E) { try { window.opener = &quot;CB_TryingToCloseWindow&quot;; window.close(); } catch(E) { try { window.close(); } catch(E) { } } } } } } } } } /** * Redirects the current client to the desired location (having in mind whether the script is running in one [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more, if we want). * @function * @param {string} address - The address where we want to go. * @param {string} [getData] - Any URL (GET) variables we want to send (as for example &quot;data1=value1&amp;data2=value2&quot;). * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to redirect the topmost [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. */ CB_Client.redirectTo = function(address, getData, mindIframes) { getData = CB_ltrim(CB_trim(getData), [&quot;&amp;&quot;, &quot;?&quot;]); if (getData !== &quot;&quot;) { if (address.indexOf(&quot;?&quot;) === -1) { getData = &quot;?&quot; + getData; } else { getData = &quot;&amp;&quot; + getData; } } try { CB_Client.getWindow(mindIframes).location = address + getData; } catch(E) { window.location = address + getData; } } /** * Returns the current URL, if possible (having in mind whether the script is running in one [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more, if we want). * @function * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to get the location of the topmost [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @returns {string} */ CB_Client.getLocation = function(mindIframes) { var address = &quot;&quot;; try { address = CB_Client.getWindow(mindIframes).location.href; } catch(E) { address = &quot;&quot;; } if (!address) { address = window.location.href; } return address; } /** * Returns the given address without the file (for example, if &quot;http://whatever.com/index.html&quot; is given, it will return &quot;http://whatever.com/&quot;). * @function * @param {string} address - The address that we want to filter. * @param {string} [fallbackURL] - The address that we want it to return in the case that the given one is not allowed (used when &quot;allowsLocal&quot; does not allow a local address). If it contains a file, it will not be stripped out. * @param {boolean} [allowsLocal=true] - Defines whether to allow returning a local address or not. If it is set to false and the address is local, it will return the &quot;fallbackURL&quot; instead (without stripping out the file, if any). * @returns {string} */ CB_Client.getAddressWithoutFile = function(address, fallbackURL, allowsLocal) { if (allowsLocal !== true &amp;&amp; allowsLocal !== false) { allowsLocal = true; } address = CB_trim(address); address = CB_rtrim(address.substring(0, address.lastIndexOf(&quot;/&quot;)), &quot;/&quot;) + &quot;/&quot;; if (allowsLocal || address.indexOf(&quot;://localhost&quot;) === -1 &amp;&amp; address.indexOf(&quot;://127.0.0.1&quot;) === -1 &amp;&amp; address.indexOf(&quot;://192.168&quot;) === -1 || !CB_isString(fallbackURL)) { return address; } else { return fallbackURL; } } /** * Returns the current URL without the file (for example, if &quot;http://whatever.com/index.html&quot; is the current URL, it will return &quot;http://whatever.com/&quot;), if possible (having in mind whether the script is running in one [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more, if we want). * @function * @param {string} [fallbackURL] - The address that we want it to return in the case that the current one is not allowed (used when &quot;allowsLocal&quot; does not allow a local address). If it contains a file, it will not be stripped out. * @param {boolean} [allowsLocal=true] - Defines whether to allow returning a local address or not. If it is set to false and the current address is local, it will return the &quot;fallbackURL&quot; instead (without stripping out the file, if any). * @param {boolean} [mindIframes={@link CB_Configuration.CrossBase.MIND_IFRAMES}] - If set to true, it will try to get the location of the topmost [window]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window} object. Useful in case the script is running in an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} or more. * @returns {string} */ CB_Client.getLocationWithoutFile = function(fallbackURL, allowsLocal, mindIframes) { return CB_Client.getAddressWithoutFile(CB_Client.getLocation(mindIframes), fallbackURL, allowsLocal); } //var firstTimeShit = 0; /** * Gets the starting pixel of top or left coordinates for [getBoundingClientRect]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect} (it's not 0 in some Internet Explorer versions). * @function * @param {('left'|'top')} [leftOrTop='left'] - String that defines whether we want it to return the values for &quot;left&quot; or for &quot;top&quot;. * @returns {integer} */ CB_Client.getBoundingClientRectMargin = function(leftOrTop) { leftOrTop = leftOrTop.toLowerCase(); if (leftOrTop === &quot;&quot; || leftOrTop !== &quot;left&quot; &amp;&amp; leftOrTop !== &quot;top&quot;) { leftOrTop = &quot;left&quot;; } var getBoundingClientRectMarginDiv = CB_Elements.id(&quot;getBoundingClientRectMarginDiv&quot;); if (getBoundingClientRectMarginDiv === null) { var getBoundingClientRectMarginDiv = document.createElement(&quot;div&quot;); getBoundingClientRectMarginDiv.id = &quot;getBoundingClientRectMarginDiv&quot;; getBoundingClientRectMarginDiv.style.position = &quot;absolute&quot;; getBoundingClientRectMarginDiv.style.width = getBoundingClientRectMarginDiv.style.height = &quot;0px&quot;; getBoundingClientRectMarginDiv.style.visibility = &quot;hidden&quot;; getBoundingClientRectMarginDiv.style.left = &quot;0px&quot;; getBoundingClientRectMarginDiv.style.top = &quot;0px&quot;; var tagBody = CB_Elements.tag(&quot;body&quot;, document); if (typeof(tagBody) !== &quot;undefined&quot; &amp;&amp; tagBody !== null &amp;&amp; typeof(tagBody[0]) !== &quot;undefined&quot; &amp;&amp; tagBody[0] !== null) { tagBody[0].appendChild(getBoundingClientRectMarginDiv); //firstTimeShit = true; } } if (typeof(getBoundingClientRectMarginDiv.getBoundingClientRect) !== &quot;undefined&quot; &amp;&amp; getBoundingClientRectMarginDiv.getBoundingClientRect !== null) { var rectMargin = getBoundingClientRectMarginDiv.getBoundingClientRect(); var margin = 0; if (typeof(rectMargin[leftOrTop]) !== &quot;undefined&quot; &amp;&amp; rectMargin[leftOrTop] !== null &amp;&amp; !isNaN(rectMargin[leftOrTop])) { margin = rectMargin[leftOrTop]; } } if (margin &lt; 0) { if (leftOrTop === &quot;left&quot;) { margin += CB_Screen.getScrollLeft(); } else { margin += CB_Screen.getScrollTop(); } if (margin &lt; 0) { margin = 0; } } return margin; } /** * Tries to change the [document title]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/title} and returns it. * @function * @param {newTitle} newTitle - The desired new title. * @returns {string} */ CB_Client.setTitle = function(newTitle) { CB_Client.getDocumentBase().title = newTitle; //Chrome and Opera fix: var tagTitle = CB_Elements.tag(&quot;title&quot;); if (typeof(tagTitle) !== &quot;undefined&quot; &amp;&amp; tagTitle !== null &amp;&amp; typeof(tagTitle[0]) !== &quot;undefined&quot; &amp;&amp; tagTitle[0] !== null) { tagTitle = tagTitle[0]; try { tagTitle.innerHTML = newTitle; } catch(E) {} //Catch to avoid IE8 error. } titleCurrent = CB_Client.getTitle(); return titleCurrent; } /** * Returns the current [document title]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/title}. * @function * @returns {string} */ CB_Client.getTitle = function() { var title = CB_trim(CB_Client.getDocumentBase().title); if (title === &quot;&quot;) { //Chrome and Opera fix: var tagTitle = CB_Elements.tag(&quot;title&quot;); if (typeof(tagTitle) !== &quot;undefined&quot; &amp;&amp; tagTitle !== null &amp;&amp; typeof(tagTitle[0]) !== &quot;undefined&quot; &amp;&amp; tagTitle[0] !== null) { tagTitle = tagTitle[0]; try { title = tagTitle.innerHTML; } catch(E) { title = &quot;&quot;; } //Catch to avoid IE8 error. } } return title; } //Sets a function to execute when a desired event is fired: CB_Client._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { target = window; } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { //If able, adds the function given to the event: CB_Events.add ( target, eventName, function(e) { e = CB_Events.normalize(e); if (typeof(eventFunction) === &quot;function&quot;) { return eventFunction(e); } return true; }, useCapture, keepOldFunction, true ); } //...but if the function given is null, it will cancel the event: else if (eventFunction === null) { CB_Events.removeByName(target, eventName); } } } × Search results Close "},"CrossBase_input_CB_Mouse.js.html":{"id":"CrossBase_input_CB_Mouse.js.html","title":"Source: CrossBase/input/CB_Mouse.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/CB_Mouse.js /** * @file Mouse and related management. Contains the {@link CB_Mouse} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the mouse and related. It will return itself if it is tried to be instantiated. * @namespace */ var CB_Mouse = function() { return CB_Mouse; }; { CB_Mouse.initialized = false; //It will tells whether the object has been initialized or not. CB_Mouse._x = 0; //Keeps the X position of the mouse (relative to the window). CB_Mouse._y = 0; //Keeps the X position of the mouse (relative to the window). CB_Mouse._xMovement = 0; //Keeps the X movement of the mouser when its pointer is locked. CB_Mouse._yMovement = 0; //Keeps the Y movement of the mouser when its pointer is locked. CB_Mouse._buttonsDown = { LEFT : false, MIDDLE : false, RIGHT : false }; //Object with the buttons of the mouse which being pressed. CB_Mouse._isLockedNow = false; //Contains whether the mouse pointer is locked or not. CB_Mouse._isLockedPrevious = false; //Contains whether the mouse pointer was locked before or not. CB_Mouse._lockElement = null; //Contains the element that the mouse pointer is locked to (if any). //CB_Mouse._showingCursor = {}; //Tells whether the cursor is showing or not (by default is showing). /** Property that keeps an object to manage the mouse cursor using a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} containing an image for clients that do not support changing the cursor image by CSS. &lt;br /&gt; Caution: Performance could be dramatically decreased while using this workaround. * @namespace CB_Mouse.CursorImage */ CB_Mouse.CursorImage = {}; //Keeps the cursor object. CB_Mouse.CursorImage._cursorImageDiv = null; //DIV that contains the IMG tag for the fake cursor image. CB_Mouse.CursorImage._cursorImage = null; //IMG that contains the fake cursor image. CB_Mouse.CursorImage._showCursorImage = false; //Defines whether the fake cursor image is shown or not. CB_Mouse.CursorImage._cursorImageSpriteAnimationTimeout = null; //Initializes all values: CB_Mouse.init = function() { if (CB_Mouse.initialized) { return CB_Mouse; } //The object has been initialized: CB_Mouse.initialized = true; //Adds event that updates X and Y position of the mouse when it moves (and moves the cursor image if it is necessary): CB_Events.add(document, &quot;mousemove&quot;, function(e) { e = CB_Mouse.normalizeEvent(e); CB_Mouse.getX(e); CB_Mouse.getY(e); CB_Mouse.CursorImage.move(); }, true, true, false); CB_Events.add(window, &quot;scroll&quot;, function() { CB_Mouse.CursorImage.move(); }, true, true, false); //Sets the event that will check if a button is down: CB_Events.add ( document, &quot;mousedown&quot;, function(e) { e = CB_Mouse.normalizeEvent(e); //Uses setCapture/releaseCapture to force IE and Firefox to release mouse buttons when dragging outside the web client window: //if (typeof(document.body) !== &quot;undefined&quot; &amp;&amp; typeof(document.body.setCapture) !== &quot;undefined&quot;) if (typeof(e.target) !== &quot;undefined&quot; &amp;&amp; typeof(e.target.setCapture) !== &quot;undefined&quot;) { //document.body.setCapture(); e.target.setCapture(); } CB_Mouse._updateButtonsDown(e, true); }, true, true, false ); //Sets the event that will check if a button is released: CB_Events.add ( document, &quot;mouseup&quot;, function(e) { e = CB_Mouse.normalizeEvent(e); //Uses setCapture/releaseCapture to force IE and Firefox to release mouse buttons when dragging outside the web client window: //if (typeof(document.body) !== &quot;undefined&quot; &amp;&amp; typeof(document.body.releaseCapture) !== &quot;undefined&quot;) if (typeof(e.target) !== &quot;undefined&quot; &amp;&amp; typeof(e.target.releaseCapture) !== &quot;undefined&quot;) { //document.body.releaseCapture(); e.target.releaseCapture(); } CB_Mouse._updateButtonsDown(e, false); }, true, true, false ); //Sets the event for when the lock pointer status changes: var onPointerLockChange = function() { CB_Mouse.isLocked(true); //Also updates the cache of the current lock element (if any). }; CB_Events.add(document, &quot;pointerlockchange&quot;, onPointerLockChange, true, true, false); CB_Events.add(document, &quot;mozpointerlockchange&quot;, onPointerLockChange, true, true, false); CB_Events.add(document, &quot;webkitpointerlockchange&quot;, onPointerLockChange, true, true, false); CB_Events.add(document, &quot;pointerlocklost&quot;, onPointerLockChange, true, true, false); CB_Events.add(document, &quot;webkitpointerlocklost&quot;, onPointerLockChange, true, true, false); CB_Events.add(document, &quot;mozpointerlocklost&quot;, onPointerLockChange, true, true, false); //Clears buttonsDown array when the mouse leaves the web client: //CB_Events.add(window, &quot;mouseleave&quot;, function() { CB_Mouse._buttonsDown = { LEFT : false, MIDDLE : false, RIGHT : false }; }, true, true, false); //CB_Events.add(document, &quot;mouseout&quot;, function() { CB_Mouse._buttonsDown = { LEFT : false, MIDDLE : false, RIGHT : false }; }, true, true, false); //Sets the focus to force a mousemove event and get the proper mouse coordinates (some web clients at the start don't get the proper mouse coordinates): CB_Screen.focus(); return CB_Mouse; } /** * Tries to return the given [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the {@link CB_Events.normalize} function internally. Some properties added or affected could be [deltaX]{@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaX}, [deltaY]{@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaY}, [deltaZ]{@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaZ}, [force]{@link https://developer.mozilla.org/es/docs/Web/API/MouseEvent/webkitForce}, [clientX]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX}, [clientY]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY}, etc. * @function * @param {Event} e - [Mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). * @returns {Event} Returns the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} normalized. * @todo Add more properties and methods to normalize ([pageX]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX}, [pageY]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY}, [offsetX]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX}, [offsetY]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetY}, etc.). */ CB_Mouse.normalizeEvent = function(e) { e = CB_Events.normalize(e); //If wheel event is not supported, normalizes the event: var onWheelEventName = CB_Mouse._getOnWheelEventName(); if (onWheelEventName !== &quot;wheel&quot;) { if (typeof(e.type) !== &quot;undefined&quot; &amp;&amp; e.type === &quot;MozMousePixelScroll&quot;) { e.deltaMode = 0; } else { e.deltaMode = 1; } if (typeof(e.deltaX) === &quot;undefined&quot;) { e.deltaX = 0; } if (typeof(e.deltaZ) === &quot;undefined&quot;) { e.deltaZ = 0; } if (typeof(e.deltaY) === &quot;undefined&quot;) { if (onWheelEventName === &quot;mousewheel&quot; &amp;&amp; typeof(e.wheelDelta) !== &quot;undefined&quot;) { e.deltaY = -(1/40 * e.wheelDelta); //e.deltaY = e.wheelDelta / -40; //e.deltaY = e.wheelDelta / 120; if (typeof(e.wheelDeltaX) !== &quot;undefined&quot;) { event.deltaX = -(1/40 * e.wheelDeltaX); } } else if (typeof(e.detail) !== &quot;undefined&quot;) { e.deltaY = e.detail; //e.deltaY = -40 * e.detail; //e.deltaY = e.detail * -120; //e.deltaY = -e.detail / 3; } else { e.deltaY = 0; } } } //Normalizes the force property (if any): if (typeof(e.force) === &quot;undefined&quot; || e.force === null || isNaN(e.force)) { if (typeof(e.webkitForce) !== &quot;undefined&quot; &amp;&amp; e.webkitForce !== null &amp;&amp; !isNaN(e.webkitForce)) { e.force = e.webkitForce; } else if (CB_Touch._force !== null) { e.force = CB_Touch._force; } //Uses force detected by Pressure.js. } if (!e.forceNormalized) { e.force = CB_Touch.normalizeForce(e.force); } e.forceNormalized = true; //TODO: add more properties and methods to normalize (pageX, pageY, offsetX, offsetY, ). //Normalize other properties: //* Source: http://www.jacklmoore.com/notes/mouse-position/ if (typeof(e.clientX) === &quot;undefined&quot; &amp;&amp; typeof(e.pageX) !== &quot;undefined&quot;) { e.clientX = e.pageX; } if (typeof(e.clientY) === &quot;undefined&quot; &amp;&amp; typeof(e.pageY) !== &quot;undefined&quot;) { e.clientY = e.pageY; } if (document.body &amp;&amp; document.documentElement) { if (typeof(e.pageX) === &quot;undefined&quot; &amp;&amp; typeof(e.clientX) !== &quot;undefined&quot;) { if (typeof(document.body.scrollLeft) !== &quot;undefined&quot; &amp;&amp; typeof(document.documentElement.scrollLeft) !== &quot;undefined&quot;) { e.pageX = e.clientX + (document.body.scrollLeft) + document.documentElement.scrollLeft; } else if (typeof(document.body.scrollWidth) !== &quot;undefined&quot; &amp;&amp; typeof(document.documentElement.scrollWidth) !== &quot;undefined&quot;) { e.pageX = e.clientX + (document.body.scrollWidth) + document.documentElement.scrollWidth; } } if (typeof(e.pageY) === &quot;undefined&quot; &amp;&amp; typeof(e.clientY) !== &quot;undefined&quot;) { if (typeof(document.body.scrollTop) !== &quot;undefined&quot; &amp;&amp; typeof(document.documentElement.scrollTop) !== &quot;undefined&quot;) { e.pageY = e.clientY + (document.body.scrollTop) + document.documentElement.scrollTop; } else if (typeof(document.body.scrollHeight) !== &quot;undefined&quot; &amp;&amp; typeof(document.documentElement.scrollHeight) !== &quot;undefined&quot;) { e.pageY = e.clientY + (document.body.scrollHeight) + document.documentElement.scrollHeight; } } } try { var targetStyle = CB_Elements.getStyle(e.target, true); } catch(E) {} if (targetStyle !== null &amp;&amp; typeof(e.clientX) !== &quot;undefined&quot; &amp;&amp; e.clientX !== null &amp;&amp; typeof(e.clientY) !== &quot;undefined&quot; &amp;&amp; e.clientY !== null) { try { e.offsetX = e.clientX - parseInt(targetStyle['borderLeftWidth'], 10) - CB_Client.getBoundingClientRectMargin(&quot;left&quot;); e.offsetY = e.clientY - parseInt(targetStyle['borderTopWidth'], 10) - CB_Client.getBoundingClientRectMargin(&quot;top&quot;); } catch(E) {} } return e; } CB_Mouse._getOnWheelEventNameReturnCache = null; CB_Mouse._getOnWheelEventName = function() { if (typeof(CB_Mouse._getOnWheelEventNameReturnCache) === &quot;undefined&quot; || CB_Mouse._getOnWheelEventNameReturnCache === null) { CB_Mouse._getOnWheelEventNameReturnCache = (&quot;onwheel&quot; in document.createElement(&quot;div&quot;)) ? &quot;wheel&quot; : //&quot;wheel&quot; supported. (typeof(document.onmousewheel) !== &quot;undefined&quot;) ? &quot;mousewheel&quot; : //&quot;onmousewheel&quot; supported. &quot;DOMMouseScroll&quot;; //assumes &quot;DOMMouseScroll&quot; support. } return CB_Mouse._getOnWheelEventNameReturnCache; } //Returns which button is down given a mouse event: CB_Mouse._updateButtonsDown = function(e, buttonDown) { e = CB_Mouse.normalizeEvent(e); var buttonsDown = CB_Mouse._buttonsDown; if (e.which) { if (e.which === 1) { buttonsDown.LEFT = buttonDown; } else if (CB_Client.getBrowser() === &quot;Opera&quot; &amp;&amp; CB_Client.getBrowserVersionMain() &lt; 8) { if (e.which === 2) { buttonsDown.RIGHT = buttonDown; } else if (e.which === 3) { buttonsDown.MIDDLE = buttonDown; } } else { if (e.which === 2) { buttonsDown.MIDDLE = buttonDown; } else if (e.which === 3) { buttonsDown.RIGHT = buttonDown; } } } else if (e.button) { if (CB_Client.getBrowser() === &quot;Explorer&quot;) { //TODO: think about performing bitwise operations. if (e.button === 1) { buttonsDown.LEFT = buttonDown; } else if (e.button === 2) { buttonsDown.RIGHT = buttonDown; } else if (e.button === 3) { buttonsDown.LEFT = buttonsDown.RIGHT = buttonDown; } else if (e.button === 4) { buttonsDown.MIDDLE = buttonDown; } else if (e.button === 5) { buttonsDown.LEFT = buttonsDown.MIDDLE = buttonDown; } else if (e.button === 6) { buttonsDown.RIGHT = buttonsDown.MIDDLE = buttonDown; } else if (e.button === 7) { buttonsDown.LEFT = buttonsDown.RIGHT = buttonsDown.MIDDLE = buttonDown; } //else if (e.button === 0) { buttonsDown.LEFT = buttonsDown.RIGHT = buttonsDown.MIDDLE = false; } } else { if (e.button === 0) { buttonsDown.LEFT = buttonDown; } else if (e.button === 1) { buttonsDown.MIDDLE = buttonDown; } else if (e.button === 2) { buttonsDown.RIGHT = buttonDown; } } } CB_Mouse._buttonsDown = buttonsDown; } /** * Alias for {@link CB_Client.getButtons}. * @function CB_Client.getButtonsDown * @see {@link CB_Client.getButtons} */ /** * Tells what mouse buttons are down (LEFT, MIDDLE and/or RIGHT buttons). * @function * @returns {Object} Returns an object using the following format (where &quot;true&quot; means that the button is being pressed): { LEFT : boolean, MIDDLE : boolean, RIGHT : boolean } */ CB_Mouse.getButtons = CB_Mouse.getButtonsDown = function() { return CB_Mouse._buttonsDown; } /** * Gets and returns the X coordinate (horizontal position) of the mouse (relative to the window in desktop) in pixels. * @function * @param {Event} [e] - [Mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. If not provided, the returning value will use the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @param {boolean} [ignoreScroll=false] - If set to true, the horizontal scroll position will not be added to the returning value. * @param {boolean} [ignoreLock=false] - If set to true, it will ignore whether the cursor is being locked or not. Otherwise, if set to false and the cursor is locked, the returning value will only have in mind the position in the locking element. * @returns {number} Returns the X coordinate (horizontal position) of the mouse (relative to the window in desktop) in pixels. */ CB_Mouse.getX = function(e, ignoreScroll, ignoreLock) { //If this function has not been called from an event, we return stored values: if (!e) { if (CB_Mouse.isLocked(false) &amp;&amp; !ignoreLock) { return CB_Mouse.getXMovement(e); } else { if (ignoreScroll) { return CB_Mouse._x; } else { return CB_Mouse._x + CB_Screen.getScrollLeft(); } } } var mouseX = 0; //If it is compatible with the W3C draft: if (typeof(e.x) !== &quot;undefined&quot;) { mouseX = e.x; } //...otherwise, if we are using Internet Explorer: else if (typeof(e.clientX) !== &quot;undefined&quot;) { mouseX = e.clientX;// + document.body.scrollLeft; } //...otherwise we don't use Internet Explorer: else if (typeof(e.pageX) !== &quot;undefined&quot;) { //document.captureEvents(Event.MOUSEMOVE); mouseX = e.pageX; } //If the coordinate is lower than zero, it should be zero: if (mouseX &lt; 0) { mouseX = 0; } //We set the value for the property of the class: CB_Mouse._x = mouseX; //Updates the mose movement (useful when the mouse pointer is locked): CB_Mouse._xMovement = CB_Mouse.getXMovement(e); //If the mouse pointer is locked and we do not want to ignore it: if (CB_Mouse.isLocked(false) &amp;&amp; !ignoreLock) { return CB_Mouse._xMovement; } //...otherwise, returns the normal position instead of the movement: else { if (ignoreScroll) { return CB_Mouse._x; } else { return CB_Mouse._x + CB_Screen.getScrollLeft(); } } } /** * Gets and returns the Y coordinate (vertical position) of the mouse (relative to the window in desktop) in pixels. * @function * @param {Event} [e] - [Mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. If not provided, the returning value will use the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @param {boolean} [ignoreScroll=false] - If set to true, the vertical scroll position will not be added to the returning value. * @param {boolean} [ignoreLock=false] - If set to true, it will ignore whether the cursor is being locked or not. Otherwise, if set to false and the cursor is locked, the returning value will only have in mind the position in the locking element. * @returns {number} Returns the Y coordinate (vertical position) of the mouse (relative to the window in desktop) in pixels. */ CB_Mouse.getY = function(e, ignoreScroll, ignoreLock) { //If this function has not been called from an event, we return stored values: if (!e) { if (CB_Mouse.isLocked(false) &amp;&amp; !ignoreLock) { return CB_Mouse.getYMovement(e); } else { if (ignoreScroll) { return CB_Mouse._y; } else { return CB_Mouse._y + CB_Screen.getScrollTop(); } } } var mouseY = 0; //If it is compatible with the W3C draft: if (typeof(e.y) !== &quot;undefined&quot;) { mouseY = e.y; } //...otherwise, if we are using Internet Explorer: else if (typeof(e.clientY) !== &quot;undefined&quot;) { mouseY = e.clientY;// + document.body.scrollTop; } //...otherwise we don't use Internet Explorer: else if (typeof(e.pageY) !== &quot;undefined&quot;) { //document.captureEvents(Event.MOUSEMOVE); mouseY = e.pageY; } //If the coordinate is lower than zero, it should be zero: if (mouseY &lt; 0) { mouseY = 0; } //We set the value for the property of the class: CB_Mouse._y = mouseY; //Updates the mose movement (useful when the mouse pointer is locked): CB_Mouse._yMovement = CB_Mouse.getYMovement(e); //If the mouse pointer is locked and we do not want to ignore it: if (CB_Mouse.isLocked(false) &amp;&amp; !ignoreLock) { return CB_Mouse._yMovement; } //...otherwise, returns the normal position instead of the movement: else { if (ignoreScroll) { return CB_Mouse._y; } else { return CB_Mouse._y + CB_Screen.getScrollTop(); } } } /** * Gets and returns the current X coordinate (horizontal position) in pixels of the mouse relative to a given X position. The returning value uses the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @function * @param {number} x - The X coordinate (horizontal position) in pixels. The returning value will be calculated relatively to it. * @param {boolean} [ignoreScroll=false] - If set to true, the horizontal scroll position will not be added to the returning value. * @returns {number} Returns the current X coordinate (horizontal position) in pixels of the mouse relative to a given X position. * @todo Think about allowing to define an &quot;e&quot; parameter with the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. */ CB_Mouse.getXRelative = function(x, ignoreScroll) { //Gets the X position of the mouse: var mouseX = CB_Mouse.getX(null, ignoreScroll); if (ignoreScroll) { x -= CB_Screen.getScrollLeft(); } var mouseRelativeX = mouseX - x; return mouseRelativeX; } /** * Gets and returns the current Y coordinate (vertical position) in pixels of the mouse relative to a given Y position. The returning value uses the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @function * @param {number} y - The Y coordinate (vertical position) in pixels. The returning value will be calculated relatively to it. * @param {boolean} [ignoreScroll=false] - If set to true, the vertical scroll position will not be added to the returning value. * @returns {number} Returns the current Y coordinate (vertical position) in pixels of the mouse relative to a given Y position. * @todo Think about allowing to define an &quot;e&quot; parameter with the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. */ CB_Mouse.getYRelative = function(y, ignoreScroll) { //Gets the Y position of the mouse: var mouseY = CB_Mouse.getY(null, ignoreScroll); if (ignoreScroll) { y -= CB_Screen.getScrollTop(); } var mouseRelativeY = mouseY - y; return mouseRelativeY; } /** * Returns the current X (horizontal) movement (useful when the mouse pointer is locked) in pixels. More information: [MouseEvent.movementX]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX}. * @function * @param {Event} [e] - [Mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. If not provided, the returning value will use the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @returns {number} Returns the current X (horizontal) movement (useful when the mouse pointer is locked) in pixels. */ CB_Mouse.getXMovement = function(e) { //If this function has been called from an event, updates the current values: if (e) { CB_Mouse._xMovement = e.movementX || e.mozMovementX || e.webkitMovementX || 0; } return CB_Mouse._xMovement; } /** * Returns the current Y (vertical) movement (useful when the mouse pointer is locked) in pixels. More information: [MouseEvent.movementY]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY}. * @function * @param {Event} [e] - [Mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent}. If not provided, the returning value will use the previously-cached value (updated the last time that the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event was fired). * @returns {number} Returns the current Y (vertical) movement (useful when the mouse pointer is locked) in pixels. */ CB_Mouse.getYMovement = function(e) { //If this function has been called from an event, updates the current values: if (e) { CB_Mouse._yMovement = e.movementY || e.mozMovementY || e.webkitMovementY || 0; } return CB_Mouse._yMovement; } /** * Sets a function to execute when a click happens ([onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onMove = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mousemove&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a click happens ([onClick]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onClick = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;click&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a click happens ([onDblClick]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onDblClick = CB_Mouse.onDoubleClick = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;dblclick&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a mouse button is down ([onMouseDown]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onButtonDown = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mousedown&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a mouse button is up ([onMouseUp]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onButtonUp = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mouseup&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a mouse leaves a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} ([onMouseLeave]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=window] - The target where we want to attach the event listener. */ CB_Mouse.onLeave = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mouseleave&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a mouse is over a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} ([onMouseOver]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseover_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onOver = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mouseover&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a mouse gets out of a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} ([onMouseOut]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onOut = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Mouse._setEvent(&quot;mouseout&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the mouse wheel is used ([onWheel]{@link https://developer.mozilla.org/en-US/docs/Web/Events/wheel}, [onMouseWheel]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousewheel_event} or [DOMMouseScroll]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/DOMMouseScroll_event} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Mouse.onWheel = function(callbackFunction, keepOldFunction, useCapture, target) { var onWheelEventName = CB_Mouse._getOnWheelEventName(); var valueToReturn = CB_Mouse._setEvent(onWheelEventName, callbackFunction, keepOldFunction, useCapture, target); //If DOMMouseScroll is detected, adds MozMousePixelScroll event for older Firefox versions: if (onWheelEventName === &quot;DOMMouseScroll&quot;) { valueToReturn = CB_Mouse._setEvent(&quot;MozMousePixelScroll&quot;, callbackFunction, keepOldFunction, useCapture, target); } return valueToReturn; } CB_Mouse.isLockSupportedReturnCache = null; /** * Tells whether mouse pointer lock is supported or not. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @returns {boolean} Returns whether mouse pointer lock is supported or not. */ CB_Mouse.isLockSupported = function() { if (CB_Mouse.isLockSupportedReturnCache === null) { CB_Mouse.isLockSupportedReturnCache = &quot;pointerLockElement&quot; in document || &quot;mozPointerLockElement&quot; in document || &quot;webkitPointerLockElement&quot; in document || (navigator &amp;&amp; (navigator.pointer || navigator.webkitPointer || navigator.mozPointer)); } return CB_Mouse.isLockSupportedReturnCache; } /** * Tells whether the mouse pointer is locked or not. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @param {boolean} [avoidCache=false] - Used as the parameter to call the {@link CB_Mouse.getLockElement} function internally. * @returns {boolean} Returns whether the mouse pointer is locked or not. */ CB_Mouse.isLocked = function(avoidCache) { CB_Mouse._isLockedPrevious = CB_Mouse._isLockedNow; var isLockedNow = (CB_Mouse.getLockElement(avoidCache) !== null); if (!isLockedNow &amp;&amp; navigator) { navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer; if (navigator.pointer) { if (typeof(navigator.pointer.isLocked) === &quot;function&quot;) { isLockedNow = navigator.pointer.isLocked(); } else if (typeof(navigator.pointer.islocked) === &quot;function&quot;) { isLockedNow = navigator.pointer.islocked(); } else if (typeof(navigator.pointer.isLocked) !== &quot;undefined&quot;) { isLockedNow = navigator.pointer.isLocked; } } } CB_Mouse._isLockedNow = isLockedNow; return CB_Mouse._isLockedNow; } /** * Tells whether the mouse pointer was locked before or not when the {@link CB_Mouse.isLocked} function was called the last time. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @returns {boolean} Returns whether the mouse pointer was locked before or not when the {@link CB_Mouse.isLocked} function was called the last time. */ CB_Mouse.wasLocked = function() { return CB_Mouse._isLockedPrevious; } /** * Gets the lock element for the mouse pointer (if any) or null otherwise. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @param {boolean} [avoidCache=false] - If set to false, the returning value will use the previously-cached value (updated when this function is called with this parameter set to true or the [onPointerLockChange]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/pointerlockchange_event} or analog event is fired or when the {@link CB_Mouse.lock} or {@link CB_Mouse.unlock} functions are called successfully). * @returns {Element|null} Returns the lock element for the mouse pointer (if any) or null otherwise. */ CB_Mouse.getLockElement = function(avoidCache) { if (avoidCache) { if (typeof(document.pointerLockElement) !== &quot;undefined&quot; &amp;&amp; document.pointerLockElement !== null) { CB_Mouse._lockElement = document.pointerLockElement; } else if (typeof(document.mozPointerLockElement) !== &quot;undefined&quot; &amp;&amp; document.mozPointerLockElement !== null) { CB_Mouse._lockElement = document.mozPointerLockElement; } else if (typeof(document.webkitPointerLockElement) !== &quot;undefined&quot; &amp;&amp; document.webkitPointerLockElement !== null) { CB_Mouse._lockElement = document.webkitPointerLockElement; } else { CB_Mouse._lockElement = null; } return CB_Mouse._lockElement; } else { return CB_Mouse._lockElement; } } /** * Locks the mouse pointer (if possible). More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @param {Element} [target=document.body] - The [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} that the mouse pointer will be locked to. * @param {function} callbackOk - Function callback that will be called (without parameters) if the mouse pointer could be locked successfully. * @param {function} callbackError - Function callback that will be called (without parameters) if the mouse pointer could not be locked successfully. * @returns {Element|null} Returns the current lock element for the mouse pointer (if any) or null otherwise. */ CB_Mouse.lock = function(target, callbackOk, callbackError) { if (typeof(target) === &quot;undefined&quot; || target === null) { target = document.body; } if (typeof(target) !== &quot;undefined&quot; &amp;&amp; target !== null) { target.requestPointerLock = target.requestPointerLock || target.mozRequestPointerLock || target.webkitRequestPointerLock; if (typeof(target.requestPointerLock) === &quot;function&quot;) { target.requestPointerLock(); if (CB_Mouse.isLocked(true)) //Also updates CB_Mouse.isLocked cache. { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } } else if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } return CB_Mouse.getLockElement(true); } else if (navigator) { navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer; if (navigator.pointer &amp;&amp; typeof(navigator.pointer.lock) === &quot;function&quot;) { navigator.pointer.lock(target, callbackOk, callbackError); CB_Mouse.isLocked(true); //Updates CB_Mouse.isLocked cache. return CB_Mouse.getLockElement(true); } } } if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } CB_Mouse.isLocked(true); //Updates CB_Mouse.isLocked cache. return null; } /** * Unlocks the mouse pointer (if possible). More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @returns {boolean} Returns true if the mouse pointer has been unlocked or false otherwise. */ CB_Mouse.unlock = function() { document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock; if (typeof(document.exitPointerLock) === &quot;function&quot;) { document.exitPointerLock(); } else if (navigator) { navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer; if (navigator.pointer &amp;&amp; typeof(navigator.pointer.unlock) === &quot;function&quot;) { navigator.pointer.unlock(); } } return (!CB_Mouse.isLocked(true)); } /** * Sets a function to execute when the mouse pointer lock functionality changes its state (it has been either locked or unlocked, using [pointerlockchange]{@link [onPointerLockChange]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/pointerlockchange_event}}, [mozpointerlockchange]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API} or [webkitpointerlockchange]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API} event) or removes it. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Mouse.onLockChange = function(callbackFunction, keepOldFunction, useCapture) { CB_Mouse._setEvent(&quot;pointerlockchange&quot;, callbackFunction, keepOldFunction, useCapture, document); CB_Mouse._setEvent(&quot;mozpointerlockchange&quot;, callbackFunction, keepOldFunction, useCapture, document); CB_Mouse._setEvent(&quot;webkitpointerlockchange&quot;, callbackFunction, keepOldFunction, useCapture, document); } /** * Sets a function to execute when the mouse pointer fails to either lock or unlock (using [pointerlockerror]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/pointerlockerror_event}, [mozpointerlockerror]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API} or [webkitpointerlockerror]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API} event) or removes it. More information: [Pointer Lock API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the [mouse event object]{@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} (already normalized by the {@link CB_Mouse.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Mouse.onLockError = function(callbackFunction, keepOldFunction, useCapture) { CB_Mouse._setEvent(&quot;pointerlockerror&quot;, callbackFunction, keepOldFunction, useCapture, document); CB_Mouse._setEvent(&quot;mozpointerlockerror&quot;, callbackFunction, keepOldFunction, useCapture, document); CB_Mouse._setEvent(&quot;webkitpointerlockerror&quot;, callbackFunction, keepOldFunction, useCapture, document); } //Sets a function to execute when a desired event is fired: CB_Mouse._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { if (eventName === &quot;mouseleave&quot;) { target = window; } else { target = document; } } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { //If able, adds the function given to the event: CB_Events.add ( target, eventName, function(e) { e = CB_Mouse.normalizeEvent(e); CB_Mouse.getX(e); //Updates mouse X position. CB_Mouse.getY(e); //Updates mouse Y position. if (eventName === &quot;mousedown&quot; || eventName === &quot;mouseup&quot;) { CB_Mouse._updateButtonsDown(e, (eventName === &quot;mousedown&quot;)); //Updates buttons down. } if (typeof(eventFunction) === &quot;function&quot;) { return eventFunction(e); } return true; }, useCapture, keepOldFunction, true ); } //...but if the function given is null, it will cancel the event: else if (eventFunction === null) { CB_Events.removeByName(target, eventName); } } /** * Tells whether the mouse is over a given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} or not. * @function * @param {Element} element - The [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} where we want to know whether the mouse is over or not. * @returns {boolean} Returns whether the mouse is over the given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} or not. */ CB_Mouse.isOverElement = function(element) { return CB_Collisions.isPointOverElement(CB_Mouse.getX(), CB_Mouse.getY(), element); } /** * Tells whether the mouse is over a given line (infinite line) or not. * @function * @param {number} lineX1 - The X coordinate (horizontal position) of the first pixel of the line. * @param {number} lineY1 - The Y coordinate (vertical position) of the first pixel of the line. * @param {number} lineX2 - The X coordinate (horizontal position) of the second pixel of the line. * @param {number} lineY2 - The Y coordinate (vertical position) of the second pixel of the line. * @param {number} [tolerance=1] - The amount of loss of precision we can tolerate to consider a collision. * @param {Element} [element] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse coordinates will be calculated relatively to the position of this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. * @returns {boolean} Returns whether the mouse is over the given line (infinite line) or not. * @todo Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). */ CB_Mouse.isOverLine = function(lineX1, lineY1, lineX2, lineY2, tolerance, element) { if (typeof(tolerance) === &quot;undefined&quot; || tolerance === null) { tolerance = 1; } if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var mouseX = CB_Mouse.getXRelative(CB_Elements.getLeft(element)); var mouseY = CB_Mouse.getYRelative(CB_Elements.getTop(element)); } else { var mouseX = CB_Mouse.getX(); var mouseY = CB_Mouse.getY(); } return CB_Collisions.isPointOverLine(mouseX, mouseY, lineX1, lineY1, lineX2, lineY2, tolerance); } /** * Tells whether the mouse is over a given line segment or not. * @function * @param {number} lineX1 - The X coordinate (horizontal position) of the first pixel of the line segment. * @param {number} lineY1 - The Y coordinate (vertical position) of the first pixel of the line segment. * @param {number} lineX2 - The X coordinate (horizontal position) of the second pixel of the line segment. * @param {number} lineY2 - The Y coordinate (vertical position) of the second pixel of the line segment. * @param {number} [tolerance=1] - The amount of loss of precision we can tolerate to consider a collision. * @param {Element} [element] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse coordinates will be calculated relatively to the position of this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. * @returns {boolean} Returns whether the mouse is over the given line segment or not. * @todo Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). */ CB_Mouse.isOverSegment = function(lineX1, lineY1, lineX2, lineY2, tolerance, element) { if (typeof(tolerance) === &quot;undefined&quot; || tolerance === null) { tolerance = 1; } if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var mouseX = CB_Mouse.getXRelative(CB_Elements.getLeft(element)); var mouseY = CB_Mouse.getYRelative(CB_Elements.getTop(element)); } else { var mouseX = CB_Mouse.getX(); var mouseY = CB_Mouse.getY(); } return CB_Collisions.isPointOverSegment(mouseX, mouseY, lineX1, lineY1, lineX2, lineY2, tolerance); } /** * Tells whether the mouse is over a given rectangle or not. * @function * @param {number} rectangleX - The X coordinate (horizontal position) of the first pixel of the rectangle (upper left corner). * @param {number} rectangleY - The Y coordinate (vertical position) of the first pixel of the rectangle (upper left corner). * @param {number} rectangleWidth - The width of the rectangle in pixels. * @param {number} rectangleHeight - The height of the rectangle in pixels. * @param {Element} [element] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse coordinates will be calculated relatively to the position of this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. * @returns {boolean} Returns whether the mouse is over the given rectangle or not. */ CB_Mouse.isOverRectangle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var mouseX = CB_Mouse.getXRelative(CB_Elements.getLeft(element)); var mouseY = CB_Mouse.getYRelative(CB_Elements.getTop(element)); } else { var mouseX = CB_Mouse.getX(); var mouseY = CB_Mouse.getY(); } return CB_Collisions.isPointOverRectangle(mouseX, mouseY, rectangleX, rectangleY, rectangleWidth, rectangleHeight); } /** * Tells whether the mouse is over a given circle or not. * @function * @param {number} centreX - The X coordinate (horizontal position) of the center of the circle in pixels. * @param {number} centreY - The Y coordinate (vertical position) of the center of the circle in pixels. * @param {number} radius - The radius of the circle in pixels. * @param {Element} [element] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse coordinates will be calculated relatively to the position of this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. * @returns {boolean} Returns whether the mouse is over the given circle or not. */ CB_Mouse.isOverCircle = function(centreX, centreY, radius, element) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { mouseX = CB_Mouse.getXRelative(CB_Elements.getLeft(element)); mouseY = CB_Mouse.getYRelative(CB_Elements.getTop(element)); } else { var mouseX = CB_Mouse.getX(); var mouseY = CB_Mouse.getY(); } return CB_Collisions.isPointOverCircle(mouseX, mouseY, centreX, centreY, radius); } /** * Tells whether the mouse is over a given ellipse or not. * @function * @param {number} centreX - The &quot;X&quot; coordinate of the center of the ellipse. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the ellipse. * @param {number} radiusX - The X (horizontal) radius of the ellipse. * @param {number} radiusY - The Y (vertical) radius of the ellipse. * @param {number} [rotation=0] - The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! * @param {boolean} [rotationUseDegrees=false] - Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! * @returns {boolean} Returns whether the mouse is over the given ellipse or not. */ CB_Mouse.isOverEllipse = function(centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees, radius, element) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { mouseX = CB_Mouse.getXRelative(CB_Elements.getLeft(element)); mouseY = CB_Mouse.getYRelative(CB_Elements.getTop(element)); } else { var mouseX = CB_Mouse.getX(); var mouseY = CB_Mouse.getY(); } return CB_Collisions.isPointOverEllipse(mouseX, mouseY, centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees, radius); } /** * Hides the mouse cursor in a given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} by changing its internal CSS code of the [style.cursor]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} property. * @function * @param {Element} [element=document.body] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse cursor will be hidden when it is over this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. Otherwise, it will be hidden in the whole document (using [document.body]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/body} as element). * @param {boolean} [recursive=true] - If it is set to true, all the child [DOM elements]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} will also be affected. * @todo Check whether the path used in the &quot;url&quot; is right or not (now it uses the {@link CB_scriptPath} variable). */ CB_Mouse.hide = function(element, recursive) { var CSS = &quot;url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg=='), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/almost_blank.png), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/blank.gif), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/blank.cur), none&quot;; if (CB_Client.getBrowser() === &quot;Explorer&quot;) { CSS = &quot;url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg=='), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/blank.cur), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/blank.gif), url(&quot; + CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;input/cursors/almost_blank.png), none&quot;; } CB_Mouse.setCSS(CSS, element, recursive); //CB_Mouse._showingCursor[element||document.body] = false; } /** * Restores (unhides) the mouse cursor in a given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} by changing its internal CSS code of the [style.cursor]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} property to the default one (using &quot;default&quot; as the CSS code). * @function * @param {Element} [element=document.body] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the mouse cursor will be restored (unhidden) when it is over this [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. Otherwise, it will be restored (unhidden) in the whole document (using [document.body]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/body} as the &quot;element&quot;). * @param {boolean} [recursive=true] - If it is set to true, all the child [DOM elements]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} will also be affected. */ CB_Mouse.restore = function(element, recursive) { var CSS = &quot;default&quot;; CB_Mouse.setCSS(CSS, element, recursive); //CB_Mouse._showingCursor[element||document.body] = true; } /* CB_Mouse.isShowing = function(element) { return CB_Mouse._showingCursor[element||document.body]; } */ /** * Sets the desired CSS code for the [style.cursor]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} property of the given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. * @function * @param {string} [CSS=&quot;&quot;] - CSS code for the [style.cursor]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} property of the given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. If not given, an empty string will be used. * @param {Element} [element=document.body] - If a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} is given, the CSS code updated will affect the given [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement}. Otherwise, it will affect the whole document (using [document.body]{@link https://developer.mozilla.org/en-US/docs/Web/API/Document/body} as the &quot;element&quot;). * @param {boolean} [recursive=true] - If it is set to true, all the child [DOM elements]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} will also be affected. */ CB_Mouse.setCSS = function(CSS, element, recursive) { //If they are not set, use default values for optional parameters: if (typeof(CSS) === &quot;undefined&quot; || CSS === null) { CSS = &quot;&quot;; } if (typeof(element) === &quot;undefined&quot; || element === null) { element = document.body; } if (typeof(recursive) === &quot;undefined&quot; || recursive === null) { recursive = true; } //It is recursive by default. //Sets the CSS style for the given element: if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null &amp;&amp; typeof(element.style) !== &quot;undefined&quot; &amp;&amp; element.style !== null) { element.style.cursor = CSS; } //If it is recursive, it affects the children of the given element: if (recursive) { var elementsChildren = element.childNodes; var elementsChildrenLength = elementsChildren.length; for (var x = 0; x &lt; elementsChildrenLength; x++) { CB_Mouse.setCSS(CSS, elementsChildren[x], true); } } } /** * Uses an [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} inside a [DIV element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div} (fakes the cursor) to simulate the mouse cursor (following its movements). If it was already called before and a fake cursor is already being used, the {@link CB_Mouse.CursorImage.hide} function must be called before in order to start using a different fake cursor image. &lt;br /&gt; Caution: Performance could be dramatically decreased while using this workaround. * @function * @param {boolean} [showCursorImage=true] - If set to true and a valid cursor image is given, the fake cursor functionality will be used. Otherwise, the fake cursor will stop being used. * @param {string} [cursorImage] - If a valid image path is given and &quot;showCursorImage&quot; is set to true, the fake cursor functionality will be used with the given image. Otherwise, the fake cursor will stop being used. * @param {number} [cursorImageWidth=32] - Width in pixels of the cursor image. * @param {number} [cursorImageHeight=32] - Height in pixels of the cursor image. * @param {boolean} [hideNormalCursor=true] - If set to true, hides the system cursor (calls the {@link CB_Mouse.hide} function internally). Otherwise, shows the system cursor (calls the {@link CB_Mouse.restore} function internally). * @param {boolean} [isSprite=false] - Defines whether the cursor will be animated (using sprites) or not. If so, the cursorImage must be an image containing sprites horizontally (their individual width is defined by the &quot;cursorImageWidth&quot; parameter). Once the last sprite is reached, it returns to the first one automatically and continues to the next one again (without stopping). * @param {number} [numberOfFrames=1] - Number of frames (sprites) being used from the cursor image (&quot;cursorImage&quot; parameter). Used when the &quot;isSprite&quot; parameter is set to true. * @param {number} [framesMs=100] - Number of milliseconds between each frame (between one sprite and next one). Used when the &quot;isSprite&quot; parameter is set to true. * @param {Element} [divElement=CB_Elements.id('CB_fakeCursorImageDiv')] - The ID of the [DIV element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div} that will contain the image of the fake cursor (uses a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} with &quot;CB_fakeCursorImageDiv&quot; ID by default). * @param {Element} [imageElement=CB_Elements.id('CB_fakeCursorImage')] - The ID of the [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} that will contain the fake cursor (uses a [DOM element]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement} with &quot;CB_fakeCursorImage&quot; ID by default). * @todo Allow defining an &quot;onMove&quot; parameter (a callback) to be able to call the &quot;move&quot; method with non-default parameters, etc. */ CB_Mouse.CursorImage.set = function(showCursorImage, cursorImage, cursorImageWidth, cursorImageHeight, hideNormalCursor, isSprite, numberOfFrames, framesMs, divElement, imageElement) { //If they are not set, use default values for optional parameters: if (typeof(showCursorImage) === &quot;undefined&quot; || showCursorImage === null) { showCursorImage = true; } //Shows the image by default. if (typeof(hideNormalCursor) === &quot;undefined&quot; || hideNormalCursor === null) { hideNormalCursor = true; } //Hides the cursor by default (unless we want to hide the image). if (typeof(cursorImageWidth) === &quot;undefined&quot; || cursorImageWidth === null) { cursorImageWidth = 32; } //If not set, uses the default width. if (typeof(cursorImageHeight) === &quot;undefined&quot; || cursorImageHeight === null) { cursorImageHeight = 32; } //If not set, uses the default height. if (typeof(numberOfFrames) === &quot;undefined&quot; || numberOfFrames === null) { numberOfFrames = 1; } //By default, the number of frames is only one. if (typeof(framesMs) === &quot;undefined&quot; || framesMs === null) { framesMs = 100; } //Sets the number of milliseconds between frames by default. //Select the image element or creates it if it doesn't exist yet: var CB_fakeCursorImageDiv = divElement || CB_Elements.id(&quot;CB_fakeCursorImageDiv&quot;); var CB_fakeCursorImage = imageElement || CB_Elements.id(&quot;CB_fakeCursorImage&quot;); if (typeof(CB_fakeCursorImageDiv) === &quot;undefined&quot; || CB_fakeCursorImageDiv === null || typeof(CB_fakeCursorImage) === &quot;undefined&quot; || CB_fakeCursorImage === null) { CB_fakeCursorImageDiv = document.createElement(&quot;div&quot;); //Creathes the DIV element. CB_fakeCursorImageDiv.setAttribute(&quot;id&quot;, &quot;CB_fakeCursorImageDiv&quot;); //Sets DIV element id. CB_fakeCursorImage = document.createElement(&quot;img&quot;); //Creathes the IMG element. CB_fakeCursorImage.setAttribute(&quot;id&quot;, &quot;CB_fakeCursorImage&quot;); //Sets IMG element id. CB_fakeCursorImageDiv.style.position = CB_fakeCursorImage.style.position = &quot;absolute&quot;; //DIV and IMG position is absolute. CB_fakeCursorImageDiv.style.visibility = &quot;hidden&quot;; //First it will be hidden. CB_fakeCursorImageDiv.style.zIndex = CB_fakeCursorImage.style.zIndex = 999999; CB_fakeCursorImageDiv.style.overflow = &quot;hidden&quot;; CB_fakeCursorImageDiv.appendChild(CB_fakeCursorImage); //DIV will contains the IMG element. document.body.appendChild(CB_fakeCursorImageDiv); //BODY will contains the DIV. } //If we don't want to show the image (or the image has not been given), we hide it: if (!showCursorImage || typeof(cursorImage) === &quot;undefined&quot; || cursorImage === null) { CB_fakeCursorImageDiv.style.visibility = &quot;hidden&quot;; CB_Mouse.CursorImage._showCursorImage = false; CB_Mouse.CursorImage._cursorImageSpriteAnimation(false); //Stops the possible sprite animation. //If set, restores the normal cursor: if (!hideNormalCursor) { CB_Mouse.restore(); } } //...otherwise, forces it to follow the cursor: else if (!CB_Mouse.CursorImage._showCursorImage) { //Sets the image given as the SRC: if (CB_fakeCursorImage.src !== cursorImage) { CB_fakeCursorImage.src = cursorImage; } //The image (sprite or not) has to start with 0px in its left: CB_fakeCursorImage.style.left = &quot;0px&quot;; //Sets the proper width and height: if (isSprite) //If it is a sprite, the IMG will be wider than the DIV: { CB_fakeCursorImageDiv.style.width = cursorImageWidth + &quot;px&quot;; CB_fakeCursorImage.style.width = (cursorImageWidth * numberOfFrames) + &quot;px&quot;; CB_fakeCursorImageDiv.style.height = CB_fakeCursorImage.style.height = cursorImageHeight + &quot;px&quot;; } else //...otherwise, if it is not a sprite, the use of pixels is not mandatory: { if (!isNaN(cursorImageWidth)) { cursorImageWidth += &quot;px&quot;; } //If it is a number, they are considered pixels. if (!isNaN(cursorImageHeight)) { cursorImageHeight += &quot;px&quot;; } //If it is a number, they are considered pixels. CB_fakeCursorImageDiv.style.width = CB_fakeCursorImage.style.width = cursorImageWidth; CB_fakeCursorImageDiv.style.height = CB_fakeCursorImage.style.height = cursorImageHeight; } //Forces the image to follow the cursor: CB_Mouse.CursorImage._showCursorImage = true; //Stores the DIV and IMG elements: CB_Mouse.CursorImage._cursorImageDiv = CB_fakeCursorImageDiv; CB_Mouse.CursorImage._cursorImage = CB_fakeCursorImage; //Refreshes the image coordinates: CB_Mouse.CursorImage.move(); //Show the image: CB_fakeCursorImageDiv.style.visibility = &quot;visible&quot;; //If set, hides the cursor: if (hideNormalCursor) { CB_Mouse.hide(); } //...otherwise, shows it: else { CB_Mouse.restore(); } //If it is a sprite, starts the animation: if (isSprite) { CB_Mouse.CursorImage._cursorImageSpriteAnimation(true, cursorImageWidth, numberOfFrames, framesMs); } } } /** * Gets the [DIV element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div} that contains the [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} of the fake cursor (if any). * @function * @returns {Element} Returns the [DIV element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div} that contains the [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} of the fake cursor (if any). */ CB_Mouse.CursorImage.get = function() { return CB_Mouse.CursorImage._cursorImageDiv; } /** * Gets the [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} of the fake cursor (if any). * @function * @returns {Element} Returns the [IMG element]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img} of the fake cursor (if any). */ CB_Mouse.CursorImage.getImage = function() { return CB_Mouse.CursorImage._cursorImage; } /** * Tells whether the fake cursor is showing or not * @function * @returns {boolean} Returns whether the fake cursor is showing or not. */ CB_Mouse.CursorImage.isShowing = function() { return CB_Mouse.CursorImage._showCursorImage; } /** * Hides the fake cursor image. * @function * @param {boolean} [showNormalCursor=true] - If set to true, restores (shows) the system cursor (calls the {@link CB_Mouse.restore} function internally). */ CB_Mouse.CursorImage.hide = function(showNormalCursor) { //If they are not set, use default values for optional parameters: if (typeof(showNormalCursor) === &quot;undefined&quot; || showNormalCursor === null) { showNormalCursor = true; } //Shows normal cursor by default. //If it is being displayed, hides the fake cursor image: if (CB_Mouse.CursorImage._showCursorImage) { CB_Mouse.CursorImage.set(false, null, null, null, !showNormalCursor); } } /** * Moves the fake cursor image (if it is not hidden). Automatically called when the [onMouseMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event} event is fired. * @function * @param {number} [x=CB_Mouse.getX(null, false)] - The X coordinate (horizontal position) in pixels where the fake cursor image wants to be moved to. If not provided, it will use the value returned by calling CB_Mouse.getX(null, false) internally. * @param {number} [y=CB_Mouse.getY(null, false)] - The Y coordinate (vertical position) in pixels where the fake cursor image wants to be moved to. If not provided, it will use the value returned by calling CB_Mouse.getY(null, false) internally. */ CB_Mouse.CursorImage.move = function(x, y) { if (CB_Mouse.CursorImage._showCursorImage) { if (typeof(CB_Mouse.CursorImage._cursorImageDiv) !== &quot;undefined&quot; &amp;&amp; CB_Mouse.CursorImage._cursorImageDiv !== null &amp;&amp; typeof(CB_Mouse.CursorImage._cursorImageDiv.style) !== &quot;undefined&quot;) { try //IE6 throws errors sometimes. { CB_Mouse.CursorImage._cursorImageDiv.style.left = (x || CB_Mouse.getX(null, false) || 0) + &quot;px&quot;; CB_Mouse.CursorImage._cursorImageDiv.style.top = (y || CB_Mouse.getY(null, false) || 0) + &quot;px&quot;; } catch(E) {} } } } //Starts or stops the sprite animation for the fake cursor image: CB_Mouse.CursorImage._cursorImageSpriteAnimation = function(runAnimation, cursorImageWidth, numberOfFrames, framesMs) { //If the number of frames is 1, it doesn't need to do anything: if (numberOfFrames &lt;= 1) { return; } //If set, stops the animation: if (!runAnimation) { clearTimeout(CB_Mouse.CursorImage._cursorImageSpriteAnimationTimeout); CB_Mouse.CursorImage._cursorImageSpriteAnimationTimeout = null; } //...otherwise, the animation starts or continues it: else { //Continues to next frame after the given milliseconds: CB_Mouse.CursorImage._cursorImageSpriteAnimationTimeout = CB_symmetricCall ( function() { if (CB_Mouse.CursorImage._cursorImageSpriteAnimationTimeout !== null) { var cursorImageLeft = CB_Elements.getStylePropertyInteger(CB_Mouse.CursorImage._cursorImage, &quot;left&quot;)[0] - cursorImageWidth; cursorImageLeft %= (cursorImageWidth * numberOfFrames); CB_Mouse.CursorImage._cursorImage.style.left = cursorImageLeft + &quot;px&quot;; CB_Mouse.CursorImage._cursorImageSpriteAnimation(runAnimation, cursorImageWidth, numberOfFrames, framesMs); } }, framesMs, &quot;CB_MOUSE_CURSOR_IMAGE&quot; ); } } } //End of the static class CB_Mouse. × Search results Close "},"CrossBase_general_CB_Collisions.js.html":{"id":"CrossBase_general_CB_Collisions.js.html","title":"Source: CrossBase/general/CB_Collisions.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_Collisions.js /** * @file Collisions management. Contains the {@link CB_Collisions} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage collisions. It will return itself if it is tried to be instantiated. * @namespace * @todo Finish many functions for many more kinds of collisions. * @todo Add triangles, polygons, arcs, etc. * @todo Add support to more dimensions (at least to 3D). * @todo Add lacking &quot;touching&quot; functions, equivalent to the &quot;over&quot; ones. * @todo Add a boolean parameter and a border parameter to detect collision just when it hits the border (not when it is inside of the object without touching the border), for &quot;hollow&quot; shapes. * @todo Think about adding function aliases with reversed names (for example, &quot;isElementOverPoint&quot; that points to &quot;isPointOverElement&quot;, etc.). Think about whether the aliases should or not have some parameters in reversed order. */ var CB_Collisions = function() { return CB_Collisions; }; { CB_Collisions.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Collisions.init = function() { if (CB_Collisions.initialized) { return CB_Collisions; } //The object has been initialized: CB_Collisions.initialized = true; //TODO. return CB_Collisions; } //TODO: add polygons, arcs, etc. /** * Tells the distance between two points. * @function * @param {number} x - The &quot;X&quot; coordinate of the first point. * @param {number} y - The &quot;Y&quot; coordinate of the first point. * @param {number} x2 - The &quot;X&quot; coordinate of the second point. * @param {number} y2 - The &quot;Y&quot; coordinate of the second point. * @returns {number|null} Returns the distance between the two points. In the case that it could not be calculated, returns null. */ CB_Collisions.getDistancePoints = function(x, y, x2, y2) { var distance = parseFloat(Math.sqrt(Math.pow(x - x2, 2) + Math.pow(y - y2, 2))); return isNaN(distance) ? null : distance; } /** * Tells whether a given point is over a given DOM element (it will be considered a rectangle). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {Element} element - The DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the point is over the given DOM element (it will be considered a rectangle). */ CB_Collisions.isPointOverElement = function(x, y, element) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isPointOverRectangle(x, y, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element)); } /** * Tells whether a given point is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {Element} element - The DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the point is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). */ CB_Collisions.isPointTouchingElement = function(x, y, element) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isPointTouchingRectangle(x, y, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element)); } /** * Tells whether a point is over a line (infinite). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} lineX1 - The &quot;X&quot; coordinate of a first point of the line. * @param {number} lineY1 - The &quot;Y&quot; coordinate of a first point of the line. * @param {number} lineX2 - The &quot;X&quot; coordinate of a second point of the line. * @param {number} lineY2 - The &quot;Y&quot; coordinate of a second point of the line. * @param {number} [tolerance=0.001] - The amount of loss of precision we can tolerate to consider a collision. * @returns {boolean} Returns whether the point is over the line (infinite). * @todo Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). * @todo Create a CB_Collisions.isPointTouchingLine function. */ CB_Collisions.isPointOverLine = function(x, y, lineX1, lineY1, lineX2, lineY2, tolerance) { if (typeof(tolerance) === &quot;undefined&quot; || tolerance === null) { tolerance = 0.001; } //If the line is vertical (infinite slope) or just a point: if (lineX1 === lineX2) { //If the point is in the same X axis: if (x === lineX1) { //If the line has the same Y at both ends, it's in fact just a point: if (lineY1 === lineY2) { //If the point is in the same Y axis: if (y === lineY1) { return true; } //The line is a point and the point given is the same one. } else if (lineY1 &lt; lineY2) { if (y &gt;= lineY1 &amp;&amp; y &lt;= lineY2) { return true; } } else //lineY1 &gt; lineY2 { if (y &gt;= lineY2 &amp;&amp; y &lt;= lineY1) { return true; } } } } else { var slope = (lineY2 - lineY1) / (lineX2 - lineX1); var yIntercept = lineY1 - slope * lineX1; if (Math.abs(y - (slope * x + yIntercept)) &lt;= tolerance) { return true; } } return false; } /** * Tells whether a point is over a line segment. * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} segmentX1 - The &quot;X&quot; coordinate of the beginning point of the line. * @param {number} segmentY1 - The &quot;Y&quot; coordinate of the beginning point of the line. * @param {number} segmentX2 - The &quot;X&quot; coordinate of the end point of the line. * @param {number} segmentY2 - The &quot;Y&quot; coordinate of the end point of the line. * @param {number} [tolerance=0.001] - The amount of loss of precision we can tolerate to consider a collision. * @returns {boolean} Returns whether the point is over the line segment. * @todo Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). * @todo Create a CB_Collisions.isPointTouchingSegment function. */ CB_Collisions.isPointOverSegment = function(x, y, segmentX1, segmentY1, segmentX2, segmentY2, tolerance) { var rectangleX1 = segmentX1; var rectangleY1 = segmentY1; var rectangleX2 = segmentX2; var rectangleY2 = segmentY2; if (segmentX2 &lt; segmentX1) { rectangleX1 = segmentX2; rectangleX2 = segmentX1; } if (segmentY2 &lt; segmentY1) { rectangleY1 = segmentY2; rectangleY2 = segmentY1; } if (CB_Collisions.isPointOverRectangle(x, y, rectangleX1, rectangleY1, rectangleX2 - rectangleX1 /*rectangleWidth*/, rectangleY2 - rectangleY1 /*rectangleHeight*/)) { return CB_Collisions.isPointOverLine(x, y, segmentX1, segmentY1, segmentX2, segmentY2, tolerance); } return false; } /** * Tells whether a point is over a rectangle. * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the rectangle. * @param {number} rectangleWidth - The width of the rectangle. * @param {number} rectangleHeight - The height of the rectangle. * @returns {boolean} Returns whether the point is over the rectangle. * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. */ CB_Collisions.isPointOverRectangle = function(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight) { return (x &gt; rectangleX &amp;&amp; x &lt; rectangleX + rectangleWidth &amp;&amp; y &gt; rectangleY &amp;&amp; y &lt; rectangleY + rectangleHeight); } /** * Tells whether a point is touching (maybe over) a rectangle. This will also return true if they are adjacent (next to each other). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the rectangle. * @param {number} rectangleWidth - The width of the rectangle. * @param {number} rectangleHeight - The height of the rectangle. * @returns {boolean} Returns whether the point is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other). * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. */ CB_Collisions.isPointTouchingRectangle = function(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight) { /* if (x &gt;= rectangleX &amp;&amp; x &lt;= rectangleX + rectangleWidth) { if (y &gt;= rectangleY &amp;&amp; y &lt;= rectangleY + rectangleHeight) { return true; } } return false; */ return (x &gt;= rectangleX &amp;&amp; x &lt;= rectangleX + rectangleWidth &amp;&amp; y &gt;= rectangleY &amp;&amp; y &lt;= rectangleY + rectangleHeight); } /** * Tells whether a point is over a circle. * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the circle. * @param {number} radius - The radius of the circle. * @returns {boolean} Returns whether the point is over the circle. */ CB_Collisions.isPointOverCircle = function(x, y, centreX, centreY, radius) { //If the distance is lower than the radius, there is a collision: //return (Math.sqrt(Math.pow(centreX - x, 2) + Math.pow(centreY - y, 2)) &lt; radius); return CB_Collisions.getDistancePoints(centreX, centreY, x, y) &lt; radius; } /** * Tells whether a point is touching (maybe over) a circle. This will also return true if they are adjacent (next to each other). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the circle. * @param {number} radius - The radius of the circle. * @returns {boolean} Returns whether the point is touching (maybe over) the circle. This will also return true if they are adjacent (next to each other). */ CB_Collisions.isPointTouchingCircle = function(x, y, centreX, centreY, radius) { //If the distance is lower than the radius, there is a collision: //return (Math.sqrt(Math.pow(centreX - x, 2) + Math.pow(centreY - y, 2)) &lt; radius); return CB_Collisions.getDistancePoints(centreX, centreY, x, y) &lt;= radius; } /** * Tells whether a point is over an ellipse. * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the ellipse. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the ellipse. * @param {number} radiusX - The X (horizontal) radius of the ellipse. * @param {number} radiusY - The Y (vertical) radius of the ellipse. * @param {number} [rotation=0] - The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! * @param {boolean} [rotationUseDegrees=false] - Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! * @returns {boolean} Returns whether the point is over the ellipse. * @todo Make the &quot;rotation&quot; parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate). */ CB_Collisions.isPointOverEllipse = function(x, y, centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees) { if (typeof(rotation) === &quot;undefined&quot; || rotation === null || isNaN(rotation)) { rotation = 0; } if (rotationUseDegrees &amp;&amp; rotation !== 0) { rotation *= Math.PI / 180 } var dx = x - centreX; var dy = y - centreY; return (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) &lt; 1; } /** * Tells whether a point is touching (maybe over) a ellipse. This will also return true if they are adjacent (next to each other). * @function * @param {number} x - The &quot;X&quot; coordinate of the point. * @param {number} y - The &quot;Y&quot; coordinate of the point. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the ellipse. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the ellipse. * @param {number} radiusX - The X (horizontal) radius of the ellipse. * @param {number} radiusY - The Y (vertical) radius of the ellipse. * @param {number} [rotation=0] - The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! * @param {boolean} [rotationUseDegrees=false] - Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! * @returns {boolean} Returns whether the point is touching (maybe over) the ellipse. This will also return true if they are adjacent (next to each other). * @todo Make the &quot;rotation&quot; parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate). */ CB_Collisions.isPointTouchingEllipse = function(x, y, centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees) { if (typeof(rotation) === &quot;undefined&quot; || rotation === null || isNaN(rotation)) { rotation = 0; } if (rotationUseDegrees &amp;&amp; rotation !== 0) { rotation *= Math.PI / 180 } var dx = x - centreX; var dy = y - centreY; return (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) &lt;= 1; } /** * Tells whether a rectangle is over another rectangle. * @function * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @param {number} rectangleX2 - The &quot;X&quot; coordinate of the upper left corner of the second rectangle. * @param {number} rectangleY2 - The &quot;Y&quot; coordinate of the upper left corner of the second rectangle. * @param {number} rectangleWidth2 - The width of the second rectangle. * @param {number} rectangleHeight2 - The height of the second rectangle. * @returns {boolean} Returns whether the rectangle is over the other rectangle. * @todo Think about using &quot;rotation&quot; and &quot;rotation2&quot; parameters to accept rotated rectangles. */ CB_Collisions.isRectangleOverRectangle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) { return ( Math.max(rectangleX, rectangleX2) &lt; Math.min(rectangleX + rectangleWidth, rectangleX2 + rectangleWidth2) &amp;&amp; Math.max(rectangleY, rectangleY2) &lt; Math.min(rectangleY + rectangleHeight, rectangleY2 + rectangleHeight2) ); } /** * Tells whether a rectangle is touching (maybe over) another rectangle. This will also return true if they are adjacent (next to each other). * @function * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @param {number} rectangleX2 - The &quot;X&quot; coordinate of the upper left corner of the second rectangle. * @param {number} rectangleY2 - The &quot;Y&quot; coordinate of the upper left corner of the second rectangle. * @param {number} rectangleWidth2 - The width of the second rectangle. * @param {number} rectangleHeight2 - The height of the second rectangle. * @returns {boolean} Returns whether the rectangle is touching (maybe over) the other rectangle. This will also return true if they are adjacent (next to each other). * @todo Think about using &quot;rotation&quot; and &quot;rotation2&quot; parameters to accept rotated rectangles. */ CB_Collisions.isRectangleTouchingRectangle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) { return ( Math.max(rectangleX, rectangleX2) &lt;= Math.min(rectangleX + rectangleWidth, rectangleX2 + rectangleWidth2) &amp;&amp; Math.max(rectangleY, rectangleY2) &lt;= Math.min(rectangleY + rectangleHeight, rectangleY2 + rectangleHeight2) ); } /** * Tells whether a rectangle is over a given DOM element (it will be considered a rectangle). * @function * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @param {Element} element - The DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the rectangle is over the given DOM element (it will be considered a rectangle). * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. */ CB_Collisions.isRectangleOverElement = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isRectangleOverRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element)); } /** * Tells whether a rectangle is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). * @function * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @param {Element} element - The DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the rectangle is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. */ CB_Collisions.isRectangleTouchingElement = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isRectangleTouchingRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element)); } /** * Tells whether two given DOM elements are over each other (they will be considered a rectangle). * @function * @param {Element} element - The first DOM element that we want to check (it will be considered a rectangle). * @param {Element} element2 - The second DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the two given DOM elements are over each other (they will be considered a rectangle). */ CB_Collisions.isElementOverElement = function(element, element2) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isRectangleOverElement(CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element), element2); } /** * Tells whether two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other). * @function * @param {Element} element - The first DOM element that we want to check (it will be considered a rectangle). * @param {Element} element2 - The second DOM element that we want to check (it will be considered a rectangle). * @returns {boolean} Returns whether the two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other). */ CB_Collisions.isElementTouchingElement = function(element, element2) { if (typeof(element) === &quot;undefined&quot; || element === null) { return false; } return CB_Collisions.isRectangleTouchingElement(CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element), element2); } /** * Tells whether a circle is over another circle. * @function * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @param {number} centreX2 - The &quot;X&quot; coordinate of the center of the second circle. * @param {number} centreY2 - The &quot;Y&quot; coordinate of the center of the second circle. * @param {number} radius2 - The radius of the second circle. * @returns {boolean} Returns whether the circle is over the other circle. */ CB_Collisions.isCircleOverCircle = function(centreX, centreY, radius, centreX2, centreY2, radius2) { //return (Math.sqrt(Math.pow(centreX - centreX2, 2) + Math.pow(centreY - centreY2, 2)) &lt; radius + radius2); return CB_Collisions.getDistancePoints(centreX, centreY, centreX2, centreY2) &lt; radius + radius2; } /** * Tells whether a circle is touching (maybe over) another circle. This will also return true if they are adjacent (next to each other). * @function * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @param {number} centreX2 - The &quot;X&quot; coordinate of the center of the second circle. * @param {number} centreY2 - The &quot;Y&quot; coordinate of the center of the second circle. * @param {number} radius2 - The radius of the second circle. * @returns {boolean} Returns whether the circle is touching (maybe over) the other circle. This will also return true if they are adjacent (next to each other). */ CB_Collisions.isCircleTouchingCircle = function(centreX, centreY, radius, centreX2, centreY2, radius2) { //return (Math.sqrt(Math.pow(centreX - centreX2, 2) + Math.pow(centreY - centreY2, 2)) &lt;= radius + radius2); return CB_Collisions.getDistancePoints(centreX, centreY, centreX2, centreY2) &lt;= radius + radius2; } /** * Tells whether a circle is over a given rectangle. * @function * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @returns {boolean} Returns whether the circle is over the rectangle. * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. */ //* Source (modified): markE at https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle CB_Collisions.isRectangleOverCircle = function(centreX, centreY, radius, rectangleX, rectangleY, rectangleWidth, rectangleHeight) { var distanceX = Math.abs(centreX - rectangleX - rectangleWidth / 2); var distanceY = Math.abs(centreY - rectangleY - rectangleHeight / 2); if (distanceX &gt; rectangleWidth / 2 + radius) { return false; } if (distanceY &gt; rectangleHeight / 2 + radius) { return false; } if (distanceX &lt; rectangleWidth / 2) { return true; } if (distanceY &lt; rectangleHeight / 2) { return true; } var dx = distanceX - rectangleWidth / 2; var dy = distanceY - rectangleHeight / 2; return (dx * dx + dy * dy &lt; radius * radius); } /** * Tells whether a circle is touching (maybe over) a given rectangle. * @function * @param {number} rectangleX - The &quot;X&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleY - The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. * @param {number} rectangleWidth - The width of the first rectangle. * @param {number} rectangleHeight - The height of the first rectangle. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @returns {boolean} Returns whether the circle is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other). * @todo Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. //* Source (modified): markE at https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle */ CB_Collisions.isRectangleTouchingCircle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, centreX, centreY, radius) { var distanceX = Math.abs(centreX - rectangleX - rectangleWidth / 2); var distanceY = Math.abs(centreY - rectangleY - rectangleHeight / 2); if (distanceX &gt; rectangleWidth / 2 + radius) { return false; } if (distanceY &gt; rectangleHeight / 2 + radius) { return false; } if (distanceX &lt;= rectangleWidth / 2) { return true; } if (distanceY &lt;= rectangleHeight / 2) { return true; } var dx = distanceX - rectangleWidth / 2; var dy = distanceY - rectangleHeight / 2; return (dx * dx + dy * dy &lt;= radius * radius); } /** * Tells whether a line (infinite) is over a given circle. * @function * @param {number} lineX1 - The &quot;X&quot; coordinate of a first point of the line. * @param {number} lineY1 - The &quot;Y&quot; coordinate of a first point of the line. * @param {number} lineX2 - The &quot;X&quot; coordinate of a second point of the line. * @param {number} lineY2 - The &quot;Y&quot; coordinate of a second point of the line. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @returns {boolean} Returns whether the line (infinite) is over the circle. */ //* Source (modified): https://github.com/mattdesl/line-circle-collision CB_Collisions.isLineOverCircle = function(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius) { if (CB_Collisions.isPointOverCircle(lineX1, lineY1, centreX, centreY, radius)) { return true; } else if (CB_Collisions.isPointOverCircle(lineX2, lineY2, centreX, centreY, radius)) { return true; } var dx = lineX2 - lineX1; var dy = lineY2 - lineY1; var lcx = centreX - lineX1; var lcy = centreY - lineY1; var dLen2 = dx * dx + dy * dy; var px = dx; var py = dy; if (dLen2 &gt; 0) { var dp = (lcx * dx + lcy * dy) / dLen2; px *= dp; py *= dp; } var pLen2 = px * px + py * py; return CB_Collisions.isPointOverCircle(lineX1 + px, lineY1 + py, centreX, centreY, radius) &amp;&amp; pLen2 &lt; dLen2 &amp;&amp; (px * dx + py * dy) &gt; 0; //TODO: test it well (some equal signs removed). } /** * Tells whether a line (infinite) is touching (maybe over) a given circle. * @function * @param {number} lineX1 - The &quot;X&quot; coordinate of a first point of the line. * @param {number} lineY1 - The &quot;Y&quot; coordinate of a first point of the line. * @param {number} lineX2 - The &quot;X&quot; coordinate of a second point of the line. * @param {number} lineY2 - The &quot;Y&quot; coordinate of a second point of the line. * @param {number} centreX - The &quot;X&quot; coordinate of the center of the first circle. * @param {number} centreY - The &quot;Y&quot; coordinate of the center of the first circle. * @param {number} radius - The radius of the first circle. * @returns {boolean} Returns whether the line (infinite) is touching (maybe over) the circle. */ //* Source (modified): https://github.com/mattdesl/line-circle-collision CB_Collisions.isLineTouchingCircle = function(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius) { if (CB_Collisions.isPointTouchingCircle(lineX1, lineY1, centreX, centreY, radius)) { return true; } else if (CB_Collisions.isPointTouchingCircle(lineX2, lineY2, centreX, centreY, radius)) { return true; } var dx = lineX2 - lineX1; var dy = lineY2 - lineY1; var lcx = centreX - lineX1; var lcy = centreY - lineY1; var dLen2 = dx * dx + dy * dy; var px = dx; var py = dy; if (dLen2 &gt; 0) { var dp = (lcx * dx + lcy * dy) / dLen2; px *= dp; py *= dp; } var pLen2 = px * px + py * py; return CB_Collisions.isPointTouchingCircle(lineX1 + px, lineY1 + py, centreX, centreY, radius) &amp;&amp; pLen2 &lt;= dLen2 &amp;&amp; (px * dx + py * dy) &gt;= 0; } //Function that returns whether a line is over another line: CB_Collisions.isLineOverLine = function() { } //Function that returns whether a line segment is over another line segment: CB_Collisions.isSegmentOverSegment = function() { } //Function that returns whether a line is over a segment: CB_Collisions.isLineOverSegment = function() { } //Function that returns whether a line is over a rectangle: CB_Collisions.isLineOverRectangle = function() { } //Function that returns whether a line is over a circle: CB_Collisions.isLineOverCircle = function() { } //Function that returns whether a line segment is over a rectangle: CB_Collisions.isSegmentOverRectangle = function() { } //Function that returns whether a line segment is over a circle: CB_Collisions.isSegmentOverCircle = function() { } //Function that returns whether a line is touching (maybe over) another line: CB_Collisions.isLineTouchingLine = function() { } //Function that returns whether a line is touching (maybe over) a line segment: CB_Collisions.isLineTouchingSegment = function() { } //Function that returns whether a line is touching (maybe over) a rectangle: CB_Collisions.isLineTouchingRectangle = function() { } //Function that returns whether a line segment is touching (maybe over) a rectangle: CB_Collisions.isSegmentTouchingRectangle = function() { } //Function that returns whether a line segment is touching (maybe over) a circle: CB_Collisions.isSegmentTouchingCircle = function() { } } function lineCircleCollide(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius) { } × Search results Close "},"CrossBase_input_controllers_CB_Controllers.js.html":{"id":"CrossBase_input_controllers_CB_Controllers.js.html","title":"Source: CrossBase/input/controllers/CB_Controllers.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/controllers/CB_Controllers.js /** * @file Controllers (gamepads, joysticks, remotes, etc.) management. Contains the {@link CB_Controllers} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage different controllers (gamepads, joysticks, remotes, etc.). It will return itself if it is tried to be instantiated. It uses [gamepad-plus]{@link https://github.com/MozillaReality/gamepad-plus}. * @namespace CB_Controllers * @todo Find a way to do button mapping (so we could use names as LEFT, RIGHT, etc.) and normalization for most web clients and gamepads (without forgetting proprietary ones as WII U, etc.). * @todo Consider using always a numeric index instead of the ID of the gamepad (array instead of object), which could be a string, for CB_Controllers._gamepads (for optimization purposes). * @todo Consider modifying {@link CB_Controllers.isButtonDown} function or add a new one to check whether any button (or axes) is down or not. */ //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers = function() { return CB_Controllers; }; { CB_Controllers.initialized = false; //It will tells whether the object has been initialized or not. CB_Controllers._gamePadHaveEvents = &quot;ongamepadconnected&quot; in window; CB_Controllers._gamepads = {}; //Object that keeps the indexes of the current gamepads and the gamepad objects as their values. CB_Controllers._eventsHolder = {}; //Keeps the functions to fire for every special event (if any). //Initializes all values: CB_Controllers.init = function() { if (CB_Controllers.initialized) { return CB_Controllers; } //Initializes proprietary controllers: CB_Controllers_Proprietary[&quot;WII_U&quot;].init(); CB_Controllers_Proprietary[&quot;WII&quot;].init(); //The object has been initialized: CB_Controllers.initialized = true; //TODO: use gamepad-plus to make it compatible with more web clients (and do not forget keyEventsEnabled property). if (!CB_Controllers._gamePadHaveEvents) { var gamePadPolling = function() { CB_Controllers._gamePadScanAll(); setTimeout(gamePadPolling, 500); }; gamePadPolling(); } else { CB_Events.add(CB_Client.getWindow(), &quot;gamepadconnected&quot;, CB_Controllers._gamePadConnectHandler, true, true, false); CB_Events.add(CB_Client.getWindow(), &quot;gamepaddisconnected&quot;, CB_Controllers._gamePadDisconnectHandler, true, true, false); } return CB_Controllers; } //Handler to execute when a gamepad is connected (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadConnectHandler = function(e) { CB_Controllers._gamePadAdd(e.gamepad); } //Handler to execute when a gamepad is disconnected (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadDisconnectHandler = function(e) { CB_Controllers._gamePadRemove(e.gamepad); } //Adds a new gamepad (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadAdd = function(gamepad) { CB_Controllers._gamepads[gamepad.index] = gamepad; //See https://github.com/luser/gamepadtest/blob/master/index.html //requestAnimationFrame(CB_Controllers._gamePadUpdateAll); CB_Controllers._gamePadUpdateAll(); //If there is any, executes the desired event: if (typeof(CB_Controllers._eventsHolder[&quot;onConnect&quot;]) === &quot;function&quot;) { CB_Controllers._eventsHolder[&quot;onConnect&quot;](gamepad, CB_Controllers._gamepads); } } //Removes a gamepad (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadRemove = function(gamepad) { //CB_Controllers._gamepads[gamepad.index] = undefined; delete CB_Controllers._gamepads[gamepad.index]; //If there is any, executes the desired event: if (typeof(CB_Controllers._eventsHolder[&quot;onDisconnect&quot;]) === &quot;function&quot;) { CB_Controllers._eventsHolder[&quot;onDisconnect&quot;](gamepad, CB_Controllers._gamepads); } } //Updates the status of all gamepads, if any (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadUpdateAllTimeout = null; CB_Controllers._gamePadUpdateAll = function() { //TODO: normalize, when possible, values for different web clients and gamepads. clearTimeout(CB_Controllers._gamePadUpdateAllTimeout); if (!CB_Controllers._gamePadHaveEvents) { CB_Controllers._gamePadScanAll(); } var i = 0; for (var j in CB_Controllers._gamepads) { var controller = CB_Controllers._gamepads[j]; //for (i = 0; i &lt; controller.buttons.length; i++) for (i in controller.buttons) { if (typeof(controller.buttons[i]) !== &quot;object&quot; || controller.buttons[i] === null) { controller.buttons[i] = { value: controller.buttons[i], pressed: controller.buttons[i] == 1.0 }; } } /* for (i = 0; i &lt; controller.axes.length; i++) { var a = axes[i]; a.innerHTML = i + &quot;: &quot; + controller.axes[i].toFixed(4); a.setAttribute(&quot;value&quot;, controller.axes[i] + 1); }*/ } //requestAnimationFrame(CB_Controllers._gamePadUpdateAll); CB_Controllers._gamePadUpdateAllTimeout = setTimeout(CB_Controllers._gamePadUpdateAll, 1); } //Scans all gamepads, if any (using GamePad API): //* Source: https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API/Using_the_Gamepad_API CB_Controllers._gamePadScanAll = function() { var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : (navigator.webkitGamepads ? navigator.webkitGamepads : [])); //Looks for new connected ones: for (var i = 0; i &lt; gamepads.length; i++) { if (gamepads[i]) { //if (gamepads[i].index in CB_Controllers._gamepads) { CB_Controllers._gamepads[gamepads[i].index] = gamepads[i]; } if (typeof(CB_Controllers._gamepads[gamepads[i].index]) !== &quot;undefined&quot;) { CB_Controllers._gamepads[gamepads[i].index] = gamepads[i]; } else { CB_Controllers._gamePadAdd(gamepads[i]); } } } //Looks for disconnected ones: //for (i = 0; i &lt; CB_Controllers._gamepads.length; i++) for (i in CB_Controllers._gamepads) { if (CB_Controllers._gamepads[i]) { if (typeof(gamepads[CB_Controllers._gamepads[i].index]) === &quot;undefined&quot;) { CB_Controllers._gamePadRemove(CB_Controllers._gamepads[i]); } } } } /** * Sets a function to execute when a gamepad is connected ([&quot;onGamepadConnected&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/ongamepadconnected} event is fired) or removes it. More information: [Gamepad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the gamepad object affected and the second parameter will be an object containing all current gamepads objects (properties will be the index of each gamepad). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @todo Make it compatible with proprietary ones (if possible). */ CB_Controllers.onConnect = function(callbackFunction, keepOldFunction) { return CB_Controllers._setSpecialEventFunction(&quot;onConnect&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when a gamepad is disconnected ([&quot;onGamepadDisconnected&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/ongamepaddisconnected} event is fired) or removes it. More information: [Gamepad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the gamepad object affected and the second parameter will be an object containing all current gamepads objects (properties will be the index of each gamepad). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @todo Make it compatible with proprietary ones (if possible). */ CB_Controllers.onDisconnect = function(callbackFunction, keepOldFunction) { return CB_Controllers._setSpecialEventFunction(&quot;onDisconnect&quot;, callbackFunction, keepOldFunction); } //Sets a function to execute when an event happens (a non-existing event on JavaScript): CB_Controllers._setSpecialEventFunction = function(eventName, eventFunction, keepOldFunction) { //If no function has been sent, cancel all previous functions and exits: if (typeof(eventFunction) !== &quot;function&quot;) { if (eventFunction === null) { CB_Controllers._eventsHolder[eventName] = null; } return; } //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If we don't want to keep the old function: if (!keepOldFunction) { CB_Controllers._eventsHolder[eventName] = eventFunction; } //...otherwise if we want to keep the old function, we keep it: else { //Stores old function: var eventFunctionOld = CB_Controllers._eventsHolder[eventName]; //Stores old function of eventFunctionHolder. CB_Controllers._eventsHolder[eventName] = function(e) { if (typeof(eventFunctionOld) === &quot;function&quot;) { eventFunctionOld(e); } eventFunction(e); }; } } //Finds and returns a desired property from one or more gamepads: CB_Controllers._findProperty = function(findFunction, valueIfNotFound, gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary, extraData) { if (typeof(findFunction) !== &quot;function&quot;) { findFunction = CB_Controllers._findButtonsDown; } if (typeof(valueIfNotFound) === &quot;undefined&quot;) { valueIfNotFound = {}; } if (avoidProprietary !== true &amp;&amp; avoidProprietary !== false) { avoidProprietary = CB_Configuration[CB_BASE_NAME].CB_Controllers_avoidProprietary_DEFAULT; } gamepadId = CB_trim(gamepadId); if (gamepadId !== &quot;&quot;) { if (gamepadIdNumeric || !isNaN(gamepadId) &amp;&amp; (typeof(gamepadIdNumeric) === &quot;undefined&quot; || gamepadIdNumeric === null)) { gamepadIdNumeric = true; gamepadId = parseInt(gamepadId); } } var gamepads = CB_Controllers.getGamePads(avoidProprietary); var properties = valueIfNotFound; //If desired, just gets the buttons down from the devices compatible with the HTML5 Gamepad API: if (avoidProprietary) { properties = findFunction(gamepadId, gamepadIdNumeric, caseSensitive, gamepads, extraData); } //...otherwise, also gets from the ones which use a proprietary API: else { //Gets the buttons down from the devices compatible with the HTML5 Gamepad API: properties = findFunction(gamepadId, gamepadIdNumeric, caseSensitive, gamepads.standard.gamepads, extraData); //Adds also the buttons down from the devices which use a proprietary API: var propertiesProprietary; for (var proprietarySystem in gamepads) { if (proprietarySystem === &quot;standard&quot;) { continue; } //Just checks proprietary systems. for (var devicesType in gamepads[proprietarySystem]) { propertiesProprietary = findFunction(gamepadId, gamepadIdNumeric, caseSensitive, gamepads[proprietarySystem][devicesType], extraData); for (var propertyIndex in propertiesProprietary) { if (!properties[propertyIndex]) { properties[propertyIndex] = propertiesProprietary[propertyIndex]; } } } } } return properties; } //Returns an array with the axes from a given devices object (sub-objects returned by the CB_Controllers.getGamePads function): CB_Controllers._findAxes = function(gamepadId, gamepadIdNumeric, caseSensitive, devicesObject, extraData) { var axes = []; //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): var axesLoopLength, y; for (var x in devicesObject) { if (devicesObject[x].usingPrototype) { continue; } //Skips non-real status objects. if ( gamepadId === &quot;&quot; || gamepadIdNumeric &amp;&amp; gamepadId === parseInt(x) || !gamepadIdNumeric &amp;&amp; (caseSensitive &amp;&amp; CB_trim(devicesObject[x].id) === gamepadId || !caseSensitive &amp;&amp; CB_trim(devicesObject[x].id).toLowerCase() === gamepadId.toLowerCase()) ) { if (CB_isArray(devicesObject[x].axes)) { axesLoopLength = devicesObject[x].axes.length; for (y = 0; y &lt; axesLoopLength; y++) { if (!axes[y]) { axes[y] = devicesObject[x].axes[y]; } } } } } return axes; } /** * Gets an array with information about the status of the axes of a given gamepad (or from all if none is given). * @function * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). When more than one gamepad is checked, the first axes values found which are not zero (0) will have priority. * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {array} Returns an array with information about the status of the axes of a given gamepad (or from all if none is given). */ CB_Controllers.getAxes = function(gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary) { return CB_Controllers._findProperty(CB_Controllers._findAxes, [], gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary); } //Returns an object with the the buttons down from a given devices object (sub-objects returned by the CB_Controllers.getGamePads function): CB_Controllers._findAxesDown = function(gamepadId, gamepadIdNumeric, caseSensitive, devicesObject, extraData) { var axes = []; if (isNaN(extraData.minimumValue) || extraData.minimumValue === null) { extraData.minimumValue = 0.5; } if (isNaN(extraData.maximumValue) || extraData.maximumValue === null) { extraData.maximumValue = extraData.minimumValue &lt;= 0 ? -0.5 : 1; } if (extraData.maximumValue &lt; extraData.minimumValue) { extraData._minimumValueBackup = extraData.minimumValue; extraData.minimumValue = extraData.maximumValue; extraData.maximumValue = extraData._minimumValueBackup; } //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): var axesLoopLength, y; for (var x in devicesObject) { if (devicesObject[x].usingPrototype) { continue; } //Skips non-real status objects. if ( gamepadId === &quot;&quot; || gamepadIdNumeric &amp;&amp; gamepadId === parseInt(x) || !gamepadIdNumeric &amp;&amp; (caseSensitive &amp;&amp; CB_trim(devicesObject[x].id) === gamepadId || !caseSensitive &amp;&amp; CB_trim(devicesObject[x].id).toLowerCase() === gamepadId.toLowerCase()) ) { if (CB_isArray(devicesObject[x].axes)) { axesLoopLength = devicesObject[x].axes.length; for (y = 0; y &lt; axesLoopLength; y++) { if (!axes[y] &amp;&amp; devicesObject[x].axes[y] !== null &amp;&amp; !isNaN(devicesObject[x].axes[y]) &amp;&amp; devicesObject[x].axes[y] &gt;= extraData.minimumValue &amp;&amp; devicesObject[x].axes[y] &lt;= extraData.maximumValue) { axes[y] = devicesObject[x].axes[y]; } } } } } return axes; } /** * Gets an array with the axes pressed of a given gamepad (or from all if none is given). If more than one gamepad is pressing the same axis, it will return the value of the first one found. * @function * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). * @param {float} [minimumValue=0.5] - The minimum value (included) that the checked axis or axes must have to consider them to be pressed. * @param {float} [maximumValue=1|-0.5] - The maximum value (included) that the checked axis or axes must have to consider them to be pressed. The default value will be -0.5 if the given &quot;minimumValue&quot; is negative or zero (0) or it will be 1 otherwise. * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {Object} Returns an array with the axes pressed of a given gamepad (or from all if none is given). If more than one gamepad is pressing the same axis, it will return the value of the first one found. */ CB_Controllers.getAxesDown = function(gamepadId, minimumValue, maximumValue, gamepadIdNumeric, caseSensitive, avoidProprietary) { return CB_Controllers._findProperty(CB_Controllers._findAxesDown, [], gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary, { minimumValue: minimumValue, maximumValue: maximumValue }); } /** * Returns whether a given axis or axes are being pressed or not (accepts one index or more than one with an array). * @function * @param {integer|array} axesNumbers - Number with the index of the axis or array of numbers with the indexes of the axes that we want to check. * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). * @param {float} [minimumValue=0.5] - The minimum value (included) that the checked axis or axes must have to consider them to be pressed. * @param {float} [maximumValue=1|-0.5] - The maximum value (included) that the checked axis or axes must have to consider them to be pressed. The default value will be -0.5 if the given &quot;minimumValue&quot; is negative or zero (0) or it will be 1 otherwise. * @param {boolean} [allPressed=false] - If set to true, the function will return true only in the case that all given axes are being pressed. In the case that this parameter is set to true and the &quot;gamepadId&quot; parameter is set to an empty string, it will not have in mind whether the axes are pressed by a unique gamepad or by different ones as long as all axes are pressed. * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {boolean} If the &quot;allPressed&quot; parameter is false, returns true if the given code or any of the given codes is pressed. If the &quot;allPressed&quot; parameter is set to true, it will return true only in the case that all given axes are being pressed. In the case that the &quot;allPressed&quot; parameter is set to true and the gamepadId parameter is set to an empty string, it will not have in mind whether the axes are pressed by a unique gamepad or by different ones as long as all axes are pressed. * @todo Make it compatible with proprietary gamepads (if possible). */ CB_Controllers.isAxisDown = function(axesNumbers, gamepadId, minimumValue, maximumValue, allPressed, gamepadIdNumeric, caseSensitive, avoidProprietary) { //TODO: make it compatible with proprietary gamepads (if possible). //TODO: consider to have in mind the axis. var isDown = false; //If the parameter given is not an array, we force it to be an array: if (!CB_isArray(axesNumbers)) { axesNumbers = [axesNumbers]; } //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): var axesAll = CB_Controllers.getAxesDown(gamepadId, minimumValue, maximumValue, gamepadIdNumeric, caseSensitive, avoidProprietary); //Checks whether the buttons given are being pressed or not (checking whether all are pressed, if desired): var axesNumbersLength = axesNumbers.length; for (var x = 0; x &lt; axesNumbersLength; x++) { //If the code given is a number, it exists in the axesAll array and it is being pressed: if (typeof(axesNumbers[x]) !== &quot;undefined&quot; &amp;&amp; axesNumbers[x] !== null &amp;&amp; !isNaN(axesNumbers[x]) &amp;&amp; typeof(axesAll[axesNumbers[x]]) !== &quot;undefined&quot;) { isDown = true; if (!allPressed) { break; } //If the user does not want to know whether all are keys given are pressed, with one is enough so it exits. } //...otherwise, if the user wanted to know whether all given keys were pressed: else if (allPressed) { //Not all given keys are pressed so it exits: isDown = false; break; } } return isDown; } //Returns an object with the the buttons down from a given devices object (sub-objects returned by the CB_Controllers.getGamePads function): CB_Controllers._findButtons = function(gamepadId, gamepadIdNumeric, caseSensitive, devicesObject, extraData) { var buttons = {}; //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): for (var x in devicesObject) { if (devicesObject[x].usingPrototype) { continue; } //Skips non-real status objects. if ( gamepadId === &quot;&quot; || gamepadIdNumeric &amp;&amp; gamepadId === parseInt(x) || !gamepadIdNumeric &amp;&amp; (caseSensitive &amp;&amp; CB_trim(devicesObject[x].id) === gamepadId || !caseSensitive &amp;&amp; CB_trim(devicesObject[x].id).toLowerCase() === gamepadId.toLowerCase()) ) { for (var buttonCode in devicesObject[x].buttons) { if (typeof(devicesObject[x].buttons[buttonCode].pressed) === &quot;undefined&quot;) { continue; } //Skips properties which do not contain button objects. buttons[buttonCode] = { &quot;pressed&quot; : devicesObject[x].buttons[buttonCode].pressed, &quot;touched&quot; : devicesObject[x].buttons[buttonCode].touched, &quot;value&quot; : devicesObject[x].buttons[buttonCode].value }; } } } return buttons; } /** * Gets an object with all the buttons of a given gamepad (or from all if none is given). * @function * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {Object} Returns an object with all the buttons of a given gamepad (or from all if none is given). The indexes will be the button code and the values will be an object with information about the button (with properties such as &quot;pressed&quot;, &quot;value&quot;, etc.). */ CB_Controllers.getButtons = function(gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary) { return CB_Controllers._findProperty(CB_Controllers._findButtons, {}, gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary); } //Returns an object with the the buttons down from a given devices object (sub-objects returned by the CB_Controllers.getGamePads function): CB_Controllers._findButtonsDown = function(gamepadId, gamepadIdNumeric, caseSensitive, devicesObject, extraData) { var buttonsDown = {}; //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): for (var x in devicesObject) { if (devicesObject[x].usingPrototype) { continue; } //Skips non-real status objects. if ( gamepadId === &quot;&quot; || gamepadIdNumeric &amp;&amp; gamepadId === parseInt(x) || !gamepadIdNumeric &amp;&amp; (caseSensitive &amp;&amp; CB_trim(devicesObject[x].id) === gamepadId || !caseSensitive &amp;&amp; CB_trim(devicesObject[x].id).toLowerCase() === gamepadId.toLowerCase()) ) { for (var buttonCode in devicesObject[x].buttons) { if (devicesObject[x].buttons[buttonCode].pressed) { buttonsDown[buttonCode] = true; } } } } return buttonsDown; } /** * Gets an object with the buttons pressed of a given gamepad (or from all if none is given). * @function * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {Object} Returns an object with the buttons pressed of a given gamepad (or from all if none is given). */ CB_Controllers.getButtonsDown = function(gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary) { return CB_Controllers._findProperty(CB_Controllers._findButtonsDown, {}, gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary); } /** * Returns whether a given button or buttons are being pressed or not (accepts one key code or more than one with an array). * @function * @param {integer|array} buttonCodes - Number with the button code or array of numbers with the button codes that we want to check. * @param {integer|string} [gamepadId=&quot;&quot;] - If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). * @param {boolean} [allPressed=false] - If set to true, the function will return true only in the case that all given buttons are being pressed. In the case that this parameter is set to true and the &quot;gamepadId&quot; parameter is set to an empty string, it will not have in mind whether the buttons are pressed by a unique gamepad or by different ones as long as all buttons are pressed. * @param {boolean} [gamepadIdNumeric=false|true] - If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. * @param {boolean} [caseSensitive=false] - Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads will not be checked (performance will be faster). * @returns {boolean} If the &quot;allPressed&quot; parameter is false, returns true if the given code or any of the given codes is pressed. If the &quot;allPressed&quot; parameter is set to true, it will return true only in the case that all given buttons are being pressed. In the case that the &quot;allPressed&quot; parameter is set to true and the gamepadId parameter is set to an empty string, it will not have in mind whether the buttons are pressed by a unique gamepad or by different ones as long as all buttons are pressed. * @todo Make it compatible with proprietary gamepads (if possible). */ CB_Controllers.isButtonDown = function(buttonCodes, gamepadId, allPressed, gamepadIdNumeric, caseSensitive, avoidProprietary) { //TODO: make it compatible with proprietary gamepads (if possible). //TODO: consider to have in mind the axis. var isDown = false; //If the parameter given is not an array, we force it to be an array: if (!CB_isArray(buttonCodes)) { buttonCodes = [buttonCodes]; } //Gets the pressed buttons from the desired gamepad ID (or from all the gamepads if there is no gamepad ID given): var buttonsDown = CB_Controllers.getButtonsDown(gamepadId, gamepadIdNumeric, caseSensitive, avoidProprietary); //Checks whether the buttons given are being pressed or not (checking whether all are pressed, if desired): var buttonCodesLength = buttonCodes.length; for (var x = 0; x &lt; buttonCodesLength; x++) { //If the code given is a number, it exists in the buttonsDown array and it is being pressed: if (typeof(buttonCodes[x]) !== &quot;undefined&quot; &amp;&amp; buttonCodes[x] !== null &amp;&amp; !isNaN(buttonCodes[x]) &amp;&amp; typeof(buttonsDown[buttonCodes[x]]) !== &quot;undefined&quot; &amp;&amp; buttonsDown[buttonCodes[x]]) { isDown = true; if (!allPressed) { break; } //If the user does not want to know whether all are keys given are pressed, with one is enough so it exits. } //...otherwise, if the user wanted to know whether all given keys were pressed: else if (allPressed) { //Not all given keys are pressed so it exits: isDown = false; break; } } return isDown; } /** * Returns an object with the current gamepad objects, if any (using the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API} for non-proprietary gamepads). * @function * @param {boolean} [avoidProprietary={@link CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT}] - If set to true, proprietary gamepads which do not use the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API} (as WII, WI U gamepads, etc.) will not be included in the returning object and it will only include the ones detected by the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. Otherwise, if set to true, the returning object will contain one property called &quot;standard&quot; which will contain an object with the &quot;gamepads&quot; property with the gamepad objects that use the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API} and possibly different properties (one per each proprietary system) and inside of them an object with the &quot;gamepads&quot; property and maybe also other properties for other kind of devices which will include the status objects of those devices for each proprietary system. For gamepads that support the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}, the indexes will be the identifier for each gamepad and the value its gamepad object. For proprietary gamepads, it will contain the returning value of the &quot;getGamePads&quot; function of each proprietary API. * @returns {Object} Returns an object with the current gamepad objects, if any (using the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API} for non-proprietary gamepads). * @todo The proprietary ones should return better-normalized values to simulate the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. */ CB_Controllers.getGamePads = function(avoidProprietary) { if (avoidProprietary !== true &amp;&amp; avoidProprietary !== false) { avoidProprietary = CB_Configuration[CB_BASE_NAME].CB_Controllers_avoidProprietary_DEFAULT; } CB_Controllers._gamePadUpdateAll(); //Updates and normalizes all. if (!avoidProprietary) { //TODO: the proprietary ones should return normalize values to simulate the GamePad API. return { standard: { &quot;gamepads&quot; : CB_Controllers._gamepads }, WII_U : CB_Controllers_Proprietary[&quot;WII_U&quot;].getGamePads(), WII : CB_Controllers_Proprietary[&quot;WII&quot;].getGamePads() }; } return CB_Controllers._gamepads; } //TODO: find a way to do button mapping (so we could use names as LEFT, RIGHT, etc.) and normalization for most web clients and gamepads (without forgetting proprietary ones as WII U, etc.). } × Search results Close "},"CrossBase_input_controllers_CB_Controllers_Proprietary_WII.js.html":{"id":"CrossBase_input_controllers_CB_Controllers_Proprietary_WII.js.html","title":"Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js /** * @file Nintendo Wii remotes (Wiimotes) management. Contains the {@link CB_Controllers_Proprietary.WII} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage proprietary controller APIs. * @namespace CB_Controllers_Proprietary */ /** * Static class to manage the Nintendo Wii remotes (Wiimotes). It will return itself if it is tried to be instantiated. It uses [wii-js]{@link https://github.com/ryanmcgrath/wii-js}. NOTE: This class is still under development. * @namespace CB_Controllers_Proprietary.WII * @todo Find a way to know how to check when a button is released. * @todo Update values of CB_Controllers_Proprietary.WII._wiimotes[x].UP, etc. * @todo Do not forget x and y properties (?). */ //* Source: https://github.com/ryanmcgrath/wii-js if (typeof(CB_Controllers_Proprietary) === &quot;undefined&quot;) { var CB_Controllers_Proprietary = {}; } CB_Controllers_Proprietary.WII = function() { return CB_Controllers_Proprietary.WII; }; { CB_Controllers_Proprietary.WII.initialized = false; //It will tells whether the object has been initialized or not. //Generic template object that represents the status of a Wiimote: CB_Controllers_Proprietary.WII._wiimoteInfoTemplate = //For buttons: true = pressed, false = released, undefined = unknown. { usingPrototype: true, //This property will not exist in the case it is using the real API. connected: false, realObject: undefined, id: undefined, index: undefined, buttons: { UP: { pressed: false, touched: false, value: 0 }, DOWN: { pressed: false, touched: false, value: 0 }, LEFT: { pressed: false, touched: false, value: 0 }, RIGHT: { pressed: false, touched: false, value: 0 }, A: { pressed: false, touched: false, value: 0 }, B: { pressed: undefined, touched: false, value: 0 }, C: { pressed: undefined, touched: false, value: 0 }, Z: { pressed: undefined, touched: false, value: 0 }, _1: { pressed: false, touched: false, value: 0 }, _2: { pressed: false, touched: false, value: 0 }, PLUS: { pressed: false, touched: false, value: 0 }, MINUS: { pressed: false, touched: false, value: 0 } }, axes: [0, 0], horizontal: true, roll: undefined, distance: undefined, x: undefined, y: undefined, mapping: &quot;&quot;, timestamp: window.performance.now(), vibrationActuator: null //... maybe more properties will be added. }; CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons[&quot;ONE&quot;] = CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons[&quot;1&quot;] = CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons._1; CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons[&quot;TWO&quot;] = CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons[&quot;2&quot;] = CB_Controllers_Proprietary.WII._wiimoteInfoTemplate.buttons._2; //It will store the objects that represent the possible four Wiimotes (if any): CB_Controllers_Proprietary.WII._wiimotes = //NOTE: Using object instead of array to respect the CB_Controllers standard. { &quot;0&quot; : CB_Controllers_Proprietary.WII._wiimoteInfoTemplate, &quot;1&quot; : CB_Controllers_Proprietary.WII._wiimoteInfoTemplate, &quot;2&quot; : CB_Controllers_Proprietary.WII._wiimoteInfoTemplate, &quot;3&quot; : CB_Controllers_Proprietary.WII._wiimoteInfoTemplate }; CB_Controllers_Proprietary.WII._wiimotes[&quot;0&quot;].index = 0; CB_Controllers_Proprietary.WII._wiimotes[&quot;1&quot;].index = 1; CB_Controllers_Proprietary.WII._wiimotes[&quot;2&quot;].index = 2; CB_Controllers_Proprietary.WII._wiimotes[&quot;3&quot;].index = 3; CB_Controllers_Proprietary.WII._wiimotes[&quot;0&quot;].id = &quot;WII_REMOTE_0&quot;; CB_Controllers_Proprietary.WII._wiimotes[&quot;1&quot;].id = &quot;WII_REMOTE_1&quot;; CB_Controllers_Proprietary.WII._wiimotes[&quot;2&quot;].id = &quot;WII_REMOTE_2&quot;; CB_Controllers_Proprietary.WII._wiimotes[&quot;3&quot;].id = &quot;WII_REMOTE_3&quot;; //Initializes all values: CB_Controllers_Proprietary.WII.init = function() { if (CB_Controllers_Proprietary.WII.initialized) { return CB_Controllers_Proprietary.WII; } //The object has been initialized: CB_Controllers_Proprietary.WII.initialized = true; if (typeof(Wii) !== &quot;undefined&quot; &amp;&amp; Wii.Remote) { //Sets the events that work for all controllers: //TODO: find a way to know how to check when a button is released. //TODO: update values of CB_Controllers_Proprietary.WII._wiimotes[x].UP, etc. for (var x = 0; x &lt; 4; x++) { //NOTE: orientation scheme can be changed setting CB_Controllers_Proprietary.WII._wiimotes[index] to false. CB_Controllers_Proprietary.WII._wiimotes[x].realObject = new Wii.Remote(x + 1, {horizontal: true}); //TODO: Update &quot;timestamp&quot; property. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_up&quot;, function() { }); //&quot;UP&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_down&quot;, function() { }); //&quot;DOWN&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_left&quot;, function() { }); //&quot;LEFT&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_right&quot;, function() { }); //&quot;RIGHT&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_a&quot;, function() { }); //&quot;A&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_1&quot;, function() { /* Remember ._1 and [&quot;1&quot;] */ }); //&quot;1&quot; pressed. Note: On controller 1, this triggers a menu (read https://github.com/ryanmcgrath/wii-js). CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_2&quot;, function() { /* Remember ._2 and [&quot;2&quot;] */ }); //&quot;2&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_plus&quot;, function() { }); //&quot;PLUS&quot; (&quot;+&quot;) pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_minus&quot;, function() { }); //&quot;MINUS&quot; (&quot;-&quot;) pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;roll_change&quot;, function() { }); //The roll of the controller (balance) changed. You can get the current roll in radians with &quot;this.roll&quot;; positive is upright, negative is the other. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;distance_change&quot;, function() { }); //The distance of the wiimote (in meters) from the TV/sensor bar has changed. This event isn't totally reliable, but should work for most cases. //Events for extra controllers that do not work on the primary controller: CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_b&quot;, function() { }); //&quot;B&quot; pressed. CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_c&quot;, function() { }); //&quot;C&quot; pressed (on the Nunchuk). CB_Controllers_Proprietary.WII._wiimotes[x].realObject.when(&quot;pressed_z&quot;, function() { }); //&quot;Z&quot; pressed (on the Nunchuk). //TODO: do not forget x and y properties (?). } //Starts the main listener: Wii.listen(); } return CB_Controllers_Proprietary.WII; } /** * Returns an object with all gamepads simulating the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. * @function * @returns {Object} Returns an object with the &quot;remotes&quot; property which contains another object whose properties are the index of each device and the value an object with the status of that device. The number of remotes is 4 (index from &quot;0&quot; to &quot;3&quot;). Simulating the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. Those status objects which are not using the real API will have a property called &quot;usingPrototype&quot; set to true. */ CB_Controllers_Proprietary.WII.getGamePads = function() { //TODO: normalize all to simulate GamePad API. return { &quot;remotes&quot; : CB_Controllers_Proprietary.WII._wiimotes }; } } × Search results Close "},"CrossBase_input_controllers_CB_Controllers_Proprietary_WII_U.js.html":{"id":"CrossBase_input_controllers_CB_Controllers_Proprietary_WII_U.js.html","title":"Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js /** * @file Nintendo Wii U gamepad and remotes (Wiimotes) management. Contains the {@link CB_Controllers_Proprietary.WII_U} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the Nintendo Wii U gamepad and remotes. It will return itself if it is tried to be instantiated. NOTE: This class is still under development. * @namespace CB_Controllers_Proprietary.WII_U * @todo Function or option that returns an array with the pressed buttons (LEFT: true, L: true, R: false, etc.). Use the bitmasks of CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS and CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS. */ //* Source: http://wiiubrew.org/wiki/Internet_Browser and https://www.nintendo.com/wiiu/built-in-software/browser-specs/extended-functionality/ if (typeof(CB_Controllers_Proprietary) === &quot;undefined&quot;) { var CB_Controllers_Proprietary = {}; } CB_Controllers_Proprietary.WII_U = function() { return CB_Controllers_Proprietary.WII_U; }; { CB_Controllers_Proprietary.WII_U.initialized = false; //It will tells whether the object has been initialized or not. /** * Keeps the &quot;wiiu&quot; object (if any). * @var * @readonly * @type {Object} * @default */ CB_Controllers_Proprietary.WII_U.wiiuObject = null; /** * Keeps the last return value of the {@link CB_Controllers_Proprietary.WII_U.getGamePadStatus} function (if any). The value should be the last status object returned. * @var * @readonly * @type {Object} * @default */ CB_Controllers_Proprietary.WII_U.gamepadLastStatus = null; //Last read status for the gamepad. /** * Keeps an array with numeric indexes (should be from 0 to 7 maximum) that belong to each remote number and whose values contain the last return value of the {@link CB_Controllers_Proprietary.WII_U.getRemoteStatus} function (if any). Each value should be the last status object returned. * @var * @readonly * @type {array} * @default */ CB_Controllers_Proprietary.WII_U.remoteLastStatus = []; //Last read status for the remote. /** * Object which keeps the values for the Nintendo Wii U gamepad's buttons (bitmasks). * @memberof CB_Controllers_Proprietary.WII_U * @name GAMEPAD_BUTTONS * @constant * @type {Object} * @default * @property {number} LEFT_STICK_LEFT - LEFT on the LEFT STICK. Default action: Scroll/Pan. * @property {number} LEFT_STICK_RIGHT - RIGHT on the LEFT STICK. Default action: Scroll/Pan. * @property {number} LEFT_STICK_UP - UP on the LEFT STICK. Default action: Scroll/Pan. * @property {number} LEFT_STICK_DOWN - DOWN on the LEFT STICK. Default action: Scroll/Pan. * @property {number} LEFT_STICK_CLICK - CLICK on the LEFT STICK. Default action: Hide/show bottom toolbar. * @property {number} RIGHT_STICK_LEFT - LEFT on the RIGHT STICK. Default action: Zoom. * @property {number} RIGHT_STICK_RIGHT - RIGHT on the RIGHT STICK. Default action: Zoom. * @property {number} RIGHT_STICK_UP - UP on the RIGHT STICK. Default action: Zoom. * @property {number} RIGHT_STICK_DOWN - DOWN on the RIGHT STICK. Default action: Zoom. * @property {number} RIGHT_STICK_CLICK - CLICK on the RIGHT STICK. Default actionn: Toggle zoom in/out on center of screen. * @property {number} TV - &quot;TV&quot; button. * @property {number} A - &quot;A&quot; button. Send the &quot;Enter&quot; key (keyCode 13). * @property {number} B - &quot;B&quot; button. Default action: Back to previous page (hold B: Close current tab). * @property {number} X - &quot;X&quot; button. Default action: Toggle curtain mode. * @property {number} Y - &quot;Y&quot; button. Default action: View bookmarks. * @property {number} LEFT - LEFT button on the control pad. Default action: Select links / form fields. * @property {number} RIGHT - RIGHT button on the control pad. Default action: Select links / form fields. * @property {number} UP - UP button on the control pad. Default action: Select links / form fields. * @property {number} DOWN - DOWN button on the control pad. Default action: Select links / form fields. * @property {number} ZL - &quot;ZL&quot; button. Default action: Switch to previous tab (hold ZL+ZR: Tilt scrolling). * @property {number} ZR - &quot;ZR&quot; button. Default action: Switch to next tab (hold ZL+ZR: Tilt scrolling). * @property {number} L - &quot;L&quot; button. Default action: Back to previous page. * @property {number} R - &quot;R&quot; button. Default action: Forward to next page. * @property {number} START - &quot;START&quot; button. * @property {number} PLUS - Alias for {@link CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.START}. * @property {number} SELECT - &quot;SELECT&quot; button. * @property {number} MINUS - Alias for {@link CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.SELECT}. * @property {number} HOME - HOME button. Default action: Quit browser. */ CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS = {}; CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT_STICK_LEFT = 0x40000000; //1073741824. Default action: Scroll/Pan. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT_STICK_RIGHT = 0x20000000; //536870912. Default action: Scroll/Pan. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT_STICK_UP = 0x10000000; //268435456. Default action: Scroll/Pan. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT_STICK_DOWN = 0x08000000; //134217728. Default action: Scroll/Pan. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT_STICK_CLICK = 0x00040000; //262144. Default action: Hide/show bottom toolbar. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT_STICK_LEFT = 0x04000000; //67108864. Default action: Zoom. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT_STICK_RIGHT = 0x02000000; //33554432. Default action: Zoom. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT_STICK_UP = 0x01000000; //16777216. Default action: Zoom. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT_STICK_DOWN = 0x00800000; //8388608. Default action: Zoom. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT_STICK_CLICK = 0x00020000; //131072. Default actionn: Toggle zoom in/out on center of screen. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.TV = 0x00010000; //65536. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.A = 0x00008000; //32768. Default action: Send the &quot;Enter&quot; key (keyCode 13). CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.B = 0x00004000; //16384. Default action: Back to previous page (hold B: Close current tab). CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.X = 0x00002000; //8192. Default action: Toggle curtain mode. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.Y = 0x00001000; //4096. Default action: View bookmarks. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.LEFT = 0x00000800; //2048. Default action: Select links / form fields. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.RIGHT = 0x00000400; //1024. Default action: Select links / form fields. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.UP = 0x00000200; //512. Default action: Select links / form fields. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.DOWN = 0x00000100; //256. Default action: Select links / form fields. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.ZL = 0x00000080; //128. Default action: Switch to previous tab (hold ZL+ZR: Tilt scrolling). CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.ZR = 0x00000040; //64. Default action: Switch to next tab (hold ZL+ZR: Tilt scrolling). CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.L = 0x00000020; //32. Default action: Back to previous page. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.R = 0x00000010; //16. Default action: Forward to next page. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.START = CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.PLUS = 0x00000008; //8. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.SELECT = CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.MINUS = 0x00000004; //4. CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.HOME = 0x00000002; //2. Default action: Quit browser. /** * Object which keeps the values for the Nintendo Wii U remote's buttons (bitmasks). * @memberof CB_Controllers_Proprietary.WII_U * @name REMOTE_BUTTONS * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} A - &quot;A&quot; button. * @property {number} B - &quot;B&quot; button. * @property {number} ONE - &quot;1&quot; button. * @property {number} _1 - Alias for {@link CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.ONE}. * @property {number} 1 - Alias for {@link CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.ONE}. * @property {number} TWO - &quot;2&quot; button. * @property {number} _2 - Alias for {@link CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.TWO}. * @property {number} 2 - Alias for {@link CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.TWO}. * @property {number} PLUS - PLUS (&quot;+&quot;) button. * @property {number} MINUS - MINUS (&quot;-&quot;) button. * @property {number} HOME - HOME button. */ CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS = {}; CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.UP = 0x00000800; //2048. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.DOWN = 0x00000400; //1024. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.LEFT = 0x00000100; //256. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.RIGHT = 0x00000200; //512. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.A = 0x00000008; //8. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.B = 0x00000004; //4. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.ONE = CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS._1 = CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS[&quot;1&quot;] = 0x00000001; //1. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.TWO = CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS._2 = CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS[&quot;2&quot;] = 0x00000002; //2. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.PLUS = 0x00001000; //4096. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.MINUS = 0x00000010; //16. CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.HOME = 0x00000080; //128. //Initializes all values: CB_Controllers_Proprietary.WII_U.init = function() { if (CB_Controllers_Proprietary.WII_U.initialized) { return CB_Controllers_Proprietary.WII_U; } //The object has been initialized: CB_Controllers_Proprietary.WII_U.initialized = true; //If it does not exist any property, creates it (empty object): if (typeof(wiiu) === &quot;undefined&quot; || wiiu === null) { var wiiu = {}; } if (typeof(wiiu.gamepad) === &quot;undefined&quot; || wiiu.gamepad === null) { wiiu.gamepad = { usingPrototype: true, //This property will not exist in the case it is using the real API. //General: isDataValid: 0, //After a successful update, wiiu.gamepad.isDataValid will be set to 1. If no update has happened yet, or if the GamePad is not connected, it will be set to 0. isEnabled: 0, //If the GamePad is connected wiiu.gamepad.isEnabled will be set to 1, else it will be set to 0. //Touch screen: tpTouch: 0, //1 if touch is present. tpValidity: 3, //0 = X and Y coordinates valid, 1 = X coordinate invalid, 2 = Y coordinate invalid, 3 = X and Y coordinates invalid. tpX: undefined, //X position in screen coordinates. tpY: undefined, //Y position in screen coordinates. contentX: undefined, //X position in page coordinates. contentY: undefined, //Y position in page coordinates. //Analog sticks (from -1.0 to 1.0): lStickX: 0, //GamePad Left Control Stick X deflection. lStickY: 0, //GamePad Left Control Stick Y deflection. rStickX: 0, //GamePad Right Control Stick X deflection. rStickY: 0, //GamePad Right Control Stick Y deflection. //Buttons: hold: 0, //Bitmask (to use with properties of CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS). //Accelerometer (acceleration forces in Gs. When held level and motionless, the force of gravity will cause these variables to contain the vector (0.0, -1.0, 0.0)): accX: undefined, //Force on X (horizontal) axis. accY: undefined, //Force on Y (depth) axis. accZ: undefined, //Force on Z (vertical) axis. //Gyroscope (when the GamePad is motionless these values hover around 0.0): gyroX: undefined, //Rotation speed around X (horizontal) axis. gyroY: undefined, //Rotation speed around Y (depth) axis. gyroZ: undefined, //Rotation speed around Z (vertical) axis. //Angle (if properly calibrated, angleX and angleZ should hover around 0.0 when the GamePad is held level, but as the gyroscopes have limited range and resolution the alignment will drift with use): //Note: A change of 1.0 in these values represents a complete revolution around the specified axis. Multiple revolutions around the same axis will cause the value to continuously increase or decrease. angleX: undefined, //Rotation around X (horizontal) axis. angleY: undefined, //Rotation around Y (depth) axis. angleZ: undefined, //Rotation around Z (vertical) axis. //Orientation: //Note: This is a basis of 3 perpendicular unit vectors; each vector has length 1.0 and points along the relevant axis of the GamePad relative to an arbitrary starting orientation in three-dimensional space. //X (horizontal) axis: dirXx: undefined, dirXy: undefined, dirXz: undefined, //Y (depth) axis: dirYx: undefined, dirYy: undefined, dirYz: undefined, //Z (vertical) axis: dirZx: undefined, dirZy: undefined, dirZz: undefined }; } if (typeof(wiiu.gamepad.update) !== &quot;function&quot;) { wiiu.gamepad.update = function() { return wiiu.gamepad; }; } if (typeof(wiiu.remote) === &quot;undefined&quot; || wiiu.remote === null) { var remoteFakeObject = { usingPrototype: true, //This property will not exist in the case it is using the real API. //General: isDataValid: 0, //If the specified Wii Remote returns valid data, wiiu.remote.isDataValid will be set to 1. If no update has happened yet, or if the selected Wii Remote is not connected, it will be set to 0. //Buttons: held: 0, //Bitmask (to use with properties of CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS). //Accelerometer (acceleration forces in Gs. When held level and motionless, the force of gravity will cause these variables to contain the vector (0.0, -1.0, 0.0)): accX: undefined, //Force on X (horizontal) axis accY: undefined, //Force on Y (depth) axis accZ: undefined, //Force on Z (vertical) axis //Pointer (track the Wii Remote's cursor on the screen): setCursorViewable: function(n, enable) { return null; }, //Enable or disable the display of a Wii Remote's cursor. dpdX: undefined, //X position in screen coordinates dpdY: undefined, //Y position in screen coordinates dpdDistance: undefined, //Distance between Wii Remote and Sensor Bar contentX: undefined, //X position in page coordinates contentY: undefined, //Y position in page coordinates isCursorViewable: 0, //1 if cursor display is enabled dpdValidity: 3, //0 = X and Y coordinates valid, 1 = X coordinate invalid, 2 = Y coordinate invalid, 3 = X and Y coordinates invalid. //Motion Plus: //Note: Basis of 3 perpendicular unit vectors; Each vector has length 1.0 and points along the relevant axis of the GamePad relative to an arbitrary starting orientation in three-dimensional space. //X (horizontal) axis mplsDirXx: undefined, mplsDirXy: undefined, mplsDirXz: undefined, //Y (depth) axis mplsDirYx: undefined, mplsDirYy: undefined, mplsDirYz: undefined, //Z (vertical) axis mplsDirZx: undefined, mplsDirZy: undefined, mplsDirZz: undefined, //The following variables are also available to track the motion of the Wii Remote: mplsAngX: undefined, //Rotation around X (horizontal) axis. mplsAngY: undefined, //Rotation around Y (depth) axis. mplsAngZ: undefined, //Rotation around Z (vertical) axis. mplsVelX: undefined, //Movement speed along X (horizontal) axis. mplsVelY: undefined, //Movement speed along Y (depth) axis. mplsVelZ: undefined, //Movement speed along Z (vertical) axis. mplsRollX: undefined, //TODO: ? (Source: http://wiiubrew.org/wiki/Internet_Browser). mplsRollY: undefined //TODO: ?. }; wiiu.remote = { _devices: [remoteFakeObject] }; } if (typeof(wiiu.remote.update) !== &quot;function&quot;) { wiiu.remote.update = function(n) { return typeof(wiiu.remote._devices[n]) === &quot;undefined&quot; ? remoteFakeObject : wiiu.remote._devices[n]; }; } //Stores the object (maybe fake one): CB_Controllers_Proprietary.WII_U.wiiuObject = wiiu; //Gets the status for the first time: CB_Controllers_Proprietary.WII_U.getGamePadStatus(); return CB_Controllers_Proprietary.WII_U; } /** * Normalizes the given gamepad status object, adding missing properties. * @function * @param {object} gamepadStatusObject - The gamepad status object that we want to normalize. * @returns {Object} Returns the given gamepad status object but normalized, adding missing properties. */ CB_Controllers_Proprietary.WII_U.normalizeGamepad = function(statusObject) { if (typeof(statusObject) === &quot;undefined&quot; || statusObject === null) { statusObject = {}; } //Sets the &quot;id&quot; and &quot;index&quot; properties: statusObject.index = 0; statusObject.id = &quot;WII_U_GAMEPAD_0&quot;; //Sets its &quot;connected&quot; property: statusObject.connected = !!statusObject.isEnabled; //Updates the &quot;timestamp&quot; property if the data has been updated: if (statusObject.isDataValid) { statusObject.timestamp = window.performance.now(); } //Sets the &quot;buttons&quot; property: if (typeof(statusObject.buttons) === &quot;undefined&quot; || statusObject.buttons === null) { statusObject.buttons = {}; } for (var buttonName in CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS) { if (typeof(statusObject.buttons[buttonName]) === &quot;undefined&quot; || statusObject.buttons[buttonName] === null) { statusObject.buttons[buttonName] = {}; } statusObject.buttons[buttonName].pressed = statusObject.buttons[buttonName].touched = !!(statusObject.hold &amp; CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS[buttonName]); //statusObject.hold is a bitmask with the buttons pressed. statusObject.buttons[buttonName].value = statusObject.buttons[buttonName].pressed ? 1 : 0; } //Sets the &quot;axes&quot; property: if (typeof(statusObject.axes) === &quot;undefined&quot; || statusObject.axes === null) { statusObject.axes = [0, 0, 0, 0, 0, 0]; } //Axes for LEFT, RIGHT, UP and DOWN: statusObject.axes[0] = 0; if (statusObject.buttons.LEFT.pressed) { statusObject.axes[0] += -1; } if (statusObject.buttons.RIGHT.pressed) { statusObject.axes[0] += 1; } statusObject.axes[1] = 0; if (statusObject.buttons.UP.pressed) { statusObject.axes[1] += -1; } if (statusObject.buttons.DOWN.pressed) { statusObject.axes[1] += 1; } //Axes for LEFT, RIGHT, UP and DOWN of the LEFT STICK and their value: statusObject.axes[2] = statusObject.lStickX || 0; statusObject.buttons.LEFT_STICK_LEFT.value = 0; statusObject.buttons.LEFT_STICK_RIGHT.value = 0; if (statusObject.axes[2] &lt; 0) { statusObject.buttons.LEFT_STICK_LEFT.value = statusObject.axes[2] * -1; } else if (statusObject.axes[2] &gt; 0) { statusObject.buttons.LEFT_STICK_RIGHT.value = statusObject.axes[2]; } statusObject.axes[3] = statusObject.lStickY || 0; statusObject.buttons.LEFT_STICK_UP.value = 0; statusObject.buttons.LEFT_STICK_DOWN.value = 0; if (statusObject.axes[3] &lt; 0) { statusObject.buttons.LEFT_STICK_UP.value = statusObject.axes[3] * -1; } else if (statusObject.axes[3] &gt; 0) { statusObject.buttons.LEFT_STICK_DOWN.value = statusObject.axes[3]; } //Axes for LEFT, RIGHT, UP and DOWN of the RIGHT STICK and their value: statusObject.axes[4] = statusObject.rStickX || 0; statusObject.buttons.RIGHT_STICK_LEFT.value = 0; statusObject.buttons.RIGHT_STICK_RIGHT.value = 0; if (statusObject.axes[4] &lt; 0) { statusObject.buttons.RIGHT_STICK_LEFT.value = statusObject.axes[4] * -1; } else if (statusObject.axes[4] &gt; 0) { statusObject.buttons.RIGHT_STICK_RIGHT.value = statusObject.axes[4]; } statusObject.axes[5] = statusObject.rStickY || 0; statusObject.buttons.RIGHT_STICK_UP.value = 0; statusObject.buttons.RIGHT_STICK_DOWN.value = 0; if (statusObject.axes[5] &lt; 0) { statusObject.buttons.RIGHT_STICK_UP.value = statusObject.axes[5] * -1; } else if (statusObject.axes[5] &gt; 0) { statusObject.buttons.RIGHT_STICK_DOWN.value = statusObject.axes[5]; } //Updates the rest of the properties: statusObject.mapping = &quot;&quot;; statusObject.vibrationActuator = null; return statusObject; } /** * Normalizes the given remote status object, adding missing properties. * @function * @param {object} gamepadStatusObject - The remote status object that we want to normalize. * @param {integer} [n=0] - Number of the remote whose status we want to get, from 0 to 7 (both numbers included, 8 in total). It will be used as its identifier. * @returns {Object} Returns the given remote status object but normalized, adding missing properties. */ CB_Controllers_Proprietary.WII_U.normalizeRemote = function(statusObject, n) { if (typeof(statusObject) === &quot;undefined&quot; || statusObject === null) { statusObject = {}; } //Sets the &quot;id&quot; and &quot;index&quot; properties: statusObject.index = n ? n : 0; statusObject.id = &quot;WII_U_REMOTE_&quot; + statusObject.index; //Sets its &quot;connected&quot; property: if (!statusObject.connected) { statusObject.connected = !!statusObject.isDataValid; } //Updates the &quot;timestamp&quot; property if the data has been updated: if (statusObject.isDataValid) { statusObject.timestamp = window.performance.now(); } //Sets the &quot;buttons&quot; property: if (typeof(statusObject.buttons) === &quot;undefined&quot; || statusObject.buttons === null) { statusObject.buttons = {}; } for (var buttonName in CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS) { if (typeof(statusObject.buttons[buttonName]) === &quot;undefined&quot; || statusObject.buttons[buttonName] === null) { statusObject.buttons[buttonName] = {}; } statusObject.buttons[buttonName].pressed = statusObject.buttons[buttonName].touched = !!(statusObject.held &amp; CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS[buttonName]); //statusObject.held is a bitmask with the buttons pressed. statusObject.buttons[buttonName].value = statusObject.buttons[buttonName].pressed ? 1 : 0; } //Sets the &quot;axes&quot; property: if (typeof(statusObject.axes) === &quot;undefined&quot; || statusObject.axes === null) { statusObject.axes = [0, 0]; } //Axes for LEFT, RIGHT, UP and DOWN: statusObject.axes[0] = 0; if (statusObject.buttons.LEFT.pressed) { statusObject.axes[0] += -1; } if (statusObject.buttons.RIGHT.pressed) { statusObject.axes[0] += 1; } statusObject.axes[1] = 0; if (statusObject.buttons.UP.pressed) { statusObject.axes[1] += -1; } if (statusObject.buttons.DOWN.pressed) { statusObject.axes[1] += 1; } //Updates the rest of the properties: statusObject.mapping = &quot;&quot;; statusObject.vibrationActuator = null; return statusObject; } /** * Returns an object with the current status of each button of the gamepad. Already calls {@link CB_Controllers_Proprietary.WII_U.normalizeGamepad} automatically. * @function * @returns {Object} Returns an object with the current status of each button of the gamepad. */ CB_Controllers_Proprietary.WII_U.getGamePadStatus = function() { return CB_Controllers_Proprietary.WII_U.gamepadLastStatus = CB_Controllers_Proprietary.WII_U.normalizeGamepad(CB_Controllers_Proprietary.WII_U.wiiuObject.gamepad.update()); } /** * Returns an object with the current status of each button of the desired remote. Already calls {@link CB_Controllers_Proprietary.WII_U.normalizeRemote} automatically. * @function * @param {integer} [n=0] - Number of the remote whose status we want to get, from 0 to 7 (both numbers included, 8 in total). * @returns {Object} Returns an object with the current status of each button of the desired remote. * @todo Check documentation to see whether the first index should be 0 or 1 and maximum 7 or 8. */ CB_Controllers_Proprietary.WII_U.getRemoteStatus = function(n) { if (typeof(n) === &quot;undefined&quot; || n === null || !isNaN(n) || n &lt; 0) { n = 0; } //TODO: check documentation to see whether the minimum should be 0 or 1 and maximum 7 or 8. else if (n &gt; 8) { n = 7; } return CB_Controllers_Proprietary.WII_U.remoteLastStatus[n] = CB_Controllers_Proprietary.WII_U.normalizeRemote(CB_Controllers_Proprietary.WII_U.wiiuObject.remote.update(n), n); } /** * Returns an object with the gamepad and all remotes simulating the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. Uses the {@link CB_Controllers_Proprietary.WII_U.getRemoteStatus} and {@link CB_Controllers_Proprietary.WII_U.getRemoteStatus} internally so the objects will be normalized already. * @function * @returns {Object} Returns an object with two properties: &quot;gamepads&quot; and &quot;remotes&quot;. Each of those two properties will have an object as value whose names will be the index of the device and the value an object with the status of that device. In the case of the gamepad (which is unique), there will only be one index (&quot;0&quot;, zero). In the case of the remotes, it will contain the status objects of all the remotes. The number of remotes is 8 (index from &quot;0&quot; to &quot;7&quot;). Simulating the [GamePad API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API}. Those status objects which are not using the real API will have a property called &quot;usingPrototype&quot; set to true. * @todo Check the documentation to find out the maximum number of remotes allowed and find out whether the first index should be 0 or 1 and last one 7 or 8. */ CB_Controllers_Proprietary.WII_U.getGamePads = function() { //TODO: normalize all to simulate GamePad API. return { &quot;gamepads&quot; : { &quot;0&quot; : CB_Controllers_Proprietary.WII_U.getGamePadStatus() }, &quot;remotes&quot; : { //TODO: check the documentation to find out the maximum number of remotes allowed. &quot;0&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(0), &quot;1&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(1), &quot;2&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(2), &quot;3&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(3), &quot;4&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(4), &quot;5&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(5), &quot;6&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(6), &quot;7&quot; : CB_Controllers_Proprietary.WII_U.getRemoteStatus(7) } }; } //TODO: function or option that returns an array with the pressed buttons (LEFT: true, L: true, R: false, etc.). Use the bitmasks of CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS and CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS. } × Search results Close "},"CrossBase_device_CB_Device.js.html":{"id":"CrossBase_device_CB_Device.js.html","title":"Source: CrossBase/device/CB_Device.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/device/CB_Device.js /** * @file Device management. Contains the {@link CB_Device} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the device. It will return itself if it is tried to be instantiated. * @namespace * @todo Think about defining a parameter on many of the events to disable automatic normalization of the event object. */ var CB_Device = function() { return CB_Device; }; { CB_Device.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Device.init = function() { if (CB_Device.initialized) { return CB_Device; } //The object has been initialized: CB_Device.initialized = true; //If now() static function not available, uses getTime() method: if (!Date.now) { Date.now = function() { return new Date().getTime(); }; } //If desired and it is possible, changes the CB_Device.getTime method to use high precission: if (CB_Configuration.CrossBase.CB_Device_getTime_HIGH_PRECISION &amp;&amp; window.performance &amp;&amp; window.performance.timing &amp;&amp; window.performance.timing.navigationStart) //window.performance.now is always available (polyfilled). { CB_Device.getTime = function() { return window.performance.timing.navigationStart + window.performance.now() || Date.now(); }; } //Initializes sub-classes: CB_Device.Battery.init(); return CB_Device; } /** * Gets a timestamp in milliseconds (elapsed since 1st of January 1970 00:00:00 UTC) representing the current time. Using high precision if the {@link CB_Configuration.CrossBase.CB_Device_getTime_HIGH_PRECISION} option is true (it would return '[window.performance.timing.navigationStart]{@link https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/navigationStart} + [window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}()', where '[window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}' could be polyfilled) or normal precision otherwise (it would return '[Date.now]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now}()', where '[Date.now]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now}' could be polyfilled). * @function * @returns {integer} Returns a timestamp in milliseconds (elapsed since 1st of January 1970 00:00:00 UTC) representing the current time or zero (0) if it was not possible. */ CB_Device.getTime = function() //Can be replaced in CB_Device.init to use high precision. { return Date.now(); }; /** * Gets the time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin}. If possible, it uses [window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}, which could be polyfilled (if it is polyfilled it will not have high precision timing but, if it is not, time precision/resolution will depend on the client). * @function * @returns {number} Returns the time elapsed since the [time origin]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin}. If possible, it uses [window.performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now}, which could be polyfilled (if it is polyfilled it will not have high precision timing but, if it is not, time precision/resolution will depend on the client). */ CB_Device.getTiming = function() //Can be replaced in CB_Device.init to use high precision. { return window.performance.now(); }; //Sets a function to execute when a desired event is fired: CB_Device._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { target = window; } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { //If able, adds the function given to the event: CB_Events.add(target, eventName, eventFunction, useCapture, keepOldFunction, true); } //...but if the function given is null, it will cancel the event: else if (eventFunction === null) { CB_Events.removeByName(target, eventName); } } } //End of the static class CB_Device. /** * Static class to manage the device's location. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.Location = function() { return CB_Device.Location; }; { /** * Keeps the last watch ID that gets the location constantly. Used by the {@link CB_Device.Location.getConstantly} function. * @var * @readonly * @type {integer|null} * @default */ CB_Device.Location.getConstantly_lastId = null; /** * Keeps the &quot;WakeLock&quot; ([MozWakeLock]{@link https://developer.mozilla.org/docs/Web/API/MozWakeLock}) object to be able to release the lock related with the GPS (so far, only works in Firefox/Firefox OS). Used by the {@link CB_Device.Location.keepAwake} function. * @var * @readonly * @type {Object|null} * @default */ CB_Device.Location.keepAwake_locationLockGPS = null; /** * Keeps the callback function used when location can be gotten successfully for the {@link CB_Device.Location.get} function. * @var * @readonly * @type {function|null} * @default */ CB_Device.Location.get_callbackOk = null; /** * Keeps the callback function used when there is an error getting the location for the {@link CB_Device.Location.get} function. * @var * @readonly * @type {function|null} * @default */ CB_Device.Location.get_callbackError = null; /** * Keeps the last options used by the {@link CB_Device.Location.get} function. * @var * @readonly * @type {Object|undefined} * @default */ CB_Device.Location.get_options = undefined; /** * Keeps the callback function used when location can be gotten successfully for the {@link CB_Device.Location.getConstantly} function. * @var * @readonly * @type {function|null} * @default */ CB_Device.Location.getConstantly_callbackOk = null; /** * Keeps the callback function used when there is an error getting the location for the {@link CB_Device.Location.getConstantly} function. * @var * @readonly * @type {function|null} * @default */ CB_Device.Location.getConstantly_callbackError = null; /** * Keeps the last options used by the {@link CB_Device.Location.getConstantly} function. * @var * @readonly * @type {Object|undefined} * @default */ CB_Device.Location.getConstantly_options = undefined; /** * Tells whether the [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}) is supported or not. * @function * @returns {boolean} */ CB_Device.Location.isSupported = function() { return (window.navigator &amp;&amp; &quot;geolocation&quot; in navigator &amp;&amp; typeof(navigator.geolocation.getCurrentPosition) !== &quot;undefined&quot;); } CB_Device.Location._getFirstTime = false; /** * Gets the current position. Uses the [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}). * @function * @param {function} [callbackOk] - Callback that will be called if it gets the location successfully. Following the same rules as the first parameter of the native [getCurrentPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/getCurrentPosition} function. * @param {function} [callbackError] - Callback that will be called if there is any error getting the location. Following the same rules as the second parameter of the native [getCurrentPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/getCurrentPosition} function. * @param {Object} [options] - Object that represents the desired options. This parameter will be ignored if &quot;keepOldOptions&quot; is set to true. Following the same rules as the third parameter of the native [getCurrentPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/getCurrentPosition} function. * @param {boolean} [keepOldCallbackOk=true] - If it is set to false, it will not keep the old previous &quot;callbackOk&quot; (if any) which was/were set in previous calls to this function. * @param {boolean} [keepOldCallbackError=true] - If it is set to false, it will not keep the old previous &quot;callbackError&quot; (if any) which was/were set in previous calls to this function. * @param {boolean} [keepOldOptions=false] - If it is set to true, it will ignore the given options and it will try to use the old previous options (if any) which were set in previous calls to this function. * @returns {undefined|false} Returns false in the case that [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}) is not supported or undefined otherwise. */ CB_Device.Location.get = function(callbackOk, callbackError, options, keepOldCallbackOk, keepOldCallbackError, keepOldOptions) { if (typeof(keepOldCallbackOk) === &quot;undefined&quot; || keepOldCallbackOk === null) { keepOldCallbackOk = true; } //If not set, it keeps old ok function by default. if (typeof(keepOldCallbackError) === &quot;undefined&quot; || keepOldCallbackError === null) { keepOldCallbackError = true; } //If not set, it keeps old error function by default. if (CB_Device.Location.isSupported() &amp;&amp; typeof(callbackOk) === &quot;function&quot;) { if (!keepOldCallbackOk) { CB_Device.Location.get_callbackOk = callbackOk; } else { var callbackOkOld = CB_Device.Location.get_callbackOk; CB_Device.Location.get_callbackOk = function(locationObject) { if (typeof(callbackOkOld) === &quot;function&quot;) { callbackOkOld(locationObject); } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(locationObject); } }; } if (!keepOldCallbackError) { CB_Device.Location.get_callbackError = callbackError; } else { var callbackErrorOld = CB_Device.Location.get_callbackError; CB_Device.Location.get_callbackError = function(error) { if (typeof(callbackErrorOld) === &quot;function&quot;) { callbackErrorOld(error); } if (typeof(callbackError) === &quot;function&quot;) { callbackError(error); } }; } if (!keepOldOptions) { CB_Device.Location.get_options = options; } if (CB_Device.Location._getFirstTime === true) { CB_Device.Location._getFirstTime = false; navigator.geolocation.getCurrentPosition(function(){}, function(){}, {}); //Hack. Source: Niels Steenbeek @ http://stackoverflow.com/questions/3397585/navigator-geolocation-getcurrentposition-sometimes-works-sometimes-doesnt } return navigator.geolocation.getCurrentPosition(CB_Device.Location.get_callbackOk, CB_Device.Location.get_callbackError, CB_Device.Location.get_options); } return false; } CB_Device.Location._getConstantlyFirstTime = true; /** * Starts or stops getting the current position constantly (real-time) every time it changes. Uses the [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}). * @function * @param {function|integer} [callbackOkOrId={@link CB_Device.Location.getConstantly_lastId}] - In the case that we want to start getting the position, use a function callback that will be called every time it gets the location successfully (using the native [watchPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/watchPosition} function). To stop getting the position, use the watch ID that we want to stop (using the native [clearWatch]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/clearWatch} function). Following the same rules as the first parameter of the native [watchPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/watchPosition} function (when we want to start watching) or the first parameter of [clearWatch]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/clearWatch} function (when we want to stop watching). * @param {function} [callbackError] - Callback that will be called if there is any error getting the location. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the native [watchPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/watchPosition} function. * @param {Object} [options] - Object that represents the desired options. This parameter will be ignored if &quot;keepOldOptions&quot; is set to true. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the native [watchPosition]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/watchPosition} function. * @param {boolean} [keepOldCallbackOk=true] - If it is set to false, it will not keep the old previous &quot;callbackOk&quot; (if any) which was/were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). * @param {boolean} [keepOldCallbackError=true] - If it is set to false, it will not keep the old previous &quot;callbackError&quot; (if any) which was/were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). * @param {boolean} [keepOldOptions=false] - If it is set to true, it will ignore the given options and it will try to use the old previous options (if any) which were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). * @returns {integer|undefined|false} Returns false in the case that [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}) is not supported. In the case that we want to start getting the current position (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the position (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. */ CB_Device.Location.getConstantly = function(callbackOkOrId, callbackError, options, keepOldCallbackOk, keepOldCallbackError, keepOldOptions) { //If either callback function has been given, starts getting the position constantly: if (typeof(callbackOkOrId) === &quot;function&quot;) { if (typeof(keepOldCallbackOk) === &quot;undefined&quot; || keepOldCallbackOk === null) { keepOldCallbackOk = true; } //If not set, it keeps old ok function by default. if (typeof(keepOldCallbackError) === &quot;undefined&quot; || keepOldCallbackError === null) { keepOldCallbackError = true; } //If not set, it keeps old error function by default. if (CB_Device.Location.isSupported() &amp;&amp; typeof(navigator.geolocation.watchPosition) !== &quot;undefined&quot;) { if (!keepOldCallbackOk) { CB_Device.Location.getConstantly_callbackOk = callbackOkOrId; } else { var callbackOkOld = CB_Device.Location.getConstantly_callbackOk; CB_Device.Location.getConstantly_callbackOk = function(locationObject) { if (typeof(callbackOkOld) === &quot;function&quot;) { callbackOkOld(locationObject); } if (typeof(callbackOkOrId) === &quot;function&quot;) { callbackOkOrId(locationObject); } }; } if (!keepOldCallbackError) { CB_Device.Location.getConstantly_callbackError = callbackError; } else { var callbackErrorOld = CB_Device.Location.getConstantly_callbackError; CB_Device.Location.getConstantly_callbackError = function(error) { if (typeof(callbackErrorOld) === &quot;function&quot;) { callbackErrorOld(error); } if (typeof(callbackError) === &quot;function&quot;) { callbackError(error); } }; } if (!keepOldOptions) { CB_Device.Location.getConstantly_options = options; } if (CB_Device.Location._getConstantlyFirstTime === true) { CB_Device.Location._getConstantlyFirstTime = false; navigator.geolocation.watchPosition(function(){}, function(){}, {}); //Hack. Source: Niels Steenbeek @ http://stackoverflow.com/questions/3397585/navigator-geolocation-getcurrentposition-sometimes-works-sometimes-doesnt } CB_Device.Location.getConstantly_lastId = navigator.geolocation.watchPosition(CB_Device.Location.getConstantly_callbackOk, CB_Device.Location.getConstantly_callbackError, CB_Device.Location.getConstantly_options); return CB_Device.Location.getConstantly_lastId; } } //...otherwise, stops getting the position constantly: else { if (window.navigator &amp;&amp; &quot;geolocation&quot; in navigator &amp;&amp; typeof(navigator.geolocation.clearWatch) !== &quot;undefined&quot;) { //if (typeof(callbackOkOrId) === &quot;undefined&quot; || callbackOkOrId === null) { callbackOkOrId = CB_Device.Location.getConstantly_lastId; } if (isNaN(callbackOkOrId) || CB_trim(callbackOkOrId) === &quot;&quot;) { callbackOkOrId = CB_Device.Location.getConstantly_lastId; } return navigator.geolocation.clearWatch(callbackOkOrId); } } return false; } /** * Stops getting the current position constantly (real-time) every time it changes. Uses the [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}). * @function * @param {integer} [id={@link CB_Device.Location.getConstantly_lastId}] - The watch ID that we want to stop. Following the same rules as the first parameter of the native [clearWatch]{@link https://developer.mozilla.org/docs/Web/API/Geolocation/clearWatch} function. * @param {boolean} [keepOldCallbackOk=false] - If it is set to false, it will not remove the current &quot;callbackOk&quot; (if any) which was/were set previously. * @param {boolean} [keepOldCallbackError=false] - If it is set to false, it will remove the current &quot;callbackError&quot; (if any) which was/were set previously. * @param {boolean} [keepOldOptions=false] - If it is set to false, it will remove the current &quot;options&quot; (if any) which were set previously. * @returns {undefined|false} Returns false in the case that [Geolocation API]{@link https://developer.mozilla.org/docs/Web/API/Geolocation} (or compatible one as [Apache Cordova's Geolocation plugin]{@link https://github.com/apache/cordova-plugin-geolocation}) is not supported or undefined otherwise. */ CB_Device.Location.getConstantlyDisable = function(id, keepOldCallbackOk, keepOldCallbackError, keepOldOptions) { //if (typeof(id) === &quot;function&quot;) { id = undefined; } //Prevents calling CB_Device.Location.getConstantly with a function as parameter since that is for starting the watcher. if (isNaN(id) || !id) { id = undefined; } //Prevents calling CB_Device.Location.getConstantly with a function as parameter since that is for starting the watcher. if (!keepOldCallbackOk) { CB_Device.Location.getConstantly_callbackOk = null; } if (!keepOldCallbackError) { CB_Device.Location.getConstantly_callbackError = null; } if (!keepOldOptions) { CB_Device.Location.getConstantly_options = undefined; } return CB_Device.Location.getConstantly(id); } /** * Keeps or stops keeping the application getting the position, even when the application is invisible or screen is locked, by using [requestWakeLock]{@link https://developer.mozilla.org/docs/Web/API/Navigator/requestWakeLock} (so far, only works in Firefox/Firefox OS). * @function * @param {boolean} [keepAwake=true] - Defines whether we want to keep it awake or stop doing it. * @param {Object} [lock={@link CB_Device.Location.keepAwake_locationLockGPS}] - The &quot;WakeLock&quot; ([MozWakeLock]{@link https://developer.mozilla.org/docs/Web/API/MozWakeLock}) object that we want to unlock. It will be used only when &quot;keepAwake&quot; is set to false. * @returns {undefined|Object|false} Returns false in the case that &quot;WakeLock&quot; ([MozWakeLock]{@link https://developer.mozilla.org/docs/Web/API/MozWakeLock}) is not supported or something went wrong. Returns the &quot;WakeLock&quot; ([MozWakeLock]{@link https://developer.mozilla.org/docs/Web/API/MozWakeLock}) object in the case that we wanted to keep it awake (&quot;keepAwake&quot; is set to true). Returns undefined in the case that we do not want it to keep it awake (&quot;keepAwake&quot; is set to false and the lock is a valid &quot;WakeLock&quot; object). */ CB_Device.Location.keepAwake = function(keepAwake, lock) { if (typeof(keepAwake) === &quot;undefined&quot; || keepAwake === null) { keepAwake = true; } //If we want to lock the device to keep it awake: if (keepAwake) { if (window.navigator &amp;&amp; typeof(window.navigator.requestWakeLock) !== &quot;undefined&quot;) { CB_Device.Location.keepAwake_locationLockGPS = window.navigator.requestWakeLock(&quot;gps&quot;); //So far, only works in Firefox/Firefox OS. return CB_Device.Location.keepAwake_locationLockGPS; } } //...otherwise, if we want to release the lock that keeps the device awake: else { if (typeof(lock) === &quot;undefined&quot; || lock === null) { if (typeof(CB_Device.Location.keepAwake_locationLockGPS) !== &quot;undefined&quot; &amp;&amp; CB_Device.Location.keepAwake_locationLockGPS !== null) { lock = CB_Device.Location.keepAwake_locationLockGPS; } else { return false; } } if (typeof(lock.unlock) !== &quot;undefined&quot;) { return lock.unlock(); } //So far, only works in Firefox/Firefox OS. } return false; } } //End of the static class CB_Device.Location. /** * Static class to manage the device's orientation. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.Orientation = function() { return CB_Device.Orientation; }; { /** * Keeps the last watch ID that gets the compass heading constantly using the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation}. Used by the {@link CB_Device.Orientation.cordova_getCompassConstantly} function. * @var * @readonly * @type {integer|null} * @default */ CB_Device.Orientation.cordova_getCompassConstantly_lastId = null; /** * Tells whether the [Device Orientation Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) is supported or not. * @function * @returns {boolean} * @todo Think about using the &quot;ondeviceorientationabsolute&quot; event. */ CB_Device.Orientation.isSupported = function() { return (&quot;DeviceOrientationEvent&quot; in window || &quot;ondeviceorientation&quot; in window); } /** * Tells whether the [MozOrientation API]{@link https://developer.mozilla.org/docs/Web/Events/MozOrientation} is supported or not. * @function * @returns {boolean} */ CB_Device.Orientation.isMozOrientationSupported = function() { return (&quot;MozOrientation&quot; in window); } /** * Sets a function to execute for the [Device Orientation Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) or removes it. Falls back to the [MozOrientation API]{@link https://developer.mozilla.org/docs/Web/Events/MozOrientation} if possible. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. The event object received will already be normalized by the {@link CB_Device.Orientation.normalizeEvent} function automatically. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false} Returns false in the case that neither the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} (or compatible one) nor the [MozOrientation API]{@link https://developer.mozilla.org/docs/Web/Events/MozOrientation} are supported or undefined otherwise. * @todo Think about using the &quot;deviceorientationabsolute&quot; event. */ CB_Device.Orientation.onChange = function(eventFunction, keepOldFunction, useCapture) { if (CB_Device.Orientation.isSupported()) { return CB_Device.Orientation._setEvent(&quot;deviceorientation&quot;, eventFunction, keepOldFunction, useCapture, window); } else if (CB_Device.Orientation.isMozOrientationSupported()) { return CB_Device.Orientation._setEvent(&quot;MozOrientation&quot;, eventFunction, keepOldFunction, useCapture, window); } else { return false; } } //Sets a function to execute when a desired event is fired: CB_Device.Orientation._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { var wrapperFunction = eventFunction; if (typeof(eventFunction) === &quot;function&quot;) { wrapperFunction = function(e) { e = CB_Device.Orientation.normalizeEvent(e, eventName); return eventFunction(e); }; } CB_Device._setEvent(eventName, wrapperFunction, keepOldFunction, useCapture, target); } /** * Normalizes the data gotten from the [Device Orientation Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent} produced by different clients to try to match the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} and follow always the same rules as much as possible. * @function * @param {Event} e - The event object that we want to normalize. * @param {('deviceorientation'|'MozOrientation')} eventName - The name of the event that we want to normalize. Case sensitive. * @returns {Event} Returns the given event object again but normalized (if possible). * @todo Think about using the &quot;deviceorientationabsolute&quot; event. * @todo Normalize more differences between web clients. */ CB_Device.Orientation.normalizeEvent = function(e, eventName) { e = CB_Events.normalize(e); if (typeof(e) !== &quot;undefined&quot; &amp;&amp; e !== null) { if (eventName === &quot;deviceorientation&quot;) { if (e.webkitCompassHeading) { e.alpha = /*360 - */e.webkitCompassHeading; } //Source: https://mobiforge.com/design-development/html5-mobile-web-device-orientation-events and https://dev.opera.com/articles/w3c-device-orientation-usage/ } else if (eventName === &quot;MozOrientation&quot;) { if (!e.gamma &amp;&amp; !e.beta) //For FF3.6+ (Source: https://developer.mozilla.org/en-US/docs/Web/Events/MozOrientation) { e.gamma = -(e.x * (180 / Math.PI)); e.beta = -(e.y * (180 / Math.PI)); } } //TODO: there are still more differences between web clients! } return e; } /** * Tells whether the [Compass Needs Calibration Event]{@link https://w3c.github.io/deviceorientation/spec-source-orientation.html#compassneedscalibration} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) is supported or not. * @function * @returns {boolean} */ CB_Device.Orientation.isCompassNeedsCalibrationSupported = function() { return (&quot;CompassNeedsCalibration&quot; in window || &quot;oncompassneedscalibration&quot; in window); //return (&quot;DeviceMotionEvent&quot; in window || &quot;ondevicemotion&quot; in window); } /** * Sets a function to execute for the [Compass Needs Calibration Event]{@link https://w3c.github.io/deviceorientation/spec-source-orientation.html#compassneedscalibration} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) or removes it. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://w3c.github.io/deviceorientation/spec-source-orientation.html#compassneedscalibration}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false} Returns false in the case that the [Compass Needs Calibration Event]{@link https://w3c.github.io/deviceorientation/spec-source-orientation.html#compassneedscalibration} is not supported or undefined otherwise. */ CB_Device.Orientation.onCompassNeedsCalibration = function(eventFunction, keepOldFunction, useCapture) { if (!CB_Device.Orientation.isCompassNeedsCalibrationSupported()) { return false; } return CB_Device._setEvent(&quot;compassneedscalibration&quot;, eventFunction, keepOldFunction, useCapture, window); } /** * Tells whether the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} is available or not. * @function * @returns {boolean} */ CB_Device.Orientation.cordova_isCompassSupported = function() { return (typeof(navigator) !== &quot;undefined&quot; &amp;&amp; navigator !== null &amp;&amp; navigator.compass &amp;&amp; navigator.compass.getCurrentHeading &amp;&amp; navigator.compass.watchHeading &amp;&amp; navigator.compass.clearWatch); } /** * Gets the compass heading using the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation}. Uses &quot;navigator.compass.getCurrentHeading&quot; internally. * @function * @param {function} callbackOk - The function that will be called when it succeeds getting the compass heading. Following the same rules as in {@link https://github.com/apache/cordova-plugin-device-orientation} (&quot;navigator.compass.getCurrentHeading&quot; function). * @param {function} callbackError - The function that will be called if there is any error getting the compass heading. Following the same rules as in {@link https://github.com/apache/cordova-plugin-device-orientation} (&quot;navigator.compass.getCurrentHeading&quot; function). * @returns {undefined|false} Returns false in the case that the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} is not supported or undefined otherwise. * @todo Add a function to normalize the event and call it automatically. */ CB_Device.Orientation.cordova_getCompass = function(callbackOk, callbackError) { if (!CB_Device.Orientation.cordova_isCompassSupported()) { return false; } navigator.compass.getCurrentHeading(callbackOk, callbackError); } /** * Starts or stops getting the compass heading constantly at a regular interval. Uses the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} (&quot;navigator.compass.watchHeading&quot; and &quot;navigator.compass.clearWatch&quot; functions). * @function * @param {function|integer} [callbackOkOrId={@link CB_Device.Orientation.cordova_getCompassConstantly_lastId}] - In the case that we want to start getting the compass heading, use a function callback that will be called regularly when the compass heading is gotten successfully (using the &quot;navigator.compass.watchHeading&quot; function). To stop getting the compass heading, use the watch ID that we want to stop (using the &quot;navigator.compass.clearWatch&quot; function). Following the same rules as the first parameter of the &quot;navigator.compass.watchHeading&quot; function (when we want to start watching) or the first parameter of &quot;navigator.compass.clearWatch&quot; function (when we want to stop watching) described in {@link https://github.com/apache/cordova-plugin-device-orientation}. * @param {function} [callbackError] - Callback that will be called if there is any error getting the compass heading. Only used when we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the &quot;navigator.compass.watchHeading&quot; function described in {@link https://github.com/apache/cordova-plugin-device-orientation}. * @param {Object} [options] - Object that represents the desired options. Only used when we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the &quot;navigator.compass.watchHeading&quot; function described in {@link https://github.com/apache/cordova-plugin-device-orientation}. * @returns {integer|undefined|false} Returns false in the case that [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} is not supported. In the case that we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the compass heading (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. * @todo Add a function to normalize the event and call it automatically. * @todo Add parameters to keep old callbacks and options. */ CB_Device.Orientation.cordova_getCompassConstantly = function(callbackOkOrId, callbackError, options) //Note: options can be an object with two optional properties (&quot;frequency&quot; and &quot;filter&quot;). { if (!CB_Device.Orientation.cordova_isCompassSupported()) { return false; } //If either callback function has been given, starts getting the compass heading constantly: if (typeof(callbackOkOrId) === &quot;function&quot;) { CB_Device.Orientation.cordova_getCompassConstantly_lastId = navigator.compass.watchHeading(callbackOkOrId, callbackError, options); return CB_Device.Orientation.cordova_getCompassConstantly_lastId; } //...otherwise, stops getting the compass heading constantly: else { //if (typeof(callbackOkOrId) === &quot;undefined&quot; || callbackOkOrId === null) { callbackOkOrId = CB_Device.Orientation.cordova_getCompassConstantly_lastId; } if (isNaN(callbackOkOrId) || CB_trim(callbackOkOrId) === &quot;&quot;) { callbackOkOrId = CB_Device.Orientation.cordova_getCompassConstantly_lastId; } navigator.compass.clearWatch(callbackOkOrId); return; } return false; } /** * Stops getting the compass heading constantly at a regular interval. Uses the [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} (&quot;navigator.compass.clearWatch&quot; function). * @function * @param {integer} [id={@link CB_Device.Orientation.cordova_getCompassConstantly_lastId}] - The watch ID that we want to stop. Following the same rules as the first parameter of the &quot;navigator.compass.clearWatch&quot; function described in {@link https://github.com/apache/cordova-plugin-device-orientation}. * @returns {undefined|false} Returns false in the case that [Apache Cordova's Device Orientation plugin]{@link https://github.com/apache/cordova-plugin-device-orientation} is not supported or undefined otherwise. * @todo Add parameters to keep old callbacks and options. */ CB_Device.Orientation.cordova_getCompassConstantlyDisable = function(id) { if (typeof(id) === &quot;function&quot;) { id = undefined; } //Prevents calling CB_Device.Orientation.cordova_getCompassConstantly with a function as parameter since that is for starting the watcher. return CB_Device.Orientation.cordova_getCompassConstantly(id); } } //End of the static class CB_Device.Orientation. /** * Static class to manage the device's motion. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.Motion = function() { return CB_Device.Motion; }; { /** * Keeps the last watch ID that gets the acceleration constantly using the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion}. Used by the {@link CB_Device.Motion.cordova_getAccelerationConstantly} function. * @var * @readonly * @type {integer|null} * @default */ CB_Device.Motion.cordova_getAccelerationConstantly_lastId = null; /** * Tells whether the [Device Motion Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) is supported or not. * @function * @returns {boolean} */ CB_Device.Motion.isSupported = function() { return (&quot;DeviceMotionEvent&quot; in window || &quot;ondevicemotion&quot; in window); } /** * Sets a function to execute for the [Device Motion Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent} (used by the [Device Orientation API]{@link https://developer.mozilla.org/docs/Web/API/Detecting_device_orientation} or compatible one) or removes it. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false} Returns false in the case that the [Device Motion Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent} is not supported or undefined otherwise. */ CB_Device.Motion.onChange = function(eventFunction, keepOldFunction, useCapture) { if (!CB_Device.Motion.isSupported()) { return false; } return CB_Device._setEvent(&quot;devicemotion&quot;, eventFunction, keepOldFunction, useCapture, window); } /** * Tells whether the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} is available or not. * @function * @returns {boolean} */ CB_Device.Motion.cordova_isAccelerationSupported = function() { return (typeof(navigator) !== &quot;undefined&quot; &amp;&amp; navigator !== null &amp;&amp; navigator.accelerometer &amp;&amp; navigator.accelerometer.getCurrentAcceleration &amp;&amp; navigator.accelerometer.watchAcceleration &amp;&amp; navigator.accelerometer.clearWatch); } /** * Gets the acceleration using the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion}. Uses &quot;navigator.accelerometer.getCurrentAcceleration&quot; internally. * @function * @param {function} callbackOk - The function that will be called when it succeeds getting the acceleration. The event object received will already be normalized by the {@link CB_Device.Motion.cordova_getAccelerationNormalized} function automatically. Following the same rules as in {@link https://github.com/apache/cordova-plugin-device-motion} (&quot;navigator.accelerometer.getCurrentAcceleration&quot; function). * @param {function} callbackError - The function that will be called if there is any error getting the acceleration. Following the same rules as in {@link https://github.com/apache/cordova-plugin-device-motion} (&quot;navigator.accelerometer.getCurrentAcceleration&quot; function). * @returns {undefined|false} Returns false in the case that the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} is not supported or undefined otherwise. */ CB_Device.Motion.cordova_getAcceleration = function(callbackOk, callbackError) { if (!CB_Device.Motion.cordova_isAccelerationSupported()) { return false; } var callbackOkWrapper = function(e) { e = CB_Device.Motion.cordova_getAccelerationNormalized(e); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(e); } } //Normalizes the event. navigator.accelerometer.getCurrentAcceleration(callbackOkWrapper, callbackError); } /** * Starts or stops getting the acceleration constantly at a regular interval. Uses the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} (&quot;navigator.accelerometer.watchAcceleration&quot; and &quot;navigator.accelerometer.clearWatch&quot; functions). * @function * @param {function|integer} [callbackOkOrId={@link CB_Device.Motion.cordova_getAccelerationConstantly_lastId}] - In the case that we want to start getting the acceleration, use a function callback that will be called regularly when the acceleration is gotten successfully (using the &quot;navigator.accelerometer.watchAcceleration&quot; function) and the event object received will already be normalized by the {@link CB_Device.Motion.cordova_getAccelerationNormalized} function automatically. To stop getting the acceleration, use the watch ID that we want to stop (using the &quot;navigator.accelerometer.clearWatch&quot; function). Following the same rules as the first parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function (when we want to start watching) or the first parameter of &quot;navigator.accelerometer.clearWatch&quot; function (when we want to stop watching) described in {@link https://github.com/apache/cordova-plugin-device-motion}. * @param {function} [callbackError] - Callback that will be called if there is any error getting the acceleration. Only used when we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function described in {@link https://github.com/apache/cordova-plugin-device-motion}. * @param {Object} [options] - Object that represents the desired options. Only used when we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function described in {@link https://github.com/apache/cordova-plugin-device-motion}. * @returns {integer|undefined|false} Returns false in the case that [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} is not supported. In the case that we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the acceleration (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. * @todo Add parameters to keep old callbacks and options. */ CB_Device.Motion.cordova_getAccelerationConstantly = function(callbackOkOrId, callbackError, options) //Note: options can be an object with an optional property (&quot;frequency&quot;). { if (!CB_Device.Motion.cordova_isAccelerationSupported()) { return false; } //If either callback function has been given, starts getting the acceleration constantly: if (typeof(callbackOkOrId) === &quot;function&quot;) { var callbackOkOrIdWrapper = function(e) { e = CB_Device.Motion.cordova_getAccelerationNormalized(e); if (typeof(callbackOkOrId) === &quot;function&quot;) { callbackOkOrId(e); } } //Normalizes the event. CB_Device.Motion.cordova_getAccelerationConstantly_lastId = navigator.accelerometer.watchAcceleration(callbackOkOrIdWrapper, callbackError, options); return CB_Device.Motion.cordova_getAccelerationConstantly_lastId; } //...otherwise, stops getting the acceleration constantly: else { //if (typeof(callbackOkOrId) === &quot;undefined&quot; || callbackOkOrId === null) { callbackOkOrId = CB_Device.Motion.cordova_getAccelerationConstantly_lastId; } if (isNaN(callbackOkOrId) || CB_trim(callbackOkOrId) === &quot;&quot;) { callbackOkOrId = CB_Device.Motion.cordova_getAccelerationConstantly_lastId; } navigator.accelerometer.clearWatch(callbackOkOrId); return; } return false; } /** * Stops getting the acceleration constantly at a regular interval. Uses the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} (&quot;navigator.accelerometer.clearWatch&quot; function). * @function * @param {integer} [id={@link CB_Device.Motion.cordova_getAccelerationConstantly_lastId}] - The watch ID that we want to stop. Following the same rules as the first parameter of the &quot;navigator.accelerometer.clearWatch&quot; function described in {@link https://github.com/apache/cordova-plugin-device-motion}. * @returns {undefined|false} Returns false in the case that [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} is not supported or undefined otherwise. * @todo Add parameters to keep old callbacks and options. */ CB_Device.Motion.cordova_getAccelerationConstantlyDisable = function(id) { if (typeof(id) === &quot;function&quot;) { id = undefined; } //Prevents calling CB_Device.Motion.cordova_getAccelerationConstantly with a function as parameter since that is for starting the watcher. return CB_Device.Motion.cordova_getAccelerationConstantly(id); } /** * Normalizes the data gotten from the [Apache Cordova's Device Motion plugin]{@link https://github.com/apache/cordova-plugin-device-motion} to try to match the [Device Motion Event]{@link https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent} and follow always the same rules as much as possible. * @function * @param {Object} accelerometerData - The acceleration object that we want to normalize. * @returns {Event} Returns the given acceleration object again but normalized (if possible). * @todo Normalize the values without gravity too (accelerometerData.acceleration.x, accelerometerData.acceleration.y, accelerometerData.acceleration.z) if possible (needs gyroscope probably) and maybe more properties. */ CB_Device.Motion.cordova_getAccelerationNormalized = function(accelerometerData) { if (typeof(accelerometerData) !== &quot;undefined&quot; &amp;&amp; accelerometerData !== null) { if (typeof(accelerometerData.accelerationIncludingGravity) === &quot;undefined&quot; || accelerometerData.accelerationIncludingGravity === null) { accelerometerData.accelerationIncludingGravity = {}; if (typeof(accelerometerData.x) !== &quot;undefined&quot;) { accelerometerData.accelerationIncludingGravity.x = accelerometerData.x; } if (typeof(accelerometerData.y) !== &quot;undefined&quot;) { accelerometerData.accelerationIncludingGravity.y = accelerometerData.y; } if (typeof(accelerometerData.z) !== &quot;undefined&quot;) { accelerometerData.accelerationIncludingGravity.z = accelerometerData.z; } } //TODO: normalize the values without gravity too (accelerometerData.acceleration.x, accelerometerData.acceleration.y, accelerometerData.acceleration.z) if possible (needs gyroscope probably) and maybe more properties. } return accelerometerData; } } //End of the static class CB_Device.Motion. /** * Static class to manage the device's battery. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.Battery = function() { return CB_Device.Battery; }; { CB_Device.Battery._cordova_level = null; //Keeps the battery level for Apache Cordova. CB_Device.Battery._cordova_isPlugged = null; //Keeps whether the device is plugged in or not for Apache Cordova. //Initializes all values: CB_Device.Battery.init = function() { //Adds the event listener to let Apache Cordova get the battery level: CB_Events.add(window, &quot;batterystatus&quot;, function(batteryStatus) { CB_Device.Battery._cordova_level = batteryStatus.level; CB_Device.Battery._cordova_isPlugged = batteryStatus.isPlugged; }, true, true, false); } /** * Tells whether the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is available or not. * @function * @returns {boolean} */ CB_Device.Battery.isSupported = function() { return !!(window.navigator &amp;&amp; (typeof(navigator.getBattery) === &quot;function&quot; || navigator.battery || navigator.webkitBattery || navigator.mozBattery || navigator.msBattery)); } /** * Gets the battery object ([BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager}) using the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) if available or falling back to [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status} emulating the object if possible or a fake object otherwise. It could be synchronous or asynchronous depending on the client. &lt;br /&gt; When the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available, the generated object will always contain null values for the &quot;onchargingchange&quot;, &quot;onchargingtimechage&quot;, &quot;ondischargingtimechange&quot; and &quot;onlevelchange&quot; properties. The &quot;charging&quot; and &quot;level&quot; properties will be tried to be calculated by using [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status} if possible. &lt;br /&gt; The return will be synchronous only when [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is not available. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final battery object (real or fake). * @function * @param {function} [callbackOk] - The callback function that will be called once the final battery object (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final battery object (due the fact that some clients will execute the function asynchronously). * @param {boolean} [chargingOnFail] - Desired value for the &quot;charging&quot; property of the fake battery object when neither the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) nor [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status} are available. It should follow the same rules as the real property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @param {float} [levelOnFail] - Desired value for the &quot;level&quot; property of the fake battery object when neither the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) nor [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status} are available. It should follow the same rules as the real property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @param {integer} [chargingTimeOnFail] - Desired value for the &quot;chargingTime&quot; property of the fake battery object when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. It should follow the same rules as the real property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @param {integer} [dischargingTimeOnFail] - Desired value for the &quot;dischargingTime&quot; property of the fake battery object when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. It should follow the same rules as the real property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @returns {Object|Promise} Returns the battery object (fake or real) synchronously only when the native [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is not available. Otherwise it returns a [Promise]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise} (the result of calling [navigator.getBattery()]{@link https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery}.then(callbackOk)). It is highly recommended to ignore this returned value. */ CB_Device.Battery.get = function(callbackOk, chargingOnFail, levelOnFail, chargingTimeOnFail, dischargingTimeOnFail) { var batteryObject = null; if (window.navigator) { if (typeof(navigator.getBattery) === &quot;function&quot;) { return navigator.getBattery().then(callbackOk); } else if (typeof(navigator.battery) !== &quot;undefined&quot;) { batteryObject = navigator.battery; } else if (typeof(navigator.webkitBattery) !== &quot;undefined&quot;) { batteryObject = navigator.webkitBattery; } else if (typeof(navigator.mozBattery) !== &quot;undefined&quot;) { batteryObject = navigator.mozBattery; } else if (typeof(navigator.msBattery) !== &quot;undefined&quot;) { batteryObject = navigator.msBattery; } } if (typeof(batteryObject) === &quot;undefined&quot; || batteryObject === null) { batteryObject = { &quot;charging&quot; : typeof(CB_Device.Battery._cordova_isPlugged) !== &quot;undefined&quot; &amp;&amp; CB_Device.Battery._cordova_isPlugged !== null ? CB_Device.Battery._cordova_isPlugged : chargingOnFail, &quot;level&quot; : typeof(CB_Device.Battery._cordova_level) !== &quot;undefined&quot; &amp;&amp; CB_Device.Battery._cordova_level !== null &amp;&amp; !isNaN(CB_Device.Battery._cordova_level) ? CB_Device.Battery._cordova_level / 100 : levelOnFail, &quot;chargingTime&quot; : chargingTimeOnFail, &quot;dischargingTime&quot; : dischargingTimeOnFail, &quot;onchargingchange&quot; : null, &quot;onchargingtimechage&quot; : null, &quot;ondischargingtimechange&quot; : null, &quot;onlevelchange&quot; : null }; } if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(batteryObject); } return batteryObject; } /** * Returns whether the battery is charging or not. Using the {@link CB_Device.Battery.get} function internally. It could be synchronous or asynchronous depending on the client. &lt;br /&gt; The return will be synchronous only sometimes (when it is asynchronous it will just return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}), following the same rules as the {@link CB_Device.Battery.get} function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). * @function * @param {function} [callbackOk] - The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). * @param {boolean} [valueOnFail] - Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;charging&quot; property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @returns {boolean|Promise} Returns the desired value only when the function is executed synchronously (following the same rules as the {@link CB_Device.Battery.get} function which is called internally). It is highly recommended to ignore this returned value. */ CB_Device.Battery.isCharging = function(callbackOk, valueOnFail) { var objectOrPromise = CB_Device.Battery.get(function(batteryObject) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(batteryObject.charging); } }, valueOnFail); if (typeof(objectOrPromise) !== &quot;undefined&quot; &amp;&amp; objectOrPromise !== null &amp;&amp; typeof(objectOrPromise.charging) !== &quot;undefined&quot;) { return objectOrPromise.charging; } return objectOrPromise; } /** * Returns tha current charging level of the battery. Using the {@link CB_Device.Battery.get} function internally. It could be synchronous or asynchronous depending on the client. &lt;br /&gt; The return will be synchronous only sometimes (when it is asynchronous it will just return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}), following the same rules as the {@link CB_Device.Battery.get} function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). * @function * @param {function} [callbackOk] - The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). * @param {float} [valueOnFail] - Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;level&quot; property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @returns {float|Promise} Returns the desired value only when the function is executed synchronously (following the same rules as the {@link CB_Device.Battery.get} function which is called internally). It is highly recommended to ignore this returned value. */ CB_Device.Battery.getLevel = function(callbackOk, valueOnFail) { var objectOrPromise = CB_Device.Battery.get(function(batteryObject) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(batteryObject.level); } }, undefined, valueOnFail).level; if (typeof(objectOrPromise) !== &quot;undefined&quot; &amp;&amp; objectOrPromise !== null &amp;&amp; typeof(objectOrPromise.level) !== &quot;undefined&quot;) { return objectOrPromise.level; } return objectOrPromise; } /** * Returns the time (in seconds) that the battery needs to be completely charged. Using the {@link CB_Device.Battery.get} function internally. It could be synchronous or asynchronous depending on the client. &lt;br /&gt; The return will be synchronous only sometimes (when it is asynchronous it will just return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}), following the same rules as the {@link CB_Device.Battery.get} function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). * @function * @param {function} [callbackOk] - The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). * @param {integer} [valueOnFail] - Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;chargingTime&quot; property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @returns {integer|Promise} Returns the desired value only when the function is executed synchronously (following the same rules as the {@link CB_Device.Battery.get} function which is called internally). It is highly recommended to ignore this returned value. */ CB_Device.Battery.getChargingTime = function(callbackOk, valueOnFail) { var objectOrPromise = CB_Device.Battery.get(function(batteryObject) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(batteryObject.chargingTime); } }, undefined, undefined, valueOnFail).chargingTime; if (typeof(objectOrPromise) !== &quot;undefined&quot; &amp;&amp; objectOrPromise !== null &amp;&amp; typeof(objectOrPromise.chargingTime) !== &quot;undefined&quot;) { return objectOrPromise.chargingTime; } return objectOrPromise; } /** * Returns the time (in seconds) that the battery needs to be completely discharged (or when the device will shutdown, depending on the client). Using the {@link CB_Device.Battery.get} function internally. It could be synchronous or asynchronous depending on the client. &lt;br /&gt; The return will be synchronous only sometimes (when it is asynchronous it will just return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}), following the same rules as the {@link CB_Device.Battery.get} function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). * @function * @param {function} [callbackOk] - The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). * @param {integer} [valueOnFail] - Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;dischargingTime&quot; property of the [BatteryManager]{@link https://developer.mozilla.org/docs/Web/API/BatteryManager} object. * @returns {integer|Promise} Returns the desired value only when the function is executed synchronously (following the same rules as the {@link CB_Device.Battery.get} function which is called internally). It is highly recommended to ignore this returned value. */ CB_Device.Battery.getDischargingTime = function(callbackOk, valueOnFail) { var objectOrPromise = CB_Device.Battery.get(function(batteryObject) { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(batteryObject.dischargingTime); } }, undefined, undefined, undefined, valueOnFail).dischargingTime; if (typeof(objectOrPromise) !== &quot;undefined&quot; &amp;&amp; objectOrPromise !== null &amp;&amp; typeof(objectOrPromise.dischargingTime) !== &quot;undefined&quot;) { return objectOrPromise.dischargingTime; } return objectOrPromise; } /** * Sets a function to execute when the &quot;onchargingchange&quot; event of the battery is fired or removes it. This should happen whenever the charging status changes (is charging now but before it was not or vice versa). Using the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one). * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/Events/chargingchange}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false|Promise} Returns false when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. Returns a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} when the native [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is available. Otherwise, it returns undefined. */ CB_Device.Battery.onChargingChange = function(eventFunction, keepOldFunction, useCapture) { return CB_Device.Battery._setEvent(&quot;chargingchange&quot;, eventFunction, keepOldFunction, useCapture) } /** * Sets a function to execute when the &quot;onchargingtimechage&quot; event of the battery is fired or removes it. This should happen whenever the charging time changes. Using the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one). * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/Events/chargingtimechange}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false|Promise} Returns false when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. Returns a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} when the native [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is available. Otherwise, it returns undefined. */ CB_Device.Battery.onChargingTimeChange = function(eventFunction, keepOldFunction, useCapture) { return CB_Device.Battery._setEvent(&quot;chargingtimechage&quot;, eventFunction, keepOldFunction, useCapture) } /** * Sets a function to execute when the &quot;ondischargingtimechange&quot; event of the battery is fired or removes it. This should happen whenever the discharging time changes. Using the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one). * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/Events/dischargingtimechange}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false|Promise} Returns false when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. Returns a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} when the native [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is available. Otherwise, it returns undefined. */ CB_Device.Battery.onDischargingTimeChange = function(eventFunction, keepOldFunction, useCapture) { return CB_Device.Battery._setEvent(&quot;dischargingtimechange&quot;, eventFunction, keepOldFunction, useCapture) } /** * Sets a function to execute when the &quot;onlevelchange&quot; event of the battery is fired or removes it. This should happen when the battery level changes. Using the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one). * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://developer.mozilla.org/docs/Web/Events/levelchange}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @returns {undefined|false|Promise} Returns false when the [Battery Status API]{@link https://developer.mozilla.org/docs/Web/API/Battery_Status_API} (or compatible one) is not available. Returns a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} when the native [getBattery]{@link https://developer.mozilla.org/docs/Web/API/Navigator/getBattery} function is available. Otherwise, it returns undefined. */ CB_Device.Battery.onLevelChange = function(eventFunction, keepOldFunction, useCapture) { return CB_Device.Battery._setEvent(&quot;levelchange&quot;, eventFunction, keepOldFunction, useCapture) } //Sets an event for the Battery Status API (Battery API): CB_Device.Battery._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture) { if (!CB_Device.Battery.isSupported()) { return false; } if (window.navigator &amp;&amp; typeof(navigator.getBattery) === &quot;function&quot;) { return navigator.getBattery().then ( function(batteryObject) { CB_Device._setEvent ( eventName, function(e) { if (typeof(eventFunction) === &quot;function&quot;) { eventFunction(batteryObject, eventName, e); } }, keepOldFunction, useCapture, batteryObject ); } ); } var eventFunctionWrapper = eventFunction; if (typeof(eventFunction) === &quot;function&quot;) { eventFunctionWrapper = function(e) { eventFunction(CB_Device.Battery.get(), eventName, e); }; } return CB_Device._setEvent(eventName, eventFunctionWrapper, keepOldFunction, useCapture, navigator.battery || navigator.webkitBattery || navigator.mozBattery || navigator.msBattery); } /** * Sets a function to execute when the &quot;batterystatus&quot; event of the battery is fired or removes it. Using the [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status}. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://github.com/apache/cordova-plugin-battery-status}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Device.Battery.cordova_onChange = function(eventFunction, keepOldFunction, useCapture) { return CB_Device._setEvent(&quot;batterystatus&quot;, eventFunction, keepOldFunction, useCapture, window); } /** * Sets a function to execute when the &quot;batterylow&quot; event of the battery is fired or removes it. Using the [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status}. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://github.com/apache/cordova-plugin-battery-status}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Device.Battery.cordova_onLow = function(eventFunction, keepOldFunction, useCapture) { return CB_Device._setEvent(&quot;batterylow&quot;, eventFunction, keepOldFunction, useCapture, window); } /** * Sets a function to execute when the &quot;batterycritical&quot; event of the battery is fired or removes it. Using the [Apache Cordova's Battery Status plugin]{@link https://github.com/apache/cordova-plugin-battery-status}. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. Following the same rules as in {@link https://github.com/apache/cordova-plugin-battery-status}. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. */ CB_Device.Battery.cordova_onCritical = function(eventFunction, keepOldFunction, useCapture) { return CB_Device._setEvent(&quot;batterycritical&quot;, eventFunction, keepOldFunction, useCapture, window); } } //End of the static class CB_Device.Battery. /** * Static class to manage the device's vibration. It will return itself if it is tried to be instantiated. * @namespace */ CB_Device.Vibration = function() { return CB_Device.Vibration; }; { /** * Tells whether the [Vibration API]{@link https://developer.mozilla.org/docs/Web/API/Vibration_API} (or compatible one as [Apache Cordova's Vibration plugin]{@link https://github.com/apache/cordova-plugin-vibration}) is available or not. * @function * @returns {boolean} */ CB_Device.Vibration.isSupported = function() { return (window.navigator &amp;&amp; &quot;vibrate&quot; in navigator &amp;&amp; typeof(navigator.vibrate) === &quot;function&quot;); } /** * Makes the device vibrate using the [Vibration API]{@link https://developer.mozilla.org/docs/Web/API/Vibration_API} (or compatible one as [Apache Cordova's Vibration plugin]{@link https://github.com/apache/cordova-plugin-vibration}). * @function * @param {integer|array} [vibration] - The vibration pattern which can be either a single integer value or an array of integers. Following the same rules as the first parameter of the native [vibrate]{@link https://developer.mozilla.org/docs/Web/API/Navigator/vibrate} function. * @returns {undefined|false} Returns false in the case that [Vibration API]{@link https://developer.mozilla.org/docs/Web/API/Vibration_API} (or compatible one as [Apache Cordova's Vibration plugin]{@link https://github.com/apache/cordova-plugin-vibration}) cannot be used or undefined otherwise. */ CB_Device.Vibration.start = function(vibration) { navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate; if (navigator.vibrate) { return navigator.vibrate(vibration); } return false; } /** * Makes the device stop vibrating using the [Vibration API]{@link https://developer.mozilla.org/docs/Web/API/Vibration_API} (or compatible one as [Apache Cordova's Vibration plugin]{@link https://github.com/apache/cordova-plugin-vibration}). * @function * @returns {undefined|false} Returns false in the case that [Vibration API]{@link https://developer.mozilla.org/docs/Web/API/Vibration_API} (or compatible one as [Apache Cordova's Vibration plugin]{@link https://github.com/apache/cordova-plugin-vibration}) cannot be used or undefined otherwise. */ CB_Device.Vibration.stop = function() { return CB_Device.Vibration.start(0); } } //End of the static class CB_Device.Vibration. /** * Static class to manage the device's ambient light sensor. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.AmbientLight = function() { return CB_Device.AmbientLight; }; { /** * Tells whether the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} or the [Ambient Light Sensor Events (&quot;ondevicelight&quot;)]{@link https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events} or [&quot;onlightlevel&quot; event]{@link https://modernweb.com/introduction-to-the-ambient-light-api/} are supported or not. * @function * @returns {boolean} */ CB_Device.AmbientLight.isSupported = function() { return (typeof(AmbientLightSensor) !== &quot;undefined&quot; || &quot;ondevicelight&quot; in window || &quot;onlightlevel&quot; in window); } /** * Sets the event to get the ambient light or removes it. Uses the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} or the [Ambient Light Sensor Events (&quot;ondevicelight&quot;)]{@link https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events} or [&quot;onlightlevel&quot; event]{@link https://modernweb.com/introduction-to-the-ambient-light-api/}. &lt;br/&gt; The given &quot;eventFunction&quot; will receive the event object as the first parameter but this event object will vary depending on the way to get the ambient light which is supported by the client (if any): &lt;br /&gt; First choice, if available, uses the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} and &quot;event.value&quot; will contain the units in lux. &lt;br /&gt; Second choice, if available, uses the [Ambient Light Sensor Events (&quot;ondevicelight&quot;)]{@link https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events} and &quot;event.value&quot; will contain the units in lux. &lt;br /&gt; Third choice, if available, uses the [&quot;onlightlevel&quot; event]{@link https://modernweb.com/introduction-to-the-ambient-light-api/} and &quot;event.value&quot; will be &quot;&quot; (an empty string), &quot;dim&quot;, &quot;normal&quot; or &quot;bright&quot; instead of a number. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. The event object received will already be normalized by the {@link CB_Device.AmbientLight.normalizeEvent} function automatically. Despite of this, due to the big differences between different clients, the event object received as the first parameter will vary depending on the way to get the ambient light which is supported by the client (if any). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {function} [callbackError] - Callback that will be called if there is any error getting the ambient light. Only used by the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} (if available). * @returns {undefined|false} Returns false in the case that no way to get the ambient light is available or undefined otherwise. */ CB_Device.AmbientLight.get = function(eventFunction, keepOldFunction, useCapture, callbackError) { if (typeof(AmbientLightSensor) !== &quot;undefined&quot;) { var sensor = new AmbientLightSensor(); sensor.start(); sensor.onerror = callbackError; //if (&quot;onchange&quot; in sensor) { return CB_Device.AmbientLight._setEvent(&quot;change&quot;, function(e) { if (typeof(eventFunction) === &quot;function&quot;) { e.value = event.reading &amp;&amp; typeof(event.reading.illuminance) !== &quot;undefined&quot; ? event.reading.illuminance : e.value; eventFunction.call(sensor, e); } }, keepOldFunction, useCapture, sensor); } //event.reading.illuminance will contain the units in lux. //else { return CB_Device.AmbientLight._setEvent(&quot;reading&quot;, function(e) { if (typeof(eventFunction) === &quot;function&quot;) { e.value = sensor ? sensor.illuminance : e.value; eventFunction.call(sensor, e); } }, keepOldFunction, useCapture, sensor); } //sensor.illuminance will contain the units in lux. if (&quot;onchange&quot; in sensor) { return CB_Device.AmbientLight._setEvent(&quot;change&quot;, eventFunction, keepOldFunction, useCapture, sensor, sensor); } //event.reading.illuminance will contain the units in lux. else { return CB_Device.AmbientLight._setEvent(&quot;reading&quot;, eventFunction, keepOldFunction, useCapture, sensor, sensor); } //sensor.illuminance will contain the units in lux. } else if (&quot;ondevicelight&quot; in window) { return CB_Device.AmbientLight._setEvent(&quot;devicelight&quot;, eventFunction, keepOldFunction, useCapture, window); //event.value will contain the units in lux. } else if (&quot;onlightlevel&quot; in window) { return CB_Device.AmbientLight._setEvent(&quot;lightlevel&quot;, eventFunction, keepOldFunction, useCapture, window); //event.value will be &quot;&quot; (an empty string), &quot;dim&quot;, &quot;normal&quot; or &quot;bright&quot; instead of a number! } //if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } return false; } //Sets a function to execute when a desired event is fired: CB_Device.AmbientLight._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target, sensor) { var wrapperFunction = eventFunction; if (typeof(eventFunction) === &quot;function&quot;) { wrapperFunction = function(e) { e = CB_Device.AmbientLight.normalizeEvent(e, eventName, sensor); return eventFunction(e); }; } CB_Device._setEvent(eventName, wrapperFunction, keepOldFunction, useCapture, target); } /** * Normalizes the data gotten from the the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} or the [Ambient Light Sensor Events (&quot;ondevicelight&quot;)]{@link https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events} or [&quot;onlightlevel&quot; event]{@link https://modernweb.com/introduction-to-the-ambient-light-api/} to try to match the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/} and follow always the same rules as much as possible. * @function * @param {Event} e - The event object that we want to normalize. * @param {('change'|'reading'|'devicelight'|'lightlevel')} eventName - The name of the event that we want to normalize. Case sensitive. * @param {AmbientLightSensor} [sensor] - [AmbientLightSensor]{@link https://w3.org/TR/ambient-light/#ambient-light-sensor-interface} object used by the [Ambient Light Sensor API]{@link https://w3.org/TR/ambient-light/}. * @returns {Event} Returns the given event object again but normalized (if possible). * @todo Normalize more differences between web clients. */ CB_Device.AmbientLight.normalizeEvent = function(e, eventName, sensor) { e = CB_Events.normalize(e); //Normalizes ambient light sensor data: /* if (typeof(AmbientLightSensor) !== &quot;undefined&quot; &amp;&amp; e &amp;&amp; e.reading &amp;&amp; typeof(e.reading.illuminance) !== &quot;undefined&quot;) { if (typeof(e.value) === &quot;undefined&quot; || e.value === null) { e.value = e.reading.illuminance; } } */ if (typeof(AmbientLightSensor) !== &quot;undefined&quot; &amp;&amp; typeof(sensor) !== &quot;undefined&quot; &amp;&amp; sensor !== null) { if (eventName === &quot;change&quot;) { //e.value = (event.reading &amp;&amp; typeof(event.reading.illuminance) !== &quot;undefined&quot;) ? event.reading.illuminance : e.value; //event.reading.illuminance will contain the units in lux. e.value = (e.reading &amp;&amp; typeof(e.reading.illuminance) !== &quot;undefined&quot;) ? e.reading.illuminance : e.value; //e.reading.illuminance will contain the units in lux. } else if (eventName === &quot;reading&quot;) { e.value = sensor ? sensor.illuminance : e.value; //sensor.illuminance will contain the units in lux. } } return e; } } //End of the static class CB_Device.AmbientLight. /** * Static class to manage the device's proximity sensor. It will return itself if it is tried to be instantiated. * @namespace * @todo Normalize more differences between web clients. */ CB_Device.Proximity = function() { return CB_Device.Proximity; }; { /** * Tells whether the [Proximity Sensor API]{@link https://w3.org/TR/proximity/} or the Proximity Sensor Events as [&quot;ondeviceproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/Ambient_Light_Events} or [&quot;onuserproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/UserProximityEvent} are supported or not. * @function * @returns {boolean} */ CB_Device.Proximity.isSupported = function() { return (typeof(ProximitySensor) !== &quot;undefined&quot; || &quot;ondeviceproximity&quot; in window || &quot;onuserproximity&quot; in window); } /** * Sets the event to get the proximity or removes it. Uses the [Proximity Sensor API]{@link https://w3.org/TR/proximity/} or the Proximity Sensor Events as [&quot;ondeviceproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/ondeviceproximity} or [&quot;onuserproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/UserProximityEvent}. &lt;br/&gt; The given &quot;eventFunction&quot; will receive the event object as the first parameter but this event object will vary depending on the way to get the proximity which is supported by the client (if any) and the &quot;detectNear&quot; parameter. It will use the following logic order: &lt;br /&gt; If &quot;detectNear&quot; is not set to true, [Proximity Sensor API]{@link https://w3.org/TR/proximity/} is used as the first option (if available) and &quot;event.value&quot; will contain the units in centimeters (depending on the implementation, &quot;event.near&quot; will also be present, containing a boolean depending on whether an object is near or not). &lt;br /&gt; If &quot;detectNear&quot; is not set to true, [Proximity Sensor Events (&quot;ondeviceproximity&quot;)]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/ondeviceproximity} is used as the second option (if available) and &quot;event.value&quot; will contain the units in centimeters. &lt;br /&gt; If &quot;detectNear&quot; is set to true, [&quot;onuserproximity&quot; event]{@link https://developer.mozilla.org/en-US/docs/Web/API/UserProximityEvent} is the unique option used (if available) and &quot;event.near&quot; will be a boolean which tell us whether something is near or not. * @function * @param {function|null} eventFunction - The function that will be called when the event is fired. The event object received will already be normalized by the {@link CB_Device.Proximity.normalizeEvent} function automatically. Despite of this, due to the big differences between different clients, the event object received as the first parameter will vary depending on the way to get the proximity which is supported by the client (if any). If a null value is used, the event will be removed. * @param {boolean} [detectNear=false] - Defines whether we want to detect when a physical object is nearby. If it is set to true, it will use the [&quot;onuserproximity&quot; event]{@link https://developer.mozilla.org/en-US/docs/Web/API/UserProximityEvent}. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener or not. * @param {float} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {function} [callbackError] - Callback that will be called if there is any error getting the proximity. Only used by the [Proximity Sensor API]{@link https://w3.org/TR/proximity/} (if available). * @returns {undefined|false} Returns false in the case that no way to get the proximity is available or undefined otherwise. */ CB_Device.Proximity.get = function(eventFunction, detectNear, keepOldFunction, useCapture, callbackError) { if (!detectNear) { if (typeof(ProximitySensor) !== &quot;undefined&quot;) { var sensor = new ProximitySensor(); sensor.start(); sensor.onerror = callbackError; //if (&quot;onchange&quot; in sensor) { return CB_Device._setEvent(&quot;change&quot;, function(e) { if (typeof(eventFunction) === &quot;function&quot;) { e.value = event.reading &amp;&amp; typeof(event.reading.distance) !== &quot;undefined&quot; ? event.reading.distance : e.value; eventFunction.call(sensor, e); } }, keepOldFunction, useCapture, sensor); } //event.reading.distance will contain the units in centimeters. //else { return CB_Device._setEvent(&quot;reading&quot;, function(e) { if (typeof(eventFunction) === &quot;function&quot;) { e.value = sensor ? sensor.distance : e.value; e.near = sensor ? sensor.near : e.near; eventFunction.call(sensor, e); } }, keepOldFunction, useCapture, sensor); } //sensor.distance will contain the units in centimeters and sensor.near will be a boolean telling whether an object is near or not. if (&quot;onchange&quot; in sensor) { return CB_Device.Proximity._setEvent(&quot;change&quot;, eventFunction, keepOldFunction, useCapture, sensor, sensor); } //event.reading.distance will contain the units in centimeters. else { return CB_Device.Proximity._setEvent(&quot;reading&quot;, eventFunction, keepOldFunction, useCapture, sensor, sensor); } //sensor.distance will contain the units in centimeters and sensor.near will be a boolean telling whether an object is near or not. } else if (&quot;ondeviceproximity&quot; in window) { return CB_Device.Proximity._setEvent(&quot;deviceproximity&quot;, eventFunction, keepOldFunction, useCapture, window); //event.value will contain the units in centimeters. } } else { if (&quot;onuserproximity&quot; in window) { return CB_Device.Proximity._setEvent(&quot;userproximity&quot;, eventFunction, keepOldFunction, useCapture, window); //event.near will be received (boolean). } } //if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } return false; } //Sets a function to execute when a desired event is fired: CB_Device.Proximity._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target, sensor) { var wrapperFunction = eventFunction; if (typeof(eventFunction) === &quot;function&quot;) { wrapperFunction = function(e) { e = CB_Device.Proximity.normalizeEvent(e, eventName, sensor); return eventFunction(e); }; } CB_Device._setEvent(eventName, wrapperFunction, keepOldFunction, useCapture, target); } /** * Normalizes the data gotten from the the [Proximity Sensor API]{@link https://w3.org/TR/proximity/} or the Proximity Sensor Events as [&quot;ondeviceproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/ondeviceproximity} or [&quot;onuserproximity&quot;]{@link https://developer.mozilla.org/en-US/docs/Web/API/UserProximityEvent} to try to match the [Proximity Sensor API]{@link https://w3.org/TR/proximity/} and follow always the same rules as much as possible. * @function * @param {Event} e - The event object that we want to normalize. * @param {('change'|'reading'|'deviceproximity'|'userproximity')} eventName - The name of the event that we want to normalize. Case sensitive. * @param {ProximitySensor} [sensor] - [ProximitySensor]{@link https://w3.org/TR/proximity/#proximity-sensor-interface} object used by the [Proximity Sensor API]{@link https://w3.org/TR/proximity/}. * @returns {Event} Returns the given event object again but normalized (if possible). * @todo Normalize more differences between web clients. */ CB_Device.Proximity.normalizeEvent = function(e, eventName, sensor) { e = CB_Events.normalize(e); /* //Normalizes proximity sensor data: if (typeof(ProximitySensor) !== &quot;undefined&quot; &amp;&amp; e &amp;&amp; event.reading &amp;&amp; typeof(event.reading.distance) !== &quot;undefined&quot;) { if (typeof(e.value) === &quot;undefined&quot; || e.value === null) { e.value = event.reading.distance; } } */ if (typeof(ProximitySensor) !== &quot;undefined&quot; &amp;&amp; typeof(sensor) !== &quot;undefined&quot; &amp;&amp; sensor !== null) { if (eventName === &quot;change&quot;) { //e.value = (event.reading &amp;&amp; typeof(event.reading.distance) !== &quot;undefined&quot;) ? event.reading.distance : e.value; //event.reading.distance will contain the units in centimeters. e.value = (e.reading &amp;&amp; typeof(e.reading.distance) !== &quot;undefined&quot;) ? e.reading.distance : e.value; //e.reading.distance will contain the units in centimeters. } else if (eventName === &quot;reading&quot;) { e.value = sensor ? sensor.distance : e.value; //sensor.distance will contain the units in centimeters. e.near = sensor ? sensor.near : e.near; //sensor.near will be a boolean telling whether an object is near or not. } } return e; } } //End of the static class CB_Device.Proximity. × Search results Close "},"CrossBase_general_CB_Elements.js.html":{"id":"CrossBase_general_CB_Elements.js.html","title":"Source: CrossBase/general/CB_Elements.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_Elements.js /** * @file DOM elements management. Contains the {@link CB_Elements} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage DOM elements. It will return itself if it is tried to be instantiated. * @namespace * @todo Think about creating a function called &quot;add&quot; or &quot;create&quot; to create a new element (it could accept &quot;tagName&quot;, &quot;id&quot; and &quot;content&quot; parameters). * @todo Think about creating &quot;setStyle&quot; and &quot;setStyleById&quot; methods to add a given style attribute and also supporting a boolean parameter to also add the style attribute with vendor prefixes (webkit, moz, ms, o, khtml) if we want to. */ var CB_Elements = function() { return CB_Elements; }; { CB_Elements.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Elements.init = function() { //If this is the fist time: if (CB_Elements.initialized) { return CB_Elements; } //The object has been initialized: CB_Elements.initialized = true; //TODO. if (!document.body) { var tagBody = CB_Elements.tag(&quot;body&quot;, document); if (typeof(tagBody) !== &quot;undefined&quot; &amp;&amp; tagBody !== null &amp;&amp; typeof(tagBody[0]) !== &quot;undefined&quot; &amp;&amp; tagBody[0] !== null) { document.body = tagBody[0]; } } return CB_Elements; } CB_Elements._tagCache = {}; /** * Returns elements by their tag name. * @function * @param {string} [tagName='*'] - The name of the tag whose elements we want to find. Use asterisk (&quot;*&quot;) in the case that we want all the elements. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_tag_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. * @returns {NodeList|array} Returns the elements (NodeList or array, depending on the web client). */ CB_Elements.tag = function(tagName, baseElement, useCache) { if (typeof(baseElement) === &quot;undefined&quot; || baseElement === null) { baseElement = document; } //Uses document as default base element. if (typeof(useCache) === &quot;undefined&quot; || useCache === null) { useCache = CB_Configuration[CB_BASE_NAME].CB_Elements_tag_USE_CACHE; } //If no tag name is sent, uses &quot;*&quot; (all) by default: tagName = CB_trim(tagName).toLowerCase(); if (tagName === &quot;&quot;) { tagName = &quot;*&quot;; } if (!useCache || typeof(CB_Elements._tagCache[baseElement]) === &quot;undefined&quot; || CB_Elements._tagCache[baseElement] === null || typeof(CB_Elements._tagCache[baseElement][tagName]) === &quot;undefined&quot; || CB_Elements._tagCache[baseElement][tagName] === null) { if (typeof(CB_Elements._tagCache[baseElement]) === &quot;undefined&quot; || CB_Elements._tagCache[baseElement] === null) { CB_Elements._tagCache[baseElement] = {}; } if (typeof(baseElement.getElementsByTagName) !== &quot;undefined&quot; &amp;&amp; baseElement.getElementsByTagName !== null) { CB_Elements._tagCache[baseElement][tagName] = baseElement.getElementsByTagName(tagName); if (tagName === &quot;*&quot; &amp;&amp; CB_Elements._tagCache[baseElement][tagName].length === 0 &amp;&amp; typeof(document.all) !== &quot;undefined&quot; &amp;&amp; document.all !== null) { CB_Elements._tagCache[baseElement][tagName] = document.all; } } else if (baseElement.querySelectorAll) { CB_Elements._tagCache[baseElement][tagName] = baseElement.querySelectorAll(tagName); } else if (document.querySelectorAll) { CB_Elements._tagCache[baseElement][tagName] = document.querySelectorAll(tagName); } else if (typeof(baseElement.all) !== &quot;undefined&quot; &amp;&amp; baseElement.all !== null) { if (tagName === &quot;*&quot;) { CB_Elements._tagCache[baseElement][tagName] = baseElement.all; } else { CB_Elements._tagCache[baseElement][tagName] = baseElement.all.tags(tagName); } } else if (typeof(document.all) !== &quot;undefined&quot; &amp;&amp; document.all !== null) { if (tagName === &quot;*&quot;) { CB_Elements._tagCache[baseElement][tagName] = document.all; } else { CB_Elements._tagCache[baseElement][tagName] = document.all.tags(tagName); } } else if (baseElement.layers || document.layers) { if (typeof(CB_Elements._tagCache[baseElement][tagName]) === &quot;undefined&quot; || CB_Elements._tagCache[baseElement][tagName] === null) { CB_Elements._tagCache[baseElement][tagName] = []; } var allElements = baseElement.layers || document.layers; //If we want all elements, then we get all of them: if (tagName === &quot;*&quot;) { CB_Elements._tagCache[baseElement][tagName] = allElements; } //...otherwise, obtains all elements with the given tag name: else { //If any elements were obtained, we select just the ones with the desired tag name: var allElementsLength = allElements.length; var elementCurrent; for (var x = 0; x &lt; allElementsLength; x++) { elementCurrent = allElements[x]; if (elementCurrent !== null &amp;&amp; typeof(elementCurrent.tagName) !== &quot;undefined&quot;) { if (CB_trim(elementCurrent.tagName).toLowerCase() === tagName) { CB_Elements._tagCache[baseElement][tagName].push(elementCurrent); } } } //CB_Elements._tagCache[baseElement][tagName] = baseElement.layers[tagName]; } } else if (typeof(CB_Elements._tagCache[baseElement][tagName]) === &quot;undefined&quot; || CB_Elements._tagCache[baseElement][tagName] === null) { CB_Elements._tagCache[baseElement][tagName] = []; } /* else if (baseElement.layers) { CB_Elements._tagCache[baseElement][tagName] = baseElement.layers[tagName]; } else if (document.layers) { CB_Elements._tagCache[baseElement][tagName] = document.layers[tagName]; }*/ //If we used &quot;*&quot; and there is no elements, we try to use document.all instead (for old web clients): //if (tagName === &quot;*&quot; &amp;&amp; CB_Elements._tagCache[baseElement][tagName].length === 0) //{ //if (all in document) { CB_Elements._tagCache[baseElement][tagName] = document.all; } //} CB_Elements._tagCache[baseElement][tagName] = CB_Elements._tagCache[baseElement][tagName] || []; } return CB_Elements._tagCache[baseElement][tagName]; } /** * Returns elements by their tag name, updating (or creating) the internal cache. Calls the {@link CB_Elements.tag} function internally, with the &quot;useCache&quot; parameter set to false. * @function * @param {string} [tagName='*'] - The name of the tag whose elements we want to find. Use asterisk (&quot;*&quot;) in the case that we want all the elements. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @returns {NodeList|array} Returns the elements (NodeList or array, depending on the web client). */ CB_Elements.tagCacheUpdate = function(tagName, baseElement) { return CB_Elements.tag(tagName, baseElement, false); } /** * Clears the internal cache user by {@link CB_Elements.tag} and others. If no parameter is given, whole internal cache will be cleared. * @function * @param {string} [tagName] - The name of the tag whose internal cache we want to clear. Use asterisk (&quot;*&quot;) in the case that we want to clear the internal cache for {@link CB_Elements.tag} which is used when it is called with this exact parameter. If not provided, it will clear the whole internal cache or the internal cache that belongs to the &quot;baseElement&quot; given (if provided). * @param {Node} [baseElement] - The node element parent whose internal cache we want to clear. If not provided but &quot;tagName&quot; is provided, it will clear the internal cache which matches the given &quot;tagName&quot; for any nodes. If it is provided but &quot;tagName&quot; is not, it will clear all the internal cache that belongs to this node element. * @returns {Object} Returns the current internal cache after clearing it (if it is has been possible), which is an associative array of two dimensions (JavaScript object) whose first index belongs to the nodes, the second and last index belongs to the tag name and the value belongs to the returning value of the {@link CB_Elements.tag} function when it was called for those parameters. */ CB_Elements.tagCacheClear = function(tagName, baseElement) { tagName = CB_trim(tagName).toLowerCase(); //If no base element and no tag name are defined, we clean all the array: if (typeof(baseElement) === &quot;undefined&quot; &amp;&amp; tagName === &quot;&quot; || baseElement === null &amp;&amp; (typeof(tagName) === &quot;undefined&quot; || tagName === null)) { CB_Elements._tagCache = {}; } //...otherwise, if both base element and tag name are defined, we clear the elements of that base element: else if (typeof(baseElement) !== &quot;undefined&quot; &amp;&amp; baseElement !== null &amp;&amp; tagName !== &quot;&quot;) { if (typeof(CB_Elements._tagCache[baseElement]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._tagCache[baseElement] !== null) { if (typeof(CB_Elements._tagCache[baseElement][tagName]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._tagCache[baseElement][tagName] !== null) { CB_Elements._tagCache[baseElement][tagName] = null; } } } //...otherwise, if a base element is defined (but not a tagName), we clear all elements of that base element: else if (typeof(baseElement) !== &quot;undefined&quot; &amp;&amp; baseElement !== null) { if (typeof(CB_Elements._tagCache[baseElement]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._tagCache[baseElement] !== null) { CB_Elements._tagCache[baseElement] = {}; } } //...otherwise, if a tag name is defined (but not a base element), we clear all the elements of that tag name from all the element bases: else if (tagName !== &quot;&quot;) { for (var currentBaseElement in CB_Elements._tagCache) { if (typeof(CB_Elements._tagCache[currentBaseElement][tagName]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._tagCache[currentBaseElement][tagName] !== null) { CB_Elements._tagCache[currentBaseElement][tagName] = null; } } } return CB_Elements._tagCache; } /** * Alias for {@link CB_Elements.tagRemove}. * @function CB_Elements.removeByTagName * @see {@link CB_Elements.tagRemove} */ /** * Removes elements by their tag name. * @function * @param {string} [tagName='*'] - The name of the tag whose elements we want to delete. Use asterisk (&quot;*&quot;) in the case that we want all the elements. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_tag_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. */ CB_Elements.tagRemove = CB_Elements.removeByTagName = function(tagName, baseElement, useCache) { if (typeof(baseElement) === &quot;undefined&quot; || baseElement === null) { baseElement = document; } //Uses document as default base element. tagName = CB_trim(tagName); if (tagName === &quot;&quot;) { tagName = &quot;*&quot;; } var elementsOriginal = CB_Elements.tag(tagName, baseElement, useCache); if (typeof(elementsOriginal) !== &quot;undefined&quot; &amp;&amp; elementsOriginal !== null &amp;&amp; typeof(elementsOriginal.length) !== &quot;undefined&quot; &amp;&amp; elementsOriginal.length !== null &amp;&amp; elementsOriginal.length &gt; 0) { var elements = []; var elementsLength = elementsOriginal.length; for (var x = 0; x &lt; elementsLength; x++) { elements[x] = elementsOriginal[x]; } elementsLength = elements.length; for (var x = 0; x &lt; elementsLength; x++) { //elements[x].parentNode.removeChild(elements[x]); CB_Elements.remove(elements[x]); } CB_Elements._tagCache[baseElement][tagName] = null; } } CB_Elements._classesCache = {}; /** * Returns elements by their class or classes name. * @function * @param {string} classNames - The name of the class or classes (separated by a blank space) whose elements we want to find. The order of the classes is just important for the internal cache. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_classes_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. * @returns {NodeList|array} Returns the elements (NodeList or array, depending on the web client). */ CB_Elements.classes = function(classNames, baseElement, useCache) { if (typeof(useCache) === &quot;undefined&quot; || useCache === null) { useCache = CB_Configuration[CB_BASE_NAME].CB_Elements_classes_USE_CACHE; } if (typeof(baseElement) === &quot;undefined&quot; || baseElement === null) { baseElement = document; } //If no class name is sent, returns am empty array: classNames = CB_trim(classNames);//.toLowerCase(); if (classNames === &quot;&quot;) { return []; } if (!useCache || typeof(CB_Elements._classesCache[baseElement]) === &quot;undefined&quot; || CB_Elements._classesCache[baseElement] === null || typeof(CB_Elements._classesCache[baseElement][classNames]) === &quot;undefined&quot; || CB_Elements._classesCache[baseElement][classNames] === null) { if (typeof(CB_Elements._classesCache[baseElement]) === &quot;undefined&quot; || CB_Elements._classesCache[baseElement] === null) { CB_Elements._classesCache[baseElement] = {}; } //CB_Elements._classesCache[baseElement][classNames] = baseElement.getElementsByClassName(classNames); if (typeof(baseElement.getElementsByClassName) !== &quot;undefined&quot; &amp;&amp; baseElement.getElementsByClassName !== null) { CB_Elements._classesCache[baseElement][classNames] = baseElement.getElementsByClassName(classNames); } else if (baseElement.querySelectorAll) { CB_Elements._classesCache[baseElement][classNames] = baseElement.querySelectorAll(&quot;.&quot; + classNames.replace(/ /g, &quot;.&quot;)); } else if (document.querySelectorAll) { CB_Elements._classesCache[baseElement][classNames] = document.querySelectorAll(&quot;.&quot; + classNames.replace(/ /g, &quot;.&quot;)); } else { //Obtains all elements: var allElements = CB_Elements.tag(&quot;*&quot;, baseElement, useCache); //If any elements were obtained, we select just the ones with the desired class name: var allElementsLength = allElements.length; if (allElementsLength &gt; 0) { if (typeof(CB_Elements._classesCache[baseElement][classNames]) === &quot;undefined&quot; || CB_Elements._classesCache[baseElement][classNames] === null) { CB_Elements._classesCache[baseElement][classNames] = []; } /* //classNames = classNames.toLowerCase(); var elementCurrent; var classes; var classesLength; for (var x = 0; x &lt; allElementsLength; x++) { elementCurrent = allElements[x]; if (elementCurrent !== null) { classes = elementCurrent.className.split(&quot; &quot;); classesLength = classes.length; for (var y = 0; y &lt; classesLength; y++) { classes[y] = CB_trim(classes[y]).toLowerCase(); //TODO: make it compatible with regular expressions (be careful with web clients not compatible with RegExp!). if (classes[y] === classNames) { CB_Elements._classesCache[baseElement][classNames].push(elementCurrent); break; } } } } */ //TODO: make it compatible with regular expressions (be careful with web clients not compatible with RegExp!). var classesDesired = classNames.split(&quot; &quot;); var classesDesiredLength = classesDesired.length; for (var x = 0; x &lt; classesDesiredLength; x++) { classesDesired[x] = CB_trim(classesDesired[x]);//.toLowerCase(); } var elementCurrent; var elementCurrentClass; var classes; var classesLength; var y, z; var allClassesFound; for (x = 0; x &lt; allElementsLength; x++) { elementCurrent = allElements[x]; if (elementCurrent !== null) { elementCurrentClass = CB_trim(elementCurrent.className); if (elementCurrentClass === &quot;&quot;) { continue; } classes = elementCurrentClass.split(&quot; &quot;); classesLength = classes.length; for (y = 0; y &lt; classesLength; y++) { classes[y] = CB_trim(classes[y]);//.toLowerCase(); } allClassesFound = true; for (z = 0; z &lt; classesDesiredLength; z++) { if (CB_indexOf(classes, classesDesired[z]) === -1) { allClassesFound = false; break; } } if (allClassesFound) { CB_Elements._classesCache[baseElement][classNames].push(elementCurrent); //elements[elements.length] = elementCurrent; } } } } } /* else if (typeof(baseElement.all) !== &quot;undefined&quot; &amp;&amp; baseElement.all !== null) { //allElements = baseElement.all; allElements = CB_Elements.tag(&quot;*&quot;, baseElement, useCache); } else if (typeof(document.all) !== &quot;undefined&quot; &amp;&amp; document.all !== null) { //allElements = document.all; allElements = CB_Elements.tag(&quot;*&quot;, document, useCache); } */ /* else if (baseElement.layers) { CB_Elements._classesCache[baseElement][classNames] = baseElement.layers[classNames]; } else if (document.layers) { CB_Elements._classesCache[baseElement][classNames] = document.layers[classNames]; }*/ CB_Elements._classesCache[baseElement][classNames] = CB_Elements._classesCache[baseElement][classNames] || []; } return CB_Elements._classesCache[baseElement][classNames]; } /** * Returns elements by their class or classes name, updating (or creating) the internal cache. Calls the {@link CB_Elements.classes} function internally, with the &quot;useCache&quot; parameter set to false. * @function * @param {string} classNames - The name of the class or classes (separated by a blank space) whose elements we want to find. The order of the classes is just important for the internal cache. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @returns {NodeList|array} Returns the elements (NodeList or array, depending on the web client). */ CB_Elements.classesCacheUpdate = function(classNames, baseElement) { return CB_Elements.classes(classNames, baseElement, false); } /** * Clears the internal cache used by {@link CB_Elements.classes} and others. If no parameter is given, whole internal cache will be cleared. * @function * @param {string} [classNames] - The name of the class or classes (separated by a blank space) whose internal cache we want to clear. The order of the classes is important for the internal cache. If not provided, it will clear the whole internal cache or the internal cache that belongs to the &quot;baseElement&quot; given (if provided). * @param {Node} [baseElement] - The node element parent whose internal cache we want to clear. If not provided but &quot;classNames&quot; is provided, it will clear the internal cache which matches the given &quot;classNames&quot; for any nodes. If it is provided but &quot;classNames&quot; is not, it will clear all the internal cache that belongs to this node element. * @returns {Object} Returns the current internal cache after cleaning it (if it is has been possible), which is an associative array of two dimensions (JavaScript object) whose first index belongs to the nodes, the second and last index belongs to the class name or class names and the value belongs to the returning value of the {@link CB_Elements.classes} function when it was called for those parameters. */ CB_Elements.classesCacheClear = function(classNames, baseElement) { classNames = CB_trim(classNames);//.toLowerCase(); //If no base element and no class name are defined, we clean all the array: if (typeof(baseElement) === &quot;undefined&quot; &amp;&amp; classNames === &quot;&quot; || baseElement === null &amp;&amp; (typeof(classNames) === &quot;undefined&quot; || classNames === null)) { CB_Elements._classesCache = {}; } //...otherwise, if both base element and class name are defined, we clear the elements of that base element: else if (typeof(baseElement) !== &quot;undefined&quot; &amp;&amp; baseElement !== null &amp;&amp; classNames !== &quot;&quot;) { if (typeof(CB_Elements._classesCache[baseElement]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._classesCache[baseElement] !== null) { if (typeof(CB_Elements._classesCache[baseElement][classNames]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._classesCache[baseElement][classNames] !== null) { CB_Elements._classesCache[baseElement][classNames] = null; } } } //...otherwise, if a base element is defined (but not a classNames), we clear all elements of that base element: else if (typeof(baseElement) !== &quot;undefined&quot; &amp;&amp; baseElement !== null) { if (typeof(CB_Elements._classesCache[baseElement]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._classesCache[baseElement] !== null) { CB_Elements._classesCache[baseElement] = {}; } } //...otherwise, if a class name is defined (but not a base element), we clear all the elements of that class name from all the element bases: else if (classNames !== &quot;&quot;) { for (var currentBaseElement in CB_Elements._classesCache) { if (typeof(CB_Elements._classesCache[currentBaseElement][classNames]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._classesCache[currentBaseElement][classNames] !== null) { CB_Elements._classesCache[currentBaseElement][classNames] = null; } } } return CB_Elements._classesCache; } /** * Alias for {@link CB_Elements.classesRemove}. * @function CB_Elements.removeByClasses * @see {@link CB_Elements.classesRemove} */ /** * Removes elements by their class or classes name. * @function * @param {string} classNames - The name of the class or classes (separated by a blank space) whose elements we want to delete. The order of the classes is just important for the internal cache. * @param {Node} [baseElement=document] - The node element parent where we want to focus our search. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_classes_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. */ CB_Elements.classesRemove = CB_Elements.removeByClasses = function(classNames, baseElement, useCache) { if (typeof(baseElement) === &quot;undefined&quot; || baseElement === null) { baseElement = document; } classNames = CB_trim(classNames);//.toLowerCase(); if (classNames === &quot;&quot;) { return; } var elementsOriginal = CB_Elements.classes(classNames, baseElement, useCache); if (typeof(elementsOriginal) !== &quot;undefined&quot; &amp;&amp; elementsOriginal !== null &amp;&amp; typeof(elementsOriginal.length) !== &quot;undefined&quot; &amp;&amp; elementsOriginal.length !== null &amp;&amp; elementsOriginal.length &gt; 0) { var elements = []; var elementsLength = elementsOriginal.length; for (var x = 0; x &lt; elementsLength; x++) { elements[x] = elementsOriginal[x]; } var elementsLength = elements.length; for (var x = 0; x &lt; elementsLength; x++) { //elements[x].parentNode.removeChild(elements[x]); CB_Elements.remove(elements[x]); } CB_Elements._classesCache[baseElement][classNames] = null; } } CB_Elements._idCache = {}; /** * Alias for {@link CB_Elements.id}. * @function CB_Elements.byId * @see {@link CB_Elements.id} */ /** * Alias for {@link CB_Elements.id}. * @function CB_Elements.get * @see {@link CB_Elements.id} */ /** * Alias for {@link CB_Elements.id}. * @function CB_Elements.getById * @see {@link CB_Elements.id} */ /** * Returns an element by its ID. * @function * @param {string} id - The identifier of the element that we want to find. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_id_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. * @returns {Node|Object|null} Returns the elements (Node or object, depending on the web client). It will return null when not found. */ CB_Elements.id = CB_Elements.byId = CB_Elements.get = CB_Elements.getById = function(id, useCache) { if (typeof(useCache) === &quot;undefined&quot; || useCache === null) { useCache = CB_Configuration[CB_BASE_NAME].CB_Elements_id_USE_CACHE; } id = CB_trim(id);//.toLowerCase(); //If no id is sent, returns null: if (id === &quot;&quot;) { return null; } if (!useCache || typeof(CB_Elements._idCache[id]) === &quot;undefined&quot; || CB_Elements._idCache[id] === null) { if (document.getElementById) { CB_Elements._idCache[id] = document.getElementById(id); } else if (document.querySelector) { CB_Elements._idCache[id] = document.querySelector(&quot;#&quot; + id); } else if (document.all) { if (typeof(document.all) !== &quot;function&quot;) { CB_Elements._idCache[id] = document.all[id]; } else { CB_Elements._idCache[id] = document.all(id); } } else if (document.layers) { CB_Elements._idCache[id] = document.layers[id]; } else { CB_Elements._idCache[id] = null; } CB_Elements._idCache[id] = CB_Elements._idCache[id] || null; } return CB_Elements._idCache[id]; } /** * Returns an element by its ID, updating (or creating) the internal cache. Calls the {@link CB_Elements.id} function internally, with the &quot;useCache&quot; parameter set to false. * @function * @param {string} id - The identifier of the element that we want to find. * @returns {node|Object|null} Returns the elements (Node or object, depending on the web client). It will return null when not found. */ CB_Elements.idCacheUpdate = function(id) { return CB_Elements.id(id, false); } /** * Clears the internal cache used by {@link CB_Elements.id} and others. If no parameter is given, whole internal cache will be cleared. * @function * @param {string} [id] - The identifier of the element whose internal cache we want to clear. If not provided, it will clear the whole internal cache. * @returns {Object} Returns the current internal cache after cleaning it (if it is has been possible), which is an associative array of one dimension (JavaScript object) whose first and unique index belongs to the identifier and the value belongs to each element. */ CB_Elements.idCacheClear = function(id) { id = CB_trim(id); if (id === &quot;&quot;) { CB_Elements._idCache = {}; } else { CB_Elements._idCache[id] = null; } return CB_Elements._idCache; } /** * Alias for {@link CB_Elements.idRemove}. * @function CB_Elements.removeById * @see {@link CB_Elements.idRemove} */ /** * Removes an element by its ID. * @function * @param {string} id - The identifier of the element that we want to delete. * @param {boolean} [useCache={@link CB_Configuration.CrossBase.CB_Elements_id_USE_CACHE}] - Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. */ CB_Elements.idRemove = CB_Elements.removeById = function(id, useCache) { id = CB_trim(id); if (id === &quot;&quot;) { return; } var element = CB_Elements.id(id, useCache); //if (typeof(CB_Elements._idCache[id]) !== &quot;undefined&quot; &amp;&amp; CB_Elements._idCache[id] !== null) //{ CB_Elements._idCache[id] = null; //} return CB_Elements.remove(element); } /** * Removes an element given. * @function * @param {Node} element - The element that we want to delete. */ CB_Elements.remove = function(element) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var elementParent = CB_Elements.getParent(element); if (typeof(elementParent) !== &quot;undefined&quot; &amp;&amp; elementParent !== null &amp;&amp; typeof(elementParent.removeChild) !== &quot;undefined&quot; &amp;&amp; elementParent.removeChild !== null) { ///////return elementParent.removeChild(element); elementParent.removeChild(element); } else if (typeof(element.removeNode) !== &quot;undefined&quot; &amp;&amp; element.removeNode !== null) { ///////return element.removeNode(true); element.removeNode(true); } else if (document.all) { if (typeof(document.all) !== &quot;function&quot; &amp;&amp; element.id &amp;&amp; typeof(document.all[element.id]) !== &quot;undefined&quot; &amp;&amp; document.all[element.id] !== null) { document.all[element.id].innerHTML = document.all[element.id].outerHTML = &quot;&quot;; } else if (element.id) { //Uses try-catch because otherwise it fails on IE 8: try { document.all(element.id).innerHTML = document.all(element.id).outerHTML = &quot;&quot;; } catch(E) {} } } else if (document.layers &amp;&amp; element.id) { document.layers[element.id].visibility = &quot;hide&quot;; delete document.layers[element.id]; } if (typeof(element.remove) !== &quot;undefined&quot;) { element.remove(); } ///////////////delete(element); //Just in case (for some strange web clients). NOTE: commented since it gives problems with JSDoc (&quot;ERROR: Unable to parse CB_Elements.js: Deleting local variable in strict mode&quot;). element = null; element = undefined; } } /** * Returns an array with the parents of a given element, with the topmost parent in the highest index: * @function * @param {Node} element - The element whose parents we want to get. * @returns {array} */ CB_Elements.getParents = function(element) { var elementParents = []; var x = 0; var currentParent; while (currentParent = CB_Elements.getParent(element)) { elementParents[x++] = currentParent; element = currentParent; } return elementParents; } /** * Returns an array with the parents of a given element (by its identifier), with the topmost parent in the highest index: * @function * @param {string} elementId - The identifier of the element whose parents we want to get. * @returns {array} */ CB_Elements.getParentsById = function(elementId) { return CB_Elements.getParents(CB_Elements.id(elementId)); } /** * Returns the first parent of a given element: * @function * @param {Node} element - The element whose parent we want to get. * @returns {Node|null} Returns null if the parent cannot be found. */ CB_Elements.getParent = function(element) { if (typeof(element) === &quot;undefined&quot; || element === null) { return null; } var elementParent = null; if (typeof(element.parentNode) !== &quot;undefined&quot; &amp;&amp; element.parentNode !== null) { elementParent = element.parentNode; } else if (typeof(element.parentElement) !== &quot;undefined&quot; &amp;&amp; element.parentElement !== null) { elementParent = element.parentElement; } return elementParent; } /** * Returns the first parent of a given element (by its identifier): * @function * @param {string} elementId - The identifier of the element whose parent we want to get. * @returns {Node|null} Returns null if the parent cannot be found. */ CB_Elements.getParentById = function(elementId) { return CB_Elements.getParent(CB_Elements.id(elementId)); } /** * Changes a desired element property with the given value. * @function * @param {Node} element - The element whose property we want to modify. * @param {string} property - The name of the property that we want to modify. * @param {*} propertyValue - The value desired for the property. * @param {boolean} [checkValues=false] - If set to true, it will only modify the property if the current value is different from the given one. * @param {function} [onSetProperty] - Callback function that will be called if the property of the element has been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node|null} Returns the given element again or null. */ CB_Elements.setProperty = function(element, property, propertyValue, checkValues, onSetProperty) { if (typeof(element) === &quot;undefined&quot; || element === null) { return null; } if (!checkValues || element[property] !== propertyValue) { element[property] = propertyValue; if (typeof(onSetProperty) === &quot;function&quot;) { onSetProperty(element); } } return element; } /** * Changes a desired element property with the given value (by its identifier). * @function * @param {string} elementId - The identifier of the element whose property we want to modify. * @param {string} property - The name of the property that we want to modify. * @param {*} propertyValue - The value desired for the property. * @param {boolean} [checkValues=false] - If set to true, it will only modify the property if the current value is different from the given one. * @param {function} [onSetProperty] - Callback function that will be called if the property of the element has been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.setPropertyById = function(elementId, property, propertyValue, checkValues, onSetProperty) { return CB_Elements.setProperty(CB_Elements.id(elementId), property, propertyValue, checkValues, onSetProperty); } /** * Inserts the desired content inside a given element (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}). * @function * @param {Node} container - The element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @param {boolean} [append=false] - If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. * @param {boolean} [appendAtBeginning=false] - If set to true, it will append the given content to the existing one instead of overwritten it. * @returns {Node} Returns the given container again. */ CB_Elements.insertContent = function(container, content, displayValue, checkValues, computed, onContentWritten, onShow, append, appendAtBeginning) { if (container !== null) { if (!checkValues || append || container.innerHTML !== content) { if (append) { container.innerHTML = appendAtBeginning ? content + container.innerHTML : container.innerHTML + content; } else { container.innerHTML = content; } if (typeof(onContentWritten) === &quot;function&quot;) { onContentWritten(container); } } if (displayValue) { CB_Elements.show(container, displayValue, checkValues, computed, onShow); } } return container; } /** * Appends the desired content inside a given element, keeping the existing one (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}). Calls the {@link CB_Elements.insertContent} internally. * @function * @param {Node} container - The element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @param {boolean} [appendAtBeginning=false] - If set to true, it will append the given content to the existing one instead of overwritten it. * @returns {Node} Returns the given container again. */ CB_Elements.appendContent = function(container, content, displayValue, checkValues, computed, onContentWritten, onShow, appendAtBeginning) { return CB_Elements.insertContent(container, content, displayValue, checkValues, computed, onContentWritten, onShow, true, appendAtBeginning); } /** * Appends the desired content inside a given element at the beginning, keeping the existing one (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}). Calls the {@link CB_Elements.insertContent} internally. * @function * @param {Node} container - The element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @returns {Node} Returns the given container again. */ CB_Elements.appendContentBeginning = function(container, content, displayValue, checkValues, computed, onContentWritten, onShow) { return CB_Elements.insertContent(container, content, displayValue, checkValues, computed, onContentWritten, onShow, true, true); } /** * Inserts the desired content inside a given element (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}), by its identifier. * @function * @param {string} containerId - The identifier of the element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @param {boolean} [append=false] - If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. * @param {boolean} [appendAtBeginning=false] - If set to true, it will append the given content to the existing one instead of overwritten it. * @returns {Node|null} Returns the affected container (if any) or null otherwise. */ CB_Elements.insertContentById = function(containerId, content, displayValue, checkValues, computed, onContentWritten, onShow, append, appendAtBeginning) { return CB_Elements.insertContent(CB_Elements.id(containerId), content, displayValue, checkValues, computed, onContentWritten, onShow, append, appendAtBeginning); } /** * Appends the desired content inside a given element, keeping the existing one (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}), by its identifier. Calls the {@link CB_Elements.insertContent} internally. * @function * @param {string} containerId - The identifier of the element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @param {boolean} [append=false] - If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. * @param {boolean} [appendAtBeginning=false] - If set to true, it will append the given content to the existing one instead of overwritten it. * @returns {Node|null} Returns the affected container (if any) or null otherwise. */ CB_Elements.appendContentById = function(containerId, content, displayValue, checkValues, computed, onContentWritten, onShow, appendAtBeginning) { return CB_Elements.insertContent(CB_Elements.id(containerId), content, displayValue, checkValues, computed, onContentWritten, onShow, true, appendAtBeginning); } /** * Appends the desired content inside a given element at the beginning, keeping the existing one (using [innerHTML]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML}), by its identifier. Calls the {@link CB_Elements.insertContent} internally. * @function * @param {string} containerId - The identifier of the element whose content we want to modify. * @param {string} content - The content that we want to add. * @param {string} [displayValue] - If provided, it will call {@link CB_Elements.show} internally after inserting the content to set the given [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the element. * @param {boolean} [checkValues=false] - If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {boolean} [computed=false] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} if it is called internally (when &quot;displayValue&quot; is given). * @param {function} [onContentWritten] - Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. * @param {function} [onShow] - If &quot;displayValue&quot; is given, it will pass this parameter to {@link CB_Elements.show} when it is called internally. * @param {boolean} [append=false] - If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. * @returns {Node|null} Returns the affected container (if any) or null otherwise. */ CB_Elements.appendContentByIdBeginning = function(containerId, content, displayValue, checkValues, computed, onContentWritten, onShow) { return CB_Elements.insertContent(CB_Elements.id(containerId), content, displayValue, checkValues, computed, onContentWritten, onShow, true, true); } /** * Returns the style of an element, computed or static: * @function * @param {Node} element - The element whose style property we want to get. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {Object|null} Returns an associative array (JavaScript object) with all the styles retrieved or null if nothing can be retrieved. */ CB_Elements.getStyle = function(element, computed) { if (typeof(element) === &quot;undefined&quot; || element === null) { return null; } if (computed) { if (&quot;getComputedStyle&quot; in window &amp;&amp; window.getComputedStyle) { return window.getComputedStyle(element, null); } else if (element.currentStyle) { return element.currentStyle; } } if (element.style) { return element.style; } return null; } /** * Returns the style of an element, computed or static (by its identifier): * @function * @param {string} elementId - The identifier of the element whose style property we want to get. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {Object|null} Returns an associative array (JavaScript object) with all the styles retrieved or null if nothing can be retrieved. */ CB_Elements.getStyleById = function(elementId, computed) { return CB_Elements.getStyle(CB_Elements.id(elementId), computed); } /** * Returns the desired attribute value from the style of an element, computed or static: * @function * @param {Node} element - The element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {*} Returns null if nothing can be retrieved. * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStyleProperty = function(element, attribute, computed) { //If we have received a string instead of an element, we try to get an element with that string as id: //if (CB_isString(element)) { element = CB_Elements.id(element); } var elementStyle = CB_Elements.getStyle(element, computed); if (elementStyle !== null &amp;&amp; typeof(elementStyle[attribute]) !== &quot;undefined&quot;) { return elementStyle[attribute]; } return null; } /** * Returns the desired attribute value from the style of an element, computed or static (by its identifier): * @function * @param {string} elementId - The identifier of the element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {*} Returns null if nothing can be retrieved. * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStylePropertyById = function(elementId, attribute, computed) { return CB_Elements.getStyleProperty(CB_Elements.id(elementId), attribute, computed); } /** * Returns the integer value or values (base decimal) of a desired attribute from the style of an element, computed or static: * @function * @param {Node} element - The element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {array} Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStylePropertyInteger = function(element, attribute, computed) { return CB_Elements.getStylePropertyNumeric(element, attribute, computed, true); } /** * Returns the integer value or values (base decimal) of a desired attribute from the style of an element, computed or static (by its identifier): * @function * @param {string} elementId - The identifier of the element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @returns {array} Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStylePropertyIntegerById = function(elementId, attribute, computed) { return CB_Elements.getStylePropertyInteger(CB_Elements.id(elementId), attribute, computed); } /** * Returns the numeric value or values (base decimal) of a desired attribute from the style of an element, computed or static: * @function * @param {Node} element - The element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @param {boolean} [parseToInteger=false] - If it is set to true, the value or values will be parsed to integer. * @returns {array} Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStylePropertyNumeric = function(element, attribute, computed, parseToInteger)//, parseToFloat) { var propertyValue = CB_Elements.getStyleProperty(element, attribute, computed); var propertyValuesNumeric = []; if (typeof(propertyValue) !== &quot;undefined&quot; &amp;&amp; propertyValue !== null) { var propertyValues = propertyValue.split(&quot; &quot;); var propertyValuesLength = propertyValues.length; var y = 0; for (x = 0; x &lt; propertyValues.length; x++) { propertyValue = parseFloat(propertyValues[x]); if (typeof(propertyValue) !== &quot;undefined&quot; &amp;&amp; propertyValue !== null &amp;&amp; !isNaN(propertyValue)) { if (parseToInteger) { propertyValue = parseInt(propertyValue, 10); } //if (parseToFloat) { propertyValue = parseFloat(propertyValue); } //else { propertyValue = parseFloat(propertyValue); } propertyValuesNumeric[y++] = propertyValue; //break; } } } //if (propertyValue === null || CB_trim(propertyValue) === &quot;&quot;) { propertyValue = 0; } if (propertyValuesNumeric.length === 0) { propertyValuesNumeric[0] = 0; } //If there are no values, it will returns 0 as the unique one. //if (isNaN(propertyValue)) { propertyValue = 0; } //if (isNaN(propertyValue)) { propertyValue = 0; } //return propertyValue; return propertyValuesNumeric; } /** * Returns the numeric value or values (base decimal) of a desired attribute from the style of an element, computed or static (by its identifier): * @function * @param {string} elementId - The identifier of the element whose attribute value from its style we want to get. * @param {string} attribute - The name of the attribute whose value we want to get from the style. * @param {boolean} [computed=false] - If it is set to true, it will try to use the native function [window.getComputedStyle]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle} (if available). * @param {boolean} [parseToInteger=false] - If it is set to true, the value or values will be parsed to integer. * @returns {array} Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). * @todo Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). */ CB_Elements.getStylePropertyNumericById = function(elementId, attribute, computed, parseToInteger, parseToFloat) { return CB_Elements.getStylePropertyNumeric(CB_Elements.id(elementId), attribute, computed, parseToInteger, parseToFloat); } /** * Toggles the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (from &quot;none&quot; to the desired value or vice versa) of a given element, to show or hide it. * If the element is hidden (its [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} is &quot;none&quot;), it will call {@link CB_Elements.show} internally to show it. Otherwise, it will call {@link CB_Elements.hide} internally. Note that these two functions will also change the [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property (setting it to either &quot;visible&quot; or &quot;hidden&quot;, respectively) of the element. * @function * @param {Node} element - The element whose [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property we want to toggle. * @param {string} [displayValue='block'] - The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value when we want to show the element (it will be used only if the element is currently hidden, when it calls {@link CB_Elements.show} internally). The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value to hide the element is always &quot;none&quot;. * @param {boolean} [checkValues=false] - This parameter will be used when it calls either {@link CB_Elements.show} or {@link CB_Elements.hide} internally. * @param {boolean} [computed=false] - This parameter will be used to get the current style and also when it calls either {@link CB_Elements.show} or {@link CB_Elements.hide} internally. * @param {function} [onToggleDisplay] - This parameter will be used when it calls either {@link CB_Elements.show} if &quot;onShow&quot; is not provided or {@link CB_Elements.hide} if &quot;onHide&quot; is not provided, internally. * @param {function} [onShow] - This parameter will be used when it calls {@link CB_Elements.show} internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. * @param {function} [onHide] - This parameter will be used when it calls {@link CB_Elements.hide} internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. * @returns {Node} Returns the given element again. */ CB_Elements.showHide = function(element, displayValue, checkValues, computed, onToggleDisplay, onShow, onHide) { var style = CB_Elements.getStyle(element, computed); if (style !== null) { if (style.display === &quot;none&quot;) { CB_Elements.show(element, displayValue, checkValues, computed, typeof(onToggleDisplay) === &quot;function&quot; ? onToggleDisplay : onShow); } else { CB_Elements.hide(element, checkValues, computed, typeof(onToggleDisplay) === &quot;function&quot; ? onToggleDisplay : onHide); } } return element; } /** * Toggles the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (from &quot;none&quot; to the desired value or vice versa) of a given element, to show or hide it (by its identifier). * If the element is hidden (its [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} is &quot;none&quot;), it will call {@link CB_Elements.show} internally to show it. Otherwise, it will call {@link CB_Elements.hide} internally. Note that these two functions will also change the [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property (setting it to either &quot;visible&quot; or &quot;hidden&quot;, respectively) of the element. * @function * @param {string} elementId - The identifier of the element whose [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property we want to toggle. * @param {string} [displayValue='block'] - The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value when we want to show the element (it will be used only if the element is currently hidden, when it calls {@link CB_Elements.show} internally). The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value to hide the element is always &quot;none&quot;. * @param {boolean} [checkValues=false] - This parameter will be used when it calls either {@link CB_Elements.show} or {@link CB_Elements.hide} internally. * @param {boolean} [computed=false] - This parameter will be used to get the current style and also when it calls either {@link CB_Elements.show} or {@link CB_Elements.hide} internally. * @param {function} [onToggleDisplay] - This parameter will be used when it calls either {@link CB_Elements.show} if &quot;onShow&quot; is not provided or {@link CB_Elements.hide} if &quot;onHide&quot; is not provided, internally. * @param {function} [onShow] - This parameter will be used when it calls {@link CB_Elements.show} internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. * @param {function} [onHide] - This parameter will be used when it calls {@link CB_Elements.hide} internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.showHideById = function(elementId, displayValue, checkValues, computed, onToggleDisplay, onShow, onHide) { return CB_Elements.showHide(CB_Elements.id(elementId), displayValue, checkValues, computed, onToggleDisplay, onShow, onHide); } /** * Changes the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the desired value of a given element, to show it. Its [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property will be set to &quot;visible&quot;. * @function * @param {Node} element - The element whose [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property we want to change. * @param {string} [displayValue='block'] - The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value we want to set. If not provided or &quot;none&quot; is provided, it will use &quot;block&quot; instead. * @param {boolean} [checkValues=false] - If it is set to true, it will only perform the change if either the current [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property is not &quot;visible&quot; or the current [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property is different from the given one. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyle} internally. * @param {function} [onShow] - Callback function that will be called if the change has been performed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (not computed). * @returns {Node} Returns the given element again. */ CB_Elements.show = function(element, displayValue, checkValues, computed, onShow) { var style = CB_Elements.getStyle(element, computed); if (style !== null) { displayValue = CB_trim(displayValue); if (displayValue === &quot;&quot; || displayValue.toLowerCase() === &quot;none&quot;) { displayValue = &quot;block&quot;; } if (!checkValues || style.visibility !== &quot;visible&quot; || style.display !== displayValue) { element.style.visibility = &quot;visible&quot;; element.style.display = displayValue; if (typeof(onShow) === &quot;function&quot;) { onShow(element, element.style.display); } } } return element; } /** * Changes the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to the desired value of a given element, to show it (by its identifier). Its [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property will be set to &quot;visible&quot;. * @function * @param {string} elementId - The identifier of the element whose [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property we want to change. * @param {string} [displayValue='block'] - The [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} value we want to set. If not provided or &quot;none&quot; is provided, it will use &quot;block&quot; instead. * @param {boolean} [checkValues=false] - If it is set to true, it will only perform the change if either the current [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property is not &quot;visible&quot; or the current [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property is different from the given one. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyle} internally. * @param {function} [onShow] - Callback function that will be called if the change has been performed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (not computed). * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.showById = function(elementId, displayValue, checkValues, computed, onShow) { return CB_Elements.show(CB_Elements.id(elementId), displayValue, checkValues, computed, onShow); } /** * Hides a given element by changing its [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to &quot;none&quot; and its [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} to &quot;hidden&quot;. * @function * @param {Node} element - The element that we want to hide. * @param {boolean} [checkValues=false] - If it is set to true, it will only perform the change if either the current [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property is not &quot;hidden&quot; or the current [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property is not &quot;none&quot;. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyle} internally. * @param {function} [onHide] - Callback function that will be called if the element has been hidden, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (not computed) which should be &quot;none&quot;. * @returns {Node} Returns the given element again. */ CB_Elements.hide = function(element, checkValues, computed, onHide) { var style = CB_Elements.getStyle(element, computed); if (style !== null) { if (!checkValues || style.visibility !== &quot;hidden&quot; || style.display !== &quot;none&quot;) { element.style.visibility = &quot;hidden&quot;; element.style.display = &quot;none&quot;; if (typeof(onHide) === &quot;function&quot;) { onHide(element, element.style.display); } } } return element; } /** * Hides a given element by changing its [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property to &quot;none&quot; and its [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} to &quot;hidden&quot; (by its identifier). * @function * @param {string} elementId - The identifier of the element that we want to hide. * @param {boolean} [checkValues=false] - If it is set to true, it will only perform the change if either the current [visibility]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility} property is not &quot;hidden&quot; or the current [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property is not &quot;none&quot;. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyle} internally. * @param {function} [onHide] - Callback function that will be called if the element has been hidden, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the [display]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/display} property (not computed) which should be &quot;none&quot;. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.hideById = function(elementId, checkValues, computed, onHide) { return CB_Elements.hide(CB_Elements.id(elementId), checkValues, computed, onHide); } /** * Toggles the class of a given element between two given classes or adds/removes the given class. The element can contain other classes and they will be kept. * @function * @param {Node} element - The element whose class we want to toggle. * @param {string} classA - The class that will be used in the case that the element is not using it already. * @param {string} [classB=''] - The class that will be used in the case that the given &quot;classA&quot; is being used by the element. If not given or an empty string is given, it will just remove the &quot;classA&quot; in the case it is being used by the element. * @param {function} [onToggleClass] - Callback function that will be called if the class of the element has been toggled or removed, after doing it. The first parameter passed will be the affected element itself and the second and last parameter will be the class used this time (or an empty string). * @returns {Node} Returns the given element again. */ CB_Elements.toggleClass = function(element, classA, classB, onToggleClass) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { classA = CB_trim(classA).toLowerCase(); classB = CB_trim(classB).toLowerCase(); if (classA === &quot;&quot; &amp;&amp; classB === &quot;&quot;) { return element; } else if (classA === &quot;&quot;) { classA = classB; classB = &quot;&quot;; } var classesUsed = &quot; &quot; + CB_trim(element.className).toLowerCase() + &quot; &quot;; if (classesUsed.indexOf(&quot; &quot; + classA + &quot; &quot;) === -1) { if (classB !== &quot;&quot; &amp;&amp; classesUsed.indexOf(&quot; &quot; + classB + &quot; &quot;) !== -1) { classesUsed = classesUsed.replace(CB_regularExpressionString(&quot; &quot; + classB + &quot; &quot;, true, true), &quot; &quot; + classA + &quot; &quot;); } else { classesUsed += &quot; &quot; + classA; } element.className = CB_trim(classesUsed); if (typeof(onToggleClass) === &quot;function&quot;) { onToggleClass(element, classA); } } else { classesUsed = classesUsed.replace(CB_regularExpressionString(&quot; &quot; + classA + &quot; &quot;, true, true), &quot; &quot;); if (classB !== &quot;&quot; &amp;&amp; classesUsed.indexOf(&quot; &quot; + classB + &quot; &quot;) === -1) { classesUsed += &quot; &quot; + classB; } element.className = CB_trim(classesUsed); if (typeof(onToggleClass) === &quot;function&quot;) { onToggleClass(element, classB); } } } return element; } /** * Toggles the class of a given element between two given classes (by its identifier). The element can contain other classes and they will be kept. * @function * @param {string} elementId - The identifier of the element whose class we want to toggle. * @param {string} classA - The class that will be used in the case that the element is not using it already. * @param {string} [classB=''] - The class that will be used in the case that the given &quot;classA&quot; is being used by the element. If not given or an empty string is given, it will just remove the &quot;classA&quot; in the case it is being used by the element. * @param {function} [onToggleClass] - Callback function that will be called if the class of the element has been toggled or removed, after doing it. The first parameter passed will be the affected element itself and the second and last parameter will be the class used this time (or an empty string). * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.toggleClassById = function(elementId, classA, classB, onToggleClass) { return CB_Elements.toggleClass(CB_Elements.id(elementId), classA, classB, onToggleClass); } /** * Removes a desired class from a given element. The element can contain other classes and they will be kept. * @function * @param {Node} element - The element whose class we want to remove. * @param {string} className - The class that will be removed if the element is using it. * @param {boolean} [checkValues=false] - If it is set to true, it will only try to perform the action if the given &quot;className&quot; is being used. The result will be the same with either true or false, but depending on the client used it could gain or lose performance. * @param {function} [onRemoveClass] - Callback function that will be called if the class of the element has been tried to be removed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node} Returns the given element again. * @todo Think about allowing to remove more than once class at the same time, regardless of the order given and order set. */ CB_Elements.removeClass = function(element, className, checkValues, onRemoveClass) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { className = CB_trim(className).toLowerCase(); if (className === &quot;&quot;) { return element; } var classesUsed = &quot; &quot; + CB_trim(element.className).toLowerCase() + &quot; &quot;; if (!checkValues || classesUsed.indexOf(&quot; &quot; + className + &quot; &quot;) !== -1) { element.className = CB_trim(classesUsed.replace(CB_regularExpressionString(&quot; &quot; + className + &quot; &quot;, true, true), &quot; &quot;)); if (typeof(onRemoveClass) === &quot;function&quot;) { onRemoveClass(element); } } } return element; } /** * Removes a desired class from a given element (by its identifier). The element can contain other classes and they will be kept. * @function * @param {string} elementId - The identifier of the element whose class we want to remove. * @param {string} className - The class that will be removed if the element is using it. * @param {boolean} [checkValues=false] - If it is set to true, it will only try to perform the action if the given &quot;className&quot; is being used. The result will be the same with either true or false, but depending on the client used it could gain or lose performance. * @param {function} [onRemoveClass] - Callback function that will be called if the class of the element has been tried to be removed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node|null} Returns the affected element (if any) or null otherwise. * @todo Think about allowing to remove more than once class at the same time, regardless of the order given and order set. */ CB_Elements.removeClassById = function(elementId, className, checkValues, onRemoveClass) { return CB_Elements.removeClass(CB_Elements.id(elementId), className, checkValues, onRemoveClass); } /** * Adds a desired class to a given element. The element can contain other classes and they will be kept. * @function * @param {Node} element - The element that will get the new given class. * @param {string} className - The class that will be added. * @param {boolean} [checkValues=false] - If it is set to true, it will only try to add the given class if it is not being used already. It is recommended to use true to prevent some old clients from adding the same class multiple times. * @param {function} [onAddClass] - Callback function that will be called if the class of the element has been added, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node} Returns the given element again. * @todo Think about allowing to use more than once class (and think how many times the &quot;onAddClass&quot; function should be called). */ CB_Elements.addClass = function(element, className, checkValues, onAddClass) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { className = CB_trim(className).toLowerCase(); if (className === &quot;&quot;) { return element; } var classesUsed = &quot; &quot; + CB_trim(element.className).toLowerCase() + &quot; &quot;; if (!checkValues || classesUsed.indexOf(&quot; &quot; + className + &quot; &quot;) === -1) { element.className = CB_trim(CB_trim(classesUsed) + &quot; &quot; + className); if (typeof(onAddClass) === &quot;function&quot;) { onAddClass(element); } } } return element; } /** * Adds a desired class to a given element (by its identifier). The element can contain other classes and they will be kept. * @function * @param {string} elementId - The identifier of the element that will get the new given class. * @param {string} className - The class that will be added. * @param {boolean} [checkValues=false] - If it is set to true, it will only try to add the given class if it is not being used already. It is recommended to use true to prevent some old clients from adding the same class multiple times. * @param {function} [onAddClass] - Callback function that will be called if the class of the element has been added, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node|null} Returns the affected element (if any) or null otherwise. * @todo Think about allowing to use more than once class (and think how many times the &quot;onAddClass&quot; function should be called). */ CB_Elements.addClassById = function(elementId, className, checkValues, onAddClass) { return CB_Elements.addClass(CB_Elements.id(elementId), className, checkValues, onAddClass); } /** * Sets a desired class or classes to a given element. All previous classes (if any) will be replaced by the new one or new ones. * @function * @param {Node} element - The element that will get the new given class or classes. * @param {string} classNames - The class or classes that will be set. More than one class can be given (separated by blank spaces). * @param {boolean} [checkValues=false] - If it is set to true, it will only try to set the given class or classes if they are not being used already. * @param {function} [onSetClass] - Callback function that will be called if the class or classes of the element have been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node} Returns the given element again. */ CB_Elements.setClass = function(element, classNames, checkValues, onSetClass) { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { if (!checkValues || element.className !== classNames) { element.className = classNames; if (typeof(onSetClass) === &quot;function&quot;) { onSetClass(element); } } } return element; } /** * Sets a desired class or classes to a given element (by its identifier). All previous classes (if any) will be replaced by the new one or new ones. * @function * @param {string} elementId - The identifier of the element that will get the new given class or classes. * @param {string} classNames - The class or classes that will be set. More than one class can be given (separated by blank spaces). * @param {boolean} [checkValues=false] - If it is set to true, it will only try to set the given class or classes if they are not being used already. * @param {function} [onSetClass] - Callback function that will be called if the class or classes of the element have been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.setClassById = function(elementId, classNames, checkValues, onSetClass) { return CB_Elements.setClass(CB_Elements.id(elementId), classNames, checkValues, onSetClass); } /** * Returns the left position of an element (having in mind [getBoundingClientRect]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect} if available, its parents, etc.). * @function * @param {Node} element - The element whose data we are interested in. * @param {boolean} [ignoreScroll=true] - If it is set to false, it will have in mind the current scroll position to calculate the result. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyleProperty} and {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getLeft = function(element, ignoreScroll, returnNullOnFail, computed) { if (typeof(element) === &quot;undefined&quot; || element === null) { return returnNullOnFail ? null : 0; } //If it's not set, we mind scroll as default: if (typeof(ignoreScroll) === &quot;undefined&quot; || ignoreScroll === null) { ignoreScroll = true; } var elementLeft = 0; var originalElement = true; if (typeof(element.getBoundingClientRect) !== &quot;undefined&quot; &amp;&amp; element.getBoundingClientRect !== null) { var rect = element.getBoundingClientRect(); if (typeof(rect.left) !== &quot;undefined&quot; &amp;&amp; rect.left !== null &amp;&amp; !isNaN(rect.left)) { elementLeft = rect.left; elementLeft -= CB_Client.getBoundingClientRectMargin(&quot;left&quot;); if (ignoreScroll) { elementLeft += CB_Screen.getScrollLeft(); } return elementLeft; } } //Gets the left position having in mind its parents (if any) and adds them: do { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var elementPosition = CB_Elements.getStyleProperty(element, &quot;position&quot;, computed); if (elementPosition === &quot;absolute&quot;) { if (typeof(getComputedStyle) !== &quot;undefined&quot; &amp;&amp; getComputedStyle !== null) { if (element !== document &amp;&amp; !isNaN(parseInt(getComputedStyle(element, &quot;&quot;).getPropertyValue(&quot;left&quot;)))) { elementLeft += parseInt(getComputedStyle(element, &quot;&quot;).getPropertyValue(&quot;left&quot;)); } else if (!isNaN(parseInt(getComputedStyle(document.body, &quot;&quot;).getPropertyValue(&quot;left&quot;)))) { elementLeft += parseInt(getComputedStyle(document.body, &quot;&quot;).getPropertyValue(&quot;left&quot;)); } ////////elementLeft += CB_Elements.getStylePropertyInteger(element, &quot;borderLeftWidth&quot;)[0]; ////////elementLeft += CB_Elements.getStylePropertyInteger(element, &quot;paddingLeft&quot;)[0]; elementLeft += CB_Elements.getStylePropertyInteger(element, &quot;borderLeftWidth&quot;, computed)[0]; elementLeft += CB_Elements.getStylePropertyInteger(element, &quot;paddingLeft&quot;, computed)[0]; if (originalElement) { ///////elementLeft -= CB_Elements.getStylePropertyInteger(element, &quot;border&quot;)[0]; elementLeft -= CB_Elements.getStylePropertyInteger(element, &quot;border&quot;, computed)[0]; originalElement = false; } } else if (typeof(element.offsetLeft) !== &quot;undefined&quot; &amp;&amp; element.offsetLeft !== null &amp;&amp; !isNaN(parseInt(element.offsetLeft))) { elementLeft += parseInt(element.offsetLeft, 10); } } else { if (typeof(element.offsetLeft) !== &quot;undefined&quot; &amp;&amp; element.offsetLeft !== null &amp;&amp; !isNaN(parseInt(element.offsetLeft))) { elementLeft += parseInt(element.offsetLeft, 10); } } } if (typeof(element.offsetParent) !== &quot;undefined&quot; &amp;&amp; element.offsetParent !== null) { element = element.offsetParent; } /* else if (typeof(element.parentNode) !== &quot;undefined&quot; &amp;&amp; element.parentNode !== null) { element = element.parentNode; } else if (typeof(element.parentElement) !== &quot;undefined&quot; &amp;&amp; element.parentElement !== null) { element = element.parentElement; } */ else { var elementParent = CB_Elements.getParent(element); if (typeof(elementParent) !== &quot;undefined&quot; &amp;&amp; elementParent !== null) { element = elementParent; } else { element = null; } } } while (element) if (!ignoreScroll) { elementLeft -= CB_Screen.getScrollLeft(); } return isNaN(elementLeft) &amp;&amp; returnNullOnFail ? null : elementLeft; } /** * Returns the left position of an element (having in mind [getBoundingClientRect]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect} if available, its parents, etc.), by its identifier. * @function * @param {string} elementId - The identifier of the element whose data we are interested in. * @param {boolean} [ignoreScroll=true] - If it is set to false, it will have in mind the current scroll position to calculate the result. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyleProperty} and {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getLeftById = function(elementId, ignoreScroll, returnNullOnFail, computed) { return CB_Elements.getLeft(CB_Elements.id(elementId), ignoreScroll, returnNullOnFail, computed); } /** * Returns the top position of an element (having in mind [getBoundingClientRect]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect} if available, its parents, etc.). * @function * @param {Node} element - The element whose data we are interested in. * @param {boolean} [ignoreScroll=true] - If it is set to false, it will have in mind the current scroll position to calculate the result. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyleProperty} and {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getTop = function(element, ignoreScroll, returnNullOnFail, computed) { if (typeof(element) === &quot;undefined&quot; || element === null) { return returnNullOnFail ? null : 0; } //If it's not set, we mind scroll as default: if (typeof(ignoreScroll) === &quot;undefined&quot; || ignoreScroll === null) { ignoreScroll = true; } var elementTop = 0; var originalElement = true; if (typeof(element.getBoundingClientRect) !== &quot;undefined&quot; &amp;&amp; element.getBoundingClientRect !== null) { var rect = element.getBoundingClientRect(); if (typeof(rect.top) !== &quot;undefined&quot; &amp;&amp; rect.top !== null &amp;&amp; !isNaN(rect.top)) { elementTop = rect.top; elementTop -= CB_Client.getBoundingClientRectMargin(&quot;top&quot;); if (ignoreScroll) { elementTop += CB_Screen.getScrollTop(); } return elementTop; } } //Gets the top position having in mind its parents (if any) and adds them: do { if (typeof(element) !== &quot;undefined&quot; &amp;&amp; element !== null) { var elementPosition = CB_Elements.getStyleProperty(element, &quot;position&quot;, computed); if (elementPosition === &quot;absolute&quot;) { if (typeof(getComputedStyle) !== &quot;undefined&quot; &amp;&amp; getComputedStyle !== null) { if (element !== document &amp;&amp; !isNaN(parseInt(getComputedStyle(element, &quot;&quot;).getPropertyValue(&quot;top&quot;)))) { elementTop += parseInt(getComputedStyle(element, &quot;&quot;).getPropertyValue(&quot;top&quot;)); } else if (!isNaN(parseInt(getComputedStyle(document.body, &quot;&quot;).getPropertyValue(&quot;top&quot;)))) { elementTop += parseInt(getComputedStyle(document.body, &quot;&quot;).getPropertyValue(&quot;top&quot;)); } ////////elementTop += CB_Elements.getStylePropertyInteger(element, &quot;borderTopWidth&quot;)[0]; ////////elementTop += CB_Elements.getStylePropertyInteger(element, &quot;paddingTop&quot;)[0]; elementTop += CB_Elements.getStylePropertyInteger(element, &quot;borderTopWidth&quot;, computed)[0]; elementTop += CB_Elements.getStylePropertyInteger(element, &quot;paddingTop&quot;, computed)[0]; if (originalElement) { //////////elementTop -= CB_Elements.getStylePropertyInteger(element, &quot;border&quot;)[0]; elementTop -= CB_Elements.getStylePropertyInteger(element, &quot;border&quot;, computed)[0]; originalElement = false; } } else if (typeof(element.offsetTop) !== &quot;undefined&quot; &amp;&amp; element.offsetTop !== null &amp;&amp; !isNaN(parseInt(element.offsetTop))) { elementTop += parseInt(element.offsetTop, 10); } } else { if (typeof(element.offsetTop) !== &quot;undefined&quot; &amp;&amp; element.offsetTop !== null &amp;&amp; !isNaN(parseInt(element.offsetTop))) { elementTop += parseInt(element.offsetTop, 10); } } } if (typeof(element.offsetParent) !== &quot;undefined&quot; &amp;&amp; element.offsetParent !== null) { element = element.offsetParent; } /* else if (typeof(element.parentNode) !== &quot;undefined&quot; &amp;&amp; element.parentNode !== null) { element = element.parentNode; } else if (typeof(element.parentElement) !== &quot;undefined&quot; &amp;&amp; element.parentElement !== null) { element = element.parentElement; } else { element = null; } */ else { var elementParent = CB_Elements.getParent(element); if (typeof(elementParent) !== &quot;undefined&quot; &amp;&amp; elementParent !== null) { element = elementParent; } else { element = null; } } } while (element) if (!ignoreScroll) { elementTop -= CB_Screen.getScrollTop(); } return isNaN(elementTop) &amp;&amp; returnNullOnFail ? null : elementTop; } /** * Returns the top position of an element (having in mind [getBoundingClientRect]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect} if available, its parents, etc.), by its identifier. * @function * @param {string} elementId - The identifier of the element whose data we are interested in. * @param {boolean} [ignoreScroll=true] - If it is set to false, it will have in mind the current scroll position to calculate the result. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStyleProperty} and {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getTopById = function(elementId, ignoreScroll, returnNullOnFail, computed) { return CB_Elements.getTop(CB_Elements.id(elementId), ignoreScroll, returnNullOnFail, computed); } /** * Returns the width of an element (having in mind its border). * @function * @param {Node} element - The element whose data we are interested in. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getWidth = function(element, returnNullOnFail, computed) { if (typeof(element) === &quot;undefined&quot; || element === null) { return returnNullOnFail ? null : 0; } var elementWidth = 0; if (typeof(element.getBoundingClientRect) !== &quot;undefined&quot; &amp;&amp; element.getBoundingClientRect !== null) { var rect = element.getBoundingClientRect(); if (typeof(rect.width) !== &quot;undefined&quot; &amp;&amp; rect.width !== null &amp;&amp; !isNaN(rect.width)) { elementWidth += rect.width; } } if (typeof(elementWidth) === &quot;undefined&quot; || elementWidth === null || isNaN(elementWidth) || elementWidth === 0) { if (typeof(element.offsetWidth) !== &quot;undefined&quot; &amp;&amp; element.offsetWidth !== null &amp;&amp; !isNaN(parseInt(element.offsetWidth))) { elementWidth += parseInt(element.offsetWidth, 10); } else { /* elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;width&quot;)[0]; //elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;border&quot;)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;borderLeftWidth&quot;)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;borderRightWidth&quot;)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;paddingLeft&quot;)[0]; */ elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;width&quot;, computed)[0]; //elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;border&quot;, computed)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;borderLeftWidth&quot;, computed)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;borderRightWidth&quot;, computed)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;paddingLeft&quot;, computed)[0]; } } return isNaN(elementWidth) &amp;&amp; returnNullOnFail ? null : elementWidth; } /** * Returns the width of an element (having in mind its border), by its identifier. * @function * @param {string} elementId - The identifier of the element whose data we are interested in. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getWidthById = function(elementId, returnNullOnFail, computed) { return CB_Elements.getWidth(CB_Elements.id(elementId)); } /** * Returns the height of an element (having in mind its border). * @function * @param {Node} element - The element whose data we are interested in. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getHeight = function(element, returnNullOnFail, computed) { if (typeof(element) === &quot;undefined&quot; || element === null) { return returnNullOnFail ? null : 0; } var elementHeight = 0; if (typeof(element.getBoundingClientRect) !== &quot;undefined&quot; &amp;&amp; element.getBoundingClientRect !== null) { var rect = element.getBoundingClientRect(); if (typeof(rect.height) !== &quot;undefined&quot; &amp;&amp; rect.height !== null &amp;&amp; !isNaN(rect.height)) { elementHeight += rect.height; } } if (typeof(elementHeight) === &quot;undefined&quot; || elementHeight === null || isNaN(elementHeight) || elementHeight === 0) { if (typeof(element.offsetHeight) !== &quot;undefined&quot; &amp;&amp; element.offsetHeight !== null &amp;&amp; !isNaN(parseInt(element.offsetHeight))) { elementHeight += parseInt(element.offsetHeight, 10); } else { /* elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;height&quot;)[0]; //elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;border&quot;)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;borderTopWidth&quot;)[0]; elementWidth += CB_Elements.getStylePropertyInteger(element, &quot;borderBottomWidth&quot;)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;paddingTop&quot;)[0]; */ elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;height&quot;, computed)[0]; //elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;border&quot;, computed)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;borderTopWidth&quot;, computed)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;borderBottomWidth&quot;, computed)[0]; elementHeight += CB_Elements.getStylePropertyInteger(element, &quot;paddingTop&quot;, computed)[0]; } } return isNaN(elementHeight) &amp;&amp; returnNullOnFail ? null : elementHeight; } /** * Returns the height of an element (having in mind its border), by its identifier. * @function * @param {string} elementId - The identifier of the element whose data we are interested in. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @param {boolean} [computed=false] - This parameter will be used when it calls {@link CB_Elements.getStylePropertyInteger} internally. * @returns {*} It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getHeightById = function(elementId, returnNullOnFail, computed) { return CB_Elements.getHeight(CB_Elements.id(elementId)); } /** * Prevents or allows the possibility of selecting the content of a given element (makes it unselectable). * @function * @param {Node} element - The element which we want to affect. * @param {boolean} [avoidSelection=true] - If set to false, it will allow selecting the content. Otherwise, it will prevent it to be selected. * @returns {Node|null} Returns the given element again or null. */ CB_Elements.preventSelection = function(element, avoidSelection) { if (typeof(element) === &quot;undefined&quot; || element === null) { return null; } if (avoidSelection !== true &amp;&amp; avoidSelection !== false) { avoidSelection = true; } if (avoidSelection) { element.unselectable = &quot;on&quot;; element.style.MozUserSelect = &quot;none&quot;; element.style.WebkitUserSelect = &quot;none&quot;; element.style.userSelect = &quot;none&quot;; element.style.KhtmlUserSelect = &quot;none&quot;; element.style.MsUserSelect = &quot;none&quot;; element.style.MsTouchSelect = &quot;none&quot;; element.style.touchSelect = &quot;none&quot;; //-webkit-tap-highlight-color:rgba(0, 0, 0, 0); //-webkit-touch-callout:none; //-ms-touch-action:none; //-touch-action:none; element.onselectstart = function() { return false; }; } else { element.unselectable = undefined; element.style.MozUserSelect = undefined; element.style.WebkitUserSelect = undefined; element.style.userSelect = undefined; element.style.KhtmlUserSelect = undefined; element.style.MsUserSelect = undefined; element.style.MsTouchSelect = undefined; element.style.touchSelect = undefined; //-webkit-tap-highlight-color:rgba(0, 0, 0, 0); //-webkit-touch-callout:none; //-ms-touch-action:none; //-touch-action:none; element.onselectstart = undefined; } return element; } /** * Prevents or allows the possibility of selecting the content of a given element (makes it unselectable), by its ID. * @function * @param {string} elementId - The identifier of the element which we want to affect. * @param {boolean} [avoidSelection=true] - If set to false, it will allow selecting the content. Otherwise, it will prevent it to be selected. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.preventSelectionById = function(elementId, allowSelection) { return CB_Elements.preventSelection(CB_Elements.id(elementId), allowSelection); } /** * Disables or enables the contextual menu for a given element or in the whole document. * @function * @param {Node} [element=document] - The element whose contextual menu we want to disable or enable. If not given, it will affect the whole document. * @param {boolean} [disableContextMenu=true] - If set to false, it will allow showing the contextual menu. Otherwise, it will prevent it to show. * @returns {Node} Returns the affected element. */ CB_Elements.contextMenuDisable = function(element, disableContextMenu) { if (typeof(element) === &quot;undefined&quot; || element === null) { element = document; } if (disableContextMenu !== true &amp;&amp; disableContextMenu !== false) { disableContextMenu = true; } if (disableContextMenu) { CB_Events.add(element, &quot;contextmenu&quot;, function(e) { e = CB_Events.normalize(e); if (typeof(e.preventDefault) !== &quot;undefined&quot;) { e.preventDefault(); } return false; }, true, true, false); } else { element.contextmenu = undefined; } return element; } /** * Disables or enables the contextual menu for a given element (by its identifier). * @function * @param {string} elementId - The identifier of the element whose contextual menu we want to disable or enable. * @param {boolean} [disableContextMenu=true] - If set to false, it will allow showing the contextual menu. Otherwise, it will prevent it to show. * @returns {Node|null} Returns the affected element (if any) or null otherwise. */ CB_Elements.contextMenuDisableById = function(elementId, allowContextMenu) { var element = CB_Elements.id(elementId); if (element !== null) { return CB_Elements.contextMenuDisable(element, allowContextMenu); } return null; } /** * Tries to get the body content of an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}. Depending on the client and the safety measures, this might fail. * @function * @param {HTMLIFrameElement} frameElement - The [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} element whose body content we want to get. * @returns {string|null} Returns null if something goes wrong. */ //* Source: Jose Basilio and nekno @ http://stackoverflow.com/questions/926916/how-to-get-the-bodys-content-of-an-iframe-in-javascript CB_Elements.getFrameBodyContent = function(frameElement) { if (typeof(frameElement) !== &quot;undefined&quot; &amp;&amp; frameElement !== null) { var frameBody = null; if (frameElement.contentDocument &amp;&amp; typeof(frameElement.contentDocument.getElementsByTagName) !== &quot;undefined&quot;) { frameBody = frameElement.contentDocument.getElementsByTagName(&quot;body&quot;); if (frameBody !== null &amp;&amp; typeof(frameBody[0]) !== &quot;undefined&quot; &amp;&amp; frameBody[0] !== null) { frameBody = frameBody[0]; } else { frameBody = null; } } if (frameBody === null &amp;&amp; frameElement.contentWindow &amp;&amp; typeof(frameElement.contentWindow.document) !== &quot;undefined&quot; &amp;&amp; typeof(frameElement.contentWindow.document.getElementsByTagName) !== &quot;undefined&quot;) { frameBody = frameElement.contentWindow.document.getElementsByTagName(&quot;body&quot;); if (frameBody !== null &amp;&amp; typeof(frameBody[0]) !== &quot;undefined&quot; &amp;&amp; frameBody[0] !== null) { frameBody = frameBody[0]; } else { frameBody = null; } } if (frameBody === null &amp;&amp; frameElement !== &quot;&quot; &amp;&amp; window.frames &amp;&amp; window.frames[frameElement] &amp;&amp; window.frames[frameElement].document &amp;&amp; window.frames[frameElement].document.body) { frameBody = window.frames[frameElement].document.body; } if (typeof(frameBody) !== &quot;undefined&quot; &amp;&amp; frameBody !== null &amp;&amp; frameBody.innerHTML) { return frameBody.innerHTML; } } return null; } /** * Tries to get the body content of an [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} (by its identifier). Depending on the client and the safety measures, this might fail. * @function * @param {string} frameElementId - The identifier of the [iframe]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe} element whose body content we want to get. * @returns {string|null} Returns null if something goes wrong. */ CB_Elements.getFrameBodyContentById = function(frameElementId) { CB_Elements.getFrameBodyContent(CB_Elements.id(frameElementId)); } /** * Callback that is used as the &quot;onScrollLeftChanges&quot; parameter for the {@link CB_Elements.getScrollLeftById} function or as the &quot;onScrollTopChanges&quot; parameter for the {@link CB_Elements.getScrollTopById} function. All values received should be checked since some could be not numbers. * @memberof CB_Elements * @callback CB_Elements.getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES * @param {*} scrollLeftOrTop - The scroll left or scroll top position. * @param {*} scrollLeftOrTopPrevious - The previous scroll left or scroll top position. * @param {*} scrollWidthOrHeight - The scroll width or scroll height. * @param {*} clientWidthOrHeight - The client width or client height ([element.clientWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth}/[element.offsetWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth} or [element.clientHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight}/[element.offsetHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight}, depending on the web client). * @param {*} scrollLeftOrTopRelative - The relative scroll left or scroll top position. * @param {*} scrollLeftOrTopRelativePrevious - The previous relative scroll left or scroll top position. */ CB_Elements._getScrollLeftByIdLastValue = {}; CB_Elements._getScrollLeftByIdTimeout = {}; CB_Elements._getScrollLeftByIdScrollRelativePrevious = {}; /** * Returns the horizontal scroll of a given element (by its identifier) and allows running a callback function (becoming recursive if desired). Any previous interval started by a previous call to this function, for the same &quot;elementId&quot;, will be stopped. * @function * @param {string|window} [elementId=window] - The identifier of the element whose horizontal scroll position we want to get. If a string with the identifier is not given, the unique value allowed is the window object (which is the default value when a non-valid value or no value is given). * @param {CB_Elements.getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES} [onScrollLeftChanges] - The desired callback function. It will be called as an interval if &quot;timeoutMs&quot; is a valid integer value. * @param {boolean} [fireFirstTime=false] - If it is set to true, it will call the callback function (if any) as soon as this function is called. * @param {boolean} [fireAlways=false] - If it is set to true, it will call the callback function (if any) every interval even if the horizontal scroll value has not changed from the last call. * @param {integer} [timeoutMs] - The number of milliseconds between one call to the callback function (if any) and the next one. If not given, it will not perform any interval. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @returns {number|null} Returns the horizontal scroll of the given element (by its identifier). It could return zero (0) if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getScrollLeftById = function(elementId, onScrollLeftChanges, fireFirstTime, fireAlways, timeoutMs, returnNullOnFail, timeout) { if (typeof(elementId) === &quot;undefined&quot; || elementId === null || elementId === window) { elementId === &quot;_WHOLE_DOCUMENT_&quot;; } if (typeof(CB_Elements._getScrollLeftByIdLastValue[elementId]) === &quot;undefined&quot;) { CB_Elements._getScrollLeftByIdLastValue[elementId] = null; } if (typeof(timeout) === &quot;undefined&quot; || timeout === null) { if (typeof(CB_Elements._getScrollLeftByIdTimeout[elementId]) === &quot;undefined&quot;) { CB_Elements._getScrollLeftByIdTimeout[elementId] = null; } timeout = CB_Elements._getScrollLeftByIdTimeout[elementId]; } clearTimeout(timeout); var element = CB_isString(elementId) ? CB_Elements.id(elementId) : elementId; var scrollLeftValue = returnNullOnFail ? null : 0; if (typeof(element) === &quot;undefined&quot; || element === null || element === window) { element = CB_Elements.tag(&quot;body&quot;, document); if (element === null || typeof(element[0]) === &quot;undefined&quot; || element[0] === null) { return returnNullOnFail ? null : 0; } element = element[0]; if (typeof(window.pageXOffset) !== &quot;undefined&quot;) { scrollLeftValue = window.pageXOffset; } else if (typeof(window.scrollX) !== &quot;undefined&quot;) { scrollLeftValue = window.scrollX; } else if (typeof(document.documentElement.scrollLeft) !== &quot;undefined&quot; &amp;&amp; document.documentElement.scrollLeft !== null &amp;&amp; !isNaN(document.documentElement.scrollLeft) &amp;&amp; document.documentElement.scrollLeft &gt; 0) { scrollLeftValue = document.documentElement.scrollLeft; } else if (typeof(document.body.scrollLeft) !== &quot;undefined&quot; &amp;&amp; document.body.scrollLeft !== null) { scrollLeftValue = document.body.scrollLeft; } } else { if (typeof(element.scrollLeft) !== &quot;undefined&quot; &amp;&amp; element.scrollLeft !== null &amp;&amp; !isNaN(element.scrollLeft) &amp;&amp; element.scrollLeft &gt; 0) { scrollLeftValue = element.scrollLeft; } else if (typeof(element.scrollWidth) !== &quot;undefined&quot; &amp;&amp; element.scrollWidth !== null &amp;&amp; !isNaN(element.scrollWidth) &amp;&amp; element.scrollWidth &gt; 0) { scrollLeftValue = element.scrollWidth; } } if (isNaN(scrollLeftValue)) { scrollLeftValue = 0; if (returnNullOnFail) { scrollLeftValue = null; } } //If it's not the first time and scroll has been changed, calls the onScrollLeft function (if any): if (fireAlways || ((fireFirstTime || CB_Elements._getScrollLeftByIdLastValue[elementId] !== null) &amp;&amp; CB_Elements._getScrollLeftByIdLastValue[elementId] !== scrollLeftValue)) { //If there is any defined function: if (typeof(onScrollLeftChanges) === &quot;function&quot;) { var scrollRelative = (scrollLeftValue + (element.clientWidth || element.offsetWidth)) / element.scrollWidth * 100; if (isNaN(scrollRelative)) { scrollRelative = 0; if (returnNullOnFail) { scrollRelative = null; } } //Sets the new position (to avoid possible infinite recursive loop in the case fireAlways is false): CB_Elements._getScrollLeftByIdLastValue[elementId] = scrollLeftValue; //Executes the function: onScrollLeftChanges(scrollLeftValue, CB_Elements._getScrollLeftByIdLastValue[elementId], element.scrollWidth, element.clientWidth || element.offsetWidth, scrollRelative, CB_Elements._getScrollLeftByIdScrollRelativePrevious[elementId]); CB_Elements._getScrollLeftByIdScrollRelativePrevious[elementId] = scrollRelative; } } //Sets the new position: CB_Elements._getScrollLeftByIdLastValue[elementId] = scrollLeftValue; if (typeof(timeoutMs) !== &quot;undefined&quot; &amp;&amp; timeoutMs !== null &amp;&amp; !isNaN(timeoutMs) &amp;&amp; timeoutMs &gt;= 0) { CB_Elements._getScrollLeftByIdTimeout[elementId] = timeout = setTimeout ( function() { CB_Elements.getScrollLeftById(elementId, onScrollLeftChanges, fireFirstTime, timeoutMs, returnNullOnFail, timeout); }, timeoutMs ); } return scrollLeftValue; } CB_Elements._getScrollTopByIdLastValue = {}; CB_Elements._getScrollTopByIdTimeout = {}; CB_Elements._getScrollTopByIdScrollRelativePrevious = {}; /** * Returns the vertical scroll of a given element (by its identifier) and allows running a callback function (becoming recursive if desired). Any previous interval started by a previous call to this function, for the same &quot;elementId&quot;, will be stopped. * @function * @param {string|window} [elementId=window] - The identifier of the element whose vertical scroll position we want to get. If a string with the identifier is not given, the unique value allowed is the window object (which is the default value when a non-valid value or no value is given). * @param {CB_Elements.getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES} [onScrollTopChanges] - The desired callback function. It will be called as an interval if &quot;timeoutMs&quot; is a valid integer value. * @param {boolean} [fireFirstTime=false] - If it is set to true, it will call the callback function (if any) as soon as this function is called. * @param {boolean} [fireAlways=false] - If it is set to true, it will call the callback function (if any) every interval even if the vertical scroll value has not changed from the last call. * @param {integer} [timeoutMs] - The number of milliseconds between one call to the callback function (if any) and the next one. If not given, it will not perform any interval. * @param {function} [returnNullOnFail=false] - If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. * @returns {number|null} Returns the vertical scroll of the given element (by its identifier). It could return zero (0) if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). */ CB_Elements.getScrollTopById = function(elementId, onScrollTopChanges, fireFirstTime, fireAlways, timeoutMs, returnNullOnFail, timeout) { if (typeof(elementId) === &quot;undefined&quot; || elementId === null || elementId === window) { elementId === &quot;_WHOLE_DOCUMENT_&quot;; } if (typeof(CB_Elements._getScrollTopByIdLastValue[elementId]) === &quot;undefined&quot;) { CB_Elements._getScrollTopByIdLastValue[elementId] = null; } if (typeof(timeout) === &quot;undefined&quot; || timeout === null) { if (typeof(CB_Elements._getScrollTopByIdTimeout[elementId]) === &quot;undefined&quot;) { CB_Elements._getScrollTopByIdTimeout[elementId] = null; } timeout = CB_Elements._getScrollTopByIdTimeout[elementId]; } clearTimeout(timeout); var element = CB_isString(elementId) ? CB_Elements.id(elementId) : elementId; var scrollTopValue = returnNullOnFail ? null : 0; if (typeof(element) === &quot;undefined&quot; || element === null || element === window) { element = CB_Elements.tag(&quot;body&quot;, document); if (element === null || typeof(element[0]) === &quot;undefined&quot; || element[0] === null) { return returnNullOnFail ? null : 0; } element = element[0]; if (typeof(window.pageYOffset) !== &quot;undefined&quot;) { scrollTopValue = window.pageYOffset; } else if (typeof(window.scrollY) !== &quot;undefined&quot;) { scrollTopValue = window.scrollY; } else if (typeof(document.documentElement.scrollTop) !== &quot;undefined&quot; &amp;&amp; document.documentElement.scrollTop !== null &amp;&amp; !isNaN(document.documentElement.scrollTop) &amp;&amp; document.documentElement.scrollTop &gt; 0) { scrollTopValue = document.documentElement.scrollTop; } else if (typeof(document.body.scrollTop) !== &quot;undefined&quot; &amp;&amp; document.body.scrollTop !== null) { scrollTopValue = document.body.scrollTop; } } else { if (typeof(element.scrollTop) !== &quot;undefined&quot; &amp;&amp; element.scrollTop !== null &amp;&amp; !isNaN(element.scrollTop) &amp;&amp; element.scrollTop &gt; 0) { scrollTopValue = element.scrollTop; } else if (typeof(element.scrollHeight) !== &quot;undefined&quot; &amp;&amp; element.scrollHeight !== null &amp;&amp; !isNaN(element.scrollHeight) &amp;&amp; element.scrollHeight &gt; 0) { scrollTopValue = element.scrollHeight; } } if (isNaN(scrollTopValue)) { scrollTopValue = 0; if (returnNullOnFail) { scrollTopValue = null; } } //If it's not the first time and scroll has been changed, calls the onScrollTop function (if any): if (fireAlways || ((fireFirstTime || CB_Elements._getScrollTopByIdLastValue[elementId] !== null) &amp;&amp; CB_Elements._getScrollTopByIdLastValue[elementId] !== scrollTopValue)) { //If there is any defined function: if (typeof(onScrollTopChanges) === &quot;function&quot;) { var scrollRelative = (scrollTopValue + (element.clientHeight || element.offsetHeight)) / element.scrollHeight * 100; if (isNaN(scrollRelative)) { scrollRelative = 0; if (returnNullOnFail) { scrollRelative = null; } } //Sets the new position (to avoid possible infinite recursive loop in the case fireAlways is false): CB_Elements._getScrollTopByIdLastValue[elementId] = scrollTopValue; //Executes the function: onScrollTopChanges(scrollTopValue, CB_Elements._getScrollTopByIdLastValue[elementId], element.scrollHeight, element.clientHeight || element.offsetHeight, scrollRelative, CB_Elements._getScrollTopByIdScrollRelativePrevious[elementId]); CB_Elements._getScrollTopByIdScrollRelativePrevious[elementId] = scrollRelative; } } //Sets the new position: CB_Elements._getScrollTopByIdLastValue[elementId] = scrollTopValue; if (typeof(timeoutMs) !== &quot;undefined&quot; &amp;&amp; timeoutMs !== null &amp;&amp; !isNaN(timeoutMs) &amp;&amp; timeoutMs &gt;= 0) { CB_Elements._getScrollTopByIdTimeout[elementId] = timeout = setTimeout ( function() { CB_Elements.getScrollTopById(elementId, onScrollTopChanges, fireFirstTime, timeoutMs, returnNullOnFail, timeout); }, timeoutMs ); } return scrollTopValue; } } × Search results Close "},"CrossBase_general_CB_Events.js.html":{"id":"CrossBase_general_CB_Events.js.html","title":"Source: CrossBase/general/CB_Events.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_Events.js /** * @file Events management. Contains the {@link CB_Events} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage events. It will return itself if it is tried to be instantiated. * @namespace */ var CB_Events = function() { return CB_Events; }; { CB_Events.initialized = false; //It will tells whether the object has been initialized or not. CB_Events._stored = []; //Array that stores the events (so we could delete all from one type if we wanted). //Initializes all values: CB_Events.init = function() { if (CB_Events.initialized) { return CB_Events; } //The object has been initialized: CB_Events.initialized = true; //TODO. return CB_Events; } /** * Gets the right event object for the current web client and normalizes it attaching to it some methods and properties if they were not present (as preventDefault, stopPropagation, target, etc.). The new attached methods and properties may include polyfills, etc. * @function * @param {Event} e - Event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). * @returns {Event} Returns the event object normalized. */ CB_Events.normalize = function(e) { if (!e) { if (typeof(event) !== &quot;undefined&quot;) { e = event; } else if (typeof(window.event) !== &quot;undefined&quot;) { e = window.event; } else if (typeof(Event) !== &quot;undefined&quot;) { e = Event; } if (!e) { e = {}; } } try { e._writable = true; } catch(E) { e._writable = false; } if (!e._writable) { e = CB_copyObject(e); } //If the event object cannot be written, copies it. //NOTE: Think about using Object.defineProperty with writable: true as option to prevent some web client problems that have readonly properties. //If not supported, adds preventDefault compatibility to the event object: if (typeof(e.preventDefault) === &quot;undefined&quot; || e.preventDefault === null) { if (&quot;returnValue&quot; in e) { e.preventDefault = function() { e.returnValue = false; return false; }; } else if (typeof(window.event) !== &quot;undefined&quot; &amp;&amp; &quot;returnValue&quot; in window.event) { e.preventDefault = function() { window.event.returnValue = false; return false; }; } else { e.preventDefault = function() { return false; } } } //If not supported, adds stopPropagation compatibility to the event object: if (typeof(e.stopPropagation) === &quot;undefined&quot; || e.stopPropagation === null) { if (typeof(e.cancelBubble) !== &quot;undefined&quot; &amp;&amp; e.cancelBubble !== null) { e.stopPropagation = function() { e.cancelBubble = true; }; } else if (typeof(window.event) !== &quot;undefined&quot; &amp;&amp; typeof(window.event.cancelBubble) !== &quot;undefined&quot;) { e.stopPropagation = function() { window.event.cancelBubble = true; }; } else { e.stopPropagation = function() { } } } //If not supported, adds the target property to the object: if (typeof(e.target) === &quot;undefined&quot; &amp;&amp; typeof(e.srcElement) !== &quot;undefined&quot;) { e.target = e.srcElement; } //Prevents Safari bug (source: http://www.quirksmode.org/js/events_properties.html): if (typeof(e.target) !== &quot;undefined&quot; &amp;&amp; typeof(e.target.nodeType) !== &quot;undefined&quot; &amp;&amp; e.target.nodeType === 3) { try { e.target = e.target.parentNode; } catch(E) {} } //Adds target property (if possible): if (typeof(e.target) === &quot;undefined&quot; &amp;&amp; typeof(e.srcElement) !== &quot;undefined&quot;) { e.target = e.srcElement; } return e; } /** * Returns the type of an event, if any (otherwise, returns an empty string). * @function * @param {Event} e - Event object. * @returns {string} */ CB_Events.getType = function(e) { e = CB_Events.normalize(e); if (typeof(e.type) !== &quot;undefined&quot; &amp;&amp; e.type !== null) { return e.type; } else { return &quot;&quot;; } } /** * Removes an event listener (even if it is not erasable). * @function * @param {Object} eventTarget - The target whose event listener we want to remove. * @param {string} eventName - The name of the event that we want to remove. * @param {function} eventFunction - The function (event listener) of the event that we want to remove. * @param {boolean} [useCapture=false] - Defines whether the event we want to remove was defined to use capture or not. */ CB_Events.remove = function(eventTarget, eventName, eventFunction, useCapture) { //If the target (node) is null or is not an object, exits: if (typeof(eventTarget) === &quot;undefined&quot; || eventTarget === null || typeof(eventTarget) !== &quot;object&quot;) { return; } //If not defined, set default value for useCapture parameter: if (useCapture !== true &amp;&amp; useCapture !== false) { useCapture = false; } //Removes the event from the array: CB_Events._storedClear(eventTarget, eventName, eventFunction, useCapture); //Removes the event: if (typeof(eventTarget.addEventListener) !== &quot;undefined&quot; &amp;&amp; eventTarget.removeEventListener) { eventTarget.removeEventListener(eventName, eventFunction, useCapture); } else if (typeof(eventTarget.attachEvent) !== &quot;undefined&quot; &amp;&amp; eventTarget.detachEvent) { eventTarget.detachEvent(&quot;on&quot; + eventName, eventFunction); } } /** * Alias for {@link CB_Events.on}. * @function CB_Events.add * @see {@link CB_Events.on} */ /** * Adds an event listener. * @function * @param {Object} eventTarget - The target where we want to attach the event listener. * @param {string} eventName - The name of the event that we want to add. * @param {function} eventFunction - The function (event listener) of the event that we want to add. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {boolean} [keepOldEventFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [erasable=true] - Defines whether the event listener will be erasable by {@link CB_Events.removeAll} or {@link CB_Events.removeByName} functions later or not (it will always be erasable if we force delete). * @todo Try to simulate &quot;useCapture&quot; when the &quot;addEventListener&quot; method is not available. */ CB_Events.on = CB_Events.add = function(eventTarget, eventName, eventFunction, useCapture, keepOldEventFunction, erasable) { //If the target (node) is null or is not an object, exits: if (typeof(eventTarget) === &quot;undefined&quot; || eventTarget === null || typeof(eventTarget) !== &quot;object&quot;) { return; } //If not defined, set default values for optional parameters: if (useCapture !== true &amp;&amp; useCapture !== false) { useCapture = false; } if (typeof(keepOldEventFunction) === &quot;undefined&quot; || keepOldEventFunction === null) { keepOldEventFunction = true; } if (typeof(erasable) === &quot;undefined&quot; || erasable === null) { erasable = true; } //If we don't want to keep the old event functions, we delete them: if (!keepOldEventFunction) { CB_Events.removeByName(eventTarget, eventName); } //Adds the new event listeners: if (typeof(eventTarget.addEventListener) !== &quot;undefined&quot; &amp;&amp; eventTarget.addEventListener) { eventTarget.addEventListener(eventName, eventFunction, useCapture); } else if (typeof(eventTarget.attachEvent) !== &quot;undefined&quot; &amp;&amp; eventTarget.attachEvent) { eventTarget.attachEvent(&quot;on&quot; + eventName, eventFunction); } //else if (eventTarget &amp;&amp; typeof( eval(&quot;eventTarget.on&quot; + eventName) ) !== &quot;undefined&quot;) else if (eventTarget &amp;&amp; typeof(eventTarget[&quot;on&quot; + eventName]) !== &quot;undefined&quot;) { var newEventFunction = function(e) { //e = CB_Events.normalize(e); return CB_Events.executeByName(eventTarget, eventName, e); } eventTarget[&quot;on&quot; + eventName] = newEventFunction; } //Stores the event (so we could delete all from one type if we wanted): CB_Events._store(eventTarget, eventName, eventFunction, useCapture, erasable); //If we mind Iframes: if (CB_Configuration[CB_BASE_NAME].MIND_IFRAMES) { //If the event is &quot;keydown&quot;, &quot;keyup&quot;, &quot;keypress&quot;, &quot;mousedown&quot; or &quot;click&quot;: eventName = eventName.toLowerCase(); if (eventName === &quot;keydown&quot; || eventName === &quot;keyup&quot; || eventName === &quot;keydown&quot; || eventName === &quot;mousedown&quot; || eventName === &quot;click&quot;) { try { var eventTargetParents = []; //If the event is the main window object (no one of its possible parents): if (eventTarget === window) { eventTargetParents = CB_Client.getWindowParents(); } //...otherwise if the event is the main document object (no one of its possible parents): else if (eventTarget === document) { eventTargetParents = CB_Client.getWindowParents().slice(0); CB_forEach ( eventTargetParents, function(element, index, array) { if (index &gt; 0) { array[index] = element.document; } } ); } //If there are parents, applies the same event listener to them: if (eventTargetParents.length &gt; 1) { CB_forEach ( eventTargetParents, function(element, index, array) { if (index &gt; 0) { CB_Events.add(element, eventName, eventFunction, useCapture, keepOldEventFunction, erasable); } } ); } } catch(E) { } } } } /** * Object that contains an event handler. * @memberof CB_Events * @typedef {Object} CB_Events.EVENT_HANDLER * @property {Object} eventTarget - The target of the event. * @property {string} eventName - The name of the event. * @property {function} eventFunction - The event listener. * @property {boolean} useCapture - Defines whether the event listener was defined to use capture or not. * @property {boolean} erasable - Defines whether the event handler is erasable (without forcing delete) or not. */ //Function that stores an event (so we could delete all from one type if we wanted): CB_Events._store = function(eventTarget, eventName, eventFunction, useCapture, erasable) { var x = CB_Events._stored.length; CB_Events._stored[x] = new Array(5); CB_Events._stored[x][&quot;eventTarget&quot;] = eventTarget; CB_Events._stored[x][&quot;eventName&quot;] = eventName; CB_Events._stored[x][&quot;eventFunction&quot;] = eventFunction; //Stores the function. CB_Events._stored[x][&quot;useCapture&quot;] = useCapture; //Stores the capture mode. CB_Events._stored[x][&quot;erasable&quot;] = erasable; //Stores whether is erasable or not. } //Function that clears (deletes) a stored event: CB_Events._storedClear = function(eventTarget, eventName, eventFunction, useCapture) { var CB_storedEventsLength = CB_Events._stored.length for (var x = 0; x &lt; CB_storedEventsLength; x++) { //If the target (node) exists: if (eventTarget === CB_Events._stored[x][&quot;eventTarget&quot;]) { //If the event exists if (eventName === CB_Events._stored[x][&quot;eventName&quot;]) { //If the function (event handler) exists: if (eventFunction === CB_Events._stored[x][&quot;eventFunction&quot;]) { //If it's the same capture mode: if (useCapture === CB_Events._stored[x][&quot;useCapture&quot;]) { CB_Events._stored[x] = Array(5); //Clears the array (deletes the stored event). break; //It exits so that way only one element will be cleared. } } } } } } /** * Deletes all handlers for an specific event from a node (target). * @function * @param {Object} eventTarget - The target whose event listeners we want to remove. * @param {string} eventName - The name of the event whose event listeners we want to remove. * @param {boolean} [forceDelete=false] - If it is set to true, it will remove any listener (even the ones which were added as not erasable). */ CB_Events.removeByName = function(eventTarget, eventName, forceDelete) { var CB_storedEventsLength = CB_Events._stored.length; for (var x = 0; x &lt; CB_storedEventsLength; x++) { //If the target (node) exists: if (eventTarget === CB_Events._stored[x][&quot;eventTarget&quot;]) { //If the event exists if (eventName === CB_Events._stored[x][&quot;eventName&quot;]) { //Removes the element if is erasable or is in force delete mode: if (forceDelete || CB_Events._stored[x][&quot;erasable&quot;]) { CB_Events.remove(eventTarget, eventName, CB_Events._stored[x][&quot;eventFunction&quot;], CB_Events._stored[x][&quot;useCapture&quot;]); } } } } } /** * Removes all event listeners. * @function * @param {boolean} [forceDelete=false] - If it is set to true, it will remove all event listeners (even the ones which were added as not erasable). */ CB_Events.removeAll = function(forceDelete) { //For every targets (nodes): var CB_storedEventsLength = CB_Events._stored.length; for (var x = 0; x &lt; CB_storedEventsLength; x++) { //If the event has not been cleared before: if (typeof(CB_Events._stored[x][&quot;eventTarget&quot;]) !== &quot;undefined&quot; &amp;&amp; typeof(CB_Events._stored[x][&quot;eventName&quot;]) !== &quot;undefined&quot;) { CB_Events.removeByName(CB_Events._stored[x][&quot;eventTarget&quot;], CB_Events._stored[x][&quot;eventName&quot;], forceDelete); } } } /** * Executes all event listeners for an specific event from a node (target). * @function * @param {Object} eventTarget - The target whose event listeners we want to execute. It will be the value of &quot;this&quot; for every call to each listener. * @param {string} eventName - The name of the event whose event listeners we want to execute. * @param {Event} [e] - Event object that will be passed as the first and unique parameter for every call to each listener. * @param {*} [returnOnNothingExecuted] - The value that will be returned by the function if nothing is executed. * @returns {boolean} Returns the result of doing the AND operator of all return values of each listener executed. If only one listener is executed, it will return the result of doing the AND operator with its returning value and &quot;true&quot;. Returns the value of the &quot;returnOnNothingExecuted&quot; parameter if nothing is executed. */ CB_Events.executeByName = function(eventTarget, eventName, e, returnOnNothingExecuted) { var CB_storedEventsLength = CB_Events._stored.length; var returnValue = true; var somethingExecuted = false; for (var x = 0; x &lt; CB_storedEventsLength; x++) { //If the target (node) exists: if (eventTarget === CB_Events._stored[x][&quot;eventTarget&quot;]) { //If the event exists if (eventName === CB_Events._stored[x][&quot;eventName&quot;]) { //if an event function exists: if (typeof(CB_Events._stored[x][&quot;eventFunction&quot;]) === &quot;function&quot;) { returnValue = CB_Events._stored[x][&quot;eventFunction&quot;].call(eventTarget, e) &amp;&amp; returnValue; somethingExecuted = true; } } } } return somethingExecuted ? returnValue : returnOnNothingExecuted; } /** * Returns all handlers for an specific event from a node (target), if any. * @function * @param {Object} eventTarget - The target whose event listeners we want to get. * @param {string} eventName - The name of the event whose event listeners we want to get. * @param {boolean} [onlyWithFunction=false] - Defines whether to return only the handlers which have a function as the listener. * @returns {array} Returns an array of {@link CB_Events.EVENT_HANDLER} objects. */ CB_Events.getByName = function(eventTarget, eventName, onlyWithFunction) { var found = []; var CB_storedEventsLength = CB_Events._stored.length; for (var x = 0; x &lt; CB_storedEventsLength; x++) { //If the target (node) exists: if (eventTarget === CB_Events._stored[x][&quot;eventTarget&quot;]) { //If the event exists if (eventName === CB_Events._stored[x][&quot;eventName&quot;]) { if (!onlyWithFunction || typeof(CB_Events._stored[x][&quot;eventFunction&quot;]) === &quot;function&quot;) { found[found.length] = CB_Events._stored[x]; } } } } return found; } /** * Returns all stored event handlers (if any). * @function * @returns {array} Returns an array of {@link CB_Events.EVENT_HANDLER} objects. */ CB_Events.getAll = function() { return CB_Events._stored; } } × Search results Close "},"CrossBase_audiovisual_image_CB_GraphicSpritesScene.js.html":{"id":"CrossBase_audiovisual_image_CB_GraphicSpritesScene.js.html","title":"Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js /** * @file Groups of graphic sprites management (2D or 3D). Internally, it manages {@link CB_GraphicSprites} objects. Contains the {@link CB_GraphicSpritesScene} class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * An object with the information that belongs to a group of graphic sprites. * @example { //'my_sprites_scene_1': id: &quot;my_sprites_scene_1&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, //Sprites groups: spritesGroups: [ //'my_sprites_1': { id: &quot;my_sprites_1&quot;, src: &quot;path/to/image.gif&quot;, sprites: [ //'my_sprite_1': { id: &quot;my_sprite_1&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_2': { id: &quot;my_sprite_2&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_3&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_4&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] }, //'my_sprites_2': { id: &quot;my_sprites_2&quot;, src: &quot;path/to/image2.gif&quot;, sprites: [ //'my_sprite_3': { id: &quot;my_sprite_3&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_5&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_6&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_4': { id: &quot;my_sprite_4&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_7&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_8&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] } ] } * @memberof CB_GraphicSpritesScene * @typedef {Object} CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT * @property {string|*} [id='CB_GraphicSpritesScene_' + CB_GraphicSpritesScene._idUnique++] - Identifier of the sprites groups object and also for the graphic sprites scene (also used as the {@link CB_GraphicSprites.id} property for the {@link CB_GraphicSpritesScene} object). It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @property {*} [src=&quot;&quot;] - The value for the &quot;src&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {string} [srcType={@link CB_GraphicSprites.SRC_TYPES.DEFAULT}] - The value for the &quot;srcType&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. It should point to a property of the {@link CB_GraphicSprites.SRC_TYPES} object. You can use other values of the {@link CB_GraphicSprites.SRC_TYPES} object or create new ones. * @property {number} [srcLeft={@link CB_GraphicSprites.LEFT_SOURCE_DEFAULT}] - The value for the &quot;srcLeft&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [srcTop={@link CB_GraphicSprites.TOP_SOURCE_DEFAULT}] - The value for the &quot;srcTop&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [srcWidth={@link CB_GraphicSprites.WIDTH_SOURCE_DEFAULT}] - The value for the &quot;srcWidth&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [srcHeight={@link CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT}] - The value for the &quot;srcHeight&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [left={@link CB_GraphicSprites.LEFT_DEFAULT}] - The value for the &quot;left&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [top={@link CB_GraphicSprites.TOP_DEFAULT}] - The value for the &quot;top&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [width={@link CB_GraphicSprites.WIDTH_DEFAULT}] - The value for the &quot;width&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [height={@link CB_GraphicSprites.HEIGHT_DEFAULT}] - The value for the &quot;height&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {number} [zIndex={@link CB_GraphicSprites.ZINDEX_DEFAULT}] - The value for the &quot;zIndex&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {boolean} [disabled=false] - The value for the &quot;disabled&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {object} [data={ 'that' : CB_GraphicSprites.SPRITES_GROUPS_OBJECT, 'getThis' = function() { return this.that; } }] - Object with any additional data desired which can be any kind. It will always have a &quot;that&quot; property pointing to the {@link CB_GraphicSprites.SPRITES_GROUPS_OBJECT} object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. The value given will also be used for the &quot;data&quot; property which will be used as default if not provided (or the provided one was wrong) in the given {@link CB_GraphicSprites.SPRITES_OBJECT} objects (in the &quot;spritesGroups&quot; property), when creating the internal {@link CB_GraphicSprites} objects. * @property {array} [spritesGroups=[]] - Numeric array containing {@link CB_GraphicSprites.SPRITES_OBJECT} objects with all the sprites groups that are useful for creating the internal {@link CB_GraphicSprites} objects. Recommended at least to provide one {@link CB_GraphicSprites.SPRITES_OBJECT} object in the first index. * @property {*} [parent=undefined] - Property pointing to or containing its parent (also used as the {@link CB_GraphicSpritesScene.parent} property for the {@link CB_GraphicSpritesScene} object). * @property {array} items - Read-only numeric array containing {@link CB_GraphicSprites} objects created internally. Their &quot;parent&quot; property will be set to point the current {@link CB_GraphicSpritesScene} object which contains them. * @property {array} itemsByZIndex - Read-only property containing a numeric array of all the {@link CB_GraphicSprites} objects ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sprite is set with its {@link CB_GraphicSprites#setZIndex} method or when inserting/removing {@link CB_GraphicSprites} objects through the {@link CB_GraphicSpritesScene#insertSpritesGroups}, {@link CB_GraphicSpritesScene#insertSpritesGroup}, {@link CB_GraphicSpritesScene#removeSpritesGroup} or {@link CB_GraphicSpritesScene#removeSpritesGroupById} methods. * @property {boolean} [byReference_DEFAULT=false] - Default value to use as the &quot;byReference&quot; parameter for the constructor and for the {@link CB_GraphicSpritesScene#insertSpritesGroups} method. If a boolean value is not provided, it will be parsed to boolean (resulting undefined to be false). * @property {CB_GraphicSpritesScene} container - Read-only property pointing to the {@link CB_GraphicSpritesScene} object which contains it. * @property {boolean} isSpritesGroups - Read-only property which is always set to true to help identify this type of object. * @property {'spritesGroups'} type - Read-only property indicating the type of object (always &quot;spritesGroups&quot;). */ /** * Class to manage different groups of graphic sprites (2D or 3D). Internally, it manages {@link CB_GraphicSprites} objects. * @class * @classdesc Class to manage different groups of graphic sprites (2D or 3D). Internally, it manages {@link CB_GraphicSprites} objects. * @param {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} [spritesGroups] - Object with the desired groups of sprites. The information will be used for the {@link CB_GraphicSpritesScene#spritesGroups} property. Used as the &quot;spritesGroups&quot; parameter when calling the {@link CB_GraphicSpritesScene#insertSpritesGroups} method internally. * @param {boolean} [byReference=false] - This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal {@link CB_GraphicSprites} objects. If a boolean value is not provided, it will use the value of the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT} property of the given {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object (parsed to boolean). * @returns {CB_GraphicSpritesScene} Returns a new {@link CB_GraphicSpritesScene} object. * @todo Think about a &quot;createCopy&quot; parameter on different the insert methods (to insert sprites groups/graphic sprites objects, etc.) so it will make a copy of the object to avoid using/modifying the original one. If the &quot;createCopy&quot; is set to false, it should always use the object as reference (using/modifying it). * @todo Think about a method to remove a sprite group object when the same sprite group is received by parameter. The same to remove a {@link CB_GraphicSprites} object, receiving a {@link CB_GraphicSprites} object by parameter. The same to remove the sprites groups object, receiving a sprites groups object by parameter. Only remove them if they match exactly. * @todo Think about a method to insert {@link CB_GraphicSprites} object directly. The same with a method that inserts many {@link CB_GraphicSprites} objects (receiving an array with them). */ var CB_GraphicSpritesScene = function(spritesGroups, byReference) { //Creates an instance of this object and returns it in the case that it is being called from an unexpected context: if (this === window || !(this instanceof CB_GraphicSpritesScene)) { return new CB_GraphicSpritesScene(spritesGroups, byReference); } //Properties and variables: /** * Identifier of the sprites groups object (the &quot;id&quot; property of the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} stored in the {@link CB_GraphicSpritesScene#spritesGroups} property) and the {@link CB_GraphicSpritesScene} object itself (same one). It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). * @var * @readonly * @type {string|*} * @default 'CB_GraphicSpritesScene_' + CB_GraphicSpritesScene._idUnique++ */ this.id = &quot;&quot;; /** * Property pointing to or containing its parent. It is the same as the &quot;parent&quot; property of the {@link CB_GraphicSprites.SPRITES_GROUPS_OBJECT} stored in the {@link CB_GraphicSprites#spritesGroups} property. * @var * @readonly * @type {*} * @default */ this.parent = undefined; /** * Object containing all the internally-created {@link CB_GraphicSprites} objects and their information. * @var * @readonly * @type {SPRITES_GROUPS_OBJECT} * @default */ this.spritesGroups = {}; //Calls the constructor of the object when creates an instance: return this._init(spritesGroups, byReference); } //Constants: /** * Property which is always set to true to help identify this type of object. * @constant * @type {boolean} * @default */ CB_GraphicSpritesScene.prototype.isSpritesScene = true; /** * Indicates the type of object (always &quot;spritesScene&quot;). * @constant * @type {string} * @default */ CB_GraphicSpritesScene.prototype.type = &quot;spritesScene&quot;; //Variables: CB_GraphicSpritesScene._idUnique = 0; //Counter to make the sprites group id unique. //Constructor: CB_GraphicSpritesScene.prototype._init = function(spritesGroups, byReference) { this.insertSpritesGroups(spritesGroups, byReference); return this; } /** * Destroys the graphic sprites scene object (removing all the sprites groups and the internal {@link CB_GraphicSprites} objects, etc.) and frees memory. * @function */ CB_GraphicSpritesScene.prototype.destructor = function() { //Destroys all the internal CB_GraphicSprites objects: this.executeFunctionAll(function() { this.destructor(); }); //Resets properties to their default value: this.removeSpritesGroups(); } /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroups}. * @function CB_GraphicSpritesScene#removeAll * @see {@link CB_GraphicSpritesScene#removeSpritesGroups} */ /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroups}. * @function CB_GraphicSpritesScene#removeSpritesGroupsAll * @see {@link CB_GraphicSpritesScene#removeSpritesGroups} */ /** * Removes all the sprites groups (and all the {@link CB_GraphicSprites} objects) by clearing the {@link CB_GraphicSprites#spritesGroups} property. * @function */ CB_GraphicSpritesScene.prototype.removeSpritesGroups = CB_GraphicSpritesScene.prototype.removeSpritesGroupsAll = CB_GraphicSpritesScene.prototype.removeAll = function() { this.spritesGroups = {}; } /** * Adds the desired groups of graphic sprites. Calls the {@link CB_GraphicSpritesScene#insertSpritesGroup} and {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} methods internally. * @function * @param {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} [spritesGroups] - Object with the desired sprites groups. They will be stored in the &quot;{@link CB_GraphicSpritesScene#spritesGroups}.spritesGroups&quot; property and the {@link CB_GraphicSprites} objects created internally will be stored in the &quot;{@link CB_GraphicSpritesScene#spritesGroups}.items&quot; property. * @param {boolean} [byReference=!!{@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT}] - This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal {@link CB_GraphicSprites} objects. If a boolean value is not provided, it will use the value of the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT} property of the given {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object (parsed to boolean). * @returns {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} Returns the {@link CB_GraphicSpritesScene#spritesGroups} property after updating it. */ CB_GraphicSpritesScene.prototype.insertSpritesGroups = function(spritesGroups, byReference) { //Sets the properties (sanitizing them): this.spritesGroups = this.spritesGroups || {}; spritesGroups = spritesGroups || {}; this.spritesGroups.isSpritesGroups = true; this.spritesGroups.type = &quot;spritesGroups&quot;; this.spritesGroups.container = this; this.parent = this.spritesGroups.parent = spritesGroups.parent; this.id = this.spritesGroups.id = spritesGroups.id = spritesGroups.id || &quot;CB_GraphicSpritesScene_&quot; + CB_GraphicSpritesScene._idUnique++; this.spritesGroups.src = spritesGroups.src = spritesGroups.src || !isNaN(spritesGroups.src) &amp;&amp; spritesGroups.src !== null ? spritesGroups.src : &quot;&quot;; this.spritesGroups.srcType = spritesGroups.srcType = spritesGroups.srcType || CB_GraphicSprites.SRC_TYPES.DEFAULT; spritesGroups.srcLeft = parseFloat(spritesGroups.srcLeft); this.spritesGroups.srcLeft = spritesGroups.srcLeft = !isNaN(spritesGroups.srcLeft) ? spritesGroups.srcLeft : parseFloat(CB_GraphicSprites.LEFT_SOURCE_DEFAULT) || 0; spritesGroups.left = parseFloat(spritesGroups.left); this.spritesGroups.left = spritesGroups.left = !isNaN(spritesGroups.left) ? spritesGroups.left : parseFloat(CB_GraphicSprites.LEFT_DEFAULT) || 0; spritesGroups.srcTop = parseFloat(spritesGroups.srcTop); this.spritesGroups.srcTop = spritesGroups.srcTop = !isNaN(spritesGroups.srcTop) ? spritesGroups.srcTop : parseFloat(CB_GraphicSprites.TOP_SOURCE_DEFAULT) || 0; spritesGroups.top = parseFloat(spritesGroups.top); this.spritesGroups.top = spritesGroups.top = !isNaN(spritesGroups.top) ? spritesGroups.top : parseFloat(CB_GraphicSprites.TOP_DEFAULT) || 0; spritesGroups.srcWidth = parseFloat(spritesGroups.srcWidth); this.spritesGroups.srcWidth = spritesGroups.srcWidth = !isNaN(spritesGroups.srcWidth) ? spritesGroups.srcWidth : parseFloat(CB_GraphicSprites.WIDTH_SOURCE_DEFAULT) || 0; spritesGroups.width = parseFloat(spritesGroups.width); this.spritesGroups.width = spritesGroups.width = !isNaN(spritesGroups.width) ? spritesGroups.width : parseFloat(CB_GraphicSprites.WIDTH_DEFAULT) || 0; spritesGroups.srcHeight = parseFloat(spritesGroups.srcHeight); this.spritesGroups.srcHeight = spritesGroups.srcHeight = !isNaN(spritesGroups.srcHeight) ? spritesGroups.srcHeight : parseFloat(CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT) || 0; spritesGroups.height = parseFloat(spritesGroups.height); this.spritesGroups.height = spritesGroups.height = !isNaN(spritesGroups.height) ? spritesGroups.height : parseFloat(CB_GraphicSprites.HEIGHT_DEFAULT) || 0; spritesGroups.zIndex = parseFloat(spritesGroups.zIndex); this.spritesGroups.zIndex = spritesGroups.zIndex = !isNaN(spritesGroups.zIndex) ? spritesGroups.zIndex : parseFloat(CB_GraphicSprites.ZINDEX_DEFAULT) || 0; this.spritesGroups.data = typeof(spritesGroups.data) === &quot;object&quot; &amp;&amp; spritesGroups.data !== null ? CB_copyObject(spritesGroups.data, false) : {}; //Accepts any object but not other values. this.spritesGroups.data.that = this.spritesGroups; this.spritesGroups.data.getThis = function() { return this.that; }; spritesGroups.spritesGroups = CB_isArray(spritesGroups.spritesGroups) ? spritesGroups.spritesGroups : []; //Inserts the given sprites groups, one by one: byReference = (byReference === true || byReference === false) ? byReference : !!spritesGroups.byReference_DEFAULT; var spritesGroupsLength = spritesGroups.spritesGroups.length; for (var x = 0; x &lt; spritesGroupsLength; x++) { this.insertSpritesGroup(spritesGroups.spritesGroups[x], true, byReference); } //Updates the array with the CB_GraphicSprites ordered by z-index: this.updateGraphicSpritesByZIndex(); //Returns the sprites: return this.spritesGroups; } /** * Alias for {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex}. * @function CB_GraphicSpritesScene#updateItemsByZIndex * @see {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} */ /** * Updates (sorts again) the &quot;itemsByZIndex&quot; property (which is an array with the {@link CB_GraphicSprites} objects ordered by z-index, whose data comes from the array in the &quot;items&quot; property of the {@link CB_GraphicSpritesScene#spritesGroups} object) of the {@link CB_GraphicSpritesScene#spritesGroups} object. * @function * @returns {array} Returns the &quot;itemsByZIndex&quot; array of the {@link CB_GraphicSpritesScene#spritesGroups} object after updating it. Returns null if the property could not be obtained or updated. */ CB_GraphicSpritesScene.prototype.updateGraphicSpritesByZIndex = CB_GraphicSpritesScene.prototype.updateItemsByZIndex = function() { this.spritesGroups.items = this.spritesGroups.items || null; if (this.spritesGroups.items) { var spritesGroupLength = this.spritesGroups.items.length; if (spritesGroupLength) { var elementIndex = null; this.spritesGroups.itemsByZIndex = []; for (var x = 0; x &lt; spritesGroupLength; x++) { elementIndex = CB_GraphicSpritesScene._choosePositionByZIndex(this.spritesGroups.itemsByZIndex, this.spritesGroups.items[x]); this.spritesGroups.itemsByZIndex = CB_Arrays.insertElement(this.spritesGroups.itemsByZIndex, elementIndex, this.spritesGroups.items[x]); this.spritesGroups.items[x].positionByZIndex = elementIndex; } return this.spritesGroups.itemsByZIndex; } } return null; } /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroup}. * @function CB_GraphicSpritesScene#remove * @see {@link CB_GraphicSpritesScene#removeSpritesGroup} */ /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroup}. * @function CB_GraphicSpritesScene#removeGraphicSprites * @see {@link CB_GraphicSpritesScene#removeSpritesGroup} */ /** * Removes a sprites group and its {@link CB_GraphicSprites} object by its index (its position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array). Calls the {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally. * @function * @param {integer} [index=0] - The index where the {@link CB_GraphicSprites} object is located (its position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array). * @returns {boolean} Returns true if the {@link CB_GraphicSprites} object has been deleted from the graphic sprites scene object or false otherwise. */ CB_GraphicSpritesScene.prototype.removeSpritesGroup = CB_GraphicSpritesScene.prototype.removeGraphicSprites = CB_GraphicSpritesScene.prototype.remove = function(index) { var removed = false; var spritesGroupsLeft = CB_Arrays.removeElementByPosition(this.spritesGroups.items, index, function() { removed = true; }); if (removed) { this.spritesGroups.spritesGroups = CB_Arrays.removeElementByPosition(this.spritesGroups.spritesGroups, index); this.spritesGroups.items = spritesGroupsLeft; //Updates the array with the CB_GraphicSprites ordered by z-index: this.updateGraphicSpritesByZIndex(); } return removed; } /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroupById}. * @function CB_GraphicSpritesScene#removeById * @see {@link CB_GraphicSpritesScene#removeSpritesGroupById} */ /** * Alias for {@link CB_GraphicSpritesScene#removeSpritesGroupById}. * @function CB_GraphicSpritesScene#removeGraphicSpritesById * @see {@link CB_GraphicSpritesScene#removeSpritesGroupById} */ /** * Removes a sprites group and its {@link CB_GraphicSprites} object by its identifier. Calls the {@link CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally. * @function * @param {string|*} [id=undefined] - The identifier of the {@link CB_GraphicSprites} object. * @returns {boolean} Returns true if the {@link CB_GraphicSprites} object has been deleted from the graphic sprites scene object or false otherwise. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSpritesScene.prototype.removeSpritesGroupById = CB_GraphicSpritesScene.prototype.removeGraphicSpritesById = CB_GraphicSpritesScene.prototype.removeById = function(id) { var removed = false; var index = null; var spritesGroupsLeft = CB_Arrays.removeDuplicated(this.spritesGroups.items, function(value, position, array) { if (value &amp;&amp; value.id === id) { removed = true; index = position; return true; }; return false; }, true); if (removed) { if (index !== null) { this.spritesGroups.spritesGroups = CB_Arrays.removeElementByPosition(this.spritesGroups.spritesGroups, index); } this.spritesGroups.items = spritesGroupsLeft; //Updates the array with the CB_GraphicSprites ordered by z-index: this.updateGraphicSpritesByZIndex(); } return removed; } /** * Object used as the returning value of the {@link CB_GraphicSpritesScene#insertSpritesGroup} method. * @memberof CB_GraphicSpritesScene * @typedef {Object} CB_GraphicSpritesScene.insertSpritesGroup_OBJECT * @property {CB_GraphicSprites.SPRITES_OBJECT} spritesGroup - The {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited) and was used to create the internal {@link CB_GraphicSprites} object when calling its constructor. * @property {CB_GraphicSprites} item - The {@link CB_GraphicSprites} object created and inserted from the {@link CB_GraphicSprites.SPRITES_OBJECT}. */ /** * Alias for {@link CB_GraphicSpritesScene#insertSpritesGroup}. * @function CB_GraphicSpritesScene#insert * @see {@link CB_GraphicSpritesScene#insertSpritesGroup} */ /** * Adds the desired group of graphic sprites. Creates internal {@link CB_GraphicSprites} objects. * @function * @param {CB_GraphicSprites.SPRITES_OBJECT} [spritesGroup] - Object with the desired sprites group. It will be stored in the &quot;{@link CB_GraphicSpritesScene#spritesGroups}.spritesGroups&quot; property and the {@link CB_GraphicSprites} object created internally will be stored in the &quot;{@link CB_GraphicSpritesScene#spritesGroups}.items&quot; property. * @param {boolean} [avoidUpdatingGraphicSpritesByZIndex=false] - If set to true, it will not call the {CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally. Internal usage recommended only. * @param {boolean} [byReference=false] - This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal {@link CB_GraphicSprites} objects. * @returns {CB_GraphicSpritesScene.insertSpritesGroup_OBJECT} Returns an object whose &quot;spritesGroup&quot; property contains the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited) and was used to create the internal {@link CB_GraphicSprites} object when calling its constructor and the &quot;item&quot; property contains the {@link CB_GraphicSprites} object created and inserted. */ CB_GraphicSpritesScene.prototype.insertSpritesGroup = CB_GraphicSpritesScene.prototype.insert = function(spritesGroup, avoidUpdatingGraphicSpritesByZIndex, byReference) { //Sets the properties (sanitizing them): this.spritesGroups = this.spritesGroups || {}; spritesGroup = spritesGroup || {}; spritesGroup.parent = this; //Overwrites the parent to point to the CB_GraphicSprites itself which will contain it. spritesGroup.src = spritesGroup.src || !isNaN(spritesGroup.src) &amp;&amp; spritesGroup.src !== null ? spritesGroup.src : this.spritesGroups.src || !isNaN(this.spritesGroups.src) &amp;&amp; this.spritesGroups.src !== null ? this.spritesGroups.src : &quot;&quot;; spritesGroup.srcType = spritesGroup.srcType || this.spritesGroups.srcType || CB_GraphicSprites.SRC_TYPES.DEFAULT; spritesGroup.srcLeft = parseFloat(spritesGroup.srcLeft); spritesGroup.srcLeft = !isNaN(spritesGroup.srcLeft) ? spritesGroup.srcLeft : parseFloat(this.spritesGroups.srcLeft); spritesGroup.srcLeft = !isNaN(spritesGroup.srcLeft) ? spritesGroup.srcLeft : parseFloat(CB_GraphicSprites.LEFT_SOURCE_DEFAULT) || 0; spritesGroup.left = parseFloat(spritesGroup.left); spritesGroup.left = !isNaN(spritesGroup.left) ? spritesGroup.left : parseFloat(this.spritesGroups.left); spritesGroup.left = !isNaN(spritesGroup.left) ? spritesGroup.left : parseFloat(CB_GraphicSprites.LEFT_DEFAULT) || 0; spritesGroup.srcTop = parseFloat(spritesGroup.srcTop); spritesGroup.srcTop = !isNaN(spritesGroup.srcTop) ? spritesGroup.srcTop : parseFloat(this.spritesGroups.srcTop); spritesGroup.srcTop = !isNaN(spritesGroup.srcTop) ? spritesGroup.srcTop : parseFloat(CB_GraphicSprites.TOP_SOURCE_DEFAULT) || 0; spritesGroup.top = parseFloat(spritesGroup.top); spritesGroup.top = !isNaN(spritesGroup.top) ? spritesGroup.top : parseFloat(this.spritesGroups.top); spritesGroup.top = !isNaN(spritesGroup.top) ? spritesGroup.top : parseFloat(CB_GraphicSprites.TOP_DEFAULT) || 0; spritesGroup.srcWidth = parseFloat(spritesGroup.srcWidth); spritesGroup.srcWidth = !isNaN(spritesGroup.srcWidth) ? spritesGroup.srcWidth : parseFloat(this.spritesGroups.srcWidth); spritesGroup.srcWidth = !isNaN(spritesGroup.srcWidth) ? spritesGroup.srcWidth : parseFloat(CB_GraphicSprites.WIDTH_SOURCE_DEFAULT) || 0; spritesGroup.width = parseFloat(spritesGroup.width); spritesGroup.width = !isNaN(spritesGroup.width) ? spritesGroup.width : parseFloat(this.spritesGroups.width); spritesGroup.width = !isNaN(spritesGroup.width) ? spritesGroup.width : parseFloat(CB_GraphicSprites.WIDTH_DEFAULT) || 0; spritesGroup.srcHeight = parseFloat(spritesGroup.srcHeight); spritesGroup.srcHeight = !isNaN(spritesGroup.srcHeight) ? spritesGroup.srcHeight : parseFloat(this.spritesGroups.srcHeight); spritesGroup.srcHeight = !isNaN(spritesGroup.srcHeight) ? spritesGroup.srcHeight : parseFloat(CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT); spritesGroup.height = parseFloat(spritesGroup.height); spritesGroup.height = !isNaN(spritesGroup.height) ? spritesGroup.height : parseFloat(this.spritesGroups.height); spritesGroup.height = !isNaN(spritesGroup.height) ? spritesGroup.height : parseFloat(CB_GraphicSprites.HEIGHT_DEFAULT) || 0; spritesGroup.zIndex = parseFloat(spritesGroup.zIndex); spritesGroup.zIndex = !isNaN(spritesGroup.zIndex) ? spritesGroup.zIndex : parseFloat(this.spritesGroups.zIndex); spritesGroup.zIndex = !isNaN(spritesGroup.zIndex) ? spritesGroup.zIndex : parseFloat(CB_GraphicSprites.ZINDEX_DEFAULT) || 0; spritesGroup.disabled = !!spritesGroup.disabled || false; spritesGroup.data = typeof(spritesGroup.data) === &quot;object&quot; &amp;&amp; spritesGroup.data !== null ? spritesGroup.data : {}; //this.spritesGroups.data; if (typeof(this.spritesGroups.data) === &quot;object&quot; &amp;&amp; this.spritesGroups.data !== null) { spritesGroup.data = CB_combineJSON(this.spritesGroups.data, spritesGroup.data); } //Combine objects. spritesGroup.data = typeof(spritesGroup.data) === &quot;object&quot; &amp;&amp; spritesGroup.data !== null ? CB_copyObject(spritesGroup.data, false) : {}; //Note: the CB_GraphicSprites class will add the &quot;that&quot; and &quot;getThis&quot; properties to the &quot;data&quot;. //Creates and inserts the sprites group: this.spritesGroups.items = this.spritesGroups.items || []; this.spritesGroups.spritesGroups = this.spritesGroups.spritesGroups || []; var item = new CB_GraphicSprites(spritesGroup, byReference); var position = this.getGraphicSpritesIndexById(item.id); //If there is a sprites group with the same ID, it will be replaced by the new one (in the same position). position = position !== -1 ? position : this.spritesGroups.items.length; item.position = position; this.spritesGroups.items[position] = item; spritesGroup.isSpritesGroup = true; //Adds the &quot;isSpritesGroup&quot; property to the sprites groups object. spritesGroup.type = &quot;spritesGroup&quot;; //Adds the &quot;type&quot; property to the sprites groups object. this.spritesGroups.spritesGroups[position] = spritesGroup; //Overrides the sprites groups object, sanitized. if (!avoidUpdatingGraphicSpritesByZIndex) { this.updateGraphicSpritesByZIndex(); } //Returns the sprites: return { &quot;spritesGroup&quot; : spritesGroup, &quot;item&quot; : item }; } //Returns the position that an element (subsprites group, sprite or sub-sprite) should have in a given array, having in mind that they are sorted by by z-index in that array (ascending order): CB_GraphicSpritesScene._choosePositionByZIndex = function(array, element) { if (array &amp;&amp; element) { var arrayLength = array.length; if (arrayLength) { for (var x = 0; x &lt; arrayLength; x++) { if (array[x] &amp;&amp; array[x].zIndex &gt; element.zIndex) { return x; } } return array.length; //By default, best position is at the end of the array (as a new element). } } return 0; } /** * Alias for {@link CB_GraphicSpritesScene#getSpritesGroups}. * @function CB_GraphicSpritesScene#getSpritesGroupsAll * @see {@link CB_GraphicSpritesScene#getSpritesGroups} */ /** * Gets the sprites groups object (the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object which is in the {@link CB_GraphicSpritesScene#spritesGroups} property), if any. * @function * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT|*} Returns the sprites groups object (the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object which is in the {@link CB_GraphicSpritesScene#spritesGroups} property), if any, or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSpritesScene.prototype.getSpritesGroups = CB_GraphicSpritesScene.prototype.getSpritesGroupsAll = function(returnValueOnFail) { return this.spritesGroups ? this.spritesGroups : returnValueOnFail; } /** * Alias for {@link CB_GraphicSpritesScene#getGraphicSpritesAll}. * @function CB_GraphicSpritesScene#getAll * @see {@link CB_GraphicSpritesScene#getGraphicSpritesAll} */ /** * Gets all the sprites graphic objects (the &quot;items&quot; property of the internal {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object, if any). * @function * @param {boolean} [orderedByZIndex=false] - If set to true, it will return the {@link CB_GraphicSprites} objects sorted by their z-index (ascending order). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {array|*} Returns an array with all the {@link CB_GraphicSprites} objects or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSpritesScene.prototype.getGraphicSpritesAll = CB_GraphicSpritesScene.prototype.getAll = function(orderedByZIndex, returnValueOnFail) { if (this.spritesGroups) { if (!orderedByZIndex) { return (this.spritesGroups.items) ? this.spritesGroups.items : returnValueOnFail; } else { return (this.spritesGroups.itemsByZIndex) ? this.spritesGroups.itemsByZIndex : returnValueOnFail; } } return returnValueOnFail; } /** * Alias for {@link CB_GraphicSpritesScene#getGraphicSprites}. * @function CB_GraphicSpritesScene#get * @see {@link CB_GraphicSpritesScene#getGraphicSprites} */ /** * Gets a desired {@link CB_GraphicSprites} object through its index (its position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array). Faster than getting it through its identifier with the {@link CB_GraphicSpritesScene#getGraphicSpritesById} method. * @function * @param {integer} [index=0] - The index where the desired {@link CB_GraphicSprites} object must be located (its position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array). * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites|*} Returns a {@link CB_GraphicSprites} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSpritesScene.prototype.getGraphicSprites = CB_GraphicSpritesScene.prototype.get = function(index, returnValueOnFail) { index = parseInt(index); index = isNaN(index) ? 0 : index; if (index &lt; 0) { index *= -1; } //It must be a positive integer. return this.spritesGroups &amp;&amp; this.spritesGroups.items &amp;&amp; this.spritesGroups.items[index] ? this.spritesGroups.items[index] : returnValueOnFail; } /** * Alias for {@link CB_GraphicSpritesScene#getGraphicSpritesById}. * @function CB_GraphicSpritesScene#getById * @see {@link CB_GraphicSpritesScene#getGraphicSpritesById} */ /** * Gets a desired {@link CB_GraphicSprites} object through its identifier. Slower than getting it through its index with the {@link CB_GraphicSpritesScene#getGraphicSprites} method. * @function * @param {string|*} [id=undefined] - The identifier of the {@link CB_GraphicSprites} object that we want to get. * @param {*} [returnValueOnFail=undefined] - The value we want it to return in the case that no value is found. If not provided, undefined will be returned. * @returns {CB_GraphicSprites|*} Returns a {@link CB_GraphicSprites} object if found or the value of &quot;returnValueOnFail&quot; otherwise. */ CB_GraphicSpritesScene.prototype.getGraphicSpritesById = CB_GraphicSpritesScene.prototype.getById = function(id, returnValueOnFail) { var index = this.getGraphicSpritesIndexById(id); return index !== -1 ? this.spritesGroups.items[index] : returnValueOnFail; } /** * Alias for {@link CB_GraphicSpritesScene#getGraphicSpritesIndexById}. * @function CB_GraphicSpritesScene#getIndexById * @see {@link CB_GraphicSpritesScene#getGraphicSpritesIndexById} */ /** * Gets the index (the position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array) of a desired {@link CB_GraphicSprites} object by its identifier. * @function * @param {string|*} [id=undefined] - The identifier of the {@link CB_GraphicSprites} object whose index we want to get. * @returns {integer} Returns the index (the position in the {@link CB_GraphicSpritesScene#spritesGroups.items} array) of the desired {@link CB_GraphicSprites} object or -1 if not found. * @todo Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). */ CB_GraphicSpritesScene.prototype.getGraphicSpritesIndexById = CB_GraphicSpritesScene.prototype.getIndexById = function(id) { if (this.spritesGroups &amp;&amp; this.spritesGroups.items) { var spritesGroupsLength = this.spritesGroups.items.length; for (var x = 0; x &lt; spritesGroupsLength; x++) { if (this.spritesGroups.items[x].id === id) { return x; } } } return -1; } /** * Alias for {@link CB_GraphicSpritesScene#executeFunctionAll}. * @function CB_GraphicSpritesScene#executeAll * @see {@link CB_GraphicSpritesScene#executeFunctionAll} */ /** * Alias for {@link CB_GraphicSpritesScene#executeFunctionAll}. * @function CB_GraphicSpritesScene#forEach * @see {@link CB_GraphicSpritesScene#executeFunctionAll} */ /** * Alias for {@link CB_GraphicSpritesScene#executeFunctionAll}. * @function CB_GraphicSpritesScene#forEachGraphicSprites * @see {@link CB_GraphicSpritesScene#executeFunctionAll} */ /** * Performs a desired action, using the provided function, on all the existing {@link CB_GraphicSprites} objects or on the desired ones (if provided). Calls the {@link CB_Arrays.executeFunctionAll} function internally and returns its returning value. * @function * @param {CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} functionEach - Function that will be called for each {@link CB_GraphicSprites} object. As the first parameter it receives the {@link CB_GraphicSprites} object of the &quot;graphicSpritesObjects&quot; being looped, as the second parameter the position of this {@link CB_GraphicSprites} object in the &quot;graphicSpritesObjects&quot; array provided (or, if not provided, in the array returned by the {@link CB_GraphicSpritesScene#getGraphicSpritesAll} method), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the {@link CB_GraphicSprites} object itself. * @param {boolean} [orderedByZIndex=false] - If set to true, it will loop the {@link CB_GraphicSprites} sorted by their z-index (ascending order). * @param {number|CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK} [delayBetweenEach=0] - If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each {@link CB_GraphicSprites} object). * @param {array} [graphicSpritesObjects={@link CB_GraphicSpritesScene#getGraphicSpritesAll}()] - A numeric array containing the {@link CB_GraphicSprites} objects that we want to loop. It should contain only {@link CB_GraphicSprites} objects which are already in the current {@link CB_GraphicSpritesScene} object. If not provided, it will use all the {@link CB_GraphicSprites} objects contained in the {@link CB_GraphicSpritesScene} object. * @param {boolean} [returnSetTimeoutsArray=false] - Defines whether we want the method to return an integer or a numeric array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call. Returning an array with information of each [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} call is only useful when the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). * @param {boolean} [delayBetweenEachAffectsFirst=false] - If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. * @param {CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK} [functionFinish] - Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. * @returns {integer|array} If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the {@link CB_GraphicSprites} objects given in the &quot;graphicSpritesObjects&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a {@link CB_Arrays.executeFunctionAll_OBJECT} object for each {@link CB_GraphicSprites} given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the [setTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function. * @todo Think about only allowing {@link CB_GraphicSprites} objects (in the &quot;graphicSpritesObjects&quot; parameter) which are already in the {@link CB_GraphicSpritesScene} (identify them by their ID), to avoid problems. */ CB_GraphicSpritesScene.prototype.executeFunctionAll = CB_GraphicSpritesScene.prototype.executeAll = CB_GraphicSpritesScene.prototype.forEachGraphicSprites = CB_GraphicSpritesScene.prototype.forEach = function(functionEach, orderedByZIndex, delayBetweenEach, graphicSpritesObjects, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish) { return CB_Arrays.executeFunctionAll(CB_isArray(graphicSpritesObjects) ? graphicSpritesObjects : this.getGraphicSpritesAll(orderedByZIndex, []), functionEach, delayBetweenEach, returnSetTimeoutsArray, delayBetweenEachAffectsFirst, functionFinish); } /** * Sets the desired value of a given property name to the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object as well to its {@link CB_GraphicSprites} objects and their children (their {@link CB_GraphicSprites.SPRITES_OBJECT} object, including their {@link CB_GraphicSprites.SPRITE_OBJECT} and their {@link CB_GraphicSprites.SUBSPRITE_OBJECT} objects). Calls the {@link CB_GraphicSprites#setPropertyCascade} method internally. * @function * @param {number} propertyName - The name of the property we want to affect. Also used as the &quot;propertyName&quot; parameter when calling the {@link CB_GraphicSprites#setPropertyCascade} method internally. * @param {*} [value=undefined] - The value desired for the given property. Also used as the &quot;value&quot; parameter when calling the {@link CB_GraphicSprites#setPropertyCascade} method internally. * @param {boolean} [onlyCurrent=false] - If set to true, it will only affect the current sprite and its sub-sprites of each {@link CB_GraphicSprites} object (and also the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object and the {@link CB_GraphicSprites.SPRITES_OBJECT} object of each {@link CB_GraphicSprites} object). Used as the &quot;propertyName&quot; parameter when calling the {@link CB_GraphicSprites#setPropertyCascade} method internally. * @returns {integer} Returns the number of elements affected (counting the {@link CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} object and the {@link CB_GraphicSprites.SPRITES_OBJECT} objects). */ CB_GraphicSpritesScene.prototype.setPropertyCascade = function(propertyName, value, onlyCurrent) { if (!propertyName) { return; } this.spritesGroups[propertyName] = value; var affected = 1; this.forEachGraphicSprites(function() { affected += this.setPropertyCascade(propertyName, value, onlyCurrent); }); return affected; } /** * Gets a new copy of this object with the same attributes (all sub-objects will be a copy, they will not the same reference). * @function * @param {boolean} [avoidCopyingPointers=false] - If set to true, it will not copy the {@link CB_GraphicSprites#pointer} property of each {@link CB_GraphicSprites} object. * @param {boolean} [avoidCopyingTimes=false] - If set to true, it will not copy neither the {@link CB_GraphicSprites#time} property of each {@link CB_GraphicSprites} object nor the &quot;time&quot; property of each of their sprites ({@link CB_GraphicSprites.SPRITE_OBJECT} objects). * @param {boolean} [clearReferences=false] - If set to true, it will not copy neither the &quot;container&quot; nor the &quot;parent&quot; nor the &quot;data.that&quot; nor the &quot;data.getThis&quot; properties of any element. Useful to be able to stringify the object preventing the &quot;TypeError: cyclic object value&quot; error. When set to true, calls the {@link CB_GraphicSprites.clearReferences} function internally. If set to true and the &quot;filterProperties&quot; parameter is also set to true, the {@link CB_GraphicSprites.filterProperties} will always be called before calling the {@link CB_GraphicSprites.clearReferences} function. * @param {boolean} [filterProperties=false] - If set to true, it will call the {@link CB_GraphicSprites.filterProperties} function internally to filter the properties that we do not want to keep (using the given &quot;propertiesToKeepObject&quot; as the parameter to call it). When set to true, calls the {@link CB_GraphicSprites.filterProperties} function internally. If set to true and the &quot;clearReferences&quot; parameter is also set to true, the {@link CB_GraphicSprites.filterProperties} will always be called before calling the {@link CB_GraphicSprites.clearReferences} function. * @param {CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE} [propertiesToKeepObject=CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES] - The object with the properties that we want to keep. Only used when the &quot;filterProperties&quot; parameter is set to true, as the &quot;propertiesToKeepObject&quot; when calling the {@link CB_GraphicSprites.filterProperties} function internally. * @returns {CB_GraphicSpritesScene} Returns a copy of this object with the same attributes (all sub-objects will be a copy, not the same reference). */ CB_GraphicSpritesScene.prototype.getCopy = function(avoidCopyingPointers, avoidCopyingTimes, clearReferences, filterProperties, propertiesToKeepObject) { var spritesGroupsCopy = CB_copyObject(this.spritesGroups); var newCopy = new CB_GraphicSpritesScene(spritesGroupsCopy, false); CB_GraphicSprites._copyNeededProperties(newCopy, this) //Copies the needed properties from the original element. CB_GraphicSprites._copyNeededProperties(newCopy.spritesGroups, this.spritesGroups) //Copies the needed properties from the original element. this.forEach ( function(CB_GraphicSpritesObject, index) { CB_GraphicSprites._copyNeededProperties(newCopy.get(index), CB_GraphicSpritesObject) //Copies the needed properties from the original element. CB_GraphicSprites._copyNeededProperties(newCopy.get(index).spritesGroup, CB_GraphicSpritesObject.spritesGroup) //Copies the needed properties from the original element. //If desired, sets the same pointers of each CB_GraphicSprites object: if (!avoidCopyingPointers) { newCopy.get(index).pointer = this.pointer; newCopy.get(index).pointerPrevious = this.pointerPrevious; } if (!avoidCopyingTimes) { newCopy.get(index).time = this.time; } newCopy.get(index).time = this.time; this.forEach ( function(sprite, spriteIndex) { if (!avoidCopyingTimes) { newCopy.get(index).get(spriteIndex).time = this.time; } CB_GraphicSprites._copyNeededProperties(newCopy.get(index).get(spriteIndex), sprite) //Copies the needed properties from the original element. sprite.forEach ( function(subSprite, subSpriteIndex) { CB_GraphicSprites._copyNeededProperties(newCopy.get(index).get(spriteIndex).get(subSpriteIndex), subSprite) //Copies the needed properties from the original element. //If desired, sets the same times: if (!avoidCopyingTimes) { sprite.get(subSpriteIndex).time = this.time; } } ); } ); } ); //Sets the same parent: newCopy.parent = this.parent; //If we want to, filters the properties keeping just the desired ones: if (filterProperties) { newCopy = CB_GraphicSprites.filterProperties(newCopy, propertiesToKeepObject); } //If we want to, clears the references: if (clearReferences) { CB_GraphicSprites.clearReferences(newCopy); } return newCopy; } × Search results Close "},"CrossBase_input_CB_Keyboard.js.html":{"id":"CrossBase_input_CB_Keyboard.js.html","title":"Source: CrossBase/input/CB_Keyboard.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/CB_Keyboard.js /** * @file Keyboard management (and other devices which also fire [keyboard events]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} as TV remote controls, game consoles' gamepads, etc.). Contains the {@link CB_Keyboard} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the keyboard and other input devices that generate key codes. It will return itself if it is tried to be instantiated. * @namespace */ var CB_Keyboard = function() { return CB_Keyboard; }; { //CB_Keyboard.onKeyPressFunction; //Function that is executed when a key is pressed (onKeyPress event). //CB_Keyboard.onKeyDownFunction; //Function that is executed when a key is down (onKeyDown event). //CB_Keyboard.onKeyUpFunction; //Function that is executed when a key is released (onKeyUp event). //CB_Keyboard.firstEvent = &quot;&quot;; //Defines wheter the first event captured is onKeyDown or onKeyPress (compatibility reasons). //CB_Keyboard.onKeyDownOrPressFunction; //Function that is executed when either a key is down os pressed (onKeyDown or onKeyPress event) /** * Object that will store the status for each key detected, using the key code as index and a boolean as their value (true when down or false when released). * @var * @readonly * @type {Object} * @default */ CB_Keyboard.keysDown = {}; /** * Array with the codes of the keys pressed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setKeysPressedExpiration} function). * @var * @readonly * @type {array} * @default */ CB_Keyboard.keysPressed = []; CB_Keyboard._keysPressedExpiration = 500; //Milliseconds before keys pressed array expires. CB_Keyboard._keysPressedExpirationTimeout = null; //It will store the timeout that clears the keys pressed array. /** * Array with the codes of the string typed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setTypedStringExpiration} function). * @var * @readonly * @type {array} * @default */ CB_Keyboard.typedStringCodes = []; /** * Stores the string typed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setTypedStringExpiration} function). * @var * @readonly * @type {string} * @default */ CB_Keyboard.typedString = &quot;&quot;; //Stores the string typed (it will be cleared after some milliseconds). CB_Keyboard._typedStringExpiration = 500; //Milliseconds before typed string expires. CB_Keyboard._typedStringExpirationTimeout = null; //It will store the timeout that clears the typed string. CB_Keyboard.initialized = false; //It will tells whether the object has been initialized or not. /** Property that keeps extended key codes for different systems and platforms. * @namespace CB_Keyboard.extended */ CB_Keyboard.extended = {}; /** * Smart TV Alliance and virtual keyboard key codes. * @memberof CB_Keyboard.extended * @name VK * @constant * @type {Object} * @default * @todo Consider adding more (found in {@link https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx} and {@link http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/}) * @property {number} ENTER - ENTER key. * @property {number} PAUSE - PAUSE key. * @property {number} PAGE_UP - PAGE UP key. * @property {number} PAGE_DOWN - PAGE DOWN key. * @property {number} LEFT - LEFT key. * @property {number} UP - UP key. * @property {number} RIGHT - RIGHT key. * @property {number} DOWN - DOWN key. * @property {number} _0 - 0 (zero) key. * @property {number} _1 - 1 key. * @property {number} _2 - 2 key. * @property {number} _3 - 3 key. * @property {number} _4 - 4 key. * @property {number} _5 - 5 key. * @property {number} _6 - 6 key. * @property {number} _7 - 7 key. * @property {number} _8 - 8 key. * @property {number} _9 - 9 key. * @property {number} 0 - Alias for {@link CB_Keyboard.extended.VK._0}. * @property {number} 1 - Alias for {@link CB_Keyboard.extended.VK._1}. * @property {number} 2 - Alias for {@link CB_Keyboard.extended.VK._2}. * @property {number} 3 - Alias for {@link CB_Keyboard.extended.VK._3}. * @property {number} 4 - Alias for {@link CB_Keyboard.extended.VK._4}. * @property {number} 5 - Alias for {@link CB_Keyboard.extended.VK._5}. * @property {number} 6 - Alias for {@link CB_Keyboard.extended.VK._6}. * @property {number} 7 - Alias for {@link CB_Keyboard.extended.VK._7}. * @property {number} 8 - Alias for {@link CB_Keyboard.extended.VK._8}. * @property {number} 9 - Alias for {@link CB_Keyboard.extended.VK._9}. * @property {number} REWIND - RW (REWIND) key. * @property {number} STOP - STOP key. * @property {number} PLAY - PLAY key. * @property {number} FAST_FWD - FF (FAST FORWARD) key. * @property {number} BACK - BACK key. * @property {number} PREV - PREVIOUS key. * @property {number} NEXT - NEXT key. * @property {number} INFO - INFORMATION key. * @property {number} RED - RED key. * @property {number} GREEN - GREEN key. * @property {number} YELLOW - YELLOW key. * @property {number} BLUE - BLUE key. * @property {number} SPACE - SPACE key. * @property {number} BACK_SPACE - BACK SPACE key. * @property {number} A - A key. * @property {number} B - B key. * @property {number} C - C key. * @property {number} D - D key. * @property {number} E - E key. * @property {number} F - F key. * @property {number} G - G key. * @property {number} H - H key. * @property {number} I - I key. * @property {number} J - J key. * @property {number} K - K key. * @property {number} L - L key. * @property {number} M - M key. * @property {number} N - N key. * @property {number} O - O key. * @property {number} P - P key. * @property {number} Q - Q key. * @property {number} R - R key. * @property {number} S - S key. * @property {number} T - T key. * @property {number} U - U key. * @property {number} V - V key. * @property {number} W - W key. * @property {number} X - X key. * @property {number} Y - Y key. * @property {number} Z - Z key. * @property {number} VOLUME_UP - VOLUME UP key. * @property {number} VOLUME_DOWN - VOLUME DOWN key. * @property {number} MUTE - MUTE key. * @property {number} PLAY_PAUSE - PLAY/PAUSE key. * @property {number} HELP - HELP key. * @property {number} SUBTITLE - SUBTITLE key. * @property {number} SEARCH - SEARCH key. * @property {number} AUDIODESCRIPTION - AUDIODESCRIPTION key. * @property {number} HD - HD (High Definition) key. */ CB_Keyboard.extended.VK = { //* Source: http://smarttv-alliance.org/Markets/Developers.aspx ENTER: window.VK_ENTER || 13, PAUSE: window.VK_PAUSE || 19, PAGE_UP: window.VK_PAGE_UP || 33, PAGE_DOWN: window.VK_PAGE_DOWN || 34, LEFT: window.VK_LEFT || 37, UP: window.VK_UP || 38, RIGHT: window.VK_RIGHT || 39, DOWN: window.VK_DOWN || 40, _0: window.VK_0 || 48, _1: window.VK_1 || 49, _2: window.VK_2 || 50, _3: window.VK_3 || 51, _4: window.VK_4 || 52, _5: window.VK_5 || 53, _6: window.VK_6 || 54, _7: window.VK_7 || 55, _8: window.VK_8 || 56, _9: window.VK_9 || 57, REWIND: window.VK_REWIND || 412, STOP: window.VK_STOP || 413, PLAY: window.VK_PLAY || 415, FAST_FWD: window.VK_FAST_FWD || 417, BACK: window.VK_BACK || 461, PREV: window.VK_PREV || 424, NEXT: window.VK_NEXT || 425, INFO: window.VK_INFO || 457, RED: window.VK_RED || 403, GREEN: window.VK_GREEN || 404, YELLOW: window.VK_YELLOW || 405, BLUE: window.VK_BLUE || 406, //More virtual keyboard keys: //* Source: https://fmtvp.github.io/tal/jsdoc/symbols/src/antie_static_script_events_keyevent.js.html SPACE: window.VK_SPACE || 32, BACK_SPACE: window.VK_BACK_SPACE || 8, A: window.VK_A || 65, B: window.VK_B || 66, C: window.VK_C || 67, D: window.VK_D || 68, E: window.VK_E || 69, F: window.VK_F || 70, G: window.VK_G || 71, H: window.VK_H || 72, I: window.VK_I || 73, J: window.VK_J || 74, K: window.VK_K || 75, L: window.VK_L || 76, M: window.VK_M || 77, N: window.VK_N || 78, O: window.VK_O || 79, P: window.VK_P || 80, Q: window.VK_Q || 81, R: window.VK_R || 82, S: window.VK_S || 83, T: window.VK_T || 84, U: window.VK_U || 85, V: window.VK_V || 86, W: window.VK_W || 87, X: window.VK_X || 88, Y: window.VK_Y || 89, Z: window.VK_Z || 90, VOLUME_UP: window.VK_VOLUME_UP || 447, VOLUME_DOWN: window.VK_VOLUME_DOWN || 448, MUTE: window.VK_MUTE || 449, PLAY_PAUSE: window.VK_PLAY_PAUSE || 402, HELP: window.VK_HELP || 156, SUBTITLE: window.VK_SUBTITLE || 460, SEARCH: window.VK_SEARCH || 112, //112 is the same code as the F1 key. AUDIODESCRIPTION: window.VK_AUDIODESCRIPTION || 113, //113 is the same code as the F2 key. HD: window.VK_HD || 114 //114 is the same code as the F3 key. }; CB_Keyboard.extended.VK[0] = CB_Keyboard.extended.VK._0; CB_Keyboard.extended.VK[1] = CB_Keyboard.extended.VK._1; CB_Keyboard.extended.VK[2] = CB_Keyboard.extended.VK._2; CB_Keyboard.extended.VK[3] = CB_Keyboard.extended.VK._3; CB_Keyboard.extended.VK[4] = CB_Keyboard.extended.VK._4; CB_Keyboard.extended.VK[5] = CB_Keyboard.extended.VK._5; CB_Keyboard.extended.VK[6] = CB_Keyboard.extended.VK._6; CB_Keyboard.extended.VK[7] = CB_Keyboard.extended.VK._7; CB_Keyboard.extended.VK[8] = CB_Keyboard.extended.VK._8; CB_Keyboard.extended.VK[9] = CB_Keyboard.extended.VK._9; CB_Keyboard.extended.VK._allowDuplicateKeyAliases = CB_Configuration[CB_BASE_NAME].CB_Keyboard_extended_VK_allowDuplicateKeyAliases; /** * Samsung Tizen TV key codes. * @memberof CB_Keyboard.extended * @name SAMSUNG_TIZEN_TV * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} ENTER - ENTER button. * @property {number} MEDIA_PLAY_PAUSE - PLAY/PAUSE MEDIA button. * @property {number} MEDIA_REWIND - RW (REWIND) MEDIA button. * @property {number} MEDIA_FORWARD - FW (FORWARD) MEDIA button. * @property {number} MEDIA_PLAY - PLAY MEDIA button. * @property {number} MEDIA_PAUSE - PAUSE MEDIA button. * @property {number} MEDIA_STOP - STOP MEDIA button. * @property {number} RETURN - RETURN button. * @property {number} MEDIA_RECORD - RECORD MEDIA button. * @property {number} MEDIA_TRACK_PREVIOUS - PREVIOUS TRACK MEDIA button. * @property {number} MEDIA_TRACK_NEXT - NEXT TRACK MEDIA button. * @property {number} VOLUME_UP - VOLUME UP button. * @property {number} VOLUME_DOWN - VOLUME DOWN button. * @property {number} MUTE - MUTE button. * @property {number} _0 - 0 (zero) button. * @property {number} _1 - 1 button. * @property {number} _2 - 2 button. * @property {number} _3 - 3 button. * @property {number} _4 - 4 button. * @property {number} _5 - 5 button. * @property {number} _6 - 6 button. * @property {number} _7 - 7 button. * @property {number} _8 - 8 button. * @property {number} _9 - 9 button. * @property {number} 0 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._0}. * @property {number} 1 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._1}. * @property {number} 2 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._2}. * @property {number} 3 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3}. * @property {number} 4 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._4}. * @property {number} 5 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._5}. * @property {number} 6 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._6}. * @property {number} 7 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._7}. * @property {number} 8 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._8}. * @property {number} 9 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._9}. * @property {number} RED - RED button. * @property {number} GREEN - GREEN button. * @property {number} YELLOW - YELLOW button. * @property {number} BLUE - BLUE button. * @property {number} INFO - INFORMATION button. * @property {number} EXIT - EXIT button. * @property {number} MINUS - MINUS button. * @property {number} CAPTION - CAPTION button. * @property {number} CH_UP - CHANNEL UP button. * @property {number} CH_DOWN - CHANNEL DOWN button. * @property {number} CH_PREVIOUS - PREVIOUS CHANNEL button. * @property {number} CH_LIST - CHANNEL LIST button. * @property {number} E_MANUAL - E-MANUAL button. * @property {number} SEARCH - SEARCH button. * @property {number} _3D - 3D button. * @property {number} 3D - Alias for {@link CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3D}. * @property {number} GUIDE - GUIDE button. * @property {number} SOURCE - SOURCE button. * @property {number} PICTURE_SIZE - PICTURE SIZE button. * @property {number} EXTRA - EXTRA button. * @property {number} SOCCER - SOCCER button. * @property {number} MTS - MTS (Multichannel Television Sound) button. * @property {number} TELETEXT - TELETEXT button. * @property {number} MENU - MENU button. * @property {number} TOOLS - TOOLS button. */ CB_Keyboard.extended.SAMSUNG_TIZEN_TV = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, ENTER: 13, MEDIA_PLAY_PAUSE: 10252, MEDIA_REWIND: 412, MEDIA_FORWARD: 417, MEDIA_PLAY: 415, MEDIA_PAUSE: 19, MEDIA_STOP: 413, RETURN: 10009, MEDIA_RECORD: 416, MEDIA_TRACK_PREVIOUS: 10232, MEDIA_TRACK_NEXT: 10233, VOLUME_UP: 447, VOLUME_DOWN: 448, MUTE: 449, _0: 48, _1: 49, _2: 50, _3: 51, _4: 52, _5: 53, _6: 54, _7: 55, _8: 56, _9: 57, RED: 403, GREEN: 404, YELLOW: 405, BLUE: 406, INFO: 457, EXIT: 10182, MINUS: 189, CAPTION: 10221, CH_UP: 427, CH_DOWN: 428, CH_PREVIOUS: 10190, CH_LIST: 10073, E_MANUAL: 10146, SEARCH: 10225, _3D: 10199, GUIDE: 458, SOURCE: 10072, PICTURE_SIZE: 10140, EXTRA: 10253, SOCCER: 10228, MTS: 10195, TELETEXT: 10200, MENU: 457, TOOLS: 10135 }; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[0] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._0; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[1] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._1; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[2] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._2; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[3] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[4] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._4; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[5] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._5; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[6] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._6; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[7] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._7; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[8] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._8; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[9] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._9; CB_Keyboard.extended.SAMSUNG_TIZEN_TV[&quot;3D&quot;] = CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3D; try { var tvKey = new Common.API.TVKeyValue(); } catch(E) { try { tvKey = sf.key; } catch(E) { tvKey = {}; } } /** * Samsung TV key codes. * @memberof CB_Keyboard.extended * @name SAMSUNG_TV * @constant * @type {Object} * @default * @property {number} TOOLS - TOOLS button. * @property {number} EMODE - EMODE button. * @property {number} DMA - DMA (Digital Media Adapter) button. * @property {number} SOURCE - SOURCE button. * @property {number} CHDOWN - CHANNEL DOWN button. * @property {number} CHUP - CHANNEL UP button. * @property {number} PANEL_CH_UP - CHANNEL UP PANEL button #1. * @property {number} PANEL_CH_DOWN - CHANNEL DOWN PANEL button #1. * @property {number} PANEL_CHUP - CHANNEL UP PANEL button #2. * @property {number} PANEL_CHDOWN - CHANNEL DOWN PANEL button #2. * @property {number} PIP_CHUP - CHANNEL UP PIP (Picture In Picture) button. * @property {number} PIP_CHDOWN - CHANNEL DOWN PIP (Picture In Picture) button. * @property {number} PRECH - PRE-CHANNEL (PREVIOUS CHANNEL) button. * @property {number} FAVCH - FAVOURITE CHANNEL button. * @property {number} CHLIST - CHANNEL LIST button. * @property {number} TTX_MIX - TELETEXT button. * @property {number} GUIDE - GUIDE button. * @property {number} ASPECT - ASPECT button. * @property {number} DOLBY_SRR - DOLBY SRR (SuRroundRight) button. * @property {number} MTS - MTS (Multichannel Television Sound) button. * @property {number} WHEELDOWN - WHEEL DOWN #1. * @property {number} WHEEL_DOWN - WHEEL DOWN #2. * @property {number} WHEELUP - WHEEL UP #1. * @property {number} WHEEL_UP - WHEEL UP #2. * @property {number} WHEELLEFT - WHEEL LEFT #1. * @property {number} WHEEL_LEFT - WHEEL LEFT #2. * @property {number} WHEELRIGHT - WHEEL RIGHT #1. * @property {number} WHEEL_RIGHT - WHEEL RIGHT #2. * @property {number} SMART - SMART TV button. * @property {number} EXIT - EXIT button. * @property {number} POWER - POWER button. * @property {number} PANEL_POWER - POWER PANEL button. * @property {number} POWEROFF - POWER OFF button. * @property {number} POWERON - POWER ON button. * @property {number} CONTENT - CONTENT button. * @property {number} WLINK - WLINK (Wiselink) button #1. * @property {number} W_LINK - WLINK (Wiselink) button #2. * @property {number} EMPTY - EMPTY button. * @property {number} CC - CC (Closed Captioning) button. * @property {number} REC - REC button. * @property {number} VOLUP - VOLUME UP button #1. * @property {number} VOL_UP - VOLUME UP button #2. * @property {number} VOLDOWN - VOLUME DOWN button #1. * @property {number} VOL_DOWN - VOLUME DOWN button #2. * @property {number} PANEL_VOLUP - PANEL VOLUME UP button #1. * @property {number} PANEL_VOL_UP - PANEL VOLUME UP button #2. * @property {number} PANEL_VOLDOW - PANEL VOLUME DOWN button #1. * @property {number} PANEL_VOLDOWN - PANEL VOLUME DOWN button #2. * @property {number} PANEL_VOL_DOWN - PANEL VOLUME DOWN button #3. * @property {number} MUTE - MUTE button. * @property {number} INFO - INFORMATION button. * @property {number} INFOLINK - INFOLINK button. * @property {number} MENU - MENU button. * @property {number} SUBTITLE - SUBTITLE button #1. * @property {number} SUB_TITLE - SUBTITLE button #2. * @property {number} PANEL_SOURCE - SOURCE PANEL button. * @property {number} _0 - 0 (zero) button. * @property {number} _1 - 1 button. * @property {number} _2 - 2 button. * @property {number} _3 - 3 button. * @property {number} _4 - 4 button. * @property {number} _5 - 5 button. * @property {number} _6 - 6 button. * @property {number} _7 - 7 button. * @property {number} _8 - 8 button. * @property {number} _9 - 9 button. * @property {number} _10 - 10 button. * @property {number} _11 - 11 button. * @property {number} _12 - 12 button. * @property {number} 0 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._0}. * @property {number} 1 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._1}. * @property {number} 2 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._2}. * @property {number} 3 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._3}. * @property {number} 4 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._4}. * @property {number} 5 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._5}. * @property {number} 6 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._6}. * @property {number} 7 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._7}. * @property {number} 8 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._8}. * @property {number} 9 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._9}. * @property {number} 10 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._10}. * @property {number} 11 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._11}. * @property {number} 12 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._12}. * @property {number} RED - RED button. * @property {number} GREEN - GREEN button. * @property {number} YELLOW - YELLOW button. * @property {number} BLUE - BLUE button. * @property {number} CYAN - CYAN button. * @property {number} RW - RW (REWIND) button #1. * @property {number} REWIND - RW (REWIND) button #2. * @property {number} REWIND_ - RW (REWIND) button #3. * @property {number} FF - FF (FAST FORWARD) button #1. * @property {number} FF_ - FF (FAST FORWARD) button #2. * @property {number} PAUSE - PAUSE button. * @property {number} PLAY - PLAY button. * @property {number} STOP - STOP button. * @property {number} SEARCH - SEARCH button. * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} CH_UP - CHANNEL UP button. * @property {number} CH_DOWN - CHANNEL DOWN button. * @property {number} DISC_MENU - DISC MENU button. * @property {number} _3D - 3D button. * @property {number} 3D - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._3D}. * @property {number} PIP_ONOFF - PIP (Picture In Picture) ON/OFF button. * @property {number} AD - AD (Audio Description) button. * @property {number} PMODE - PICTURE MODE button. * @property {number} SMODE - SOUND MODE button. * @property {number} SLEEP - SLEEP button. * @property {number} D_AUDIO - DIGITAL AUDIO button. * @property {number} D_FRONT_PLAY - DIGITAL FRONT PLAY button. * @property {number} D_VIEW_MODE - DIGITAL VIEW MODE button. * @property {number} STEP - STEP button. * @property {number} CALLER_ID - CALLED ID button. * @property {number} ANTENNA - ANTENNA button. * @property {number} ZOOM_MOVE - MOVE ZOOM button. * @property {number} ZOOM1 - ZOOM 1 button. * @property {number} ZOOM2 - ZOOM 2 button. * @property {number} ZOOM_IN - ZOOM IN button. * @property {number} ZOOM_OUT - ZOOM OUT button. * @property {number} RETURN - RETURN button. * @property {number} PANEL_RETURN - RETURN PANEL button. * @property {number} ENTER - ENTER button. * @property {number} PANEL_ENTER - ENTER PANEL button. * @property {number} PANEL_MENU - MENU PANEL button. * @property {number} ADDDEL - ADD/DEL button. * @property {number} PIP_SWAP - PIP (Picture In Picture) SWAP button. * @property {number} PLUS100 - SAMSUNG AUTO MOTION PLUS 100 HZ button. * @property {number} CAPTION - CAPTION button. * @property {number} PICTURE_SIZE - PICTURE SIZE button. * @property {number} PIP_SIZE - PIP (Picture In Picture) SIZE button. * @property {number} MAGIC_CHANNEL - MAGIC CHANNEL button. * @property {number} PIP_SCAN - PIP (Picture In Picture) SCAN button. * @property {number} DEVICE_CONNECT - DEVICE CONNECT button. * @property {number} HELP - HELP button. * @property {number} CONVERGENCE - CONVERGENCE button. * @property {number} AUTO_PROGRAM - AUTO PROGRAM button. * @property {number} FACTORY - FACTORY button. * @property {number} _3SPEED - 3SPEED button. * @property {number} 3SPEED - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._3SPEED}. * @property {number} RSURF - R.SURF button. * @property {number} TOPMENU - TOP MENU button. * @property {number} GAME - GAME button. * @property {number} QUICK_REPLAY - QUICK REPLAY button. * @property {number} STILL_PICTURE - STILL PICTURE button. * @property {number} DTV - DTV (Digital Television) button. * @property {number} INSTANT_REPLAY - INSTANT REPLAY button. * @property {number} LINK - LINK button. * @property {number} ANGLE - ANGLE button. * @property {number} RESERVED1 - RESERVED1 button. * @property {number} RESERVED5 - RESERVED5 button. * @property {number} PROGRAM - PROGRAM button. * @property {number} BOOKMARK - BOOKMARK button. * @property {number} PRINT - PRINT button. * @property {number} CLEAR - CLEAR button. * @property {number} VCHIP - V-CHIP button. * @property {number} REPEAT - REPEAT button. * @property {number} DOOR - DOOR button. * @property {number} OPEN - OPEN button. * @property {number} TURBO - TURBO button. * @property {number} DVR_MENU - DVR (Digital Video Recorder) MENU button. * @property {number} TTX_SUBFACE - Teletext Subface button. * @property {number} CH_LIST - CHANNEL LIST button. * @property {number} DNIe - DNIe (Digital Natural Image Engine) button. * @property {number} DNSe - DNSe (Digital Natural Sound Engine) button. * @property {number} SRS - SRS (Sound Retrieval System) button. * @property {number} CONVERT_AUDIO_MAINSUB - CONVERT AUDIO MAIN/SUB button. * @property {number} MDC - MDC button. * @property {number} SEFFECT - SOUND EFFECT button. * @property {number} DVR - DVR (Digital Video Recorder) button. * @property {number} DTV_SIGNAL - DTV (Digital Television) SIGNAL button. * @property {number} LIVE - LIVE button. * @property {number} PERPECT_FOCUS - PERPECT FOCUS button. * @property {number} HOME - HOME button. * @property {number} ESAVING - ENERGY SAVING button. * @property {number} CONTENTS - CONTENTS button. * @property {number} SCALE - SCALE button. * @property {number} CLOCK_DISPLAY - CLOCK DISPLAY button. * @property {number} SETUP_CLOCK_TIMER - SETUP CLOCK TIMER button. * @property {number} MAGIC_BRIGHT - MAGIC BRIGHT button. * @property {number} FM_RADIO - FM RADIO button. * @property {number} VCR_MODE - VCR MODE button. * @property {number} CATV_MODE - CATV (Community Antenna Television) MODE button. * @property {number} DSS_MODE - DSS MODE button. * @property {number} DVD_MODE - DVD MODE button. * @property {number} STB_MODE - STB (Set-Top Box) MODE button. * @property {number} PCMODE - PC MODE button. * @property {number} TV_MODE - TV MODE button. * @property {number} TV - TV button. * @property {number} AV1 - AV #1 button. * @property {number} AV2 - AV #2 button. * @property {number} AV3 - AV #3 button. * @property {number} SVIDEO1 - S-VIDEO (Separated-Video) #1 button. * @property {number} SVIDEO2 - S-VIDEO (Separated-Video) #2 button. * @property {number} SVIDEO3 - S-VIDEO (Separated-Video) #3 button. * @property {number} COMPONENT1 - COMPONENT #1 button. * @property {number} COMPONENT2 - COMPONENT #2 button. * @property {number} DVI - DVI (Digital Visual Interface) button. * @property {number} HDMI - HDMI button. * @property {number} HDMI1 - HDMI #1 button. * @property {number} HDMI2 - HDMI #2 button. * @property {number} HDMI3 - HDMI #3 button. * @property {number} HDMI4 - HDMI #4 button. * @property {number} DTV_LINK - DTVLINK (DIGITAL TELEVISION LINK) button. * @property {number} APP_LIST - APP LIST button. * @property {number} BACK_MHP - BACK MHP (Multimedia Home Platform) button. * @property {number} ALT_MHP - ALTERNATE MHP (Multimedia Home Platform) button. * @property {number} RSS - RSS button. * @property {number} ENTERTAINMENT - ENTERTAINMENT button. * @property {number} ID_INPUT - ID INPUT button. * @property {number} ID_SETUP - ID SETUP button. * @property {number} ANYNET - ANYNET button. * @property {number} ANYVIEW - ANYVIEW button. * @property {number} MS - MS button. * @property {number} MORE - MORE button. * @property {number} _4_3 - 4:3 button. * @property {number} 4_3 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._4_3}. * @property {number} _16_9 - 16:9 button. * @property {number} 16_9 - Alias for {@link CB_Keyboard.extended.SAMSUNG_TV._16_9}. * @property {number} PANORAMA - PICTURE MODE PANORAMA button. * @property {number} DYNAMIC - PICTURE MODE DYNAMIC button. * @property {number} STANDARD - PICTURE MODE STANDARD button. * @property {number} MOVIE1 - PICTURE MODE MOVIE1 button. * @property {number} CUSTOM - PICTURE MODE CUSTOM button. * @property {number} AUTO_ARC_RESET - AUTO ARC (Audio Return Channel) RESET button. * @property {number} AUTO_ARC_LNA_ON - AUTO ARC (Audio Return Channel) LNA (Low Noise Amplifier) ON button. * @property {number} AUTO_ARC_LNA_OFF - AUTO ARC (Audio Return Channel) LNA (Low Noise Amplifier) OFF button. * @property {number} AUTO_ARC_ANYNET_MODE_OK - AUTO ARC (Audio Return Channel) ANYNET MODE OK button. * @property {number} AUTO_ARC_ANYNET_AUTO_START - AUTO ARC (Audio Return Channel) ANYNET AUTO START button. * @property {number} AUTO_ARC_CAPTION_ON - AUTO ARC (Audio Return Channel) CAPTION ON button. * @property {number} AUTO_ARC_CAPTION_OFF - AUTO ARC (Audio Return Channel) CAPTION OFF button. * @property {number} AUTO_ARC_PIP_DOUBLE - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) DOUBLE button. * @property {number} AUTO_ARC_PIP_LARGE - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LARGE button. * @property {number} AUTO_ARC_PIP_SMALL - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) SMALL button. * @property {number} AUTO_ARC_PIP_WIDE - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) WIDE button. * @property {number} AUTO_ARC_PIP_LEFT_TOP - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LEFT TOP button. * @property {number} AUTO_ARC_PIP_RIGHT_TOP - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) RIGHT TOP button. * @property {number} AUTO_ARC_PIP_LEFT_BOTTOM - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LEFT BOTTOM button. * @property {number} AUTO_ARC_PIP_RIGHT_BOTTOM - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) RIGHT BOTTOM button. * @property {number} AUTO_ARC_PIP_CH_CHANGE - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) CHANNEL CHANGE button. * @property {number} AUTO_ARC_PIP_SOURCE_CHANGE - AUTO ARC (Audio Return Channel) PIP (Picture In Picture) SOURCE CHANGE button. * @property {number} AUTO_ARC_AUTOCOLOR_SUCCESS - AUTO ARC (Audio Return Channel) AUTOCOLOR SUCCESS button. * @property {number} AUTO_ARC_AUTOCOLOR_FAIL - AUTO ARC (Audio Return Channel) AUTOCOLOR FAIL button. * @property {number} AUTO_ARC_C_FORCE_AGING - AUTO ARC (Audio Return Channel) C-FORCE AGING button. * @property {number} AUTO_ARC_USBJACK_INSPECT - AUTO ARC (Audio Return Channel) USB JACK INSPECT button. * @property {number} AUTO_ARC_JACK_IDENT - AUTO ARC (Audio Return Channel) JACK IDENT button. * @property {number} AUTO_ARC_CAPTION_KOR - AUTO ARC (Audio Return Channel) CAPTION KOREAN button. * @property {number} AUTO_ARC_CAPTION_ENG - AUTO ARC (Audio Return Channel) CAPTION ENGLISH button. * @property {number} AUTO_ARC_ANTENNA_AIR - AUTO ARC (Audio Return Channel) ANTENNA AIR button. * @property {number} AUTO_ARC_ANTENNA_CABLE - AUTO ARC (Audio Return Channel) ANTENNA CABLE button. * @property {number} AUTO_ARC_ANTENNA_SATELLITE - AUTO ARC (Audio Return Channel) ANTENNA SATELLITE button. * @property {number} AUTO_FORMAT - AUTO FORMAT button. * @property {number} DNET - D-NET button. * @property {number} NINE_SEPARATE - NINE SEPARATE button. * @property {number} MIC - MIC (MICROPHONE) button. * @property {number} EXT1 - EXT1 button. * @property {number} EXT2 - EXT2 button. * @property {number} EXT3 - EXT3 button. * @property {number} EXT4 - EXT4 button. * @property {number} EXT5 - EXT5 button. * @property {number} EXT6 - EXT6 button. * @property {number} EXT7 - EXT7 button. * @property {number} EXT8 - EXT8 button. * @property {number} EXT9 - EXT9 button. * @property {number} EXT10 - EXT10 button. * @property {number} EXT11 - EXT11 button. * @property {number} EXT12 - EXT12 button. * @property {number} EXT13 - EXT13 button. * @property {number} EXT14 - EXT14 button. * @property {number} EXT15 - EXT15 button. * @property {number} EXT16 - EXT16 button. * @property {number} EXT17 - EXT17 button. * @property {number} EXT18 - EXT18 button. * @property {number} EXT19 - EXT19 button. * @property {number} EXT20 - EXT20 button. * @property {number} EXT21 - EXT21 button. * @property {number} EXT22 - EXT22 button. * @property {number} EXT23 - EXT23 button. * @property {number} EXT24 - EXT24 button. * @property {number} EXT25 - EXT25 button. * @property {number} EXT26 - EXT26 button. * @property {number} EXT27 - EXT27 button. * @property {number} EXT28 - EXT28 button. * @property {number} EXT29 - EXT29 button. * @property {number} EXT30 - EXT30 button. * @property {number} EXT31 - EXT31 button. * @property {number} EXT32 - EXT32 button. * @property {number} EXT33 - EXT33 button. * @property {number} EXT34 - EXT34 button. * @property {number} EXT35 - EXT35 button. * @property {number} EXT36 - EXT36 button. * @property {number} EXT37 - EXT37 button. * @property {number} EXT38 - EXT38 button. * @property {number} EXT39 - EXT39 button. * @property {number} EXT40 - EXT40 button. * @property {number} EXT41 - EXT41 button. */ //* Source: https://forum.samygo.tv/viewtopic.php?t=1792 and http://www.openremote.org/pages/viewpage.action?pageId=19434990 and https://github.com/Ape/samsungctl/issues/87 CB_Keyboard.extended.SAMSUNG_TV = { TOOLS: tvKey.KEY_TOOLS || tvKey.TOOLS, //Same code as &quot;K&quot; key (75). EMODE: tvKey.KEY_EMODE || tvKey.EMODE, //148 DMA: tvKey.KEY_DMA || tvKey.DMA, //260 SOURCE: tvKey.KEY_SOURCE || tvKey.SOURCE, //222 CHDOWN: tvKey.KEY_CHDOWN || tvKey.CHDOWN, CHUP: tvKey.KEY_CHUP || tvKey.CHUP, PANEL_CH_UP: tvKey.KEY_PANEL_CH_UP || tvKey.PANEL_CH_UP, //105 (same code as &quot;9&quot; in the numeric pad). PANEL_CH_DOWN: tvKey.KEY_PANEL_CH_DOWN || tvKey.PANEL_CH_DOWN, //106 (same code as asterisk (&quot;*&quot;) in the numeric pad). PANEL_CHUP: tvKey.KEY_PANEL_CHUP || tvKey.KEY_PANNEL_CHUP || tvKey.PANEL_CHUP || tvKey.PANNEL_CHUP, PANEL_CHDOWN: tvKey.KEY_PANEL_CHDOWN || tvKey.KEY_PANNEL_CHDOWN || tvKey.PANEL_CHDOWN || tvKey.PANNEL_CHDOWN, PIP_CHUP: tvKey.KEY_PIP_CHUP || tvKey.PIP_CHUP, //1050 PIP_CHDOWN: tvKey.KEY_PIP_CHDOWN || tvKey.PIP_CHDOWN, //1051 PRECH: tvKey.KEY_PRECH || tvKey.PRECH, //259 FAVCH: tvKey.KEY_FAVCH || tvKey.FAVCH, //256 CHLIST: tvKey.KEY_CHLIST || tvKey.CHLIST, //84 (same code as &quot;T&quot; key). TTX_MIX: tvKey.KEY_TTX_MIX || tvKey.TTX_MIX, //650 GUIDE: tvKey.KEY_GUIDE || tvKey.GUIDE, //651 ASPECT: tvKey.KEY_ASPECT || tvKey.ASPECT, //653 DOLBY_SRR: tvKey.KEY_DOLBY_SRR || tvKey.DOLBY_SRR, //654 MTS: tvKey.KEY_MTS || tvKey.MTS, //655 WHEELDOWN: tvKey.KEY_WHEELDOWN || tvKey.WHEELDOWN, //29469 WHEEL_DOWN: tvKey.KEY_WHEEL_DOWN || tvKey.WHEEL_DOWN, WHEELUP: tvKey.KEY_WHEELUP || tvKey.WHEELUP, //29468 WHEEL_UP: tvKey.KEY_WHEEL_UP || tvKey.WHEEL_UP, WHEELLEFT: tvKey.KEY_WHEELLEFT || tvKey.WHEELLEFT, WHEEL_LEFT: tvKey.KEY_WHEEL_LEFT || tvKey.WHEEL_LEFT, WHEELRIGHT: tvKey.KEY_WHEELRIGHT || tvKey.WHEELRIGHT, WHEEL_RIGHT: tvKey.KEY_WHEEL_RIGHT || tvKey.WHEEL_RIGHT, SMART: tvKey.KEY_SMART || tvKey.SMART, EXIT: tvKey.KEY_EXIT || tvKey.EXIT, //Same code as INS key (45). POWER: tvKey.KEY_POWER || tvKey.POWER, //76 (same code as &quot;L&quot; key). PANEL_POWER: tvKey.KEY_PANEL_POWER || tvKey.KEY_PANNEL_POWER || tvKey.PANEL_POWER || tvKey.PANNEL_POWER, //614 POWEROFF: tvKey.KEY_POWEROFF || tvKey.POWEROFF, POWERON: tvKey.KEY_POWERON || tvKey.POWERON, CONTENT: tvKey.KEY_CONTENT || tvKey.CONTENT, //261 WLINK: tvKey.KEY_WLINK || tvKey.WLINK, //115 (same code as F4 key) W_LINK: tvKey.KEY_W_LINK || tvKey.W_LINK, EMPTY: tvKey.KEY_EMPTY || tvKey.EMPTY, //0 CC: tvKey.KEY_CC || tvKey.CC, //118 (same code as F7 key) REC: tvKey.KEY_REC || tvKey.REC, //192 VOLUP: tvKey.KEY_VOLUP || tvKey.VOLUP, VOL_UP: tvKey.KEY_VOL_UP || tvKey.VOL_UP, //7 VOLDOWN: tvKey.KEY_VOLDOWN || tvKey.VOLDOWN, VOL_DOWN: tvKey.KEY_VOL_DOWN || tvKey.VOL_DOWN, //1 PANEL_VOLUP: tvKey.KEY_PANEL_VOLUP || tvKey.KEY_PANNEL_VOLUP || tvKey.PANEL_VOLUP || tvKey.PANNEL_VOLUP, PANEL_VOL_UP: tvKey.KEY_PANEL_VOL_UP || tvKey.PANEL_VOL_UP, //203 PANEL_VOLDOW: tvKey.KEY_PANEL_VOLDOW || tvKey.KEY_PANNEL_VOLDOW || tvKey.PANEL_VOLDOW || tvKey.PANNEL_VOLDOW, PANEL_VOLDOWN: tvKey.KEY_PANEL_VOLDOWN || tvKey.KEY_PANNEL_VOLDOWN || tvKey.PANEL_VOLDOWN || tvKey.PANNEL_VOLDOWN, PANEL_VOL_DOWN: tvKey.KEY_PANEL_VOL_DOWN || tvKey.PANEL_VOL_DOWN, //204 MUTE: tvKey.KEY_MUTE || tvKey.MUTE, //Same code as ESC key (27). INFO: tvKey.KEY_INFO || tvKey.INFO, //31 INFOLINK: tvKey.KEY_INFOLINK || tvKey.INFOLINK, //147 MENU: tvKey.KEY_MENU || tvKey.MENU, //262 SUBTITLE: tvKey.KEY_SUBTITLE || tvKey.SUBTITLE, //652 SUB_TITLE: tvKey.KEY_SUB_TITLE || tvKey.SUB_TITLE, //1089 PANEL_SOURCE: tvKey.KEY_PANEL_SOURCE || tvKey.KEY_PANNEL_SOURCE || tvKey.PANEL_SOURCE || tvKey.PANNEL_SOURCE, //612 _0: tvKey.KEY_0 || tvKey.N0 || tvKey._0 || tvKey[&quot;0&quot;], //17 (same code as CTRL or META key, depending on the system). _1: tvKey.KEY_1 || tvKey.N1 || tvKey._1 || tvKey[&quot;1&quot;], //101 (same code as &quot;5&quot; in the numeric pad). _2: tvKey.KEY_2 || tvKey.N2 || tvKey._2 || tvKey[&quot;2&quot;], //98 (same code as &quot;2&quot; in the numeric pad). _3: tvKey.KEY_3 || tvKey.N3 || tvKey._3 || tvKey[&quot;3&quot;], //6 _4: tvKey.KEY_4 || tvKey.N4 || tvKey._4 || tvKey[&quot;4&quot;], //8 _5: tvKey.KEY_5 || tvKey.N5 || tvKey._5 || tvKey[&quot;5&quot;], //9 _6: tvKey.KEY_6 || tvKey.N6 || tvKey._6 || tvKey[&quot;6&quot;], //10 _7: tvKey.KEY_7 || tvKey.N7 || tvKey._7 || tvKey[&quot;7&quot;], //12 _8: tvKey.KEY_8 || tvKey.N8 || tvKey._8 || tvKey[&quot;8&quot;], //13 _9: tvKey.KEY_9 || tvKey.N9 || tvKey._9 || tvKey[&quot;9&quot;], //14 _10: tvKey.KEY_10 || tvKey.N10 || tvKey._10 || tvKey[&quot;10&quot;], _11: tvKey.KEY_11 || tvKey.N11 || tvKey._11 || tvKey[&quot;11&quot;], _12: tvKey.KEY_12 || tvKey.N12 || tvKey._12 || tvKey[&quot;12&quot;], //1057 RED: tvKey.KEY_RED || tvKey.RED, //Same code as SEPARATOR key (108). GREEN: tvKey.KEY_GREEN || tvKey.GREEN, //Same code as CAPS_LOCK key (20). YELLOW: tvKey.KEY_YELLOW || tvKey.YELLOW, //21 BLUE: tvKey.KEY_BLUE || tvKey.BLUE, //22 CYAN: tvKey.KEY_CYAN || tvKey.CYAN, RW: tvKey.KEY_RW || tvKey.RW, //69 (same code as &quot;E&quot; key). PAUSE: tvKey.KEY_PAUSE || tvKey.PAUSE, //74 (same code as &quot;J&quot; key). FF: tvKey.KEY_FF || tvKey.FF, //72 (same code as &quot;H&quot; key). FF_: tvKey.KEY_FF_ || tvKey.FF_, //1078 REWIND: tvKey.KEY_REWIND || tvKey.REWIND, REWIND_: tvKey.KEY_REWIND_ || tvKey.REWIND_, //1080 PLAY: tvKey.KEY_PLAY || tvKey.PLAY, //71 (same code as &quot;G&quot; key). STOP: tvKey.KEY_STOP || tvKey.STOP, //70 (same code as &quot;F&quot; key). SEARCH: tvKey.KEY_SEARCH || tvKey.SEARCH, UP: tvKey.KEY_UP || tvKey.UP, //29460. DOWN: tvKey.KEY_DOWN || tvKey.DOWN, //29461 LEFT: tvKey.KEY_LEFT || tvKey.LEFT, //4 RIGHT: tvKey.KEY_RIGHT || tvKey.RIGHT, //5 CH_UP: tvKey.KEY_CH_UP || tvKey.CH_UP, //68 (same code as &quot;D&quot; key) CH_DOWN: tvKey.KEY_CH_DOWN || tvKey.CH_DOWN, //65 (same code as &quot;A&quot; key) DISC_MENU: tvKey.KEY_DISC_MENU || tvKey.DISC_MENU, //1086 _3D: tvKey.KEY_3D || tvKey._3D || tvKey[&quot;3D&quot;], //1219 PIP_ONOFF: tvKey.KEY_PIP_ONOFF || tvKey.PIP_ONOFF, //1032 AD: tvKey.KEY_AD || tvKey.AD, //1039 PMODE: tvKey.KEY_PMODE || tvKey.PMODE, //1040 SMODE: tvKey.KEY_SMODE || tvKey.SMODE, //1043 SLEEP: tvKey.KEY_SLEEP || tvKey.SLEEP, //1097 D_AUDIO: tvKey.KEY_D_AUDIO || tvKey.D_AUDIO, //1236 D_FRONT_PLAY: tvKey.KEY_D_FRONT_PLAY || tvKey.D_FRONT_PLAY, //1243 (for BD) D_VIEW_MODE: tvKey.KEY_D_VIEW_MODE || tvKey.D_VIEW_MODE, //1249 STEP: tvKey.KEY_STEP || tvKey.STEP, //1023 (REC PAUSE(BD)) CALLER_ID: tvKey.KEY_CALLER_ID || tvKey.CALLER_ID, //1128 (FULL SCREEN (BD)) ANTENNA: tvKey.KEY_ANTENA || tvKey.ANTENA || tvKey.KEY_ANTENNA || tvKey.ANTENNA, //1054 (for CN) ZOOM_MOVE: tvKey.KEY_ZOOM_MOVE || tvKey.ZOOM_MOVE, ZOOM1: tvKey.KEY_ZOOM1 || tvKey.ZOOM1, //1083 ZOOM2: tvKey.KEY_ZOOM2 || tvKey.ZOOM2, ZOOM_IN: tvKey.KEY_ZOOM_IN || tvKey.ZOOM_IN, ZOOM_OUT: tvKey.KEY_ZOOM_OUT || tvKey.ZOOM_OUT, RETURN: tvKey.KEY_RETURN || tvKey.RETURN, //Same code as &quot;X&quot; key (88). PANEL_RETURN: tvKey.KEY_PANEL_RETURN || tvKey.PANEL_RETURN, ENTER: tvKey.KEY_ENTER || tvKey.ENTER, //29443 PANEL_ENTER: tvKey.KEY_PANEL_ENTER || tvKey.KEY_PANNEL_ENTER || tvKey.PANEL_ENTER || tvKey.PANNEL_ENTER, //309 PANEL_MENU: tvKey.KEY_PANEL_MENU || tvKey.KEY_PANNEL_MENU || tvKey.PANEL_MENU || tvKey.PANNEL_MENU, //613 ADDDEL: tvKey.KEY_ADDDEL || tvKey.ADDDEL, PIP_SWAP: tvKey.KEY_PIP_SWAP || tvKey.PIP_SWAP, PLUS100: tvKey.KEY_PLUS100 || tvKey.PLUS100, CAPTION: tvKey.KEY_CAPTION || tvKey.CAPTION, PICTURE_SIZE: tvKey.KEY_PICTURE_SIZE || tvKey.PICTURE_SIZE, PIP_SIZE: tvKey.KEY_PIP_SIZE || tvKey.PIP_SIZE, MAGIC_CHANNEL: tvKey.KEY_MAGIC_CHANNEL || tvKey.MAGIC_CHANNEL, PIP_SCAN: tvKey.KEY_PIP_SCAN || tvKey.PIP_SCAN, DEVICE_CONNECT: tvKey.KEY_DEVICE_CONNECT || tvKey.DEVICE_CONNECT, HELP: tvKey.KEY_HELP || tvKey.HELP, CONVERGENCE: tvKey.KEY_CONVERGENCE || tvKey.CONVERGENCE, AUTO_PROGRAM: tvKey.KEY_AUTO_PROGRAM || tvKey.AUTO_PROGRAM, FACTORY: tvKey.KEY_FACTORY || tvKey.FACTORY, _3SPEED: tvKey.KEY_3SPEED || tvKey._3SPEED || tvKey[&quot;3SPEED&quot;], RSURF: tvKey.KEY_RSURF || tvKey.RSURF, TOPMENU: tvKey.KEY_TOPMENU || tvKey.TOPMENU, GAME: tvKey.KEY_GAME || tvKey.GAME, QUICK_REPLAY: tvKey.KEY_QUICK_REPLAY || tvKey.QUICK_REPLAY, STILL_PICTURE: tvKey.KEY_STILL_PICTURE || tvKey.STILL_PICTURE, DTV: tvKey.KEY_DTV || tvKey.DTV, INSTANT_REPLAY: tvKey.KEY_INSTANT_REPLAY || tvKey.INSTANT_REPLAY, LINK: tvKey.KEY_LINK || tvKey.LINK, ANGLE: tvKey.KEY_ANGLE || tvKey.ANGLE, RESERVED1: tvKey.KEY_RESERVED1 || tvKey.RESERVED1, RESERVED5: tvKey.KEY_RESERVED5 || tvKey.RESERVED5, PROGRAM: tvKey.KEY_PROGRAM || tvKey.PROGRAM, BOOKMARK: tvKey.KEY_BOOKMARK || tvKey.BOOKMARK, PRINT: tvKey.KEY_PRINT || tvKey.PRINT, CLEAR: tvKey.KEY_CLEAR || tvKey.CLEAR, VCHIP: tvKey.KEY_VCHIP || tvKey.VCHIP, REPEAT: tvKey.KEY_REPEAT || tvKey.REPEAT, DOOR: tvKey.KEY_DOOR || tvKey.DOOR, OPEN: tvKey.KEY_OPEN || tvKey.OPEN, TURBO: tvKey.KEY_TURBO || tvKey.TURBO, DVR_MENU: tvKey.KEY_DVR_MENU || tvKey.DVR_MENU, TTX_SUBFACE: tvKey.KEY_TTX_SUBFACE || tvKey.TTX_SUBFACE, CH_LIST: tvKey.KEY_CH_LIST || tvKey.CH_LIST, DNIe: tvKey.KEY_DNIe || tvKey.KEY_DNIE || tvKey.DNIe || tvKey.DNIE, DNSe: tvKey.KEY_DNSe || tvKey.KEY_DNSE || tvKey.DNSe || tvKey.DNSE, SRS: tvKey.KEY_SRS || tvKey.SRS, CONVERT_AUDIO_MAINSUB: tvKey.KEY_CONVERT_AUDIO_MAINSUB || tvKey.CONVERT_AUDIO_MAINSUB, MDC: tvKey.KEY_MDC || tvKey.MDC, SEFFECT: tvKey.KEY_SEFFECT || tvKey.SEFFECT, DVR: tvKey.KEY_DVR || tvKey.DVR, DTV_SIGNAL: tvKey.KEY_DTV_SIGNAL || tvKey.DTV_SIGNAL, LIVE: tvKey.KEY_LIVE || tvKey.LIVE, PERPECT_FOCUS: tvKey.KEY_PERPECT_FOCUS || tvKey.PERPECT_FOCUS, HOME: tvKey.KEY_HOME || tvKey.HOME, ESAVING: tvKey.KEY_ESAVING || tvKey.ESAVING, CONTENTS: tvKey.KEY_CONTENTS || tvKey.CONTENTS, SCALE: tvKey.KEY_SCALE || tvKey.SCALE, CLOCK_DISPLAY: tvKey.KEY_CLOCK_DISPLAY || tvKey.CLOCK_DISPLAY, SETUP_CLOCK_TIMER: tvKey.KEY_SETUP_CLOCK_TIMER || tvKey.SETUP_CLOCK_TIMER, MAGIC_BRIGHT: tvKey.KEY_MAGIC_BRIGHT || tvKey.MAGIC_BRIGHT, FM_RADIO: tvKey.KEY_FM_RADIO || tvKey.FM_RADIO, VCR_MODE: tvKey.KEY_VCR_MODE || tvKey.VCR_MODE, CATV_MODE: tvKey.KEY_CATV_MODE || tvKey.CATV_MODE, DSS_MODE: tvKey.KEY_DSS_MODE || tvKey.DSS_MODE, DVD_MODE: tvKey.KEY_DVD_MODE || tvKey.DVD_MODE, STB_MODE: tvKey.KEY_STB_MODE || tvKey.STB_MODE, PCMODE: tvKey.KEY_PCMODE || tvKey.PCMODE, TV_MODE: tvKey.KEY_TV_MODE || tvKey.TV_MODE, TV: tvKey.KEY_TV || tvKey.TV, //77 AV1: tvKey.KEY_AV1 || tvKey.AV1, AV2: tvKey.KEY_AV2 || tvKey.AV2, AV3: tvKey.KEY_AV3 || tvKey.AV3, SVIDEO1: tvKey.KEY_SVIDEO1 || tvKey.SVIDEO1, SVIDEO2: tvKey.KEY_SVIDEO2 || tvKey.SVIDEO2, SVIDEO3: tvKey.KEY_SVIDEO3 || tvKey.SVIDEO3, COMPONENT1: tvKey.KEY_COMPONENT1 || tvKey.COMPONENT1, COMPONENT2: tvKey.KEY_COMPONENT2 || tvKey.COMPONENT2, DVI: tvKey.KEY_DVI || tvKey.DVI, HDMI: tvKey.KEY_HDMI || tvKey.HDMI, HDMI1: tvKey.KEY_HDMI1 || tvKey.HDMI1, HDMI2: tvKey.KEY_HDMI2 || tvKey.HDMI2, HDMI3: tvKey.KEY_HDMI3 || tvKey.HDMI3, HDMI4: tvKey.KEY_HDMI4 || tvKey.HDMI4, DTV_LINK: tvKey.KEY_DTV_LINK || tvKey.DTV_LINK, APP_LIST: tvKey.KEY_APP_LIST || tvKey.APP_LIST, BACK_MHP: tvKey.KEY_BACK_MHP || tvKey.BACK_MHP, ALT_MHP: tvKey.KEY_ALT_MHP || tvKey.ALT_MHP, RSS: tvKey.KEY_RSS || tvKey.RSS, ENTERTAINMENT: tvKey.KEY_ENTERTAINMENT || tvKey.ENTERTAINMENT, ID_INPUT: tvKey.KEY_ID_INPUT || tvKey.ID_INPUT, ID_SETUP: tvKey.KEY_ID_SETUP || tvKey.ID_SETUP, ANYNET: tvKey.KEY_ANYNET || tvKey.ANYNET, ANYVIEW: tvKey.KEY_ANYVIEW || tvKey.ANYVIEW, MS: tvKey.KEY_MS || tvKey.MS, MORE: tvKey.KEY_MORE || tvKey.MORE, _4_3: tvKey.KEY_4_3 || tvKey._4_3 || tvKey[&quot;4_3&quot;], _16_9: tvKey.KEY_16_9 || tvKey._16_9 || tvKey[&quot;16_9&quot;], PANORAMA: tvKey.KEY_PANORAMA || tvKey.PANORAMA, DYNAMIC: tvKey.KEY_DYNAMIC || tvKey.DYNAMIC, STANDARD: tvKey.KEY_STANDARD || tvKey.STANDARD, MOVIE1: tvKey.KEY_MOVIE1 || tvKey.MOVIE1, CUSTOM: tvKey.KEY_CUSTOM || tvKey.CUSTOM, AUTO_ARC_RESET: tvKey.KEY_AUTO_ARC_RESET || tvKey.AUTO_ARC_RESET, AUTO_ARC_LNA_ON: tvKey.KEY_AUTO_ARC_LNA_ON || tvKey.AUTO_ARC_LNA_ON, AUTO_ARC_LNA_OFF: tvKey.KEY_AUTO_ARC_LNA_OFF || tvKey.AUTO_ARC_LNA_OFF, AUTO_ARC_ANYNET_MODE_OK: tvKey.KEY_AUTO_ARC_ANYNET_MODE_OK || tvKey.AUTO_ARC_ANYNET_MODE_OK, AUTO_ARC_ANYNET_AUTO_START: tvKey.KEY_AUTO_ARC_ANYNET_AUTO_START || tvKey.AUTO_ARC_ANYNET_AUTO_START, AUTO_ARC_CAPTION_ON: tvKey.KEY_AUTO_ARC_CAPTION_ON || tvKey.AUTO_ARC_CAPTION_ON, AUTO_ARC_CAPTION_OFF: tvKey.KEY_AUTO_ARC_CAPTION_OFF || tvKey.AUTO_ARC_CAPTION_OFF, AUTO_ARC_PIP_DOUBLE: tvKey.KEY_AUTO_ARC_PIP_DOUBLE || tvKey.AUTO_ARC_PIP_DOUBLE, AUTO_ARC_PIP_LARGE: tvKey.KEY_AUTO_ARC_PIP_LARGE || tvKey.AUTO_ARC_PIP_LARGE, AUTO_ARC_PIP_SMALL: tvKey.KEY_AUTO_ARC_PIP_SMALL || tvKey.AUTO_ARC_PIP_SMALL, AUTO_ARC_PIP_WIDE: tvKey.KEY_AUTO_ARC_PIP_WIDE || tvKey.AUTO_ARC_PIP_WIDE, AUTO_ARC_PIP_LEFT_TOP: tvKey.KEY_AUTO_ARC_PIP_LEFT_TOP || tvKey.AUTO_ARC_PIP_LEFT_TOP, AUTO_ARC_PIP_RIGHT_TOP: tvKey.KEY_AUTO_ARC_PIP_RIGHT_TOP || tvKey.AUTO_ARC_PIP_RIGHT_TOP, AUTO_ARC_PIP_LEFT_BOTTOM: tvKey.KEY_AUTO_ARC_PIP_LEFT_BOTTOM || tvKey.AUTO_ARC_PIP_LEFT_BOTTOM, AUTO_ARC_PIP_RIGHT_BOTTOM: tvKey.KEY_AUTO_ARC_PIP_RIGHT_BOTTOM || tvKey.AUTO_ARC_PIP_RIGHT_BOTTOM, AUTO_ARC_PIP_CH_CHANGE: tvKey.KEY_AUTO_ARC_PIP_CH_CHANGE || tvKey.AUTO_ARC_PIP_CH_CHANGE, AUTO_ARC_PIP_SOURCE_CHANGE: tvKey.KEY_AUTO_ARC_PIP_SOURCE_CHANGE || tvKey.AUTO_ARC_PIP_SOURCE_CHANGE, AUTO_ARC_AUTOCOLOR_SUCCESS: tvKey.KEY_AUTO_ARC_AUTOCOLOR_SUCCESS || tvKey.AUTO_ARC_AUTOCOLOR_SUCCESS, AUTO_ARC_AUTOCOLOR_FAIL: tvKey.KEY_AUTO_ARC_AUTOCOLOR_FAIL || tvKey.AUTO_ARC_AUTOCOLOR_FAIL, AUTO_ARC_C_FORCE_AGING: tvKey.KEY_AUTO_ARC_C_FORCE_AGING || tvKey.AUTO_ARC_C_FORCE_AGING, AUTO_ARC_USBJACK_INSPECT: tvKey.KEY_AUTO_ARC_USBJACK_INSPECT || tvKey.AUTO_ARC_USBJACK_INSPECT, AUTO_ARC_JACK_IDENT: tvKey.KEY_AUTO_ARC_JACK_IDENT || tvKey.AUTO_ARC_JACK_IDENT, AUTO_ARC_CAPTION_KOR: tvKey.KEY_AUTO_ARC_CAPTION_KOR || tvKey.AUTO_ARC_CAPTION_KOR, AUTO_ARC_CAPTION_ENG: tvKey.KEY_AUTO_ARC_CAPTION_ENG || tvKey.AUTO_ARC_CAPTION_ENG, AUTO_ARC_ANTENNA_AIR: tvKey.KEY_AUTO_ARC_ANTENNA_AIR || tvKey.AUTO_ARC_ANTENNA_AIR, AUTO_ARC_ANTENNA_CABLE: tvKey.KEY_AUTO_ARC_ANTENNA_CABLE || tvKey.AUTO_ARC_ANTENNA_CABLE, AUTO_ARC_ANTENNA_SATELLITE: tvKey.KEY_AUTO_ARC_ANTENNA_SATELLITE || tvKey.AUTO_ARC_ANTENNA_SATELLITE, AUTO_FORMAT: tvKey.KEY_AUTO_FORMAT || tvKey.AUTO_FORMAT, DNET: tvKey.KEY_DNET || tvKey.DNET, NINE_SEPARATE: tvKey.KEY_NINE_SEPERATE || tvKey.NINE_SEPERATE || tvKey.KEY_NINE_SEPARATE || tvKey.NINE_SEPARATE, MIC: tvKey.KEY_MIC || tvKey.MIC, EXT1: tvKey.KEY_EXT1 || tvKey.EXT1, EXT2: tvKey.KEY_EXT2 || tvKey.EXT2, EXT3: tvKey.KEY_EXT3 || tvKey.EXT3, EXT4: tvKey.KEY_EXT4 || tvKey.EXT4, EXT5: tvKey.KEY_EXT5 || tvKey.EXT5, EXT6: tvKey.KEY_EXT6 || tvKey.EXT6, EXT7: tvKey.KEY_EXT7 || tvKey.EXT7, EXT8: tvKey.KEY_EXT8 || tvKey.EXT8, EXT9: tvKey.KEY_EXT9 || tvKey.EXT9, EXT10: tvKey.KEY_EXT10 || tvKey.EXT10, EXT11: tvKey.KEY_EXT11 || tvKey.EXT11, EXT12: tvKey.KEY_EXT12 || tvKey.EXT12, EXT13: tvKey.KEY_EXT13 || tvKey.EXT13, EXT14: tvKey.KEY_EXT14 || tvKey.EXT14, EXT15: tvKey.KEY_EXT15 || tvKey.EXT15, EXT16: tvKey.KEY_EXT16 || tvKey.EXT16, EXT17: tvKey.KEY_EXT17 || tvKey.EXT17, EXT18: tvKey.KEY_EXT18 || tvKey.EXT18, EXT19: tvKey.KEY_EXT19 || tvKey.EXT19, EXT20: tvKey.KEY_EXT20 || tvKey.EXT20, EXT21: tvKey.KEY_EXT21 || tvKey.EXT21, EXT22: tvKey.KEY_EXT22 || tvKey.EXT22, EXT23: tvKey.KEY_EXT23 || tvKey.EXT23, EXT24: tvKey.KEY_EXT24 || tvKey.EXT24, EXT25: tvKey.KEY_EXT25 || tvKey.EXT25, EXT26: tvKey.KEY_EXT26 || tvKey.EXT26, EXT27: tvKey.KEY_EXT27 || tvKey.EXT27, EXT28: tvKey.KEY_EXT28 || tvKey.EXT28, EXT29: tvKey.KEY_EXT29 || tvKey.EXT29, EXT30: tvKey.KEY_EXT30 || tvKey.EXT30, EXT31: tvKey.KEY_EXT31 || tvKey.EXT31, EXT32: tvKey.KEY_EXT32 || tvKey.EXT32, EXT33: tvKey.KEY_EXT33 || tvKey.EXT33, EXT34: tvKey.KEY_EXT34 || tvKey.EXT34, EXT35: tvKey.KEY_EXT35 || tvKey.EXT35, EXT36: tvKey.KEY_EXT36 || tvKey.EXT36, EXT37: tvKey.KEY_EXT37 || tvKey.EXT37, EXT38: tvKey.KEY_EXT38 || tvKey.EXT38, EXT39: tvKey.KEY_EXT39 || tvKey.EXT39, EXT40: tvKey.KEY_EXT40 || tvKey.EXT40, EXT41: tvKey.KEY_EXT41 || tvKey.EXT41 }; CB_Keyboard.extended.SAMSUNG_TV[0] = CB_Keyboard.extended.SAMSUNG_TV._0; CB_Keyboard.extended.SAMSUNG_TV[1] = CB_Keyboard.extended.SAMSUNG_TV._1; CB_Keyboard.extended.SAMSUNG_TV[2] = CB_Keyboard.extended.SAMSUNG_TV._2; CB_Keyboard.extended.SAMSUNG_TV[3] = CB_Keyboard.extended.SAMSUNG_TV._3; CB_Keyboard.extended.SAMSUNG_TV[4] = CB_Keyboard.extended.SAMSUNG_TV._4; CB_Keyboard.extended.SAMSUNG_TV[5] = CB_Keyboard.extended.SAMSUNG_TV._5; CB_Keyboard.extended.SAMSUNG_TV[6] = CB_Keyboard.extended.SAMSUNG_TV._6; CB_Keyboard.extended.SAMSUNG_TV[7] = CB_Keyboard.extended.SAMSUNG_TV._7; CB_Keyboard.extended.SAMSUNG_TV[8] = CB_Keyboard.extended.SAMSUNG_TV._8; CB_Keyboard.extended.SAMSUNG_TV[9] = CB_Keyboard.extended.SAMSUNG_TV._9; CB_Keyboard.extended.SAMSUNG_TV[10] = CB_Keyboard.extended.SAMSUNG_TV._10; CB_Keyboard.extended.SAMSUNG_TV[11] = CB_Keyboard.extended.SAMSUNG_TV._11; CB_Keyboard.extended.SAMSUNG_TV[12] = CB_Keyboard.extended.SAMSUNG_TV._12; CB_Keyboard.extended.SAMSUNG_TV[&quot;3D&quot;] = CB_Keyboard.extended.SAMSUNG_TV._3D; CB_Keyboard.extended.SAMSUNG_TV[&quot;3SPEED&quot;] = CB_Keyboard.extended.SAMSUNG_TV._3SPEED; CB_Keyboard.extended.SAMSUNG_TV[&quot;4_3&quot;] = CB_Keyboard.extended.SAMSUNG_TV._4_3; CB_Keyboard.extended.SAMSUNG_TV[&quot;16_9&quot;] = CB_Keyboard.extended.SAMSUNG_TV._16_9; CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases = CB_Configuration[CB_BASE_NAME].CB_Keyboard_extended_SAMSUNG_TV_allowDuplicateKeyAliases; /** * Amazon Fire TV remote control key codes. * @memberof CB_Keyboard.extended * @name AMAZON_FIRE_TV_REMOTE * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} SELECT - SELECT button. * @property {number} PLAY_PAUSE - PLAY/PAUSE button. * @property {number} RW - RW (REWIND) button. * @property {number} FF - FF (FAST FORWARD) button. */ CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, SELECT: 13, PLAY_PAUSE: 179, RW: 227, FF: 228 }; /** * Amazon Fire TV game controller key codes. * @memberof CB_Keyboard.extended * @name AMAZON_FIRE_TV_GAME_CONTROLLER * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} A - &quot;A&quot; button. * @property {number} B - &quot;B&quot; button. * @property {number} X - &quot;X&quot; button. * @property {number} Y - &quot;Y&quot; button. */ CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, A: 13, B: 8, //Same as BACKSPACE. X: 13, //Same code as A button. Y: 13 //Same code as A button. } /** * Nintendo Wii (Wiimote) key codes. * @memberof CB_Keyboard.extended * @name WII * @constant * @type {Object} * @default * @property {number} UP - D-PAD UP button. * @property {number} DOWN - D-PAD DOWN button. * @property {number} LEFT - D-PAD LEFT button. * @property {number} RIGHT - D-PAD RIGHT button. * @property {number} A - &quot;A&quot; button. * @property {number} B - &quot;B&quot; button. * @property {number} MINUS - MINUS (&quot;-&quot;) button. * @property {number} PLUS - PLUS (&quot;+&quot;) button. * @property {number} ONE - &quot;1&quot; button. * @property {number} _1 - Alias for {@link CB_Keyboard.extended.WII.ONE}. * @property {number} 1 - Alias for {@link CB_Keyboard.extended.WII.ONE}. * @property {number} TWO - &quot;2&quot; button. * @property {number} _2 - Alias for {@link CB_Keyboard.extended.WII.TWO}. * @property {number} 2 - Alias for {@link CB_Keyboard.extended.WII.TWO}. * @property {number} HOME - HOME button. */ //* Source: tomy @ https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes CB_Keyboard.extended.WII = { UP: 175, //D-PAD: UP (also scrolls up). Note: same code as &quot;VOL_UP&quot; key. DOWN: 176, //D-PAD DOWN (also scrolls down). Note: same code as &quot;MEDIA_FORWARD&quot; key. LEFT: 178, //D-PAD LEFT (also scrolls left). Note: same code as &quot;MEDIA_STOP&quot; key. RIGHT: 177, //D-PAD RIGHT (also scrolls right). Note: same code as &quot;MEDIA_BACK&quot; key. A: 13, //&quot;A&quot; button. Note: same code as ENTER key. B: 171, //&quot;B&quot; button. Note: same code as BROWSER_FAVORITES key and PLUS (&quot;+&quot;) in Firefox browser. MINUS: 170, //Minus (&quot;-&quot;) button (also zooms out). Note: same code as BROWSER_SEARCH key. PLUS: 174, //Plus (&quot;+&quot;) button (also zooms in). Note: same code as VOL_DOWN key. ONE: 172, //&quot;1&quot; button. Note: same code as BROWSER_HOME key. TWO: 173, //&quot;2&quot; button (also splits screen into single column mode). Note: same code as MUTE key and MINUS (&quot;-&quot;) in Firefox browser. HOME: 2 //Home button (also leaves the browser). }; CB_Keyboard.extended.WII[1] = CB_Keyboard.extended.WII._1 = CB_Keyboard.extended.WII.ONE; //&quot;1&quot; button. Note: same code as BROWSER_HOME key. CB_Keyboard.extended.WII[2] = CB_Keyboard.extended.WII._2 = CB_Keyboard.extended.WII.TWO; //&quot;2&quot; button (also splits screen into single column mode). Note: same code as MUTE key and MINUS (&quot;-&quot;) in Firefox browser. CB_Keyboard.extended.WII._allowDuplicateKeyAliases = CB_Configuration[CB_BASE_NAME].CB_Keyboard_extended_WII_allowDuplicateKeyAliases; /** * Sony PlayStation 3 key codes. * @memberof CB_Keyboard.extended * @name PS3 * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. * @property {number} CROSS - CROSS button. */ //* Source: tomy @ https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes CB_Keyboard.extended.PS3 = { UP: 38, DOWN: 40, LEFT: 37, RIGHT: 39, CROSS: 63 //Caution, also clicks! Note: same code as &quot;?&quot; symbol key. //CIRCLE: 27 //Not sure. }; /** * Sony PlayStation 4 key codes. * @memberof CB_Keyboard.extended * @name PS4 * @constant * @type {Object} * @default * @property {number} UP - D-PAD UP button. * @property {number} DOWN - D-PAD DOWN button. * @property {number} LEFT - D-PAD LEFT button. * @property {number} RIGHT - D-PAD RIGHT button. * @property {number} TRIANGLE - TRIANGLE button. * @property {number} SQUARE - SQUARE button. * @property {number} CIRCLE - CIRCLE button. * @property {number} L1 - L1 button. * @property {number} L2 - L2 button. * @property {number} R1 - R1 button. * @property {number} R2 - R2 button. * @property {number} LEFT_STICK_CLICK - LEFT STICK CLICK button. * @property {number} RIGHT_STICK_CLICK - RIGHT STICK CLICK button. * @property {number} OPTIONS - OPTIONS button. */ //* Source: http://coding.vdhdesign.co.nz/?p=351 (https://web.archive.org/web/20140222065645/http://coding.vdhdesign.co.nz/?p=351) CB_Keyboard.extended.PS4 = { UP: 38, //D-PAD: UP. DOWN: 40, //D-PAD: DOWN. LEFT: 37, //D-PAD: LEFT. RIGHT: 39, //D-PAD: RIGHT. TRIANGLE: 112, //Also initiates search bar. Note: same code as F1 key. SQUARE: 113, //Also initiates full screen mode. Note: same code as F2 key. CIRCLE: 27, //Browser history back. Note: same code as ESC key. //CROSS: undefined, //No keycode event was fired for this button, as this is used as a mouse left click. L1: 116, //History Back. It seems the web browser does not send any event for L1 button. Note: same codes as F5 key. L2: 118, //Goes to browser tab to the left. Note: same codes as F7 key. R1: 117, //History Forward. Note: same codes as F6 key. R2: 119, //Goes to browser tab to the right. Note: same codes as F8 key. LEFT_STICK_CLICK: 120, //Zooms browser out. Note: same codes as F9 key. RIGHT_STICK_CLICK: 121, //Zooms browser In. Note: same codes as F10 key. OPTIONS: 114 //Opens up options menu. Note: same codes as F3 key. //SHARE: undefined //Share Button (goes directly to a native application, no key code was fires). }; CB_Keyboard.extended.PS4._allowDuplicateKeyAliases = CB_Configuration[CB_BASE_NAME].CB_Keyboard_extended_PS4_allowDuplicateKeyAliases; /** * Sony PlayStation Vita key codes. * @memberof CB_Keyboard.extended * @name PSVITA * @constant * @type {Object} * @default * @property {number} UP - UP button. * @property {number} DOWN - DOWN button. * @property {number} LEFT - LEFT button. * @property {number} RIGHT - RIGHT button. */ //* Source: https://github.com/goldenratio/console-browsers-gamepad/tree/master/playstation CB_Keyboard.extended.PSVITA = { UP: 38, //UP. DOWN: 40, //DOWN. LEFT: 37, //LEFT. RIGHT: 39 //RIGHT. }; /** * LG Smart TV (Linux 35230) key codes. * @memberof CB_Keyboard.extended * @name LG_SMART_TV_LINUX_35230 * @constant * @type {Object} * @default * @property {number} _0 - 0 (zero) button. * @property {number} _1 - 1 button. * @property {number} _2 - 2 button. * @property {number} _3 - 3 button. * @property {number} _4 - 4 button. * @property {number} _5 - 5 button. * @property {number} _6 - 6 button. * @property {number} _7 - 7 button. * @property {number} _8 - 8 button. * @property {number} _9 - 9 button. * @property {number} 0 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._0}. * @property {number} 1 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._1}. * @property {number} 2 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._2}. * @property {number} 3 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._3}. * @property {number} 4 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._4}. * @property {number} 5 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._5}. * @property {number} 6 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._6}. * @property {number} 7 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._7}. * @property {number} 8 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._8}. * @property {number} 9 - Alias for {@link CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._9}. * @property {number} FORWARD - FORWARD button. * @property {number} REWIND - REWIND button. * @property {number} PLAY - PLAY button. * @property {number} PAUSE - PAUSE button. */ //* Source: tomy @ https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes CB_Keyboard.extended.LG_SMART_TV_LINUX_35230 = { //TODO: add more codes (if there is any more) and use them in CB_Keyboard.keys. _0: 48, _1: 49, _2: 50, _3: 51, _4: 52, _5: 53, _6: 54, _7: 55, _8: 56, _9: 57, FORWARD: 417, //Forward button. REWIND: 412, //Rewind button. PLAY: 445, //Play button. PAUSE: 19 //Pause button. }; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[0] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._0; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[1] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._1; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[2] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._2; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[3] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._3; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[4] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._4; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[5] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._5; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[6] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._6; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[7] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._7; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[8] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._8; CB_Keyboard.extended.LG_SMART_TV_LINUX_35230[9] = CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._9; /** * Object whose properties are aliases for key codes (each property can contain an array with one or more integers which belong to the key codes). * @namespace * @type {Object} */ CB_Keyboard.keys = { /** * The Escape (ESC) key. * @type {array} * @default */ &quot;ESC&quot; : [27], /** * The F1 key. * @type {array} * @default */ &quot;F1&quot; : [112], /** * The F2 key. * @type {array} * @default */ &quot;F2&quot; : [113], /** * The F3 key. * @type {array} * @default */ &quot;F3&quot; : [114], /** * The F4 key. * @type {array} * @default */ &quot;F4&quot; : [115], /** * The F5 key. * @type {array} * @default */ &quot;F5&quot; : [116], /** * The F6 key. * @type {array} * @default */ &quot;F6&quot; : [117], /** * The F7 key. * @type {array} * @default */ &quot;F7&quot; : [118], /** * The F8 key. * @type {array} * @default */ &quot;F8&quot; : [119], /** * The F9 key. * @type {array} * @default */ &quot;F9&quot; : [120], /** * The F10 key. * @type {array} * @default */ &quot;F10&quot; : [121], /** * The F11 key. * @type {array} * @default */ &quot;F11&quot; : [122], /** * The F12 key. * @type {array} * @default */ &quot;F12&quot; : [123], /** * The Control key. * @type {array} * @default */ &quot;CTRL&quot; : [17, 162, 163], /** * The Alt key. * @type {array} * @default */ &quot;ALT&quot; : [18], /** * The Shift (left or right) key. * @type {array} * @default */ &quot;SHIFT&quot; : [16, 160, 161], /** * The meta (Windows Start, Apple Command, etc.) key. * @type {array} * @default */ &quot;META&quot; : [/*17,*/ 91, 92, 219, 220, 224], /** * The up arrow key. * @type {array} * @default */ &quot;UP&quot; : [ 38, CB_Keyboard.extended.WII._allowDuplicateKeyAliases ? CB_Keyboard.extended.WII.UP : null, //Note: same code as &quot;VOL_UP&quot; key (175). CB_Keyboard.extended.VK.UP, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.UP, //29460 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.UP, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.UP, CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.UP, CB_Keyboard.extended.PS3.UP, CB_Keyboard.extended.PS4.UP, CB_Keyboard.extended.PSVITA.UP ], /** * The down arrow key. * @type {array} * @default */ &quot;DOWN&quot; : [ 40, CB_Keyboard.extended.WII._allowDuplicateKeyAliases ? CB_Keyboard.extended.WII.DOWN : null, //Note: same code as &quot;MEDIA_FORWARD&quot; key (176). CB_Keyboard.extended.VK.DOWN, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.DOWN, //29461 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.DOWN, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.DOWN, CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.DOWN, CB_Keyboard.extended.PS3.DOWN, CB_Keyboard.extended.PS4.DOWN, CB_Keyboard.extended.PSVITA.DOWN ], /** * The left arrow key. * @type {array} * @default */ &quot;LEFT&quot; : [ 37, CB_Keyboard.extended.WII._allowDuplicateKeyAliases ? CB_Keyboard.extended.WII.LEFT : null, //Note: same code as &quot;MEDIA_STOP&quot; key (178). CB_Keyboard.extended.VK.LEFT, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.LEFT, //4 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.LEFT, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.LEFT, CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.LEFT, CB_Keyboard.extended.PS3.LEFT, CB_Keyboard.extended.PS4.LEFT, CB_Keyboard.extended.PSVITA.LEFT ], /** * The right arrow key. * @type {array} * @default */ &quot;RIGHT&quot; : [ 39, CB_Keyboard.extended.WII._allowDuplicateKeyAliases ? CB_Keyboard.extended.WII.RIGHT : null, //Note: same code as &quot;MEDIA_BACK&quot; key (177). CB_Keyboard.extended.VK.RIGHT, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.RIGHT, //5 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RIGHT, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.RIGHT, CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.RIGHT, CB_Keyboard.extended.PS3.RIGHT, CB_Keyboard.extended.PS4.RIGHT, CB_Keyboard.extended.PSVITA.RIGHT ], /** * The Enter (Return) key. * @type {array} * @default */ &quot;ENTER&quot; : [ 13, //10, //Safari Mobile (probaby old). Source: http://mscerts.programming4.us/programming/coding%20javascript%20for%20mobile%20browsers%20%28part%2011%29.aspx CB_Keyboard.extended.VK.ENTER, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.ENTER, //29443 CB_Keyboard.extended.SAMSUNG_TV.PANEL_ENTER, //309 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.ENTER, CB_Keyboard.extended.PS3.CROSS, //Caution, also clicks! Note: same code as &quot;?&quot; symbol key. CB_Keyboard.extended.PS4._allowDuplicateKeyAliases ? CB_Keyboard.extended.PS4.SQUARE : null //Also initiates full screen mode. Note: same code as F2 key. ], /** * The Backspace key. * @type {array} * @default */ &quot;BACKSPACE&quot; : [ 8, 127, //Safari Mobile (probaby old). Source: http://mscerts.programming4.us/programming/coding%20javascript%20for%20mobile%20browsers%20%28part%2011%29.aspx CB_Keyboard.extended.VK.BACK_SPACE ], /** * The Spacebar key. * @type {array} * @default */ &quot;SPACEBAR&quot; : [ 32, CB_Keyboard.extended.VK.SPACE ], /** * The Tabulator (Tab) key. * @type {array} * @default */ &quot;TAB&quot; : [9], /** * The Caps Lock key. * @type {array} * @default */ &quot;CAPS_LOCK&quot; : [20], /** * The Num Lock (Numeric Lock) key. * @type {array} * @default */ &quot;NUM_LOCK&quot; : [144], /** * The Scroll Lock key. * @type {array} * @default */ &quot;SCROLL_LOCK&quot; : [145], /** * Alias for {@link CB_Keyboard.keys.0}. * @var CB_Keyboard.keys._0 * @see {@link CB_Keyboard.keys.0} */ /** * The 0 (zero) key. * @type {array} * @default */ &quot;0&quot; : [ 48, //For keydown for normal keyboard and for keypress. 96, //For keydown for numeric pad. CB_Keyboard.extended.VK._0, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV._0 : null, //17 (same code as CTRL or META key, depending on the system). CB_Keyboard.extended.SAMSUNG_TIZEN_TV._0, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._0 ], /** * Alias for {@link CB_Keyboard.keys.1}. * @var CB_Keyboard.keys._1 * @see {@link CB_Keyboard.keys.1} */ /** * The 1 key. * @type {array} * @default */ &quot;1&quot; : [ 49, //For keydown for normal keyboard and for keypress. 97, //For keydown for numeric pad. CB_Keyboard.extended.VK._1, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV._1 : null, //101 (same code as &quot;5&quot; in the numeric pad). CB_Keyboard.extended.SAMSUNG_TIZEN_TV._1, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._1 ], /** * Alias for {@link CB_Keyboard.keys.2}. * @var CB_Keyboard.keys._2 * @see {@link CB_Keyboard.keys.2} */ /** * The 2 key. * @type {array} * @default */ &quot;2&quot; : [ 50, //For keydown for normal keyboard and for keypress. 98, //For keydown for numeric pad. CB_Keyboard.extended.VK._2, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV._2 : null, //98 (same code as &quot;2&quot; in the numeric pad). CB_Keyboard.extended.SAMSUNG_TIZEN_TV._2, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._2 ], /** * Alias for {@link CB_Keyboard.keys.3}. * @var CB_Keyboard.keys._3 * @see {@link CB_Keyboard.keys.3} */ /** * The 3 key. * @type {array} * @default */ &quot;3&quot; : [ 51, //For keydown for normal keyboard and for keypress. 99, //For keydown for numeric pad. CB_Keyboard.extended.VK._3, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._3, //6 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._3 ], /** * Alias for {@link CB_Keyboard.keys.4}. * @var CB_Keyboard.keys._4 * @see {@link CB_Keyboard.keys.4} */ /** * The 4 key. * @type {array} * @default */ &quot;4&quot; : [ 52, //For keydown for normal keyboard and for keypress. 100, //For keydown for numeric pad. CB_Keyboard.extended.VK._4, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._4, //8 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._4, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._4 ], /** * Alias for {@link CB_Keyboard.keys.5}. * @var CB_Keyboard.keys._5 * @see {@link CB_Keyboard.keys.5} */ /** * The 5 key. * @type {array} * @default */ &quot;5&quot; : [ 53, //For keydown for normal keyboard and for keypress. 101, //For keydown for numeric pad. CB_Keyboard.extended.VK._5, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._5, //9 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._5, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._5 ], /** * Alias for {@link CB_Keyboard.keys.6}. * @var CB_Keyboard.keys._6 * @see {@link CB_Keyboard.keys.6} */ /** * The 6 key. * @type {array} * @default */ &quot;6&quot; : [ 54, //For keydown for normal keyboard and for keypress. 102, //For keydown for numeric pad. CB_Keyboard.extended.VK._6, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._6, //10 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._6, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._6 ], /** * Alias for {@link CB_Keyboard.keys.7}. * @var CB_Keyboard.keys._7 * @see {@link CB_Keyboard.keys.7} */ /** * The 7 key. * @type {array} * @default */ &quot;7&quot; : [ 55, //For keydown for normal keyboard and for keypress. 103, //For keydown for numeric pad. CB_Keyboard.extended.VK._7, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._7, //12 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._7, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._7 ], /** * Alias for {@link CB_Keyboard.keys.8}. * @var CB_Keyboard.keys._8 * @see {@link CB_Keyboard.keys.8} */ /** * The 8 key. * @type {array} * @default */ &quot;8&quot; : [ 56, //For keydown for normal keyboard and for keypress. 104, //For keydown for numeric pad. CB_Keyboard.extended.VK._8, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._8, //13 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._8, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._8 ], /** * Alias for {@link CB_Keyboard.keys.9}. * @var CB_Keyboard.keys._9 * @see {@link CB_Keyboard.keys.9} */ /** * The 9 key. * @type {array} * @default */ &quot;9&quot; : [ 57, //For keydown for normal keyboard and for keypress. 105, //For keydown for numeric pad. CB_Keyboard.extended.VK._9, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._9, //14 CB_Keyboard.extended.SAMSUNG_TIZEN_TV._9, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._9 ], /** * The &quot;+&quot; (plus) symbol key. NOTE: In some keyboards (for example in Chinese ones), you have to press EQUAL (code 61) with SHIFT to access to &quot;+&quot;. * @type {array} * @default */ &quot;PLUS&quot; : [ 107, //For keydown for numeric pad. 171, //For keydown for normal keyboard in Firefox. 187 //For keydown for normal keyboard in Chrome and IE8. ], /** * The &quot;-&quot; (minus) symbol key. * @type {array} * @default */ &quot;MINUS&quot; : [ 109, //For keydown for numeric pad. 173, //For keydown for normal keyboard in Firefox. Note: 173 is also used for &quot;MUTE&quot; 189, //For keydown for normal keyboard in Chrome and IE8. CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MINUS ], /** * The &quot;&amp;#42;&quot; (asterisk) symbol key. NOTE: In some keyboards (for example in Spanish for Spain ones), you have to press PLUS (code 187) with SHIFT to access to &quot;*&quot;. * @type {array} * @default */ &quot;ASTERISK&quot; : [ //Note: For * and #, Nokia and Samsung report a keyCode of 56/51, Sony Ericsson reports a keyCode of 83/72, onkeypress Nokia, Samsung and Sony Ericsson report both as 42/35. //* Source: http://www.quirksmode.org/m/table.html 106 //For keydown for numeric pad. ], /** * The &quot;/&quot; (slash) symbol key. NOTE: In some keyboards (for example in Spanish for Spain ones), you have to press 7 (code 55) with SHIFT to access to &quot;/&quot;. * @type {array} * @default */ &quot;SLASH&quot; : [ 111 //For keydown for numeric pad. ], /** * The &quot;.&quot; (dot) symbol key. * @type {array} * @default */ &quot;DOT&quot; : [ 190 //For keydown for normal keyboard. ], /** * The &quot;,&quot; (comma) symbol key. * @type {array} * @default */ &quot;COMMA&quot; : [ 188 //For keydown for normal keyboard. ], /** * The Home key. * @type {array} * @default */ &quot;HOME&quot; : [ 36, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.HOME : null ], /** * The End key. * @type {array} * @default */ &quot;END&quot; : [35], /** * The Page Up key. * @type {array} * @default */ &quot;PAGE_UP&quot; : [ 33, CB_Keyboard.extended.VK.PAGE_UP ], /** * The Page Down key. * @type {array} * @default */ &quot;PAGE_DOWN&quot; : [ 34, CB_Keyboard.extended.VK.PAGE_DOWN ], /** * The Ins (Insert) key. * @type {array} * @default */ &quot;INS&quot; : [45], /** * The Del (Delete) key. * @type {array} * @default */ &quot;DEL&quot; : [46], /** * The &quot;A&quot; key. * @type {array} * @default */ &quot;A&quot; : [65, CB_Keyboard.extended.VK.A], /** * The &quot;B&quot; key. * @type {array} * @default */ &quot;B&quot; : [66, CB_Keyboard.extended.VK.B], /** * The &quot;C&quot; key. * @type {array} * @default */ &quot;C&quot; : [67, CB_Keyboard.extended.VK.C], /** * The &quot;D&quot; key. * @type {array} * @default */ &quot;D&quot; : [68, CB_Keyboard.extended.VK.D], /** * The &quot;E&quot; key. * @type {array} * @default */ &quot;E&quot; : [69, CB_Keyboard.extended.VK.E], /** * The &quot;F&quot; key. * @type {array} * @default */ &quot;F&quot; : [70, CB_Keyboard.extended.VK.F], /** * The &quot;G&quot; key. * @type {array} * @default */ &quot;G&quot; : [71, CB_Keyboard.extended.VK.G], /** * The &quot;H&quot; key. * @type {array} * @default */ &quot;H&quot; : [72, CB_Keyboard.extended.VK.H], /** * The &quot;I&quot; key. * @type {array} * @default */ &quot;I&quot; : [73, CB_Keyboard.extended.VK.I], /** * The &quot;J&quot; key. * @type {array} * @default */ &quot;J&quot; : [74, CB_Keyboard.extended.VK.J], /** * The &quot;K&quot; key. * @type {array} * @default */ &quot;K&quot; : [75, CB_Keyboard.extended.VK.K], /** * The &quot;L&quot; key. * @type {array} * @default */ &quot;L&quot; : [76, CB_Keyboard.extended.VK.L], /** * The &quot;M&quot; key. * @type {array} * @default */ &quot;M&quot; : [77, CB_Keyboard.extended.VK.M], /** * The &quot;N&quot; key. * @type {array} * @default */ &quot;N&quot; : [78, CB_Keyboard.extended.VK.N], /** * The &quot;O&quot; key. * @type {array} * @default */ &quot;O&quot; : [79, CB_Keyboard.extended.VK.O], /** * The &quot;P&quot; key. * @type {array} * @default */ &quot;P&quot; : [80, CB_Keyboard.extended.VK.P], /** * The &quot;Q&quot; key. * @type {array} * @default */ &quot;Q&quot; : [81, CB_Keyboard.extended.VK.Q], /** * The &quot;R&quot; key. * @type {array} * @default */ &quot;R&quot; : [82, CB_Keyboard.extended.VK.R], /** * The &quot;S&quot; key. * @type {array} * @default */ &quot;S&quot; : [83, CB_Keyboard.extended.VK.S], /** * The &quot;T&quot; key. * @type {array} * @default */ &quot;T&quot; : [84, CB_Keyboard.extended.VK.T], /** * The &quot;U&quot; key. * @type {array} * @default */ &quot;U&quot; : [85, CB_Keyboard.extended.VK.U], /** * The &quot;V&quot; key. * @type {array} * @default */ &quot;V&quot; : [86, CB_Keyboard.extended.VK.V], /** * The &quot;W&quot; key. * @type {array} * @default */ &quot;W&quot; : [87, CB_Keyboard.extended.VK.W], /** * The &quot;X&quot; key. * @type {array} * @default */ &quot;X&quot; : [88, CB_Keyboard.extended.VK.X], /** * The &quot;Y&quot; key. * @type {array} * @default */ &quot;Y&quot; : [89, CB_Keyboard.extended.VK.Y], /** * The &quot;Z&quot; key. * @type {array} * @default */ &quot;Z&quot; : [90, CB_Keyboard.extended.VK.Z], /** * The Pause key. * @type {array} * @default */ &quot;PAUSE&quot; : [ 19, CB_Keyboard.extended.VK.PAUSE, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PAUSE : null, //74 (same code as &quot;J&quot; key). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PAUSE, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.PAUSE ], /** * The Clear key. * @type {array} * @default */ &quot;CLEAR&quot; : [ 12, 254, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.CLEAR : null ], /** * The Select key (for Windows' Virtual keyboard). * @type {array} * @default */ &quot;SELECT&quot; : [41], /** * The Print key. * @type {array} * @default */ &quot;PRINT&quot; : [ 42, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PRINT : null ], /** * The Print Screen key. * @type {array} * @default */ &quot;PRINT_SCREEN&quot; : [44], //Print screen key. Note: 44 is the same code as comma (&quot;,&quot;) keypress code. /** * The Execute key. * @type {array} * @default */ &quot;EXECUTE&quot; : [43], //Execute key. Note: 43 is the same code as plus (&quot;+&quot;) keypress code. /** * The Help key. * @type {array} * @default */ &quot;HELP&quot; : //Help key. Note: 47 is the same code as slash (&quot;/&quot;) keypress code: [ 47, CB_Keyboard.extended.VK.HELP, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.HELP : null ], /** * The Apps (Applications) key. * @type {array} * @default */ &quot;APPS&quot; : [93], /** * The Sleep key. * @type {array} * @default */ &quot;SLEEP&quot; : [ 95, CB_Keyboard.extended.SAMSUNG_TV.SLEEP //1097 ], /** * The Separator key. * @type {array} * @default */ &quot;SEPARATOR&quot; : [108], //Separator key. Note: 108 is the same code as L lowercase (&quot;l&quot;) keypress code. /** * The Decimal key (for numeric pads). NOTE: In some decimal systems, as in Spanish, it is a comma (&quot;,&quot;). Normally, numeric keypads in Spanish for Spain keyboards show a dot (&quot;.&quot;) but others as German keyboards shows a comma (&quot;,&quot;). * @type {array} * @default */ &quot;DECIMAL&quot; : [110], /** * The Menu key. * @type {array} * @default */ &quot;MENU&quot; : [ 164, 165, CB_Keyboard.extended.SAMSUNG_TV.MENU, //262 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PANEL_MENU : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MENU ], /** * The mouse's left button (for Windows' Virtual Keyboard). * @type {array} * @default */ &quot;MOUSE_LEFT_BUTTON&quot; : [1], /** * The mouse's middle button (for Windows' Virtual Keyboard). * @type {array} * @default */ &quot;MOUSE_MIDDLE_BUTTON&quot; : [4], /** * The mouse's right button (for Windows' Virtual Keyboard). * @type {array} * @default */ &quot;MOUSE_RIGHT_BUTTON&quot; : [2], //For Windows' Virtual keyboard. /** * The mouse's X1 button (for Windows' Virtual Keyboard). * @type {array} * @default */ &quot;MOUSE_X1_BUTTON&quot; : [5], //For Windows' Virtual keyboard. /** * The mouse's X2 button (for Windows' Virtual Keyboard). * @type {array} * @default */ &quot;MOUSE_X2_BUTTON&quot; : [6], //For Windows' Virtual keyboard. /** * The Mute key. * @type {array} * @default */ &quot;MUTE&quot; : //Mute key. Note: 173 is the same code as minus (&quot;-&quot; symbol) in normal keyboard in Firefox: [ 173, 181, CB_Keyboard.extended.VK.MUTE, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.MUTE : null, //Same code as ESC key (27). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MUTE ], /** * The Volume Up key. * @type {array} * @default */ &quot;VOL_UP&quot; : //Volume up key. Note: 175 is same code as &quot;UP&quot; for Wii (Wiimote) D-PAD: [ 175, 183, CB_Keyboard.extended.VK.VOLUME_UP, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.VOLUP : null, CB_Keyboard.extended.SAMSUNG_TV.VOL_UP, //7 CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOL_UP, //203 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOLUP : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.VOLUME_UP ], /** * The Volume Down key. * @type {array} * @default */ &quot;VOL_DOWN&quot; : [ 174, 182, CB_Keyboard.extended.VK.VOLUME_DOWN, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.VOLDOWN : null, CB_Keyboard.extended.SAMSUNG_TV.VOL_DOWN, //1 CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOL_DOWN, //204 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOLDOW : null, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOLDOWN : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.VOLUME_DOWN ], /** * The Multimedia Forward key. * @type {array} * @default */ &quot;MEDIA_FORWARD&quot; : //Multimedia forward key. Note: 176 is same code as &quot;DOWN&quot; for Wii (Wiimote) D-PAD: [ 176, 228, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.FORWARD, //LG Smart TV (Linux 35230). CB_Keyboard.extended.VK.FAST_FWD, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV.FF_, //1078 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.FF : null, //72 (same code as &quot;H&quot; key). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_FORWARD, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.FF ], /** * The Multimedia Rewind key. * @type {array} * @default */ &quot;MEDIA_REWIND&quot; : //Multimedia rewind key. Note: 177 is same code as &quot;RIGHT&quot; for Wii (Wiimote) D-PAD: [ 177, 227, CB_Keyboard.extended.VK.REWIND, //Smart TV Alliance. CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.REWIND, //LG Smart TV (Linux 35230). CB_Keyboard.extended.SAMSUNG_TV.REWIND_, //1080 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.RW : null, //69 (same code as &quot;E&quot; key). CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.REWIND : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_REWIND, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.RW ], /** * The Multimedia Stop key. * @type {array} * @default */ &quot;MEDIA_STOP&quot; : //Multimedia stop key. Note: 178 is same code as &quot;LEFT&quot; for Wii (Wiimote) D-PAD: [ 178, CB_Keyboard.extended.VK.STOP, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.STOP : null, //70 (same code as &quot;F&quot; key). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_STOP ], /** * The Multimedia Play/Pause key. * @type {array} * @default */ &quot;MEDIA_PLAY_PAUSE&quot; : [ 179, CB_Keyboard.extended.VK.PLAY_PAUSE, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PLAY_PAUSE, CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.PLAY_PAUSE ], /** * The Browser's Back key. * @type {array} * @default */ &quot;BROWSER_BACK&quot; : [ 166, CB_Keyboard.extended.VK.PREV, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.RETURN : null, //Same code as &quot;X&quot; key (88). CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PANEL_RETURN : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RETURN, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_TRACK_PREVIOUS, CB_Keyboard.extended.VK.BACK //Smart TV Alliance. ], /** * The Browser's Forward key. * @type {array} * @default */ &quot;BROWSER_FORWARD&quot; : [ 167, CB_Keyboard.extended.VK.NEXT, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_TRACK_NEXT ], /** * The Browser's Refresh (Reload) key. * @type {array} * @default */ &quot;BROWSER_REFRESH&quot; : [168], /** * The Browser's Stop key. * @type {array} * @default */ &quot;BROWSER_STOP&quot; : [169], /** * The Browser's Search key. * @type {array} * @default */ &quot;BROWSER_SEARCH&quot; : [ 170, CB_Keyboard.extended.VK._allowDuplicateKeyAliases ? CB_Keyboard.extended.VK.SEARCH : null, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.SEARCH : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.SEARCH ], /** * The Browser's Favorites key. * @type {array} * @default */ &quot;BROWSER_FAVORITES&quot; : [171], //Browser favourites key. Note: 171 is the same code as plus (&quot;+&quot;) in normal keyboard in Firefox. /** * The Browser's Home key. * @type {array} * @default */ &quot;BROWSER_HOME&quot; : [ 172 ], /** * The Mail key. * @type {array} * @default */ &quot;MAIL&quot; : [180], /** * The Select Media key. * @type {array} * @default */ &quot;MEDIA_SELECT&quot; : [181], //Select media key. Note: 181 is the same code as mute key. /** * The App1 key. * @type {array} * @default */ &quot;APP1&quot; : [182], //App1 key. Note: 182 is the same code as volume down key. /** * The App2 key. * @type {array} * @default */ &quot;APP2&quot; : [183], //App2 key. Note: 182 is the same code as volume up key. /** * The Attn key. * @type {array} * @default */ &quot;ATTN&quot; : [246], /** * The CrSel key. * @type {array} * @default */ &quot;CRSEL&quot; : [247], /** * The ExSel key. * @type {array} * @default */ &quot;EXSEL&quot; : [248], /** * The EREOF (Erase EOF) key. * @type {array} * @default */ &quot;EREOF&quot; : [249], /** * The Play key. * @type {array} * @default */ &quot;PLAY&quot; : [ 250, CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.PLAY, //LG Smart TV (Linux 35230). CB_Keyboard.extended.VK.PLAY, //Smart TV Alliance. CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.PLAY : null, //71 (same code as &quot;G&quot; key). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PLAY ], /** * The Zoom key. * @type {array} * @default */ &quot;ZOOM&quot; : [ 251, CB_Keyboard.extended.SAMSUNG_TV.ZOOM1, //1083 CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.ZOOM2 : null, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.ZOOM_IN : null//, //CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.ZOOM_OUT : null ], /** * The PA1 key. * @type {array} * @default */ &quot;PA1&quot; : [253], /** * The Info (Information) key. * @type {array} * @default */ &quot;INFO&quot; : [ CB_Keyboard.extended.VK.INFO, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.INFO : null, //31 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.INFO ], /** * The Audio Description key. * @type {array} * @default */ &quot;AUDIODESCRIPTION&quot; : [ CB_Keyboard.extended.VK._allowDuplicateKeyAliases ? CB_Keyboard.extended.VK.AUDIODESCRIPTION : null, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.CAPTION : null, CB_Keyboard.extended.SAMSUNG_TIZEN_TV.CAPTION ], /** * The Subtitle key. * @type {array} * @default */ &quot;SUBTITLE&quot; : [ CB_Keyboard.extended.VK.SUBTITLE, CB_Keyboard.extended.SAMSUNG_TV.SUBTITLE, //652 CB_Keyboard.extended.SAMSUNG_TV.SUB_TITLE //1089 ], /** * The HD (High Definition) key. * @type {array} * @default */ &quot;HD&quot; : [ CB_Keyboard.extended.VK._allowDuplicateKeyAliases ? CB_Keyboard.extended.VK.HD : null ], /** * The Red colour button. * @type {array} * @default */ &quot;RED&quot; : [ CB_Keyboard.extended.VK.RED, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.RED : null, //Same code as SEPARATOR key (108). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RED ], /** * The Green colour button. * @type {array} * @default */ &quot;GREEN&quot; : [ CB_Keyboard.extended.VK.GREEN, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.GREEN : null, //Same code as CAPS_LOCK key (20). CB_Keyboard.extended.SAMSUNG_TIZEN_TV.GREEN ], /** * The Yellow colour button. * @type {array} * @default */ &quot;YELLOW&quot; : [ CB_Keyboard.extended.VK.YELLOW, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.YELLOW : null, //21 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.YELLOW ], /** * The Blue colour button. * @type {array} * @default */ &quot;BLUE&quot; : [ CB_Keyboard.extended.VK.BLUE, CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.BLUE : null, //22 CB_Keyboard.extended.SAMSUNG_TIZEN_TV.BLUE ], /** * The Cyan colour button. * @type {array} * @default */ &quot;CYAN&quot; : [ CB_Keyboard.extended.SAMSUNG_TV._allowDuplicateKeyAliases ? CB_Keyboard.extended.SAMSUNG_TV.CYAN : null ] }; for (CB_Keyboard._x = 0; CB_Keyboard._x &lt; 10; CB_Keyboard._x++) { CB_Keyboard.keys[&quot;_&quot; + CB_Keyboard._x] = CB_Keyboard.keys[CB_Keyboard._x]; } //Sets CB_Keyboard.keys._NUMBER = CB_Keyboard.keys[NUMBER] from 0 to 9. CB_Keyboard._x = undefined; /** * Object whose properties are aliases for char codes (each property can contain an array with one or more integers which belong to the char codes). * @namespace * @type {Object} */ CB_Keyboard.chars = { /** * The &quot;0&quot; (zero) character. * @type {array} * @default */ &quot;0&quot; : [48], /** * The &quot;1&quot; character. * @type {array} * @default */ &quot;1&quot; : [49], /** * The &quot;2&quot; character. * @type {array} * @default */ &quot;2&quot; : [50], /** * The &quot;3&quot; character. * @type {array} * @default */ &quot;3&quot; : [51], /** * The &quot;4&quot; character. * @type {array} * @default */ &quot;4&quot; : [52], /** * The &quot;5&quot; character. * @type {array} * @default */ &quot;5&quot; : [53], /** * The &quot;6&quot; character. * @type {array} * @default */ &quot;6&quot; : [54], /** * The &quot;7&quot; character. * @type {array} * @default */ &quot;7&quot; : [55], /** * The &quot;8&quot; character. * @type {array} * @default */ &quot;8&quot; : [56], /** * The &quot;9&quot; character. * @type {array} * @default */ &quot;9&quot; : [57], /** * The &quot;+&quot; (plus) character. * @type {array} * @default */ &quot;PLUS&quot; : [43], /** * The &quot;-&quot; (minus) character. * @type {array} * @default */ &quot;MINUS&quot; : [45], /** * The &quot;*&quot; (asterisk) character. * @type {array} * @default */ &quot;ASTERISK&quot; : [42], /** * The &quot;/&quot; (slash) character. * @type {array} * @default */ &quot;SLASH&quot; : [47], /** * The &quot;.&quot; (dot) character. * @type {array} * @default */ &quot;DOT&quot; : [46], /** * The &quot;,&quot; (comma) character. * @type {array} * @default */ &quot;COMMA&quot; : [44], /** * The &quot;A&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;A&quot; : [65], /** * The &quot;a&quot; letter, lower case. * @type {array} * @default */ &quot;a&quot; : [97], /** * The &quot;B&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;B&quot; : [66], /** * The &quot;b&quot; letter, lower case. * @type {array} * @default */ &quot;b&quot; : [98], /** * The &quot;C&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;C&quot; : [67], /** * The &quot;c&quot; letter, lower case. * @type {array} * @default */ &quot;c&quot; : [99], /** * The &quot;D&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;D&quot; : [68], /** * The &quot;d&quot; letter, lower case. * @type {array} * @default */ &quot;d&quot; : [100], /** * The &quot;E&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;E&quot; : [69], /** * The &quot;e&quot; letter, lower case. * @type {array} * @default */ &quot;e&quot; : [101], /** * The &quot;F&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;F&quot; : [70], /** * The &quot;f&quot; letter, lower case. * @type {array} * @default */ &quot;f&quot; : [102], /** * The &quot;G&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;G&quot; : [71], /** * The &quot;g&quot; letter, lower case. * @type {array} * @default */ &quot;g&quot; : [103], /** * The &quot;H&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;H&quot; : [72], /** * The &quot;h&quot; letter, lower case. * @type {array} * @default */ &quot;h&quot; : [104], /** * The &quot;I&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;I&quot; : [73], /** * The &quot;i&quot; letter, lower case. * @type {array} * @default */ &quot;i&quot; : [105], /** * The &quot;J&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;J&quot; : [74], /** * The &quot;j&quot; letter, lower case. * @type {array} * @default */ &quot;j&quot; : [106], /** * The &quot;K&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;K&quot; : [75], /** * The &quot;k&quot; letter, lower case. * @type {array} * @default */ &quot;k&quot; : [107], /** * The &quot;L&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;L&quot; : [76], /** * The &quot;l&quot; letter, lower case. * @type {array} * @default */ &quot;l&quot; : [108], /** * The &quot;M&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;M&quot; : [77], /** * The &quot;m&quot; letter, lower case. * @type {array} * @default */ &quot;m&quot; : [109], /** * The &quot;N&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;N&quot; : [78], /** * The &quot;n&quot; letter, lower case. * @type {array} * @default */ &quot;n&quot; : [110], /** * The &quot;O&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;O&quot; : [79], /** * The &quot;o&quot; letter, lower case. * @type {array} * @default */ &quot;o&quot; : [111], /** * The &quot;P&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;P&quot; : [80], /** * The &quot;p&quot; letter, lower case. * @type {array} * @default */ &quot;p&quot; : [112], /** * The &quot;Q&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;Q&quot; : [81], /** * The &quot;q&quot; letter, lower case. * @type {array} * @default */ &quot;q&quot; : [113], /** * The &quot;R&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;R&quot; : [82], /** * The &quot;r&quot; letter, lower case. * @type {array} * @default */ &quot;r&quot; : [114], /** * The &quot;S&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;S&quot; : [83], /** * The &quot;s&quot; letter, lower case. * @type {array} * @default */ &quot;s&quot; : [115], /** * The &quot;T&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;T&quot; : [84], /** * The &quot;t&quot; letter, lower case. * @type {array} * @default */ &quot;t&quot; : [116], /** * The &quot;U&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;U&quot; : [85], /** * The &quot;u&quot; letter, lower case. * @type {array} * @default */ &quot;u&quot; : [117], /** * The &quot;V&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;V&quot; : [86], /** * The &quot;v&quot; letter, lower case. * @type {array} * @default */ &quot;v&quot; : [118], /** * The &quot;W&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;W&quot; : [87], /** * The &quot;w&quot; letter, lower case. * @type {array} * @default */ &quot;w&quot; : [119], /** * The &quot;X&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;X&quot; : [88], /** * The &quot;x&quot; letter, lower case. * @type {array} * @default */ &quot;x&quot; : [120], /** * The &quot;Y&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;Y&quot; : [89], /** * The &quot;y&quot; letter, lower case. * @type {array} * @default */ &quot;y&quot; : [121], /** * The &quot;Z&quot; letter, upper case (capitalized). * @type {array} * @default */ &quot;Z&quot; : [90], /** * The &quot;z&quot; letter, lower case. * @type {array} * @default */ &quot;z&quot; : [122] }; //Initializes all values: CB_Keyboard.init = function() { if (CB_Keyboard.initialized) { return CB_Keyboard; } //The object has been initialized: CB_Keyboard.initialized = true; //Removes possible key codes duplicated or not really defined (undefined or null): for (var k in CB_Keyboard.keys) { CB_Keyboard.keys[k] = CB_Arrays.removeDuplicated(CB_Keyboard.keys[k], function(v) { return (typeof(v) === &quot;undefined&quot; || v === null || isNaN(v)); }); } //Every time that focus is lost, it will clear the keysDown array: ////CB_Events.add(window, &quot;blur&quot;, function() { CB_Keyboard.keysDown = {}; }, true, true, false); try //using catch due some web clients doesn't allow to manipulate the window object of parent iframes: { //CB_Events.add(CB_Client.getWindow(), &quot;blur&quot;, function() { CB_Keyboard.keysDown = {}; }, true, true, false); CB_Events.add(CB_Client.getWindow(), &quot;blur&quot;, CB_Keyboard.clearKeysDown, true, true, false); } catch(E) { //CB_Events.add(window, &quot;blur&quot;, function() { CB_Keyboard.keysDown = {}; }, true, true, false); CB_Events.add(window, &quot;blur&quot;, CB_Keyboard.clearKeysDown, true, true, false); } //Every time that visibility is changed, it will clear the array: //CB_Screen.onVisibilityChange(function() { CB_Keyboard.keysDown = {}; }); //Sets the default keyboard events: CB_Keyboard._setDefaultEvents(); return CB_Keyboard; } //Sets the default Keyboard events to an object (document by default): CB_Keyboard._setDefaultEvents = function(target) { if (typeof(target) === &quot;undefined&quot; || target === null) { target = document; } var keyDownCallbackFunction = undefined; //If we want to prevent the Firefox bug that affects SockJS library (see https://github.com/sockjs/sockjs-client/issues/18): if (CB_Configuration[CB_BASE_NAME].CB_Net_Sockets_PREVENT_FIREFOX_ESC_BUG) { keyDownCallbackFunction = function(e, keyDown, updateKeysPressed, callbackFunction, keyCode) { if (keyCode === 27) { e.preventDefault(); } }; } //Sets the event that will check if a key is down: CB_Events.add(target, &quot;keydown&quot;, function(e) { /*e = CB_Events.normalize(e);*/ CB_Keyboard._updateKeysDown(e, true, true, keyDownCallbackFunction); }, true, true, false); //Prevents F11 key if the web client is compatible with Fullscreen API: //CB_Events.add(target, &quot;keydown&quot;, function(e) { e = CB_Events.normalize(e); CB_Keyboard.preventF11Key(e); }, true, true, false); //Sets the event that will check if a key is released: CB_Events.add(target, &quot;keyup&quot;, function(e) { /*e = CB_Events.normalize(e);*/ CB_Keyboard._updateKeysDown(e, false, true); }, true, true, false); //Sets the event that will store the typed string (or clear it): //CB_Events.add(target, &quot;keydown&quot;, function(e) { /*e = CB_Events.normalize(e);*/ CB_Keyboard._updateTypedString(e); }, true, true, false); CB_Events.add(target, &quot;keypress&quot;, function(e) { /*e = CB_Events.normalize(e);*/ CB_Keyboard._updateTypedString(e); }, true, true, false); } /** * Tries to return the given [keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the {@link CB_Events.normalize} function internally. Some properties added or affected could be [keyCode]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode}, [location]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/location}, [ctrlKey]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/ctrlKey}, [altKey]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/altKey}, [shiftKey]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/shiftKey}, etc. * @function * @param {Event} e - [Keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). * @returns {Event} Returns the [keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} object normalized. * @todo Calculate (if possible) the values for location, ctrlKey, altKey, etc. when added, to simulate the expected behaviour. */ CB_Keyboard.normalizeEvent = function(e) { e = CB_Events.normalize(e); //If the web client doesn't support it, sets the keyCode property: if (typeof(e.keyCode) === &quot;undefined&quot; || e.keyCode === null) { e.keyCode = CB_Keyboard.getKeyCode(e, true); } //Sometimes the property keyCode cannot be overwritten, so we defines this function: e.getKeyCode = e.getKeyCode || function() { return CB_Keyboard.getKeyCode(this); }; //If the web client doesn't support it, sets the location property: if (typeof(e.location) === &quot;undefined&quot; || e.location === null) { e.location = e.keyLocation ? e.keyLocation : 0; } //If the web client doesn't support it, determines whether the CTRL, ALT, SHIFT or META keys are pressed: if (typeof(e.ctrlKey) === &quot;undefined&quot; || e.ctrlKey === null) { e.ctrlKey = CB_Keyboard.isKeyDown(CB_Keyboard.keys.CTRL); } if (typeof(e.altKey) === &quot;undefined&quot; || e.altKey === null) { e.altKey = CB_Keyboard.isKeyDown(CB_Keyboard.keys.ALT); } if (typeof(e.shiftKey) === &quot;undefined&quot; || e.shiftKey === null) { e.shiftKey = CB_Keyboard.isKeyDown(CB_Keyboard.keys.SHIFT); } /*if (typeof(e.metaKey) === &quot;undefined&quot; || e.metaKey === null) { e.metaKey = CB_Keyboard.isKeyDown(CB_Keyboard.keys.META); }*/ return e; } /** * Returns the key code that is contained in the given [keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent}. * @function * @param {Event} e - [Keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} object. * @param {boolean} [avoidNormalize=false] - If it is not set to true, it will call the {@link CB_Events.normalize} function internally before. * @returns {integer} Returns the key code. * @todo Have in mind that [keyCode]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode} is deprecated. */ CB_Keyboard.getKeyCode = function(e, avoidNormalize) { if (!avoidNormalize) { e = CB_Events.normalize(e); } var keyCode = null; if (e.keyCode) { keyCode = e.keyCode; } else if (e.key &amp;&amp; typeof(e.key) === &quot;number&quot;) { keyCode = e.key; } //For SLCanvas. else if (window.Event &amp;&amp; e.which) { keyCode = e.which; } else if (typeof(e.charCode) === &quot;number&quot;) { keyCode = e.charCode; } return keyCode; } //Updates array keysDown (this is called whenever a key is down or released): CB_Keyboard._updateKeysDown = function(e, keyDown, updateKeysPressed, callbackFunction) { //By default, updates keys pressed array: if (typeof(updateKeysPressed) === &quot;undefined&quot; || updateKeysPressed === null) { updateKeysPressed = true; } //Defines the code of the key pressed: //e = CB_Events.normalize(e); e = CB_Keyboard.normalizeEvent(e); //var keyCode = CB_Keyboard.getKeyCode(e); //var keyCode = e.keyCode; var keyCode = e.getKeyCode(); //If the key code is defined: if (keyCode !== null) { //Sets the status of the key (being pressed/down or relased): CB_Keyboard.keysDown[keyCode] = keyDown; //If pressed, stores the key code pressed in the keys pressed array: if (updateKeysPressed &amp;&amp; keyDown) { CB_Keyboard._updateKeysPressed(keyCode); } if (typeof(callbackFunction) === &quot;function&quot;) { callbackFunction(e, keyDown, updateKeysPressed, callbackFunction, keyCode); } } } /** * Clears (empties totally or partially) the {@link CB_Keyboard.keysDown} object which contains the detected keys pressed or released. * @function * @param {boolean} keepPressed - If set to true, it will keep the pressed keys. */ CB_Keyboard.clearKeysDown = function(keepPressed) { if (!keepPressed) { CB_Keyboard.keysDown = {}; } else { var keysDown = {}; for (var keyCode in CB_Keyboard.keysDown) { if (CB_Keyboard.keysDown[keyCode]) { keysDown[keyCode] = true; } } CB_Keyboard.keysDown = keysDown; } } /** * Returns the {@link CB_Keyboard.keysDown} object which contains the detected keys pressed or released. * @function * @returns {Object} Returns the {@link CB_Keyboard.keysDown} object. */ CB_Keyboard.getKeysDown = function() { return CB_Keyboard.keysDown; } /** * Returns whether the given key codes are being pressed (any of them or all at the same time, depending on the &quot;allPressed&quot; parameter). * @function * @param {integer|array|Object} keyCodes - An integer with the key code or a numeric array with the key codes that we want to check. It can also be an array of arrays, being each element a numeric array with the key codes that we want to check. Although not recommended (for performance purposes), this parameter can also support an object whose indexes are the keycodes (it will be converted to a numeric array internally). * @param {boolean} [allPressed=false] - If set true, the function will only return true in the case that all given key codes are currently being pressed. Otherwise, if set to false, the function will return true in the case that any of the given key codes is currently being pressed. When the &quot;keyCodes&quot; is an array of arrays with key codes, it will be considered that all keys are being pressed if each single array (all of them) has at least one of its key codes pressed. * @returns {boolean} If &quot;allPressed&quot; parameter is set to true, returns true in the case that all given key codes are currently being pressed. If &quot;allPressed&quot; parameter is set to false, returns true in the case that any of the given key codes is currently being pressed. In all other cases, it returns false. */ CB_Keyboard.isKeyDown = function(keyCodes, allPressed) { var isDown = false; //If the parameter given is not an array, we force it to be an array: if (!isNaN(keyCodes)) { keyCodes = [parseInt(keyCodes)]; } //If a number has been received, it will be the first and unique element of the array. Note that parseInt could return a NaN. if (!CB_isArray(keyCodes)) //If we have received an object which is not an array: { var keyCodesArray = []; for (var keyCode in keyCodes) { if (!isNaN(keyCode)) { keyCodesArray[keyCodesArray.length] = parseInt(keyCode); } //Only stores } keyCodes = keyCodesArray; } var keysDown = CB_Keyboard.getKeysDown(); var keyCodesLength = keyCodes.length; for (var x = 0; x &lt; keyCodesLength; x++) { //If the code given is a number, it exists in the keysDown array and it is being pressed: if (typeof(keyCodes[x]) !== &quot;undefined&quot; &amp;&amp; keyCodes[x] !== null &amp;&amp; !isNaN(keyCodes[x]) &amp;&amp; typeof(keysDown[keyCodes[x]]) !== &quot;undefined&quot; &amp;&amp; keysDown[keyCodes[x]]) { isDown = true; //if (!allPressed) { break; } } //...otherwise, if the value belongs to an array, calls itself recursively: else if (CB_isArray(keyCodes[x])) { isDown = CB_Keyboard.isKeyDown(keyCodes[x], false); //If any key is pressed is enough. } //...otherwise, if the user wanted to know whether all given keys were pressed: else if (allPressed) { //Not all given keys are pressed so it exits: isDown = false; //break; } if (allPressed &amp;&amp; !isDown) { break; } else if (!allPressed &amp;&amp; isDown) { break; } //If the user does not want to know whether all are keys given are pressed, with one is enough so it exits. } return isDown; } //Updates the keys pressed array: CB_Keyboard._updateKeysPressed = function(keyCode) { //Clears the timeout that clears the keys pressed: clearTimeout(CB_Keyboard._keysPressedExpirationTimeout); //Updates the keys pressed and its codes: CB_Keyboard.keysPressed[CB_Keyboard.keysPressed.length] = keyCode; //Sets the timeout that clears the array after some milliseconds: CB_Keyboard._keysPressedExpirationTimeout = setTimeout ( function() { CB_Keyboard.keysPressed = []; }, CB_Keyboard._keysPressedExpiration ); } /** * Clears (empties totally or partially) the {@link CB_Keyboard.keysPressed} array which contains the key codes pressed recently. * @function * @param {boolean} keepPressed - If set to true, it will keep the pressed keys (taken from the {@link CB_Keyboard.keysDown} object). */ CB_Keyboard.clearKeysPressed = function(keepPressed) { //Clears the timeout that clears the keys pressed: clearTimeout(CB_Keyboard._keysPressedExpirationTimeout); if (!keepPressed) { CB_Keyboard.keysPressed = []; } else { var keysPressed = []; for (var keyCode in CB_Keyboard.keysDown) { if (CB_Keyboard.keysDown[keyCode]) { keysPressed[keysPressed.length] = keyCode; } } CB_Keyboard.keysPressed = keysPressed; } } /** * Returns the {@link CB_Keyboard.keysPressed} array which contains the key codes pressed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setKeysPressedExpiration} function). * @function * @returns {array} Returns the {@link CB_Keyboard.keysPressed} array. */ CB_Keyboard.getKeysPressed = function() { return CB_Keyboard.keysPressed; } /** * Sets the milliseconds after which the {@link CB_Keyboard.keysPressed} array is always cleared (emptied). The time always starts counting from zero when a key is pressed ([onKeyDown]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keydown} event is fired). * @function * @param {integer} keysPressedExpiration - An integer greater than 0 (zero) representing the milliseconds after which we desire that the {@link CB_Keyboard.keysPressed} array is cleared (emptied), if no key is pressed during this time. * @returns {boolean} Returns true if the given time could be applied or false otherwise. */ CB_Keyboard.setKeysPressedExpiration = function(keysPressedExpiration) { //Only allows numbers greater than zero: if (typeof(keysPressedExpiration) !== &quot;undefined&quot; &amp;&amp; keysPressedExpiration !== null &amp;&amp; !isNaN(keysPressedExpiration) &amp;&amp; keysPressedExpiration &gt; 0) { CB_Keyboard._keysPressedExpiration = parseInt(keysPressedExpiration); return true; } return false; } /** * Returns the milliseconds after which the {@link CB_Keyboard.keysPressed} array is always cleared (emptied). The time always starts counting from zero again when a key is pressed ([onKeyDown]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keydown} event is fired). To define this amount of time, the {@link CB_Keyboard.setKeysPressedExpiration} method must be used. * @function * @returns {integer} Returns the milliseconds of expiration defined for the {@link CB_Keyboard.keysPressed} array. */ CB_Keyboard.getKeysPressedExpiration = function() { return CB_Keyboard._keysPressedExpiration; } //Updates the string typed (CAUTION: using String.fromCharCode(keyCode) internally as keyCode was a char code and it is not!): CB_Keyboard._updateTypedString = function(e) { //Clears the timeout that clears the typed string: clearTimeout(CB_Keyboard._typedStringExpirationTimeout); //Defines the code of the key pressed: //e = CB_Events.normalize(e); e = CB_Keyboard.normalizeEvent(e); //var keyCode = CB_Keyboard.getKeyCode(e); var keyCode = e.getKeyCode(); //var keyCode = e.keyCode; if (keyCode !== null) { //Gets the character typed: var characterTyped = String.fromCharCode(keyCode); //CAUTION: using keyCode as it was a char code and it is not! //var charCode = keyCode - 48 * Math.floor(keyCode / 48); //var characterTyped = String.fromCharCode((keyCode &gt; 96) ? keyCode : charCode); //Updates the string typed and its codes: CB_Keyboard.typedStringCodes[CB_Keyboard.typedStringCodes.length] = keyCode; CB_Keyboard.typedString += characterTyped; //Easter egg: if (CB_Keyboard.typedString.substring(CB_Keyboard.typedString.length - 11) === &quot;CrossBrowdy&quot;) { setTimeout ( function() { alert(&quot;Congratulations, you have found a CrossBrowdy Eastern egg!!! ;)&quot;); CB_Keyboard.typedStringCodes = []; //Clears the typed string codes. CB_Keyboard.typedString = &quot;&quot;; //Clears the typed string. }, 100 ); //Executes the function after some milliseconds allowing others get the typed string updated. } //Sets the timeout that clears the string after some milliseconds: CB_Keyboard._typedStringExpirationTimeout = setTimeout ( function() { CB_Keyboard.typedStringCodes = []; CB_Keyboard.typedString = &quot;&quot;; }, CB_Keyboard._typedStringExpiration ); } } /** * Clears (empties totally or partially) the {@link CB_Keyboard.typedString} string and the {@link CB_Keyboard.typedStringCodes} array. * @function * @param {boolean} keepPressed - If set to true, it will keep the values belonging to the currently-pressed keys (taken from the {@link CB_Keyboard.keysDown} object). */ CB_Keyboard.clearTypedString = function(keepPressed) //CAUTION: using String.fromCharCode(keyCode) internally as keyCode was a char code and it is not! { //Clears the timeout that clears the typed string: clearTimeout(CB_Keyboard._typedStringExpirationTimeout); if (!keepPressed) { CB_Keyboard.typedStringCodes = []; CB_Keyboard.typedString = &quot;&quot;; } else { var typedStringCodes = []; var typedString = &quot;&quot;; var characterTyped = null; var keyCode = null; var typedStringCodesLength = CB_Keyboard.typedStringCodes.length; for (var x = 0; x &lt; typedStringCodesLength; x++) { keyCode = CB_Keyboard.typedStringCodes[x]; if (CB_Keyboard.keysDown[keyCode]) { typedStringCodes[typedStringCodes.length] = keyCode; characterTyped = String.fromCharCode(keyCode); //CAUTION: using keyCode as it was a char code and it is not! typedString += characterTyped; } } /* for (var keyCode in CB_Keyboard.keysDown) { if (CB_Keyboard.keysDown[keyCode]) { typedStringCodes[typedStringCodes.length] = keyCode; characterTyped = String.fromCharCode(keyCode); //CAUTION: using keyCode as it was a char code and it is not! typedString += characterTyped; } } */ CB_Keyboard.typedStringCodes = typedStringCodes; CB_Keyboard.typedString = typedString; } } /** * Returns the {@link CB_Keyboard.typedString} string which contains the string typed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setTypedStringExpiration} function). * @function * @returns {string} Returns the {@link CB_Keyboard.typedString} string. */ CB_Keyboard.getTypedString = function() { return CB_Keyboard.typedString; } /** * Returns the {@link CB_Keyboard.typedStringCodes} array which contains the key codes pressed that belongs to the string typed recently (it will be cleared after the chosen milliseconds set with the {@link CB_Keyboard.setTypedStringExpiration} function). * @function * @returns {array} Returns the {@link CB_Keyboard.typedStringCodes} array. */ CB_Keyboard.getTypedStringCodes = function() { return CB_Keyboard.typedStringCodes; } /** * Sets the milliseconds after which the {@link CB_Keyboard.typedString} string and the {@link CB_Keyboard.typedStringCodes} array are always cleared (emptied). The time always starts counting from zero when a key is pressed ([onKeyPress]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keypress} event is fired). * @function * @param {integer} keysPressedExpiration - An integer greater than 0 (zero) representing the milliseconds after which we desire that the {@link CB_Keyboard.typedString} string and the {@link CB_Keyboard.typedStringCodes} array are cleared (emptied), if no key is pressed during this time. * @returns {boolean} Returns true if the given time could be applied or false otherwise. */ CB_Keyboard.setTypedStringExpiration = function(typedStringExpiration) { //Only allows numbers greater than zero: if (typeof(typedStringExpiration) !== &quot;undefined&quot; &amp;&amp; typedStringExpiration !== null &amp;&amp; !isNaN(typedStringExpiration) &amp;&amp; typedStringExpiration &gt; 0) { CB_Keyboard._typedStringExpiration = parseInt(typedStringExpiration); return true; } return false; } /** * Returns the milliseconds after which the {@link CB_Keyboard.typedString} string and the {@link CB_Keyboard.typedStringCodes} array are always cleared (emptied). The time always starts counting from zero again when a key is pressed ([onKeyPress]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keypress} event is fired). To define this amount of time, the {@link CB_Keyboard.setTypedStringExpiration} method must be used. * @function * @returns {integer} Returns the milliseconds of expiration defined for the {@link CB_Keyboard.typedString} string and the {@link CB_Keyboard.typedStringCodes} array. */ CB_Keyboard.getTypedStringExpiration = function() { return CB_Keyboard._typedStringExpiration; } /** * Tries to prevent the default behaviour that would produce the &quot;F11&quot; key of a given [keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} when the client is compatible with the HTML5 Fullscreen API and uses it to toggle (enable or disable) the fullscreen mode. It calls the {@link CB_Keyboard.normalizeEvent} function internally. * @function * @param {Event} e - [Keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} object. */ CB_Keyboard.preventF11Key = function(e) { //e = CB_Events.normalize(e); e = CB_Keyboard.normalizeEvent(e); //var keyCode = CB_Keyboard.getKeyCode(e); //var keyCode = e.keyCode; var keyCode = e.getKeyCode(); //If the F11 key has been pressed: if (CB_Keyboard.keys.F11.indexOf(keyCode) !== -1) { //If it's compatible with the FullScreen API, Prevents the use of F11 key and uses FullScreen API instead: if (CB_Screen.isFullScreenAPICompatible() &amp;&amp; typeof(e.preventDefault) !== &quot;undefined&quot; &amp;&amp; e.preventDefault !== null) { //If it's in fullscreen mode, we cancel it: if (CB_Screen.isFullScreen()) { //setTimeout(function(){CB_Screen.setFullScreen(false);},100); CB_Screen.setFullScreen(false); } //...otherwise, we request fullscreen mode: else { //setTimeout(function(){CB_Screen.setFullScreen();},100); CB_Screen.setFullScreen(); } e.preventDefault(); } } } /** * Callback that is called before loading a file and should return true if we want to load the file or false otherwise. * @memberof CB_Keyboard * @callback CB_Keyboard.EVENT_CALLBACK * @param {Event} e - [Keyboard event]{@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent} object. * @param {integer} keyCode - Key code which fired the event. */ /** * Sets a function to execute when a key is pressed ([onKeyPress]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keypress} event) or removes it. * @function * @param {CB_Keyboard.EVENT_CALLBACK|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the {@link CB_Keyboard.normalizeEvent} function) and the second one will be the key code associated. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Keyboard.onKeyPress = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Keyboard._setEvent(&quot;keypress&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a key is down ([onKeyDown]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keydown} event) or removes it. * @function * @param {CB_Keyboard.EVENT_CALLBACK|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the {@link CB_Keyboard.normalizeEvent} function) and the second one will be the key code associated. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Keyboard.onKeyDown = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Keyboard._setEvent(&quot;keydown&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when a key is released ([onKeyUp]{@link https://developer.mozilla.org/en-US/docs/Web/Events/keyup} event) or removes it. * @function * @param {CB_Keyboard.EVENT_CALLBACK|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the {@link CB_Keyboard.normalizeEvent} function) and the second one will be the key code associated. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Keyboard.onKeyUp = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Keyboard._setEvent(&quot;keyup&quot;, callbackFunction, keepOldFunction, useCapture, target); } //Sets a function to execute when a keyboard event happens: CB_Keyboard._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { target = document; } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { //If able, adds the function given to the event: //eventFunctionHolder = functionToAdd; CB_Events.add ( target, eventName, function(e) { //e = CB_Events.normalize(e); e = CB_Keyboard.normalizeEvent(e); if (eventName === &quot;keydown&quot; || eventName === &quot;keyup&quot;) { CB_Keyboard._updateKeysDown(e, (eventName === &quot;keydown&quot;), false); //Updates keys down. } //var keyCode = CB_Keyboard.getKeyCode(e); if (typeof(eventFunction) === &quot;function&quot;) { //return eventFunction(e, e.keyCode); return eventFunction(e, e.getKeyCode()); } return true; }, useCapture, keepOldFunction, true ); } //...but if the function given is null, it will cancel the event: else if (eventFunction === null)// &amp;&amp; eventFunctionHolder !== null) { //CB_Events.remove(target, eventName, eventFunctionHolder, useCapture); CB_Events.removeByName(target, eventName); //eventFunctionHolder = null; } } } //End of the static class CB_Keyboard. × Search results Close "},"CrossBase_net_CB_Net.js.html":{"id":"CrossBase_net_CB_Net.js.html","title":"Source: CrossBase/net/CB_Net.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/net/CB_Net.js /** * @file Management for things related with the net. Contains the {@link CB_Net} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage things related to the net. It will return itself if it is tried to be instantiated. * @namespace CB_Net */ if (typeof(CB_Net) === &quot;undefined&quot;) { var CB_Net = function() { return CB_Net; }; } { CB_Net.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Net.init = function() { if (CB_Net.initialized) { return CB_Net; } //The object has been initialized: CB_Net.initialized = true; //TODO. return CB_Net; } /** * Alias for {@link CB_Net.URIValueEncode}. * @function CB_Net.URLValueEncode * @see {@link CB_Net.URIValueEncode} */ /** * Encodes a given URI value. Uses the native [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function internally if available or fallbacks to the native [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function otherwise. * @function * @param {string|number} value - The value that we want to encode. Normally, it should be either a string or a number. * @returns {string} * @todo Think about using another thing since [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} maybe is not a good fallback. Probably a polyfill to simulate the [encodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent} function. */ CB_Net.URIValueEncode = CB_Net.URLValueEncode = function(value) { if (typeof(encodeURIComponent) !== &quot;undefined&quot;) { return encodeURIComponent(value); } else { return escape(value); } //TODO: think about using another thing since escape maybe is not a good fallback. Probably a polyfill to simulate the encodeURIComponent function. } /** * Alias for {@link CB_Net.URIValueDecode}. * @function CB_Net.URLValueDecode * @see {@link CB_Net.URIValueDecode} */ /** * Decodes a given URI value. Uses the native [decodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent} function internally if available or fallbacks to the native [unescape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/unescape} function otherwise. * @function * @param {string|number} value - The value that we want to decode. Normally, it should be either a string or a number. * @returns {string} * @todo Think about using another thing since [unescape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/unescape} maybe is not a good fallback. Probably a polyfill to simulate the [decodeURIComponent]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent} function. */ CB_Net.URIValueDecode = CB_Net.URLValueDecode = function(value) { if (typeof(decodeURIComponent) !== &quot;undefined&quot;) { return decodeURIComponent(value); } else { return unescape(value); } //TODO: think about using another thing since unescape maybe is not a good fallback. Probably a polyfill to simulate the decodeURIComponent function. } /** * Alias for {@link CB_Net.URIEncode}. * @function CB_Net.URLEncode * @see {@link CB_Net.URIEncode} */ /** * Encodes a given URI. Uses the native [encodeURI]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI} function internally if available or fallbacks to the native [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} function otherwise. * @function * @param {string|number} URI - The URI that we want to encode. Normally, it should be either a string or a number. * @returns {string} * @todo Think about using another thing since [escape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape} maybe is not a good fallback. Probably a polyfill to simulate the [encodeURI]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI} function. */ CB_Net.URIEncode = CB_Net.URLEncode = function(URI) { if (typeof(encodeURI) !== &quot;undefined&quot;) { return encodeURI(URI); } else { return escape(URI); } //TODO: think about using another thing since escape maybe is not a good fallback. Probably a polyfill to simulate the encodeURI function. } /** * Alias for {@link CB_Net.URIDecode}. * @function CB_Net.URLDecode * @see {@link CB_Net.URIDecode} */ /** * Encodes a given URI. Uses the native [decodeURI]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI} function internally if available or fallbacks to the native [unescape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/unescape} function otherwise. * @function * @param {string|number} URI - The URI that we want to decode. Normally, it should be either a string or a number. * @returns {string} * @todo Think about using another thing since [unescape]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/unescape} maybe is not a good fallback. Probably a polyfill to simulate the [decodeURI]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI} function. */ CB_Net.URIDecode = CB_Net.URLDecode = function(URI) { if (typeof(decodeURI) !== &quot;undefined&quot;) { return decodeURI(URI); } else { return unescape(URI); } //TODO: think about using another thing since unescape maybe is not a good fallback. Probably a polyfill to simulate the decodeURI function. } /** * Gets all the &quot;GET&quot; (query) parameters (names and their values) from a given URI or from the current URL. &lt;br /&gt; For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;amp;parameter2=value2#hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot;, it will return &quot;parameter1=value1&amp;amp;parameter2=value2&quot; (using the default options). * @function * @param {string} [URI=[window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href] - The URI that we want to work with. If not provided, it will try to use the current URL (by using [window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href). * @param {array} [exclude] - A numeric array containing the name of the parameters that we want to exclude in the returned string. It will exclude them even if they are contained in the given &quot;includeOnly&quot; parameter (if any). * @param {array} [includeOnly] - A numeric array containing the name of the parameters that we want to include in the returned string. If provided, it will only include these ones to the returned string (unless they are included in the &quot;exclude&quot; parameter). * @param {boolean} [includeIfNotExists=false] - If it is set to true and an array is given as the &quot;includeOnly&quot; parameter, it will add the parameters in the &quot;includeOnly&quot; array (with empty values) in the returned string even when they did not exist in the original URI provided. * @param {boolean} [trim=true] - Defines whether we want to trim the spaces around the values or not. * @param {string} [firstDelimiter='?'] - The string that indicates where the parameters start. If it is not provided, it will be &quot;?&quot; as default. If not provided and &quot;lastDelimiter&quot; is not provided either, it will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. * @param {string} [lastDelimiter=undefined|'#'] - The string that indicates where the parameters end. If not provided and &quot;firstDelimiter&quot; is provided, it will stop at the end of the given URI. If it is not provided and &quot;firstDelimiter&quot; is not provided either, &quot;firstDelimiter&quot; will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. * @param {string} [concatenator='&amp;'] - The string that joints the different parameters. * @param {string} [nameValueSeparator='='] - The string that is the separator for the parameters and their values. * @returns {string} An empty string will be returned if no parameters can be found. */ CB_Net.getURIParameters = function(URI, exclude, includeOnly, includeIfNotExists, trim, firstDelimiter, lastDelimiter, concatenator, nameValueSeparator) { concatenator = CB_trim(concatenator); if (concatenator === &quot;&quot;) { concatenator = &quot;&amp;&quot;; } nameValueSeparator = CB_trim(nameValueSeparator); if (nameValueSeparator === &quot;&quot;) { nameValueSeparator = &quot;=&quot;; } firstDelimiter = CB_trim(firstDelimiter); lastDelimiter = CB_trim(lastDelimiter); if (firstDelimiter === &quot;&quot;) { firstDelimiter = &quot;?&quot;; if (lastDelimiter === &quot;&quot;) { lastDelimiter = &quot;#&quot;; } } URI = CB_trim(URI); if (URI === &quot;&quot;) { URI = window.location.href; } if (URI.indexOf(firstDelimiter) !== -1) { URI = URI.substring(URI.indexOf(firstDelimiter) + firstDelimiter.length); } else { return &quot;&quot;; } if (lastDelimiter !== &quot;&quot; &amp;&amp; URI.indexOf(lastDelimiter) !== -1) { URI = URI.substring(0, URI.indexOf(lastDelimiter)); } URI = CB_trim(URI); var filteredURI = URI; if (typeof(trim) === &quot;undefined&quot; || trim === null) { trim = true; } //If set, only includes the desired ones: if (CB_isArray(includeOnly) &amp;&amp; includeOnly.length &gt; 0) { filteredURI = &quot;&quot;; URI = firstDelimiter + URI; for (var x = 0, includeOnlyLength = includeOnly.length; x &lt; includeOnlyLength; x++) { if (includeIfNotExists || URI.toUpperCase().indexOf(includeOnly[x].toUpperCase() + nameValueSeparator) !== -1) { filteredURI += includeOnly[x] + nameValueSeparator + CB_Net.getParameter(includeOnly[x], trim, URI, firstDelimiter, lastDelimiter, concatenator, nameValueSeparator) + concatenator; } } filteredURI = CB_rtrim(filteredURI, [concatenator]); } //If set, excludes the desired ones and/or trims values if desired: var excludePending = false; if (CB_isArray(exclude) &amp;&amp; exclude.length &gt; 0) { excludePending = true; } if (trim || excludePending) { var parametersArray = filteredURI.split(concatenator); var parameterArray; filteredURI = &quot;&quot;; for (x = 0, parametersArrayLength = parametersArray.length; x &lt; parametersArrayLength; x++) { parameterArray = parametersArray[x].split(nameValueSeparator); if (trim || excludePending &amp;&amp; CB_indexOf(exclude, parameterArray[0]) === -1) { if (typeof(parameterArray[1]) !== &quot;undefined&quot; &amp;&amp; parameterArray[1] !== null) { filteredURI += parameterArray[0] + nameValueSeparator + (trim ? CB_trim(parameterArray[1]) : parameterArray[1]) + concatenator; } else { filteredURI += parameterArray[0] + concatenator; } } } filteredURI = CB_rtrim(filteredURI, [concatenator]); } filteredURI = CB_trim(filteredURI, [concatenator]); return filteredURI; } /** * Gets all the hash parameters (names and their values) from a given URI or from the current URL. &lt;br /&gt; For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;amp;parameter2=value2#hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot;, it will return &quot;hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot; (using the default options). * @function * @param {string} [URI=[window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href] - The URI that we want to work with. If not provided, it will try to use the current URL (by using [window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href). * @param {array} [exclude] - A numeric array containing the name of the parameters that we want to exclude in the returned string. It will exclude them even if they are contained in the given &quot;includeOnly&quot; parameter (if any). * @param {array} [includeOnly] - A numeric array containing the name of the parameters that we want to include in the returned string. If provided, it will only include these ones to the returned string (unless they are included in the &quot;exclude&quot; parameter). * @param {boolean} [includeIfNotExists=false] - If it is set to true and an array is given as the &quot;includeOnly&quot; parameter, it will add the parameters in the &quot;includeOnly&quot; array (with empty values) in the returned string even when they did not exist in the original URI provided. * @param {boolean} [trim=true] - It will use this option when it calls the {@link CB_Net.getURIParameters} function internally. * @returns {string} An empty string will be returned if no parameters can be found. */ CB_Net.getHashParameters = function(URI, exclude, includeOnly, includeIfNotExists, trim) { return CB_Net.getURIParameters(URI, exclude, includeOnly, includeIfNotExists, trim, &quot;#&quot;); } /** * Gets the value of a specific URI parameter (query or hash), respecting GET/URL rules by default, from the current URL or a desired one (with the given delimiters). &lt;br /&gt; For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;amp;parameter2=value2#hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot; and the index given is &quot;parameter1&quot;, it will return &quot;value1&quot; (using the default options). * @function * @param {string} index - The name of the parameter whose value we want to get. * @param {boolean} [trim=true] - It will trim the value (using {@link CB_trim} internally) before returning it. * @param {string} [URI=[window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href] - The URI that we want to work with. If not provided, it will try to use the current URL (by using [window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href). * @param {string} [firstDelimiter='?'] - The string that indicates where the parameters start. If it is not provided, it will be &quot;?&quot; as default. If not provided and &quot;lastDelimiter&quot; is not provided either, it will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. * @param {string} [lastDelimiter=undefined|'#'] - The string that indicates where the parameters end. If not provided and &quot;firstDelimiter&quot; is provided, it will stop at the end of the given URI. If it is not provided and &quot;firstDelimiter&quot; is not provided either, &quot;firstDelimiter&quot; will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. * @param {string} [concatenator='&amp;'] - The string that joints the different parameters. * @param {string} [nameValueSeparator='='] - The string that is the separator for the parameters and their values. * @returns {string} An empty string will be returned if the value of the given parameter cannot be found. */ CB_Net.getParameter = function(index, trim, URI, firstDelimiter, lastDelimiter, concatenator, nameValueSeparator) { if (typeof(trim) === &quot;undefined&quot; || trim === null) { trim = true; } index = CB_trim(index).toUpperCase(); if (index === &quot;&quot;) { return &quot;&quot;; } concatenator = CB_trim(concatenator); if (concatenator === &quot;&quot;) { concatenator = &quot;&amp;&quot;; } nameValueSeparator = CB_trim(nameValueSeparator); if (nameValueSeparator === &quot;&quot;) { nameValueSeparator = &quot;=&quot;; } firstDelimiter = CB_trim(firstDelimiter); lastDelimiter = CB_trim(lastDelimiter); if (firstDelimiter === &quot;&quot;) { firstDelimiter = &quot;?&quot;; if (lastDelimiter === &quot;&quot;) { lastDelimiter = &quot;#&quot;; } } URI = CB_trim(URI); if (URI === &quot;&quot;) { URI = window.location.href; } if (URI.indexOf(firstDelimiter) !== -1) { URI = URI.substring(URI.indexOf(firstDelimiter) + firstDelimiter.length); } else { return &quot;&quot;; } if (lastDelimiter !== &quot;&quot; &amp;&amp; URI.indexOf(lastDelimiter) !== -1) { URI = URI.substring(0, URI.indexOf(lastDelimiter)); } URI = CB_trim(URI); if (URI === &quot;&quot;) { return &quot;&quot;; } var value = &quot;&quot;; var URIUpperCase = URI.toUpperCase(); var indexOfFound = URIUpperCase.indexOf(index + nameValueSeparator); if (indexOfFound !== -1) { URI = URI.substring(indexOfFound + index.length + nameValueSeparator.length); if (URI.indexOf(concatenator) !== -1) { URI = URI.substring(0, URI.indexOf(concatenator)); } value = URI; } if (trim) { value = CB_trim(value); } return CB_Net.URIValueDecode(value); } /** * Gets the value of a specific URI &quot;GET&quot; parameter (query) from the current URL or a desired URI. &lt;br /&gt; For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;amp;parameter2=value2#hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot; and the index given is &quot;parameter1&quot;, it will return &quot;value1&quot; (using the default options). * @function * @param {string} index - The name of the parameter whose value we want to get. * @param {boolean} [trim=true] - It will trim the value (using {@link CB_Net.getParameter} internally) before returning it. * @param {string} [URI=[window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href] - The URI that we want to work with. If not provided, it will try to use the current URL (by using [window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href). * @returns {string} An empty string will be returned if the value of the given parameter cannot be found. */ CB_Net.getURIValue = function(index, trim, URI) { return CB_Net.getParameter(index, trim, URI, &quot;?&quot;, &quot;#&quot;); } /** * Gets the value of a specific hash (string after &quot;#&quot;) parameter from the current URL or a desired URI. &lt;br /&gt; For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;amp;parameter2=value2#hash_parameter1=hash_value1&amp;amp;hash_parameter2=hash_value2&quot; and the index given is &quot;hash_parameter1&quot;, it will return &quot;hash_value1&quot; (using the default options). * @function * @param {string} index - The name of the parameter whose value we want to get. * @param {boolean} [trim=true] - It will trim the value (using {@link CB_Net.getParameter} internally) before returning it. * @param {string} [URI=[window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href] - The URI that we want to work with. If not provided, it will try to use the current URL (by using [window.location]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/location}.href). * @returns {string} An empty string will be returned if the value of the given parameter cannot be found. */ CB_Net.getHashValue = function(index, trim, URI) { return CB_Net.getParameter(index, trim, URI, &quot;#&quot;); } /** * Alias for {@link CB_Net.combineURIParameters}. * @function CB_Net.combineURLParameters * @see {@link CB_Net.combineURIParameters} */ /** * Alias for {@link CB_combineURIParameters}. * @function CB_Net.combineURIParameters * @see {@link CB_combineURIParameters} */ CB_Net.combineURIParameters = CB_Net.combineURLParameters = function(parametersA, parametersB) { return CB_combineURIParameters(parametersA, parametersB); }; } × Search results Close "},"CrossBase_net_fetch_CB_Net_Fetch.js.html":{"id":"CrossBase_net_fetch_CB_Net_Fetch.js.html","title":"Source: CrossBase/net/fetch/CB_Net_Fetch.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/net/fetch/CB_Net_Fetch.js /** * @file [Fetch API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} management. Contains the {@link CB_Net.Fetch} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ if (typeof(CB_Net) === &quot;undefined&quot;) { var CB_Net = function() { return CB_Net; }; } /** * Static class to manage things related to the [Fetch API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API}. It will return itself if it is tried to be instantiated. * @namespace */ CB_Net.Fetch = function() { return CB_Net.Fetch; }; { CB_Net.Fetch.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Net.Fetch.init = function() { if (CB_Net.Fetch.initialized) { return CB_Net.Fetch; } //The object has been initialized: CB_Net.Fetch.initialized = true; //TODO. return CB_Net.Fetch; } /** * Function that points to the [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch} method. If the [Fetch API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} is not supported natively, the [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch} function will be a polyfill. * @function * @param {string|Request} resource - First parameter of the [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch} method. * @param {Object} [init] - Second parameter of the [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch} method. * @returns {Promise} */ CB_Net.Fetch.get = function() { return fetch.apply(CB_this || window, arguments); }; //Points to the &quot;fetch&quot; function. } × Search results Close "},"CrossBase_net_REST_CB_Net_REST.js.html":{"id":"CrossBase_net_REST_CB_Net_REST.js.html","title":"Source: CrossBase/net/REST/CB_Net_REST.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/net/REST/CB_Net_REST.js /** * @file [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} client, services and related management. Contains the {@link CB_Net.REST} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ if (typeof(CB_Net) === &quot;undefined&quot;) { var CB_Net = function() { return CB_Net; }; } /** * Static class to manage [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} services and related. It will return itself if it is tried to be instantiated. * @namespace * @todo Think about accepting an onAbort function as option (with also default and permanent). */ CB_Net.REST = function() { return CB_Net.REST; }; { CB_Net.REST.initialized = false; //It will tells whether the object has been initialized or not. /** * Defines the URL for the default [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} server to use when the &quot;serverURL&quot; parameter is not available. Used by the {@link CB_Net.XHR.callREST} function as the default &quot;serverURL&quot; parameter. * @var * @type {string} * @default */ CB_Net.REST.SERVER_URL_DEFAULT = &quot;http://localhost/CrossBrowdy/tests/net/fake_rest_server/index.php&quot;; //CHANGE THIS! /** * Default value when the &quot;avoidProxy&quot; parameter is not available. Used by the {@link CB_Net.REST.actionProcess} function. &lt;br /&gt; NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the {@link CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL} property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. * @var * @type {boolean} * @default */ CB_Net.REST.avoidProxy_DEFAULT = false; /** * Default &quot;method&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {string} * @default */ CB_Net.REST.method_DEFAULT = &quot;GET&quot;; /** * Default &quot;responseType&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions when it is not provided and it is not null. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {string} * @default */ CB_Net.REST.responseType_DEFAULT = &quot;text&quot;; /** * Callback returning an object that will be used for parsing the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} route. The object returned should follow the same rules as the &quot;JSONObject&quot; parameter of the {@link CB_renderString} function. * @callback CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). * @returns {Object|null} It should return an object containing the wildcards that will be used to parse the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} route of the action being performed. Return null in the case that we do not want to modify anything. The object returned (if any) will be used as the &quot;JSONObject&quot; parameter of the {@link CB_renderString} function (the first parameter will be the route which should be a string) when it is called by {@link CB_Net.REST.actionProcess} internally. */ /** * Permanent function (must return a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object or null if we do not want to modify it) to execute the same way as the &quot;routeWildcardData&quot; parameter (if other &quot;routeWildcardData&quot; are provided or set, they will be executed before this one). The function assigned by default returns null. Used by the {@link CB_Net.REST.actionProcess} function. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA} * @default */ CB_Net.REST.routeWildcardData_PERMANENT = function(actionName, additionalData) { return null; }; /** * Default &quot;routeWildcardData&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions (must be a function returning a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object or null if we do not want to modify the route). The function assigned by default returns null. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA} * @default */ CB_Net.REST.routeWildcardData_DEFAULT = function(actionName, additionalData) { return null; }; /** * Tells whether to force [JSON]{@link https://en.wikipedia.org/wiki/JSON} response by default or not. Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;forceJSON&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.forceJSON_DEFAULT = true; /** * Tells whether get response [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} by default or not. Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;getHeaders&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.getHeaders_DEFAULT = false; /** * Tells whether to get response [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} in one-dimension array by default or not (needs &quot;getHeaders&quot; set to true). Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;getHeadersOneDimension&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.getHeadersOneDimension_DEFAULT = false; /** * Tells whether to get response [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} values in one-dimension (just one value per key) by default or not (needs &quot;getHeaders&quot; set to true). Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;getHeadersOneDimensionValues&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.getHeadersOneDimensionValues_DEFAULT = false; /** * Callback returning an object containing the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} which will be used as the &quot;headers&quot; parameter when the {@link CB_Net.XHR.callREST} function is called internally by {@link CB_Net.REST.actionProcess}. * @callback CB_Net.REST.actionProcess_HEADERS * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). * @returns {CB_Net.XHR.HEADERS|null} It should return an object containing the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers}. Return null in the case that we do not want to add anything. The object returned (if any) will be used as the &quot;headers&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called by {@link CB_Net.REST.actionProcess} internally. */ /** * Permanent function (must be a function returning a {@link CB_Net.XHR.HEADERS} object with the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers}) to execute the same way as the &quot;headers&quot; parameter. The function assigned by default returns { &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }. Used by the {@link CB_Net.REST.actionProcess} function. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_HEADERS} * @default */ CB_Net.REST.headers_PERMANENT = function(actionName, additionalData) { return { &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } }; /** * Default &quot;headers&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions (must be a function returning a {@link CB_Net.XHR.HEADERS} object with the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers}). The function assigned by default returns { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot; }. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {CB_Net.REST.actionProcess_HEADERS} * @default */ CB_Net.REST.headers_DEFAULT = function(actionName, additionalData) { return { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot; }; }; /** * Tells whether get status transparently from the server by default or not. Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;transparentStatus&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.transparentStatus_DEFAULT = true; /** * Tells whether get [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} transparently from the server by default or not. Used by the {@link CB_Net.REST.actionProcess} function when the REST action does not provided it and it is not null, as the &quot;transparentHeaders&quot; option. * @var * @type {boolean} * @default */ CB_Net.REST.transparentHeaders_DEFAULT = true; /** * Callback returning a string containing the URL (GET) data which will be used as the &quot;dataURL&quot; parameter when the {@link CB_Net.XHR.callREST} function is called internally by {@link CB_Net.REST.actionProcess}. * @callback CB_Net.REST.actionProcess_DATA_URL * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). * @returns {string} It should return a string containing the URL (GET) data. Return an empty string in the case that we do not want to add anything. The string returned (if any) will be used as the &quot;dataURL&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called by {@link CB_Net.REST.actionProcess} internally. */ /** * Permanent function (must return a string in URL/GET parameters format) to execute the same way as the &quot;dataURL&quot; parameter. The function assigned by default returns an empty string (&quot;&quot;). Used by the {@link CB_Net.REST.actionProcess} function. The returning data will be placed in the beginning of the URL, followed by the rest of the &quot;dataURL&quot; desired (if any). NOTE: remember to use {@link CB_Net.URLValueEncode} if needed. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_DATA_URL} * @default */ CB_Net.REST.dataURL_PERMANENT = //NOTE: remember to use CB_Net.URLValueEncode if needed. function(actionName, additionalData) { return &quot;&quot;; }; /** * Default &quot;dataURL&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions (must return a string in URL/GET parameters format). The function assigned by default returns an empty string (&quot;&quot;). Used by the {@link CB_Net.REST.actionProcess} function. NOTE: remember to use {@link CB_Net.URLValueEncode} if needed. * @var * @type {CB_Net.REST.actionProcess_DATA_URL} * @default */ CB_Net.REST.dataURL_DEFAULT = //NOTE: remember to use CB_Net.URLValueEncode if needed. function(actionName, additionalData) { return &quot;&quot;; }; /** * Callback returning the data (string or object) which will be used as the &quot;data&quot; parameter when the {@link CB_Net.XHR.callREST} function is called internally by {@link CB_Net.REST.actionProcess}. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since {@link CB_Net.REST.actionProcess} will use the {@link CB_combineAutomatically} function to combine them. * @callback CB_Net.REST.actionProcess_DATA * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). * @returns {string|Object} It should return a string or object containing the data. Return null or an empty string (recommended) in the case that we do not want to add anything. The value returned (if any) will be used as the &quot;data&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called by {@link CB_Net.REST.actionProcess} internally. */ /** * Permanent function (must return a string in URL/GET parameters format or a [JSON]{@link https://en.wikipedia.org/wiki/JSON} format string) to execute the same way as the &quot;data&quot; parameter. The function assigned by default returns an empty string (&quot;&quot;). Used by the {@link CB_Net.REST.actionProcess} function. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since {@link CB_Net.REST.actionProcess} will use the {@link CB_combineAutomatically} function to combine them. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. NOTE: remember to use {@link CB_Net.URLValueEncode} if needed. * @var * @type {CB_Net.REST.actionProcess_DATA} * @default */ CB_Net.REST.data_PERMANENT = //NOTE: remember to use CB_Net.URLValueEncode if needed. function(actionName, additionalData) { return &quot;&quot;; }; /** * Default &quot;data&quot; for [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions (must return a string in URL/GET parameters format or a [JSON]{@link https://en.wikipedia.org/wiki/JSON} format string). The function assigned by default returns an empty string (&quot;&quot;). Used by the {@link CB_Net.REST.actionProcess} function. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since {@link CB_Net.REST.actionProcess} will use the {@link CB_combineAutomatically} function to combine them. NOTE: remember to use {@link CB_Net.URLValueEncode} if needed. * @var * @type {CB_Net.REST.actionProcess_DATA} * @default */ CB_Net.REST.data_DEFAULT = //NOTE: remember to use CB_Net.URLValueEncode if needed. function(actionName, additionalData) { return &quot;&quot;; }; /** * Permanent values for the &quot;allowedSuccessStatuses&quot; parameter, containing the statuses to considerer a successful [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (must be a numeric array of integers). Used by the {@link CB_Net.REST.actionProcess} function. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {array} * @default */ CB_Net.REST.allowedSuccessStatuses_PERMANENT = []; /** * Default &quot;allowedSuccessStatuses&quot;, containing the statuses to considerer a successful [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (must be a numeric array of integers). Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {array} * @default */ CB_Net.REST.allowedSuccessStatuses_DEFAULT = [200, 201, 206]; /** * Callback that will be run before performing a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action and must return a boolean defining whether we want to continue performing the action (returning true) or not (returning false). * @callback CB_Net.REST.actionProcess_CALLBACK_BEFORE * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). * @returns {boolean} It should return true in the case that we want to continue performing the current [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action or false otherwise. */ /** * Permanent callback function before performing each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action returning a boolean (to decide whether to do it or not). Executed before the default or the set &quot;callbackBefore&quot; function (if any). The function assigned by default returns true. Used by the {@link CB_Net.REST.actionProcess} function. This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_BEFORE} * @default */ CB_Net.REST.callbackBefore_PERMANENT = function(actionName, additionalData) { return true; //Must return true if we want to perform the action. }; /** * Default &quot;callbackBefore&quot;, containing a callback function before performing each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action returning a boolean (to decide whether to do it or not). The function assigned by default returns true. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_BEFORE} * @default */ CB_Net.REST.callbackBefore_DEFAULT = function(actionName, additionalData) { return true; //Must return true if we want to perform the action. }; /** * Callback that will be run when the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has been performed successfully. * @callback CB_Net.REST.actionProcess_CALLBACK_OK * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {Object} [XHR] - The [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object that has been used to perform the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @param {CB_Net.REST.actionProcess_CALLBACK_ERROR} callbackError - The error callback function associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed, just in case we want to call it. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). */ /** * Permanent callback function when each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has been successful. Used by the {@link CB_Net.REST.actionProcess} function. Executed before the default or the set &quot;callbackOk&quot; function (if any). This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_OK} * @default */ CB_Net.REST.callbackOk_PERMANENT = function(actionName, XHR, callbackError, additionalData) { //Do things here. }; /** * Default &quot;callbackOk&quot;, containing a callback function when the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has been successful. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_OK} * @default */ CB_Net.REST.callbackOk_DEFAULT = function(actionName, XHR, callbackError, additionalData) { //Do things here. }; /** * Callback that will be run when the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has been performed successfully. * @callback CB_Net.REST.actionProcess_CALLBACK_ERROR * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {Object} [XHR] - The [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object that has been used to perform the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @param {*} additionalData - Any additional data associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (belongs to the &quot;additionalData&quot; parameter used when the {@link CB_Net.REST.actionProcess} function was called). */ /** * Permanent callback function when an error happens processing any [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. Used by the {@link CB_Net.REST.actionProcess} function. Executed before the default or the set &quot;callbackError&quot; function (if any). This is permanent for each [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_ERROR} * @default */ CB_Net.REST.callbackError_PERMANENT = function(actionName, XHR, additionalData) { //Do things here. }; /** * Default &quot;callbackError&quot;, containing a callback function when an error happens processing the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {CB_Net.REST.actionProcess_CALLBACK_ERROR} * @default */ CB_Net.REST.callbackError_DEFAULT = function(actionName, XHR, additionalData) { //Do things here. }; /** * Object that represents a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action. * @memberof CB_Net.REST * @typedef {Object} CB_Net.REST.actionProcess_ACTIONS * @property {string} route - The [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} route (path). Belongs to the &quot;route&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. It is mandatory. * @property {CB_Net.REST.actionProcess_CALLBACK_BEFORE} [callbackBefore={@link CB_Net.REST.callbackBefore_DEFAULT}] - Callback run before performing the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action which will decide whether to continue with it or not. * @property {boolean} [avoidProxy={@link CB_Net.REST.avoidProxy_DEFAULT}] - Belongs to the &quot;avoidProxy&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA} [routeWildcardData={@link CB_Net.REST.routeWildcardData_DEFAULT}] - Callback returning an object that will be used for parsing the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} route. The object returned should follow the same rules as the &quot;JSONObject&quot; parameter of the {@link CB_renderString} function. * @property {CB_Net.REST.actionProcess_DATA_URL} [dataURL={@link CB_Net.REST.dataURL_DEFAULT}] - Belongs to the &quot;dataURL&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {CB_Net.REST.actionProcess_DATA} [data={@link CB_Net.REST.data_DEFAULT}] - Belongs to the &quot;data&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {CB_Net.REST.actionProcess_HEADERS} [headers={@link CB_Net.REST.headers_DEFAULT}] - Belongs to the &quot;headers&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {array} [allowedSuccessStatuses={@link CB_Net.REST.allowedSuccessStatuses_DEFAULT}] - Belongs to the &quot;allowedSuccessStatuses&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {CB_Net.REST.actionProcess_CALLBACK_ERROR} [callbackError={@link CB_Net.REST.callbackError_DEFAULT}] - Callback run when the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has not been performed successfully. * @property {CB_Net.REST.actionProcess_CALLBACK_OK} [callbackOk={@link CB_Net.REST.callbackOk_DEFAULT}] - Callback run when the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action has been performed successfully. * @property {string} [serverURL={@link CB_Net.REST.SERVER_URL_DEFAULT}] - Belongs to the &quot;serverURL&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {string} [method={@link CB_Net.REST.method_DEFAULT}] - Belongs to the &quot;method&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @property {string} [responseType={@link CB_Net.REST.responseType_DEFAULT}] - Belongs to the &quot;responseType&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.responseType_DEFAULT} instead. * @property {boolean} [forceJSON={@link CB_Net.REST.forceJSON_DEFAULT}] - Belongs to the &quot;forceJSON&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.forceJSON_DEFAULT} instead. * @property {boolean} [getHeaders={@link CB_Net.REST.getHeaders_DEFAULT}] - Belongs to the &quot;getHeaders&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.getHeaders_DEFAULT} instead. * @property {boolean} [getHeadersOneDimension={@link CB_Net.REST.getHeadersOneDimension_DEFAULT}] - Belongs to the &quot;getHeadersOneDimension&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.getHeadersOneDimension_DEFAULT} instead. * @property {boolean} [getHeadersOneDimensionValues={@link CB_Net.REST.getHeadersOneDimensionValues_DEFAULT}] - Belongs to the &quot;getHeadersOneDimensionValues&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.getHeadersOneDimensionValues_DEFAULT} instead. * @property {boolean} [transparentStatus={@link CB_Net.REST.transparentStatus_DEFAULT}] - Belongs to the &quot;transparentStatus&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.transparentStatus_DEFAULT} instead. * @property {boolean} [transparentHeaders={@link CB_Net.REST.transparentHeaders_DEFAULT}] - Belongs to the &quot;transparentHeaders&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of {@link CB_Net.REST.transparentHeaders_DEFAULT} instead. */ /** * List of [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} actions. Each property name is the name of the action and its value is a {@link CB_Net.REST.actionProcess_ACTIONS} object. Used by the {@link CB_Net.REST.actionProcess} function. * @var * @type {Object} * @default */ CB_Net.REST.actions = {}; //Read the documentation to know how to add new REST actions. //Initializes all values: CB_Net.REST.init = function() { if (CB_Net.REST.initialized) { return CB_Net.REST; } //The object has been initialized: CB_Net.REST.initialized = true; //TODO. return CB_Net.REST; } /** * Processes a desired [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (which must be previously defined in the {@link CB_Net.REST.actions} object) by its name. &lt;br /&gt; NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the {@link CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL} property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. * @function * @param {string} actionName - The name of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action that we want to perform. It should be the name of an index defined in the {@link CB_Net.REST.actions} object whose value should be a {@link CB_Net.REST.actionProcess_ACTIONS} object. * @param {*} [additionalData] - Any additional data desired. It will be passed as a parameter when different callbacks are called internally, as their &quot;additionalData&quot; parameter. * @param {Object} [XHR] - Used for the &quot;XHR&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. * @param {string} [serverURL] - Used for the &quot;serverURL&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. If provided, the value defined in the &quot;serverURL&quot; parameter of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (if any) will be ignored. * @param {boolean} [avoidProxy] - Used for the &quot;avoidProxy&quot; parameter of the {@link CB_Net.XHR.callREST} function when it is called internally. If provided, the value defined in the &quot;avoidProxy&quot; parameter of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action being performed (if any) and the default one defined in {@link CB_Net.REST.avoidProxy_DEFAULT} (if any) will be both ignored. * @returns {Object|null} Returns null if the {@link CB_Net.XHR.callREST} function is not called at all (because [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} is not supported or the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action object cannot be found or the route is not well defined or the &quot;callbackBefore&quot; returns false, etc.). Otherwise, returns the same that the {@link CB_Net.XHR.callREST} function returns (called internally). */ CB_Net.REST.actionProcess = function(actionName, additionalData, XHR, serverURL, avoidProxy) { if (!CB_Net.XHR.supported()) { return null; } if (typeof(CB_Net.REST.actions[actionName]) === &quot;undefined&quot; || CB_Net.REST.actions[actionName] === null) { return null; } else if (typeof(CB_Net.REST.actions[actionName][&quot;route&quot;]) === &quot;undefined&quot; || CB_Net.REST.actions[actionName][&quot;route&quot;] === null) { return null; } //Performs the previous callback (if any): var callbackBeforeReturn = typeof(CB_Net.REST.callbackBefore_PERMANENT === &quot;function&quot;) ? CB_Net.REST.callbackBefore_PERMANENT(actionName, additionalData) : null; if (callbackBeforeReturn !== false) { if (typeof(CB_Net.REST.actions[actionName][&quot;callbackBefore&quot;]) === &quot;function&quot;) { callbackBeforeReturn = CB_Net.REST.actions[actionName][&quot;callbackBefore&quot;](actionName, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;callbackBefore&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.callbackBefore_DEFAULT) === &quot;function&quot;) { callbackBeforeReturn = CB_Net.REST.callbackBefore_DEFAULT(actionName, additionalData); } } if (callbackBeforeReturn === false) { return null; } //If we do not want to perform the action, exists and returns NULL. serverURL = CB_trim(serverURL); if (serverURL === &quot;&quot; &amp;&amp; typeof(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]) !== &quot;undefined&quot; &amp;&amp; CB_isString(CB_Net.REST.actions[actionName][&quot;serverURL&quot;])) { serverURL = CB_trim(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]); } if (avoidProxy !== true &amp;&amp; avoidProxy !== false) { if (typeof(CB_Net.REST.actions[actionName][&quot;avoidProxy&quot;]) !== &quot;undefined&quot; &amp;&amp; (CB_Net.REST.actions[actionName][&quot;avoidProxy&quot;] === true || CB_Net.REST.actions[actionName][&quot;avoidProxy&quot;] === false)) { avoidProxy = CB_Net.REST.actions[actionName][&quot;avoidProxy&quot;]; } else if (typeof(CB_Net.REST.avoidProxy_DEFAULT) !== &quot;undefined&quot; &amp;&amp; (CB_Net.REST.avoidProxy_DEFAULT === true || CB_Net.REST.avoidProxy_DEFAULT === false)) { avoidProxy = CB_Net.REST.avoidProxy_DEFAULT; } } var route = CB_Net.REST.actions[actionName][&quot;route&quot;]; var wildcardData = null; if (typeof(CB_Net.REST.actions[actionName][&quot;routeWildcardData&quot;]) === &quot;function&quot;) { wildcardData = CB_Net.REST.actions[actionName][&quot;routeWildcardData&quot;](actionName, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;routeWildcardData&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.routeWildcardData_DEFAULT) === &quot;function&quot;) { wildcardData = CB_Net.REST.routeWildcardData_DEFAULT(actionName, additionalData); } wildcardData = CB_combineAutomatically(CB_Net.REST.routeWildcardData_PERMANENT(actionName, additionalData), wildcardData, false); if (wildcardData !== null) { route = CB_renderString(CB_Net.REST.actions[actionName][&quot;route&quot;], wildcardData); } //Gets the data for URL (GET): var dataURL = &quot;&quot;; if (typeof(CB_Net.REST.actions[actionName][&quot;dataURL&quot;]) === &quot;function&quot;) { dataURL = CB_Net.REST.actions[actionName][&quot;dataURL&quot;](actionName, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;dataURL&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.dataURL_DEFAULT) === &quot;function&quot;) { dataURL = CB_Net.REST.dataURL_DEFAULT(actionName, additionalData); } dataURL = CB_trim(CB_trim(dataURL), [&quot;?&quot;, &quot;&amp;&quot;, &quot; &quot;]); var dataURLPermanent = CB_Net.REST.dataURL_PERMANENT(actionName, additionalData); dataURLPermanent = CB_trim(CB_trim(dataURLPermanent), [&quot;?&quot;, &quot;&amp;&quot;, &quot; &quot;]); if (dataURLPermanent !== &quot;&quot;) { dataURL = CB_combineAutomatically(dataURLPermanent, dataURL, false); } //Defines the data: var data = &quot;&quot;; if (typeof(CB_Net.REST.actions[actionName][&quot;data&quot;]) === &quot;function&quot;) { data = CB_Net.REST.actions[actionName][&quot;data&quot;](actionName, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;data&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.data_DEFAULT) === &quot;function&quot;) { data = CB_Net.REST.data_DEFAULT(actionName, additionalData); } data = CB_combineAutomatically(CB_Net.REST.data_PERMANENT(actionName, additionalData), data, false); //Defines the headers: var headers = null; if (typeof(CB_Net.REST.actions[actionName][&quot;headers&quot;]) === &quot;function&quot;) { headers = CB_Net.REST.actions[actionName][&quot;headers&quot;](actionName, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;headers&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.headers_DEFAULT) === &quot;function&quot;) { headers = CB_Net.REST.headers_DEFAULT(actionName, additionalData); } headers = CB_combineAutomatically(CB_Net.REST.headers_PERMANENT(actionName, additionalData), headers, false); //Defines the allowed statuses considered as successful: var allowedSuccessStatuses = CB_Net.REST.allowedSuccessStatuses_DEFAULT; if (typeof(CB_Net.REST.actions[actionName][&quot;allowedSuccessStatuses&quot;]) !== &quot;undefined&quot;) { allowedSuccessStatuses = CB_Net.REST.actions[actionName][&quot;allowedSuccessStatuses&quot;]; } allowedSuccessStatuses = CB_combineAutomatically(CB_Net.REST.allowedSuccessStatuses_PERMANENT, allowedSuccessStatuses, true); //Defines the callback functions: var callbackError = function(actionName, XHRObject, additionalData) { if (typeof(CB_Net.REST.callbackError_PERMANENT) === &quot;function&quot;) { CB_Net.REST.callbackError_PERMANENT(actionName, XHRObject, additionalData); } if (typeof(CB_Net.REST.actions[actionName][&quot;callbackError&quot;]) === &quot;function&quot;) { CB_Net.REST.actions[actionName][&quot;callbackError&quot;](actionName, XHRObject, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;callbackError&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.callbackError_DEFAULT) === &quot;function&quot;) { CB_Net.REST.callbackError_DEFAULT(actionName, XHRObject, additionalData); } }; var callbackErrorWrapper = function(XHRObject) { if (typeof(callbackError) === &quot;function&quot;) { callbackError.call(XHRObject, actionName, XHRObject, additionalData); } }; var callbackOkWrapper = function(XHRObject) { if (CB_Net.REST.actionIsAborted(XHRObject)) { return; } if (typeof(CB_Net.REST.callbackOk_PERMANENT) === &quot;function&quot;) { CB_Net.REST.callbackOk_PERMANENT.call(XHRObject, actionName, XHRObject, callbackError, additionalData); } if (typeof(CB_Net.REST.actions[actionName][&quot;callbackOk&quot;]) === &quot;function&quot;) { CB_Net.REST.actions[actionName][&quot;callbackOk&quot;].call(XHRObject, actionName, XHRObject, callbackError, additionalData); } else if (typeof(CB_Net.REST.actions[actionName][&quot;callbackOk&quot;]) === &quot;undefined&quot; &amp;&amp; typeof(CB_Net.REST.callbackOk_DEFAULT) === &quot;function&quot;) { CB_Net.REST.callbackOk_DEFAULT.call(XHRObject, actionName, XHRObject, callbackError, additionalData); } }; //Calls the REST server: return CB_Net.XHR.callREST ( //typeof(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]) !== &quot;undefined&quot; &amp;&amp; CB_isString(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]) &amp;&amp; CB_trim(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]) !== &quot;&quot; ? CB_trim(CB_Net.REST.actions[actionName][&quot;serverURL&quot;]) : serverURL, //serverURL serverURL, //serverURL route, //route dataURL, //dataURL typeof(CB_Net.REST.actions[actionName][&quot;method&quot;]) !== &quot;undefined&quot; &amp;&amp; CB_isString(CB_Net.REST.actions[actionName][&quot;method&quot;]) &amp;&amp; CB_trim(CB_Net.REST.actions[actionName][&quot;method&quot;]) !== &quot;&quot; ? CB_trim(CB_Net.REST.actions[actionName][&quot;method&quot;]) : CB_Net.REST.method_DEFAULT, //method data, //data headers, //headers typeof(CB_Net.REST.actions[actionName][&quot;responseType&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;responseType&quot;] : CB_Net.REST.responseType_DEFAULT, //responseType avoidProxy, //avoidProxy typeof(CB_Net.REST.actions[actionName][&quot;forceJSON&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;forceJSON&quot;] : CB_Net.REST.forceJSON_DEFAULT, //forceJSON typeof(CB_Net.REST.actions[actionName][&quot;getHeaders&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;getHeaders&quot;] : CB_Net.REST.getHeaders_DEFAULT, //getHeaders typeof(CB_Net.REST.actions[actionName][&quot;getHeadersOneDimension&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;getHeadersOneDimension&quot;] : CB_Net.REST.getHeadersOneDimension_DEFAULT, //headersForceOneDimension typeof(CB_Net.REST.actions[actionName][&quot;getHeadersOneDimensionValues&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;getHeadersOneDimensionValues&quot;] : CB_Net.REST.getHeadersOneDimensionValues_DEFAULT, //headersForceOneDimensionValues typeof(CB_Net.REST.actions[actionName][&quot;transparentStatus&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;transparentStatus&quot;] : CB_Net.REST.transparentStatus_DEFAULT, //transparentStatus typeof(CB_Net.REST.actions[actionName][&quot;transparentHeaders&quot;]) !== &quot;undefined&quot; ? CB_Net.REST.actions[actionName][&quot;transparentHeaders&quot;] : CB_Net.REST.transparentHeaders_DEFAULT, //transparentHeaders callbackOkWrapper, //callbackOk callbackErrorWrapper, //callbackError allowedSuccessStatuses, //allowedSuccessStatuses XHR //XHR ); } /** * Cancels a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (by its [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}/[XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} request associated) by executing the &quot;abort&quot; method of the given [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object (if available) and sets its &quot;aborted&quot; property to true if succeeds. When a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action is aborted, the callbackOk functions associated (if any) will not be called (unless they have been called already). * @function * @param {Object} XHR - The [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object that we want to abort. * @returns {boolean} Returns true if the &quot;abort&quot; method of the given [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object could be called and the &quot;aborted&quot; property was set to true. Otherwise, returns false. */ CB_Net.REST.actionAbort = function(XHR) { if (typeof(XHR) === &quot;object&quot; &amp;&amp; XHR !== null &amp;&amp; typeof(XHR.abort) === &quot;function&quot;) { XHR.abort(); XHR.aborted = true; return true; } return false; } /** * Tries to revert the abortion of a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (by its [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}/[XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} request associated) by setting the &quot;aborted&quot; property of the given [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object to false. If this function is called before the &quot;callbackOk&quot; functions associated to the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action (if any) are called, they could finally be called perhaps (depending on each case, could be different). Have in mind that, after calling {@link CB_Net.REST.actionAbort}, the &quot;abort&quot; method of the [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object was probably called already (if available). * @function * @param {Object} XHR - The [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object whose abortion we want to cancel. * @returns {boolean} Returns true if the &quot;aborted&quot; property was set to false. Otherwise, returns false. */ CB_Net.REST.actionAbortCancel = function(XHR) { if (typeof(XHR) === &quot;object&quot; &amp;&amp; XHR !== null) { XHR.aborted = false; return true; } return false; } /** * Returns whether a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} action is aborted or not (by its [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}/[XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} request associated). * @function * @param {Object} XHR - The [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} object that we want to check. * @returns {boolean} Returns true if the &quot;aborted&quot; property is set to true. Otherwise, returns false. */ CB_Net.REST.actionIsAborted = function(XHR) { return (typeof(XHR) === &quot;object&quot; &amp;&amp; XHR !== null &amp;&amp; XHR.aborted === true); } } × Search results Close "},"CrossBase_net_sockets_CB_Net_Sockets.js.html":{"id":"CrossBase_net_sockets_CB_Net_Sockets.js.html","title":"Source: CrossBase/net/sockets/CB_Net_Sockets.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/net/sockets/CB_Net_Sockets.js /** * @file Sockets and related management. Contains the {@link CB_Net.Sockets} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ if (typeof(CB_Net) === &quot;undefined&quot;) { var CB_Net = function() { return CB_Net; }; } /** * Static class to manage sockets and related. It will return itself if it is tried to be instantiated. It uses [SockJS-client]{@link https://github.com/sockjs/sockjs-client}. * @namespace */ CB_Net.Sockets = function() { return CB_Net.Sockets; }; { CB_Net.Sockets.initialized = false; //It will tells whether the object has been initialized or not. /** Property that contains the functions and properties related with the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library. * @namespace CB_Net.Sockets.SockJS */ CB_Net.Sockets.SockJS = {}; //Keeps the methods and properties related to SockJS library. /** * Keeps the last SockJS created. * @var * @readonly * @type {Object|null} * @default */ CB_Net.Sockets.SockJS.websocketLast = null; //Keeps the last websocket object. //Initializes all values: CB_Net.Sockets.init = function() { if (CB_Net.Sockets.initialized) { return CB_Net.Sockets; } //The object has been initialized: CB_Net.Sockets.initialized = true; //TODO. return CB_Net.Sockets; } /** * Alias for {@link CB_Net.Sockets.SockJS.listen}. * @function CB_Net.Sockets.SockJS.open * @see {@link CB_Net.Sockets.SockJS.listen} */ /** * Creates the websockets object and sets the listeners. Using the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library internally. * @function * @param {string} serverURL - The URL of the SockJS server. This will be used as the first parameter when it calls the constructor of SockJS internally. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation (the parameter is called &quot;url&quot;). * @param {function} [onOpen] - Function for the event &quot;onopen&quot; used by the SockJS object. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @param {function} [onClose] - Function for the event &quot;onclose&quot; used by the SockJS object. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @param {function} [onMessage] - Function for the event &quot;onmessage&quot; used by the SockJS object. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @param {function} [onError] - Function for the event &quot;onerror&quot; used by the SockJS object. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @param {Object} [options] - The desired options for the SockJS object. This will be used as the third parameter when it calls the constructor of SockJS internally. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation (the parameter is called &quot;options&quot;). * @param {array} [protocols] - This will be used as the second parameter when it calls the constructor of SockJS internally. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation (the parameter is called &quot;_reserved&quot;). * @returns {Object|null} Returns a SockJS object. Read the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation for more information. In the case of error, returns null. */ CB_Net.Sockets.SockJS.listen = function(serverURL, onOpen, onClose, onMessage, onError, options, protocols) { try { var websocket = new SockJS(serverURL, protocols || undefined, options || undefined); //Creates the SockJS object. if (typeof(websocket) === &quot;undefined&quot; || websocket === null) { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;CANNOT OPEN THE CONNECTION TO &quot; + serverURL }); } return null; } if (typeof(onOpen) === &quot;function&quot;) { websocket.onopen = onOpen; } //Example: function webSocketsOnOpen(evt) { CB_console(websocket.transport); } if (typeof(onClose) === &quot;function&quot;) { websocket.onclose = onClose; } //Example: function webSocketsOnClose(evt) { CB_console(&quot;Websocket closed. Reason: &quot; + evt.reason); } if (typeof(onMessage) === &quot;function&quot;) { websocket.onmessage = onMessage; } //Example: function webSocketsOnMessage(evt) { CB_console(evt.data); } if (typeof(onError) === &quot;function&quot;) { websocket.onerror = onError; } //Example: function webSocketsOnError(evt) { CB_console(&quot;Websocket error: &quot; + JSON.stringify(evt)); } CB_Net.Sockets.SockJS.websocketLast = websocket; //Stores the object as the last one. return websocket; } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;ERROR CALLING 'listen': &quot; + E }); } return null; } } /** * Sends a websockets message. Using the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library internally. * @function * @param {string} message - The message that we want to send. This will be used as the first and unique parameter when it calls the &quot;send&quot; function of the SockJS object internally. Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @param {function} [websocket={@link CB_Net.Sockets.SockJS.websocketLast}] - The SockJS object that we want to use. If not provided, it will try to use the last one created (if any) which is stored in {@link CB_Net.Sockets.SockJS.websocketLast}. * @param {function} [onError] - Function for the event &quot;onerror&quot; used by the SockJS object. If provided, it will replace the previous one (if any). Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @returns {undefined|false} Returns undefined (the same as the &quot;send&quot; function of the SockJS object) if the SockJS has been used or false otherwise. */ CB_Net.Sockets.SockJS.send = function(message, websocket, onError) { websocket = websocket || CB_Net.Sockets.SockJS.websocketLast; if (typeof(websocket) !== &quot;undefined&quot; &amp;&amp; websocket !== null &amp;&amp; typeof(websocket.send) === &quot;function&quot;) { if (typeof(onError) === &quot;function&quot;) { websocket.onerror = onError; } //Example: function webSocketsOnError(evt) { CB_console(&quot;Websocket error: &quot; + JSON.stringify(evt)); } var returnValue = false; try { returnValue = websocket.send(message); } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;ERROR CALLING 'send': &quot; + E }); } returnValue = false; } return returnValue; } else { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;CANNOT FIND WEBSOCKETS OBJECT&quot; }); } return false; } } /** * Tries to close the websockets connection. Using the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library internally. * @function * @param {function} [websocket={@link CB_Net.Sockets.SockJS.websocketLast}] - The SockJS object that we want to use. If not provided, it will try to use the last one created (if any) which is stored in {@link CB_Net.Sockets.SockJS.websocketLast}. * @param {function} [onError] - Function for the event &quot;onerror&quot; used by the SockJS object. If provided, it will replace the previous one (if any). Following the same rules as in the [SockJS client]{@link https://github.com/sockjs/sockjs-client} library documentation. * @returns {undefined|false} Returns undefined (the same as the &quot;close&quot; function of the SockJS object) if the SockJS has been used or false otherwise. */ CB_Net.Sockets.SockJS.close = function(websocket, onError) { websocket = websocket || CB_Net.Sockets.SockJS.websocketLast; if (typeof(websocket) !== &quot;undefined&quot; &amp;&amp; websocket !== null &amp;&amp; typeof(websocket.close) === &quot;function&quot;) { if (typeof(onError) === &quot;function&quot;) { websocket.onerror = onError; } //Example: function webSocketsOnError(evt) { CB_console(&quot;Websocket error: &quot; + JSON.stringify(evt)); } var returnValue = false; try { returnValue = websocket.close(); if (websocket === CB_Net.Sockets.SockJS.websocketLast) { CB_Net.Sockets.SockJS.websocketLast = null; } } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;ERROR CALLING 'close': &quot; + E }); } returnValue = false; } return returnValue; } else { if (typeof(onError) === &quot;function&quot;) { onError({ &quot;error&quot; : &quot;CANNOT FIND WEBSOCKETS OBJECT&quot; }); } return false; } } } × Search results Close "},"CrossBase_net_XHR_CB_Net_XHR.js.html":{"id":"CrossBase_net_XHR_CB_Net_XHR.js.html","title":"Source: CrossBase/net/XHR/CB_Net_XHR.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/net/XHR/CB_Net_XHR.js /** * @file [XMLHttpRequest]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}, [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}) and related management. Contains the {@link CB_Net.XHR} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ if (typeof(CB_Net) === &quot;undefined&quot;) { var CB_Net = function() { return CB_Net; }; } /** * Static class to manage [XMLHttpRequest]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}, [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}) and related. It will return itself if it is tried to be instantiated. * @namespace * @todo Think about providing an easy way to abort XHR (AJAX) calls. */ CB_Net.XHR = function() { return CB_Net.XHR; }; { CB_Net.XHR.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Net.XHR.init = function() { if (CB_Net.XHR.initialized) { return CB_Net.XHR; } //The object has been initialized: CB_Net.XHR.initialized = true; //TODO. return CB_Net.XHR; } CB_Net.XHR._supportedReturnCache = null; /** * Returns whether [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) is available or not. * @function * @returns {boolean} Returns true if [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} ([AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}) objects can be used. */ CB_Net.XHR.supported = function() { if (CB_Net.XHR._supportedReturnCache !== null) { return CB_Net.XHR._supportedReturnCache; } else { CB_Net.XHR._supportedReturnCache = (CB_Net.XHR.get() !== null); return CB_Net.XHR._supportedReturnCache; } } //Returns an AJAX object: //var CB_Net.XHR._getXmlHttpVersionsIE = [&quot;Msxml2.XMLHTTP.7.0&quot;, &quot;MSXML2.XmlHttp.6.0&quot;, &quot;MSXML2.XmlHttp.5.0&quot;, &quot;MSXML2.XmlHttp.4.0&quot;, &quot;MSXML2.XmlHttp.3.0&quot;, &quot;Msxml2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]; CB_Net.XHR._getXmlHttpVersionsIE = [&quot;MSXML2.XmlHttp.6.0&quot;, &quot;MSXML2.XmlHttp.3.0&quot;, &quot;Msxml2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;]; //XmlHttpVersions in order of preference for old IE versions. CB_Net.XHR._getXmlHttpVersionsIELastIndexWorked = null; //Defines the last index of CB_XmlHttpVersion that worked (for optimization). /** * Returns a new [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) object, if possible. * @function * @returns {Object|null} Returns a new [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) object if it has been possible to create it or null otherwise. */ CB_Net.XHR.get = function() { if (typeof XMLHttpRequest !== &quot;undefined&quot;) //if (window.XMLHttpRequest). { return new XMLHttpRequest(); } else if (typeof(ActiveXObject) !== &quot;undefined&quot;) { if (CB_Net.XHR._getXmlHttpVersionsIELastIndexWorked !== null) { return new ActiveXObject(CB_Net.XHR._getXmlHttpVersionsIE[CB_Net.XHR._getXmlHttpVersionsIELastIndexWorked]); } else { var XHR = null; for (var x = 0, getXmlHttpVersionsIELength = CB_Net.XHR._getXmlHttpVersionsIE.length; x &lt; getXmlHttpVersionsIELength; x++) { try { XHR = new ActiveXObject(CB_Net.XHR._getXmlHttpVersionsIE[x]); CB_Net.XHR._getXmlHttpVersionsIELastIndexWorked = x; //Defines this index as the last working one (for optimization). return XHR; } catch(E) {} } return null; } } return null; } /** * Object containing the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} and their values. * @memberof CB_Net.XHR * @typedef {Object} CB_Net.XHR.HEADERS * @property {Object} HTTPHeaderName - Each property name is an [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} and its value is the desired one for this header. * @example { &quot;Content-Type&quot; : &quot;text/plain; charset=x-user-defined&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } */ /** * Performs an [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) call. * @function * @param {string} URL - The URL that we want to call. It can also contain URL (GET) parameters. * @param {string} [method='POST'] - The [HTTP method]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods} that will be used to perform the call (GET, POST, PUT, DELETE, etc.). * @param {string|Object} [data] - The data that we want to send. If a string is given and &quot;GET&quot; method is being used, it will assume they are GET (URL) parameters and will be attached at the end of the URL given. If something which is not a string is given, it will assume it is a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object and will try to convert it into a string (using the [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} function internally) before sending it. * @param {CB_Net.XHR.HEADERS} [headers] - Object containing the [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} names and their values that we want to send (used internally by the [setRequestHeader]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader} method of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}). * @param {string} [responseType] - If provided, it will be used for the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} property of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} (if available). * @param {string} [mimeType] - [MIME type]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types} that will be used to override the default one returned by the server. Only used when the client supports the [overrideMimeType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/overrideMimeType} method of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}. * @param {function} [callbackFunction] - Function that will be used for the [onreadystatechange]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange} property of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}. The unique parameter that it will receive is the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} used by the request. If provided, the &quot;callbackFunctionOK&quot; and &quot;callbackFunctionError&quot; parameters will not be used even they were also provided. * @param {function} [callbackFunctionOK] - Function that will be called by an internally-created function used in the [onreadystatechange]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange} property of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} when the [readyState]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState} property is 4 and the [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property is included in the &quot;allowedSuccessStatuses&quot; desired. The first parameter it will receive is the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} used by the request and the second one will be the &quot;callbackFunctionError&quot; function provided (if any). It will not be used if the parameter &quot;callbackFunction&quot; is provided. * @param {function} [callbackFunctionError] - Function that will be called by an internally-created function used in the [onreadystatechange]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange} property of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} when the [readyState]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState} property is 4 and the [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property is not included in the &quot;allowedSuccessStatuses&quot; desired. The first parameter it will receive is the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} used by the request and the second one will be the &quot;callbackFunctionOk&quot; function provided (if any). It will not be used if the parameter &quot;callbackFunction&quot; is provided. * @param {integer|array} [allowedSuccessStatuses=200] - An integer or a numeric array with a list of integers with the status or statuses that will be considered as a success call by the &quot;callbackFunctionOK&quot; function (only when it is used) when the response comes. * @param {boolean} [asynchronous=true] - Defines whether to make a request asynchronously or not. It will be used for the third parameter of the method [open]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/open} of the [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}. * @param {Object} [XHR] - The [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} that we want to use for the call. If not provided, it will try to create a new one internally. * @returns {Object|null} Returns null if the URL provided was empty or the [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) object provided is not a valid object or it could not be created a new one internally. Otherwise, it returns the [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) object used to try to perform the call (even that maybe it failed or will fail later). * @todo Think about providing a way to choose whether we want the &quot;data&quot; provided to be added to the URL when the &quot;GET&quot; method is used or not. * @todo Describe better what kind of [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} will the different callbacks receive, as in some cases (as when using [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer}) they can contain some special properties with [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers}, etc. */ CB_Net.XHR.call = function(URL, method, data, headers, responseType, mimeType, callbackFunction, callbackFunctionOK, callbackFunctionError, allowedSuccessStatuses, asynchronous, XHR) { var failFunction = function(XHR) { if (typeof(callbackFunction) === &quot;function&quot;) { callbackFunction.call(XHR, XHR); } else if (typeof(callbackFunctionError) === &quot;function&quot;) { callbackFunctionError.call(XHR, XHR, callbackFunctionOK); } }; //If the URL is empty, exits the function: URL = CB_trim(URL); if (URL === &quot;&quot;) { failFunction({ readyState: 4, status: 400, errorMessage: &quot;URL is empty&quot;, originalXHR: XHR }); return null; } //If not given, sets the default parameters: method = CB_trim(method).toUpperCase(); if (method === &quot;&quot;) { method = &quot;POST&quot;; } //Request method by default. if (typeof(headers) !== &quot;object&quot; || headers === null) //Sets headers by default: { headers = {}; } mimeType = CB_trim(mimeType); //If it was unset or null, it will be an empty string. responseType = CB_trim(responseType).toLowerCase(); //If it was unset or null, it will be an empty string. if (asynchronous !== false) { asynchronous = true; } //Async by default. //By default, allows 200 success status only: if (!CB_isArray(allowedSuccessStatuses)) { allowedSuccessStatuses = [200]; } //Creates the AJAX object: if (typeof(XHR) === &quot;undefined&quot; || XHR === null || !XHR) { XHR = CB_Net.XHR.get(); } //If the XHR object is null, exits the function: if (XHR === null) { failFunction({ readyState: 4, status: 400, errorMessage: &quot;XHR is null&quot;, originalXHR: XHR }); return null; } //Processes the data (if any): if (typeof(data) !== &quot;undefined&quot; &amp;&amp; data !== null &amp;&amp; !CB_isString(data)) //If data is not a string, we assume it is JSON data. { data = JSON.stringify(data); //data = CB_Net.URLEncode(JSON.stringify(data)); } else { data = CB_trim(data); //If there are data and the method is GET, it adds them to the URL: if (data !== &quot;&quot; &amp;&amp; method === &quot;GET&quot;) { if (CB_indexOf(URL, &quot;?&quot;) === -1) { URL += &quot;?&quot; + data; } //There was not ? symbol in the URL, so we add it. else { URL += &quot;&amp;&quot; + data; } //There was ? symbol in the URL, so we add the &amp; symbol. //TODO: consider setting &quot;data&quot; to null or empty string since we do not need them to send them in the &quot;send&quot; method (we have already added them in the &quot;URL&quot; variable). } } //Opens the connection: try //Using try-catch to avoid problems with IE5.5: { XHR.open(method, URL, asynchronous); } catch(E) { var originalXHR = XHR; var fakeXHR = { readyState: 4, status: 500, errorMessage: &quot;Failed when using open method&quot;, originalXHR: XHR }; try { XHR.readyState = 4; XHR.status = 500; XHR.errorMessage = &quot;Failed when using open method&quot;; } catch(E) { XHR = fakeXHR; } if (XHR.readyState !== 4) { XHR = fakeXHR; } //Some web clients as IE9 will not fail when try to edit properties but they will not end being modified. failFunction(XHR); return originalXHR; } //Applies the given headers (if any): //if (mimeType !== null) { headers[&quot;Content-Type&quot;] = mimeType; } for (var headerName in headers) { XHR.setRequestHeader(headerName, headers[headerName]); } //Applies the given mime type (if any): if (XHR.overrideMimeType &amp;&amp; mimeType !== &quot;&quot;) { //XHR.overrideMimeType(&quot;text/plain; charset=UTF-8&quot;); XHR.overrideMimeType(mimeType); } //Applies the given response type (if any): if (typeof(XHR.responseType) !== &quot;undefined&quot; &amp;&amp; responseType !== &quot;&quot;) { XHR.responseType = responseType; } /* else { if (responseType === &quot;&quot; || responseType === &quot;text&quot;) { XHR.overrideMimeType(&quot;text/plain; charset=UTF-8&quot;); } else if (responseType === &quot;xml&quot;) { XHR.overrideMimeType(&quot;text/xml&quot;); } else if (responseType === &quot;arraybuffer&quot;) { //XHR.overrideMimeType(&quot;text/plain; charset=x-user-defined&quot;); } }*/ //If set, defines the callback function: if (typeof(callbackFunction) === &quot;function&quot;) { XHR.onreadystatechange = function() { callbackFunction.call(XHR, XHR); }; } //...otherwise, defines the callback functions for OK and error status: else { XHR.onreadystatechange = function() { //if (XHR.readyState == 4) if (XHR.readyState === 4) { //if (XHR.status == 200 || allowOtherSuccessStatus &amp;&amp; XHR.status == 206) if (CB_indexOf(allowedSuccessStatuses, parseInt(XHR.status)) !== -1) { if (typeof(callbackFunctionOK) === &quot;function&quot;) { callbackFunctionOK.call(XHR, XHR, callbackFunctionError); } } //else if (XHR.readyState == 4 &amp;&amp; (XHR.status == 0 || XHR.status == 502 || XHR.status == 12002 || XHR.status == 12029 || XHR.status == 12030 || XHR.status == 12031 || XHR.status == 12029 || XHR.status == 12152 || XHR.status == 12159)) //else if (XHR.status !== 12152 &amp;&amp; XHR.status !== 12030 &amp;&amp; XHR.status !== 0 &amp;&amp; XHR.status !== 12002 &amp;&amp; XHR.status !== 12007 &amp;&amp; XHR.status !== 12029 &amp;&amp; XHR.status !== 12031) else { if (typeof(callbackFunctionError) === &quot;function&quot;) { callbackFunctionError.call(XHR, XHR, callbackFunctionOK); } } } } } //Sends the XHR request: XHR.send(data); //Returns the XHR object: return XHR; } /** * Performs a standard [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} request to send form data by POST (no files). Uses the {@link CB_Net.XHR.call} function internally with &quot;POST&quot; method, asynchronously and &quot;mimeType&quot; parameter not provided. * @function * @param {string} URL - Used for the &quot;URL&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {string|Object} [data] - Used for the &quot;data&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {CB_Net.XHR.HEADERS} [headers={ &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=&quot; + charset, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }] - Object containing the [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} names and their values that we want to send. If not provided, it will use the default one that will include the charset defined by the &quot;charset&quot; parameter. An empty object ({}) can be used if we do not want to send any [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} at all. Used for the &quot;headers&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {string} [responseType] - Used for the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {string} [charset='UTF-8'] - The charset for the &quot;Content-Type&quot; [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} that will be sent by default only when no &quot;headers&quot; parameter is provided. * @param {function} [callbackFunction] - Used for the &quot;callbackFunction&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {function} [callbackFunctionOK] - Used for the &quot;callbackFunctionOK&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {function} [callbackFunctionError] - Used for the &quot;callbackFunctionError&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {integer|array} [allowedSuccessStatuses=200] - Used for the &quot;allowedSuccessStatuses&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {Object} [XHR] - Used for the &quot;XHR&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @returns {Object|null} Returns the same that the {@link CB_Net.XHR.call} function returns (called internally). */ CB_Net.XHR.callForm = function(URL, data, headers, responseType, charset, callbackFunction, callbackFunctionOK, callbackFunctionError, allowedSuccessStatuses, XHR) { //If not given, sets the default parameters: charset = CB_trim(charset); if (typeof(charset) === &quot;undefined&quot; || charset === &quot;&quot;) { charset = &quot;UTF-8&quot;; } //Default charset. if (typeof(headers) !== &quot;object&quot; || headers === null) { headers = { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=&quot; + charset, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }; } //Makes the AJAX request function and returns the same: return CB_Net.XHR.call ( URL, //URL &quot;POST&quot;, //method data, //data headers, //headers responseType, //responseType null, //mimeType callbackFunction, //callbackFunction callbackFunctionOK, //callbackFunctionOK callbackFunctionError, //callbackFunctionError allowedSuccessStatuses, //allowedSuccessStatuses true, //asynchronous XHR //XHR object ); } /** * Performs a standard [XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} request for a binary file. Uses the {@link CB_Net.XHR.call} function internally with &quot;GET&quot; method, using &quot;text/plain; charset=x-user-defined&quot; for the &quot;mimeType&quot; parameter and asynchronously. * @function * @param {string} URL - Used for the &quot;URL&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {string|Object} [data] - Used for the &quot;data&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {CB_Net.XHR.HEADERS} [headers={ &quot;Content-Type&quot; : &quot;text/plain; charset=x-user-defined&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }] - Object containing the [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} names and their values that we want to send. If not provided, it will use the default one. An empty object ({}) can be used if we do not want to send any [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} at all. Used for the &quot;headers&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {'arraybuffer'|'blob'|''} [blobOrArrayBuffer='arraybuffer'] - Used for the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} parameter of the {@link CB_Net.XHR.call} function when it is called internally. If an empty string is provided, the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} parameter will not be modified. * @param {function} [callbackFunction] - Used for the &quot;callbackFunction&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {function} [callbackFunctionOK] - Used for the &quot;callbackFunctionOK&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {function} [callbackFunctionError] - Used for the &quot;callbackFunctionError&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {integer|array} [allowedSuccessStatuses=200] - Used for the &quot;allowedSuccessStatuses&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @param {Object} [XHR] - Used for the &quot;XHR&quot; parameter of the {@link CB_Net.XHR.call} function when it is called internally. * @returns {Object|null} Returns the same that the {@link CB_Net.XHR.call} function returns (called internally). */ CB_Net.XHR.callBinary = function(URL, data, headers, blobOrArrayBuffer, callbackFunction, callbackFunctionOK, callbackFunctionError, allowedSuccessStatuses, XHR) { //If not given, sets the default parameters: if (typeof(headers) !== &quot;object&quot; || headers === null) { headers = { &quot;Content-Type&quot; : &quot;text/plain; charset=x-user-defined&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }; } blobOrArrayBuffer = typeof(blobOrArrayBuffer) === &quot;undefined&quot; || blobOrArrayBuffer === null ? &quot;arraybuffer&quot; : CB_trim(blobOrArrayBuffer).toLowerCase(); if (blobOrArrayBuffer !== &quot;blob&quot; &amp;&amp; blobOrArrayBuffer !== &quot;&quot;) //Only allows to be &quot;blob&quot;, &quot;arraybuffer&quot; or an empty string: { blobOrArrayBuffer = &quot;arraybuffer&quot;; } //Makes the AJAX request function and returns the same: return CB_Net.XHR.call ( URL, //URL &quot;GET&quot;, //method data, //data headers, //headers blobOrArrayBuffer, //responseType &quot;text/plain; charset=x-user-defined&quot;, //mimeType callbackFunction, //callbackFunction callbackFunctionOK, //callbackFunctionOK callbackFunctionError, //callbackFunctionError allowedSuccessStatuses, //allowedSuccessStatuses true, //asynchronous XHR //XHR object ); } /** * Performs an [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)} ([XHR]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest}) call through the proxy (made with [PHP]{@link https://en.wikipedia.org/wiki/PHP} language and using [cURL]{@link https://en.wikipedia.org/wiki/CURL}, so it will need a server which supports that) to avoid [cross-domain request]{@link https://en.wikipedia.org/wiki/Cross-origin_resource_sharing} limitations of [AJAX]{@link https://en.wikipedia.org/wiki/Ajax_(programming)}. Uses the {@link CB_Net.XHR.callForm} function (with &quot;headers&quot; and &quot;charset&quot; parameters not provided) internally to call the proxy. &lt;br /&gt; NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the {@link CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL} property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. * @function * @param {string} URL - The URL that we want the proxy to call for us. It can also contain URL (GET) parameters. * @param {string} [method='POST'] - The [HTTP method]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods} (GET, POST, PUT, DELETE, etc.) that we want the proxy to use for us when performing the call. * @param {string|Object} [data] - The data that we want to send through the proxy to the final server. If something which is not a string is given, it will assume it is a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object and will try to convert it into a string (using the [JSON.stringify]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify} function internally) before sending it. * @param {CB_Net.XHR.HEADERS} [headers] - Object ([JSON]{@link https://en.wikipedia.org/wiki/JSON} format) containing the [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} names and their values that we want the proxy to send to the final server. Even if not provided, the proxy could end sending some [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} depending on the [cURL]{@link https://en.wikipedia.org/wiki/CURL} configuration used. * @param {string} [responseType] - Used for the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @param {boolean} [forceJSON=false] - If it is set to true, the response from the proxy will be a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object with the [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property containing the [HTTP status]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Status} of the reply, the [response]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response} property with the response content itself and the &quot;headers&quot; property (only when &quot;getHeaders&quot; parameters is set to true) with the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} of the reply, all belonging to the response from the final server. * @param {boolean} [getHeaders=false] - If it is set to true, the proxy will answer including the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} from the final server. The [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} will be included in the final response string at the beginning (before the response content) if the &quot;forceJSON&quot; parameter is not set to true or in the &quot;headers&quot; property of the [JSON]{@link https://en.wikipedia.org/wiki/JSON} object that belongs to the response otherwise. * @param {boolean} [headersForceOneDimension=false] - If it is set to true, the proxy will consider that the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} of the response from the final server are not multidimensional which means that the final server would never reply the same [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} repeated multiple times (with different values, normally) in different chunks separated by double new lines (&quot;\\r\\n\\r\\n&quot;). Default value (false) is recommended. Needs &quot;getHeaders&quot; set to true. * @param {boolean} [headersForceOneDimensionValues=false] - If it is set to true, the proxy will only consider one value per [HTTP header]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} from the response from the final server. Default value (false) is recommended. Needs &quot;getHeaders&quot; set to true. * @param {boolean} [transparentStatus=false] - If it is set to true, the proxy will reply us with the same status as the final server in its HTTP response. * @param {boolean} [transparentHeaders=false] - If it is set to true, the proxy will reply us with the same [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} as the final server in its HTTP response. * @param {function} [callbackFunction] - Used for the &quot;callbackFunction&quot; parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @param {function} [callbackFunctionOK] - Used for the &quot;callbackFunctionOK&quot; parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @param {function} [callbackFunctionError] - Used for the &quot;callbackFunctionError&quot; parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @param {integer|array} [allowedSuccessStatuses=200] - Used for the &quot;allowedSuccessStatuses&quot; parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @param {Object} [XHR] - Used for the &quot;XHR&quot; parameter of the {@link CB_Net.XHR.callForm} function when it is called internally. * @returns {Object|null} Returns the same that the {@link CB_Net.XHR.callForm} function returns (called internally). * @todo Document PHP proxy more. */ CB_Net.XHR.callProxy = function(URL, method, data, headers, responseType, forceJSON, getHeaders, headersForceOneDimension, headersForceOneDimensionValues, transparentStatus, transparentHeaders, callbackFunction, callbackFunctionOK, callbackFunctionError, allowedSuccessStatuses, XHR) { //Adds the proxy data and session (for users without cookies enabled) to the data: var proxyVariables = &quot;p_url=&quot; + CB_Net.URLValueEncode(URL); method = CB_trim(method).toUpperCase(); if (method === &quot;&quot;) { method = &quot;POST&quot;; } //Request method by default. proxyVariables += &quot;&amp;p_method=&quot; + CB_Net.URLValueEncode(method); if (typeof(headers) === &quot;object&quot; &amp;&amp; headers !== null) { proxyVariables += &quot;&amp;p_headers=&quot; + CB_Net.URLValueEncode(JSON.stringify(headers)); } if (forceJSON) { proxyVariables += &quot;&amp;p_force_json=yes&quot;; } if (getHeaders) { proxyVariables += &quot;&amp;p_get_headers=yes&quot;; } if (headersForceOneDimension) { proxyVariables += &quot;&amp;p_get_headers_on_dimension=yes&quot;; } if (headersForceOneDimensionValues) { proxyVariables += &quot;&amp;p_get_headers_on_dimension_values=yes&quot;; } if (transparentStatus) { proxyVariables += &quot;&amp;p_transparent_status=yes&quot;; } if (transparentHeaders) { proxyVariables += &quot;&amp;p_transparent_headers=yes&quot;; } //proxyVariables += &quot;&amp;&quot; + SESSION_PARAMETER; //proxyVariables += &quot;&amp;ajax=true&quot;; //proxyVariables += &quot;&amp;php_root=&quot; + PROJECT_PATH_FROM_PROXY; if (typeof(data) !== &quot;undefined&quot; &amp;&amp; data !== null &amp;&amp; !CB_isString(data)) //If data is not a string, we assume it is JSON data. { data = JSON.stringify(data); } else { data = CB_trim(data); } if (data !== &quot;&quot;) { data = &quot;p_data=&quot; + CB_Net.URLValueEncode(data) + &quot;&amp;&quot; + proxyVariables; } else { data = proxyVariables; } //Calls the proxy by post method: return CB_Net.XHR.callForm ( CB_Configuration[CB_BASE_NAME].CB_Net_XHR_PROXY_URL, //URL of the proxy. data, //data null, //headers responseType, //responseType null, //charset callbackFunction, //callbackFunction callbackFunctionOK, //callbackFunctionOK callbackFunctionError, //callbackFunctionError allowedSuccessStatuses, //allowedSuccessStatuses XHR //XHR ); } /** * Performs a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} call to a [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} server. Uses the {@link CB_Net.XHR.callProxy} function (without &quot;callbackFunction&quot; parameter provided) internally if we do not want to avoid the proxy or uses the {@link CB_Net.XHR.call} function (asynchronously, with &quot;mimeType&quot; and &quot;callbackFunction&quot; parameters not provided) otherwise. * @function * @param {string} [serverURL={@link CB_Net.REST.SERVER_URL_DEFAULT}] - The URL of the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} server that we want to call. It should not contain URL (GET) parameters. It can also contain the [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} path (route), although it is recommended to set it in the &quot;route&quot; parameter. * @param {string} [route] - The [REST]{@link https://en.wikipedia.org/wiki/Representational_state_transfer} path (route) we want to request. It can also contain URL (GET) parameters, although it is recommended to set them in the &quot;dataURL&quot; parameter. * @param {string} [dataURL] - The URL (GET) data that we want to send. * @param {string} [method='POST'] - Used for the &quot;method&quot; parameter for the {@link CB_Net.XHR.callProxy} function or for the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {string|Object} [data] - Used for the &quot;data&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {CB_Net.XHR.HEADERS} [headers=undefined|{ &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }] - Used for the &quot;headers&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. If not provided and the {@link CB_Net.XHR.call} function is used (if no proxy is allowed), the default value will be: { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } * @param {string} [responseType] - Used for the [responseType]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType} parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {boolean} [avoidProxy=false] - If it is set to true, it will call the {@link CB_Net.XHR.call} internally. Otherwise, it will use the {@link CB_Net.XHR.callProxy} function internally. * @param {boolean} [forceJSON=false] - Used for the &quot;forceJSON&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {boolean} [getHeaders=false] - Used for the &quot;getHeaders&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {boolean} [headersForceOneDimension=false] - Used for the &quot;headersForceOneDimension&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {boolean} [headersForceOneDimensionValues=false] - Used for the &quot;headersForceOneDimensionValues&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {boolean} [transparentStatus=false] - Used for the &quot;transparentStatus&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {boolean} [transparentHeaders=false] - Used for the &quot;transparentHeaders&quot; parameter of the {@link CB_Net.XHR.callProxy} function (if the proxy is allowed) when it is called internally. * @param {function} [callbackFunctionOK] - Used for the &quot;callbackFunctionOK&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {function} [callbackFunctionError] - Used for the &quot;callbackFunctionError&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {integer|array} [allowedSuccessStatuses=200] - Used for the &quot;allowedSuccessStatuses&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @param {Object} [XHR] - Used for the &quot;XHR&quot; parameter of the {@link CB_Net.XHR.callProxy} function or of the {@link CB_Net.XHR.call} function (if no proxy is allowed) when it is called internally. * @returns {Object|null} When using the proxy is allowed, returns the same that the {@link CB_Net.XHR.callProxy} function returns (called internally). Otherwise, it returns the same that the {@link CB_Net.XHR.call} function returns (called internally). */ CB_Net.XHR.callREST = function(serverURL, route, dataURL, method, data, headers, responseType, avoidProxy, forceJSON, getHeaders, headersForceOneDimension, headersForceOneDimensionValues, transparentStatus, transparentHeaders, callbackFunctionOK, callbackFunctionError, allowedSuccessStatuses, XHR) { serverURL = CB_trim(serverURL); //if (serverURL === &quot;&quot;) { serverURL = CB_trim(CB_Net.REST.SERVER_URL_DEFAULT); } if (serverURL === &quot;&quot;) { serverURL = CB_Net.REST.SERVER_URL_DEFAULT; } serverURL += CB_trim(route); dataURL = CB_trim(dataURL); if (dataURL !== &quot;&quot;) { serverURL = CB_rtrim(serverURL, [&quot;?&quot;, &quot;&amp;&quot;, &quot; &quot;]); if (CB_indexOf(serverURL, &quot;?&quot;) !== -1) { serverURL += &quot;&amp;&quot; + dataURL; } else { serverURL += &quot;?&quot; + dataURL; } } if (!avoidProxy) { return CB_Net.XHR.callProxy ( serverURL, //URL of the REST server. method, //method data, //data headers, //headers responseType, //responseType forceJSON, //forceJSON getHeaders, //getHeaders headersForceOneDimension, //headersForceOneDimension headersForceOneDimensionValues, //headersForceOneDimensionValues transparentStatus, //transparentStatus transparentHeaders, //transparentHeaders null, //callbackFunction callbackFunctionOK, //callbackFunctionOK callbackFunctionError, //callbackFunctionError allowedSuccessStatuses, //allowedSuccessStatuses XHR //XHR ); } else { if (typeof(headers) !== &quot;object&quot; || headers === null) { headers = { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }; } //Makes the AJAX request function and returns the same: return CB_Net.XHR.call ( serverURL, //URL method, //method data, //data headers, //headers responseType, //responseType null, //mimeType null, //callbackFunction callbackFunctionOK, //callbackFunctionOK callbackFunctionError, //callbackFunctionError allowedSuccessStatuses, //allowedSuccessStatuses true, //asynchronous XHR //XHR object ); } } /** * Returns the [HTTP headers]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers} (it should be an object) from the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy (&quot;headers&quot; property). Useful to parse the response from the {@link CB_Net.XHR.callProxy} (or {@link CB_Net.XHR.callREST} and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. * @function * @param {Object|string} response - The [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} which contains the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property or the value of the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property (string) itself which should contain the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy. If a string is provided, tries to parse it as a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object. The &quot;headers&quot; property will be tried to be returned from it. * @param {boolean} [sanitize=true] - If it is set to true and the &quot;headers&quot; property is not found, it will return an empty object ({}) instead of returning null. * @returns {Object|null} Returns the content of the &quot;headers&quot; property if possible (it should be a {@link CB_Net.XHR.HEADERS} object). If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or an empty object ({}) otherwise. * @todo Consider adding the parameter &quot;headerNameFirst&quot;. */ CB_Net.XHR.getResponseHeaders = function(response, sanitize) //TODO: Add parameter headerNameFirst { if (typeof(sanitize) === &quot;undefined&quot; || sanitize === null) { sanitize = true; } //Sanitizes by default. var headers = CB_getJSONPropertyValue(response.responseText ? response.responseText : response, &quot;headers&quot;, null); if (sanitize &amp;&amp; headers === null) { return {}; } //If the property is not found or null and we want to sanitize, returns an empty object by default. return headers; //Can be NULL. } /** * Returns the [HTTP status]{@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Status} code from an [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} ([status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property) or from the info array generated by the [PHP]{@link https://en.wikipedia.org/wiki/PHP}'s [curl_getinfo]{@link http://php.net/manual/function.curl-getinfo.php} function (&quot;http_code&quot; index) or from the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy ([status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property). Useful to parse the response from the {@link CB_Net.XHR.callProxy} (or {@link CB_Net.XHR.callREST} and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. * @function * @param {Object|string} response - The [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} which contains the [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property or the value of the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property (string) itself which should contain the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy. If a string is provided, tries to parse it as a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object. The [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} property will be tried to be returned from it (or the &quot;http_code&quot; property as a fallback). * @param {boolean} [sanitize=true] - If it is set to true and neither the &quot;status&quot; nor the &quot;http_code&quot; property are found (or is not a number), it will return the value of &quot;statusDefault&quot; instead of returning null. * @param {boolean} [statusDefault=-1] - Default value to return when the status cannot be found (or is not a number). Only used when the &quot;sanitize&quot; parameter is set to true. * @returns {integer|*} Returns the content of the [status]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/status} (or &quot;http_code&quot;) property if possible (it should be an integer). If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or the value of &quot;statusDefault&quot; otherwise. */ CB_Net.XHR.getStatusCode = function(response, statusDefault, sanitize) { if (typeof(sanitize) === &quot;undefined&quot; || sanitize === null) { sanitize = true; } //Sanitizes by default. if (typeof(statusDefault) === &quot;undefined&quot; || statusDefault === null) { statusDefault = -1; } var statusCode = CB_getJSONPropertyValue(response, &quot;status&quot;, null); if (statusCode === null || isNaN(statusCode)) { statusCode = CB_getJSONPropertyValue(response, &quot;http_code&quot;, null); } if (sanitize &amp;&amp; (statusCode === null || isNaN(statusCode))) { return statusDefault; } //If the property is not found or null and we want to sanitize, returns -1 by default. return !isNaN(statusCode) ? parseInt(statusCode) : null; //Can be NULL. } /** * Returns the response content from an [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} (from its [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property) or from the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy ([response]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response} property). Useful to parse the response from the {@link CB_Net.XHR.callProxy} (or {@link CB_Net.XHR.callREST} and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. * @function * @param {Object|string} response - The [XHR object]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/XMLHttpRequest} which contains the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property or the value of the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property (string) itself which should contain the [JSON]{@link https://en.wikipedia.org/wiki/JSON} response generated by the &quot;getSslPage&quot; function used by the [PHP]{@link https://en.wikipedia.org/wiki/PHP} proxy. If a string is provided, tries to parse it as a [JSON]{@link https://en.wikipedia.org/wiki/JSON} object. The [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} property (or the [response]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response} property as a fallback) will be tried to be returned from it. * @param {boolean} [sanitize=true] - If it is set to true and neither the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} nor the [response]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response} properties are found, it will return an empty string (&quot;&quot;) instead of returning null. * @returns {string|null} Returns the content of the [responseText]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText} (or [response]{@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/response}) property if possible. If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or an empty string (&quot;&quot;) otherwise. */ CB_Net.XHR.getResponseContent = function(responseOrXHR, sanitize) { if (typeof(sanitize) === &quot;undefined&quot; || sanitize === null) { sanitize = true; } //Sanitizes by default. var response = null; try //Prevents the &quot;InvalidStateError: responseText is only available if responseType is '' or 'text'.&quot; error in Firefox. { response = CB_getJSONPropertyValue(responseOrXHR, &quot;responseText&quot;, responseOrXHR); } catch(E) {} response = CB_getJSONPropertyValue(response, &quot;response&quot;, response); if (sanitize &amp;&amp; response === null) { return &quot;&quot;; } //If the property is not found or null and we want to sanitize, returns an empty string by default. return response ? response : null; } } × Search results Close "},"CrossBase_input_CB_Pointer.js.html":{"id":"CrossBase_input_CB_Pointer.js.html","title":"Source: CrossBase/input/CB_Pointer.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/CB_Pointer.js /** * @file Pointer management. Contains the {@link CB_Pointer} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the pointer, using the [Pointer API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events} if available and falling back to internal emulation otherwise. It will return itself if it is tried to be instantiated. * @namespace */ var CB_Pointer = function() { return CB_Pointer; }; { //Events to emulate Pointer API in web clients that do not support it: CB_Pointer._eventEquivalents = { //Note: &quot;MSPointerHover&quot;, which was different from &quot;MSPointerOver&quot; (note the &quot;H&quot;) is deprecated and it does not have any equivalent now. pointerdown : { mouse: &quot;mousedown&quot;, touch: &quot;touchstart&quot;, IE : &quot;MSPointerDown&quot;, touchFired: false }, pointerup : { mouse: &quot;mouseup&quot;, touch: &quot;touchend&quot;, IE : &quot;MSPointerUp&quot;, touchFired: false }, pointercancel : { mouse: null, touch: &quot;touchcancel&quot;, IE : &quot;MSPointerCancel&quot;, touchFired: false }, pointerenter : { mouse: &quot;mouseenter&quot;, touch: null, IE : &quot;MSPointerEvent&quot;, touchFired: false }, pointerleave : { mouse: &quot;mouseleave&quot;, touch: null, IE : &quot;MSPointerLeave&quot;, touchFired: false }, pointerover : { mouse: &quot;mouseover&quot;, touch: null, IE : &quot;MSPointerOver&quot;, touchFired: false }, pointerout : { mouse: &quot;mouseout&quot;, touch: null, IE : &quot;MSPointerOut&quot;, touchFired: false }, pointermove : { mouse: &quot;mousemove&quot;, touch: &quot;touchmove&quot;, IE : &quot;MSPointerMove&quot;, touchFired: false }, gotpointercapture : { mouse : null, touch: null, IE : &quot;MSGotPointerCapture&quot;, touchFired: false }, lostpointercapture : { mouse : null, touch: null, IE : &quot;MSLostPointerCapture&quot;, touchFired: false } }; CB_Pointer._POINTER_TYPE_TOUCH = &quot;touch&quot;; CB_Pointer._POINTER_TYPE_MOUSE = &quot;mouse&quot;; CB_Pointer._POINTER_TYPE_PEN = &quot;pen&quot;; CB_Pointer.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Pointer.init = function() { if (CB_Pointer.initialized) { return CB_Pointer; } //The object has been initialized: CB_Pointer.initialized = true; //Creates aliases for the lock functions: CB_Pointer.isLockSupported = CB_Mouse.isLockSupported; CB_Pointer.isLocked = CB_Mouse.isLocked; CB_Pointer.wasLocked = CB_Mouse.wasLocked; CB_Pointer.getLockElement = CB_Mouse.getLockElement; CB_Pointer.lock = CB_Mouse.lock; CB_Pointer.unlock = CB_Mouse.unlock; CB_Pointer.onLockChange = CB_Mouse.onLockChange; CB_Pointer.onLockError = CB_Mouse.onLockError; //Normalizes some properties (if possible): if (navigator &amp;&amp; typeof(navigator.pointerEnabled) === &quot;undefined&quot;) { if (navigator.msPointerEnabled) { navigator.pointerEnabled = true; navigator.maxTouchPoints = navigator.msMaxTouchPoints; } //else { navigator.maxTouchPoints = 1; } //Assumes it is just capable to perform one touch at the same time. } //TODO. return CB_Pointer; } /** * Tries to return the given [pointer event]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the {@link CB_Events.normalize} function internally. Some properties added or affected could be &quot;POINTER_TYPE_TOUCH&quot;, &quot;POINTER_TYPE_MOUSE&quot;, &quot;POINTER_TYPE_PEN&quot;, &quot;[pointerId]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}&quot;, &quot;[pointerType]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType}&quot;, &quot;[pressure]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure}&quot;, &quot;[tangentialPressure]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tangentialPressure}&quot;, &quot;[tiltX]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX}&quot;, &quot;[tiltY]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY}&quot;, &quot;[width]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width}&quot;, &quot;[height]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height}&quot;, &quot;[currentTarget]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget}&quot;, &quot;[isPrimary]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary}&quot;, &quot;[twist]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/twist}&quot;, etc. * @function * @param {Event} e - Pointer event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). * @returns {Event} Returns the pointer event object normalized. * @todo Think about using Object.defineProperty with &quot;writable: true&quot; as option to prevent some web clients problems that have read only properties. * @todo Maybe e.width and e.height should be both 1 as default (?). */ CB_Pointer.normalizeEvent = function(e) { e = CB_Events.normalize(e); //NOTE: Think about using Object.defineProperty with writable: true as option to prevent some web clients problems that have readonly properties. if (typeof(e.POINTER_TYPE_TOUCH) === &quot;undefined&quot;) { e.POINTER_TYPE_TOUCH = CB_Pointer._POINTER_TYPE_TOUCH; } if (typeof(e.POINTER_TYPE_MOUSE) === &quot;undefined&quot;) { e.POINTER_TYPE_MOUSE = CB_Pointer._POINTER_TYPE_MOUSE; } if (typeof(e.POINTER_TYPE_PEN) === &quot;undefined&quot;) { e.POINTER_TYPE_PEN = CB_Pointer._POINTER_TYPE_PEN; } if (typeof(e.pointerType) === &quot;undefined&quot;) { if (typeof(e.screenX) !== &quot;undefined&quot;) { e.pointerType = e.POINTER_TYPE_TOUCH; } //Touch events have screenX property and mouse ones do not (unless I am wrong!). else { e.pointerType = e.POINTER_TYPE_MOUSE; } //Assumed a mouse event. } if (typeof(e.pressure) === &quot;undefined&quot;) { e.pressure = (typeof(e.force) !== &quot;undefined&quot; &amp;&amp; e.force !== null) ? e.force : CB_Touch.DEFAULT_FORCE; } if (typeof(e.tangentialPressure) === &quot;undefined&quot;) { e.tangentialPressure = 0; } //TODO: maybe it would be better to use e.pressure. if (typeof(e.twist) === &quot;undefined&quot;) { e.twist = 0; } if (typeof(e.tiltX) === &quot;undefined&quot;) { e.tiltX = 0; } if (typeof(e.tiltY) === &quot;undefined&quot;) { e.tiltY = 0; } if (typeof(e.width) === &quot;undefined&quot;) { e.width = 0; } //TODO: maybe e.width and e.height should be both 1 as default (?). if (typeof(e.height) === &quot;undefined&quot;) { e.height = 0; } if (typeof(e.currentTarget) === &quot;undefined&quot;) { e.currentTarget = e.target; } if (typeof(e.isPrimary) === &quot;undefined&quot;) { e.isPrimary = true; } if (typeof(e.pointerId) === &quot;undefined&quot;) { e.pointerId = 0; } return e; } /** * Sets the desired value for the CSS' style [pointer-events]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events} property of a given element. * @function * @param {Element} element - Element whose CSS' style &quot;[pointer-events]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events}&quot; property we want to edit. * @param {string} value - CSS code for the CSS' style &quot;[pointer-events]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events}&quot; property. * @param {boolean} [important=false] - If set to true, it will add the &quot; !important&quot; text to the &quot;[pointer-events]{@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events}&quot; property. */ CB_Pointer.setPointerEventsProperty = function(element, value, important) { try { value = CB_trim(value); value = (important &amp;&amp; value.toLowerCase().indexOf(&quot;!important&quot;) === -1) ? value + &quot; !important&quot; : value; element.style.pointerEvents = value; } catch(E) { CB_console(&quot;Cannot execute CB_Pointer.setPointerEventsProperty: &quot; + e); } } /** * Sets a function to execute when the &quot;[onPointerDown]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerdown}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onDown = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerdown&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the &quot;[onPointerUp]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerup}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onUp = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerup&quot;, callbackFunction, keepOldFunction, useCapture, target, true); } /** * Sets a function to execute when the &quot;[onPointerCancel]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointercancel}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onCancel = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointercancel&quot;, callbackFunction, keepOldFunction, useCapture, target, true); } /** * Sets a function to execute when the &quot;[onPointerEnter]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerenter}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onEnter = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerenter&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the &quot;[onPointerLeave]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerleave}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onLeave = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerleave&quot;, callbackFunction, keepOldFunction, useCapture, target, true); } /** * Sets a function to execute when the &quot;[onPointerOver]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerover}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onOver = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerover&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the &quot;[onPointerOut]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointerout}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onOut = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointerout&quot;, callbackFunction, keepOldFunction, useCapture, target, true); } /** * Sets a function to execute when the &quot;[onPointerMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onpointermove}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onMove = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;pointermove&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the &quot;[onGotPointerCapture]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/ongotpointercapture}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onGotPointCapture = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;gotpointercapture&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the &quot;[onLostPointerCapture]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onlostpointercapture}&quot; event is fired or removes it. More information: [Pointer events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Pointer.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Pointer.onLostPointCapture = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Pointer._setEvent(&quot;lostpointercapture&quot;, callbackFunction, keepOldFunction, useCapture, target, true); } //Sets a function to execute when a pointer event happens: CB_Pointer._lastRealPointerID = 0; CB_Pointer._currentPointerID = 0; CB_Pointer._currentPointerIDIncreased = false; CB_Pointer._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target, increasePointerID) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { target = document; } eventName = eventName.toLowerCase(); if (typeof(CB_Pointer._eventEquivalents[eventName]) === &quot;undefined&quot; || CB_Pointer._eventEquivalents[eventName] === null) { return false; } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { var oldEventName = null; var eventFunctionWrapper = function(e, increaseUnits) { e = CB_Pointer.normalizeEvent(e); increaseUnits = increaseUnits || 0; try { if (CB_trim(CB_Elements.getStyleProperty(target, &quot;pointerEvents&quot;, true)).toLowerCase().indexOf(&quot;none&quot;) !== -1) { return; } //Exists if the pointerEvents is &quot;none&quot;. } catch(E) {} e.usingEmulation = e.usingEmulation || false; e.typeReal = e.type; try { e.type = oldEventName || e.type; } catch(E) { } e.typeEmulated = oldEventName; //If it is a real pointer event, keeps the real pointer ID to use it: if (!e.usingEmulation) { CB_Pointer._currentPointerID = CB_Pointer._lastRealPointerID = e.pointerId; increaseUnits = 0; } //If the pointer is not used anymore (it is an event that cancels it), increases the pointer ID (for the next time): if (!increasePointerID) { CB_Pointer._currentPointerIDIncreased = false; } else if (!CB_Pointer._currentPointerIDIncreased &amp;&amp; !CB_Pointer._lastRealPointerID) //Only increases the pointer ID when there has never been a real one. { CB_Pointer._currentPointerID += increaseUnits; CB_Pointer._currentPointerIDIncreased = true; } if (typeof(eventFunction) === &quot;function&quot;) { return eventFunction(e); } return true; }; var newEventFunctionWrapper = null; //If the Pointer API is not supported: if (!navigator || !navigator.pointerEnabled || typeof(target.onpointerdown) === &quot;undefined&quot;) { //If the Pointer API is supported with the MS prefix (IE) and an equivalent event has been found: if (navigator &amp;&amp; navigator.msPointerEnabled &amp;&amp; typeof(target.onmspointerdown) !== &quot;undefined&quot; &amp;&amp; CB_Pointer._eventEquivalents[eventName].IE) { oldEventName = eventName; eventName = CB_Pointer._eventEquivalents[eventName].IE; } //...otherwise, uses emulation: else { //If the event can be emulated with a touch event: if (CB_Pointer._eventEquivalents[eventName].touch) { oldEventName = eventName; newEventFunctionWrapper = function(e) { CB_Pointer._eventEquivalents[eventName].touchFired = true; //Sets as already fired by a touch event. var returnValues = true; if (typeof(eventFunctionWrapper) === &quot;function&quot;) { //Dispatches the event for each touch: e = CB_Touch.normalizeEvent(e); for (var x = 0; x &lt; e.changedTouches.length; x++) { try { e.clientX = e.changedTouches[0].clientX; e.clientY = e.changedTouches[0].clientY; e.pageX = e.changedTouches[0].pageX; e.pageY = e.changedTouches[0].pageY; e.force = e.changedTouches[0].force; e.currentTarget = e.changedTouches[0].currentTarget;// || target; e.isPrimary = (x === 0); //Maybe this is not totally right! TODO: try to find out whether this is right or not. e.pointerId = CB_Pointer._currentPointerID + x; //(x + 1); //TODO: Think about this, maybe it should not be increased. e.pointerType = CB_Pointer._POINTER_TYPE_TOUCH; e.usingEmulation = true; returnValues = returnValues &amp;&amp; eventFunctionWrapper(e, 1); //TODO: see whether is possible to calculate tiltX and tiltY with radiusX, radiusY and rotationAngle. //TODO: calculate e.offsetX and e.offsetY from touch events. } catch(E) {} } } return returnValues; }; //If able, adds the function given to the emulation event: CB_Events.add(target, CB_Pointer._eventEquivalents[eventName].touch, newEventFunctionWrapper, useCapture, keepOldFunction, true); } //If the event can be emulated with a mouse event: if (CB_Pointer._eventEquivalents[eventName].mouse) { oldEventName = eventName; newEventFunctionWrapper = function(e) { //If a touch event already fired, deletes the event and exits: if (CB_Pointer._eventEquivalents[eventName].touchFired) { //Only deletes it if the defined touch and mouse events are different: if (CB_Pointer._eventEquivalents[eventName].mouse !== CB_Pointer._eventEquivalents[eventName].touch) { CB_Events.removeByName(target, CB_Pointer._eventEquivalents[eventName].mouse); } return true; } e = CB_Mouse.normalizeEvent(e); e.pointerId = CB_Pointer._currentPointerID; e.isPrimary = true; e.currentTarget = e.currentTarget || target; e.pointerType = CB_Pointer._POINTER_TYPE_MOUSE; e.usingEmulation = true; if (typeof(eventFunctionWrapper) === &quot;function&quot;) { return eventFunctionWrapper(e, 1); } return true; }; //If able, adds the function given to the emulation event: CB_Events.add(target, CB_Pointer._eventEquivalents[eventName].mouse, newEventFunctionWrapper, useCapture, keepOldFunction, true); } } } //If able, adds the function given to the event (only if no emulation event was defined before): if (typeof(newEventFunctionWrapper) !== &quot;function&quot;) { CB_Events.add(target, eventName, eventFunctionWrapper, useCapture, keepOldFunction, true); } } //...but if the function given is null, it will cancel the event: else if (eventFunction === null)// &amp;&amp; eventFunctionHolder !== null) { //If the Pointer API is not supported: if (!navigator || !navigator.pointerEnabled || typeof(target.onpointerdown) === &quot;undefined&quot;) { //If the Pointer API is supported with the MS prefix (IE) and an equivalent event has been found: if (navigator &amp;&amp; navigator.msPointerEnabled &amp;&amp; typeof(target.onmspointerdown) !== &quot;undefined&quot; &amp;&amp; CB_Pointer._eventEquivalents[eventName].IE) { CB_Events.removeByName(target, &quot;MS&quot; + CB_Pointer._eventEquivalents[eventName].IE); } //...otherwise, uses emulation: else { //If the event can be emulated with a touch event: if (CB_Pointer._eventEquivalents[eventName].touch) { CB_Events.removeByName(target, CB_Pointer._eventEquivalents[eventName].touch); } //If the event can be emulated with a mouse event: if (CB_Pointer._eventEquivalents[eventName].mouse) { CB_Events.removeByName(target, CB_Pointer._eventEquivalents[eventName].mouse); } } } CB_Events.removeByName(target, eventName); } } } × Search results Close "},"CrossBase_audiovisual_image_CB_Screen.js.html":{"id":"CrossBase_audiovisual_image_CB_Screen.js.html","title":"Source: CrossBase/audiovisual/image/CB_Screen.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/image/CB_Screen.js /** * @file Screen management. Contains the {@link CB_Screen} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the screen. It will return itself if it is tried to be instantiated. It can use [detect-zoom]{@link https://github.com/tombigel/detect-zoom} and [NoSleep.js]{@link https://github.com/richtr/NoSleep.js?utm_source=recordnotfound.com}. * @namespace */ var CB_Screen = function() { return CB_Screen; }; { CB_Screen._screenWidth = 0; //Screen width resolution. CB_Screen._screenHeight = 0; //Screen height resolution. CB_Screen._previousScreenWidth = 0; //Previous screen width resolution. CB_Screen._previousScreenHeight = 0; //Previous screen height resolution. CB_Screen._screenAvailableWidth = 0; //Screen available width resolution. CB_Screen._screenAvailableHeight = 0; //Screen available height resolution. CB_Screen._previousScreenAvailableWidth = 0; //Previous screen available width resolution. CB_Screen._previousScreenAvailableHeight = 0; //Previous screen available height resolution. CB_Screen._windowWidth = 0; //Window width resolution. CB_Screen._windowHeight = 0; //Window height resolution. CB_Screen._previousWindowWidth = 0; //Previous window width resolution. CB_Screen._previousWindowHeight = 0; //Previous window height resolution. CB_Screen._screenColorDepth = 0; //Screen color depth. CB_Screen._scrollLeft = null; //Left scroll value. CB_Screen._scrollTop = null; //Top scroll value. CB_Screen._previousScrollLeft = null; //Previous left scroll value. CB_Screen._previousScrollTop = null; //Previous top scroll value. CB_Screen._zoom = 1; //Zoom applied to the web. CB_Screen._pixelRatio = 1; //Pixel ratio multiplied by the zoom. CB_Screen._previousZoom = 0; //Zoom applied to the web. CB_Screen._previousPixelRatio = 0; //Pixel ratio multiplied by the zoom. CB_Screen._isLandscape = null; //Tells whether web is displayed in landscape or portrait position. CB_Screen._isVisible = null; //Tells whether web is visible or not. CB_Screen._isFocused = null; //Tells whether web is focused or not (has lost the focus). CB_Screen._isFullScreen = null; //Tells whether full screen mode is enabled or not. CB_Screen._screenLock = null; //Keeps the MozWakeLock object to be able to release the lock related with the screen (so far, only works in Firefox/Firefox OS). CB_Screen._noSleep = null; //Keeps the last NoSleep object for the NoSleep.js library. CB_Screen._noSleepEnabled = false; //Boolean to keeps the status of the noSleep.js object (enabled or disabled). CB_Screen._eventsHolder = {}; //Keeps the functions to fire for every special event (if any). /* CB_Screen.onResizeFunction; //Function that is executed when window is resized (onResize event). CB_Screen.onScrollLeftFunction; //Function that is executen when scroll left is changed. CB_Screen.onScrollTopFunction; //Function that is executen when scroll top is changed. CB_Screen.onVisibilityChangeFunction; //Function that is executed when window gets or losts the visibility. CB_Screen.onFocusChangeFunction; //Function that is executed when window gets or losts the focus. CB_Screen.onResizeOrZoomFunction; //Function that is executed when window is resized or zoom is applied. CB_Screen.onOrientationChangeFunction; //Function that is executed when orientation changes (landscape or portrait). CB_Screen.onFullScreenChangeFunction; //Function that is executed when full screen mode changes. */ CB_Screen._storedScreenWidth = 0; //Old screen available width resolution (internal use only). CB_Screen._storedScreenHeight = 0; //Old screen available height resolution (internal use only). CB_Screen._storedScreenAvailableWidth = 0; //Old screen available width resolution (internal use only). CB_Screen._storedScreenAvailableHeight = 0; //Old screen available height resolution (internal use only). CB_Screen._storedWindowWidth = 0; //Old window width resolution (internal use only). CB_Screen._storedWindowHeight = 0; //Old window height resolution (internal use only). CB_Screen._storedZoom = 0; //Zoom applied to the web. CB_Screen._storedPixelRatio = 0; //Pixel ratio multiplied by the zoom. CB_Screen._refreshTimeout = null; //It will store the timeout that refresh screen properties all the time. CB_Screen.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Screen.init = function() { if (CB_Screen.initialized) { return CB_Screen; } //Sets that the object has already been initialized: CB_Screen.initialized = true; //Stores first values for both old window width and height: CB_Screen._storedScreenWidth = CB_Screen._screenWidth; CB_Screen._storedScreenHeight = CB_Screen._screenHeight; CB_Screen._storedScreenAvailableWidth = CB_Screen._screenAvailableWidth; CB_Screen._storedScreenAvailableHeight = CB_Screen._screenAvailableHeight; CB_Screen._storedWindowWidth = CB_Screen._windowWidth; CB_Screen._storedWindowHeight = CB_Screen._windowHeight; //It also stores for both zoom level and pixel ratio: CB_Screen._storedZoom = CB_Screen._zoom; CB_Screen._storedPixelRatio = CB_Screen._pixelRatio; //Sets the handler for the scroll event: CB_Events.add(window, &quot;scroll&quot;, function() { CB_Screen.getScrollTop(); CB_Screen.getScrollLeft(); }, true, true, false); //It will check all the time if visibility changes: CB_Screen._isVisible = true; //By default, window is visible. NOTE: this can produce a false positive if the script is loading being not visible. if (&quot;hidden&quot; in document) { CB_Events.add(document, &quot;visibilitychange&quot;, CB_Screen._visibilityChanged, true, true, false); } //document.addEventListener(&quot;visibilitychange&quot;, CB_Screen._visibilityChanged); } else if (&quot;mozHidden&quot; in document) { CB_Events.add(document, &quot;mozvisibilitychange&quot;, CB_Screen._visibilityChanged, true, true, false); } //document.addEventListener(&quot;mozvisibilitychange&quot;, CB_Screen._visibilityChanged); } else if (&quot;webkitHidden&quot; in document) { CB_Events.add(document, &quot;webkitvisibilitychange&quot;, CB_Screen._visibilityChanged, true, true, false); } //document.addEventListener(&quot;webkitvisibilitychange&quot;, CB_Screen._visibilityChanged); } else if (&quot;msHidden&quot; in document) { CB_Events.add(document, &quot;msvisibilitychange&quot;, CB_Screen._visibilityChanged, true, true, false); } // document.addEventListener(&quot;msvisibilitychange&quot;, CB_Screen._visibilityChanged); } //else if (&quot;onfocusin&quot; in document) { document.onfocusin = document.onfocusout = CB_Screen._visibilityChanged; } //else if (&quot;onfocusin&quot; in document) { document.onfocusin = document.onfocusout = function() { CB_Screen._visibilityChanged(); CB_Screen._focusChanged(); } } //else { window.onfocus = window.onblur = CB_Screen._visibilityChanged; } //else { window.onfocus = window.onblur = function() { CB_Screen._visibilityChanged(); CB_Screen._focusChanged(); } } //It will check all the time if focus changes: CB_Screen._isFocused = true; //By default, window is focused. NOTE: this can produce a false positive if the script is loading being not visible. var focusOrBlurEventWorks = false; try //Using catch due some web clients doesn't allow to manipulate the window object of parent iframes: { CB_Events.add(CB_Client.getWindow(), &quot;focus&quot;, function() { focusOrBlurEventWorks = true; CB_Screen._focusChanged(true); }, true, true, false); CB_Events.add(CB_Client.getWindow(), &quot;blur&quot;, function() { focusOrBlurEventWorks = true; CB_Screen._focusChanged(false); }, true, true, false); } catch(E) { CB_Events.add(window, &quot;focus&quot;, function() { focusOrBlurEventWorks = true; CB_Screen._focusChanged(true); }, true, true, false); CB_Events.add(window, &quot;blur&quot;, function() { focusOrBlurEventWorks = true; CB_Screen._focusChanged(false); }, true, true, false); } CB_Events.add(document, &quot;mousedown&quot;, function() { if (focusOrBlurEventWorks) { return; } CB_Screen._focusChanged(true); }, true, true, false); //Mouse click will set focus too (IE8 fix). CB_Events.add(document, &quot;click&quot;, function() { if (focusOrBlurEventWorks) { return; } CB_Screen._focusChanged(true); }, true, true, false); //Click will set focus too (IE8 fix). //CB_Events.add(document, &quot;keydown&quot;, function() { if (focusOrBlurEventWorks) { return; } CB_Screen._focusChanged(true); }, true, true, false); //Key down event will set focus too (IE8 fix). //CB_Events.add(document, &quot;mousemove&quot;, function() { if (focusOrBlurEventWorks) { return; } CB_Screen._focusChanged(true); }, true, true, false); //Mouse movemenet will set focus too (IE8 fix). //Starts running the loop: CB_Screen._mainLoop(); return CB_Screen; } //Loop to watch the screen changes: CB_Screen._mainLoop = function() { //Cancels the timeout (if any): clearTimeout(CB_Screen._refreshTimeout); CB_Screen.getWidth(); //Defines screen width resolution. CB_Screen.getHeight(); //Defines screen height resolution. CB_Screen.getWidthPrevious(); //Defines previous window width resolution. CB_Screen.getHeightPrevious(); //Defines previous window height resolution. CB_Screen.getAvailableWidth(); //Defines screen available width resolution. CB_Screen.getAvailableHeight(); //Defines screen available height resolution. CB_Screen.getAvailableWidthPrevious(); //Defines previous window width resolution. CB_Screen.getAvailableHeightPrevious(); //Defines previous window height resolution. CB_Screen.getWindowWidth(); //Defines window width resolution. CB_Screen.getWindowHeight(); //Defines window height resolution. CB_Screen.getWindowWidthPrevious(); //Defines previous window width resolution. CB_Screen.getWindowHeightPrevious(); //Defines previous window height resolution. CB_Screen.getColorDepth(); //Defines screen color depth. //CB_Screen.getScrollLeft(); //Defines scroll left (and executes defined function if it changes). //CB_Screen.getScrollTop(); //Defines scroll top (and executes defined function if it changes). CB_Screen.getZoom(); //Defines zoom level. CB_Screen.getPixelRatio(); //Defines pixel ratio multiplied by the zoom level. CB_Screen.isLandscape(); //Defines whether device is in landscape or portrait position (and executes defined function if it changes). CB_Screen.isFullScreen(); //Defines whether it's in full screen mode or not (and executes defined function if it changes). //Executes the function defined for Resize and Zoom events (if any): CB_Screen._processOnResizeOrZoomFunction(); //Executes the function defined for Full screen change event (if any): //CB_Screen.onFullScreenChangeFunction(CB_Screen.onFullScreenChangeFunction, false); //Executes the function again: CB_Screen._refreshTimeout = setTimeout(CB_Screen._mainLoop, 1); //Calls itself again to update values all the time. } /** * Gets the current screen width (horizontal resolution). Uses the [window.screen.width]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/width} property internally, when possible. * @function * @returns {number} Returns the current screen width (horizontal resolution) in pixels. */ CB_Screen.getWidth = function() { if (screen &amp;&amp; screen.width &amp;&amp; !isNaN(screen.width)) { CB_Screen._screenWidth = screen.width; } return CB_Screen._screenWidth; } /** * Gets the current screen height (vertical resolution). Uses the [window.screen.height]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/height} property internally, when possible. * @function * @returns {number} Returns the current screen height (vertical resolution) in pixels. */ CB_Screen.getHeight = function() { if (screen &amp;&amp; screen.height &amp;&amp; !isNaN(screen.height)) { CB_Screen._screenHeight = screen.height; } return CB_Screen._screenHeight; } /** * Gets the previous screen width (horizontal resolution). Calculated through the [window.screen.width]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/width} property internally, when possible. Useful when the resolution (screen size and/or orientation) changed. * @function * @returns {number} Returns the previous screen width (horizontal resolution) in pixels. */ CB_Screen.getWidthPrevious = function() { if (CB_Screen._previousScreenWidth === 0) { CB_Screen._previousScreenWidth = CB_Screen.getWidth(); } return CB_Screen._previousScreenWidth; } /** * Gets the previous screen height (vertical resolution). Calculated through the [window.screen.height]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/height} property internally, when possible. Useful when the resolution (screen size and/or orientation) changed. * @function * @returns {number} Returns the previous screen height (vertical resolution) in pixels. */ CB_Screen.getHeightPrevious = function() { if (CB_Screen._previousScreenHeight === 0) { CB_Screen._previousScreenHeight = CB_Screen.getHeight(); } return CB_Screen._previousScreenHeight; } /** * Gets the current available screen width (horizontal resolution). Uses the [window.screen.availWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/availWidth} property internally, when possible. * @function * @returns {number} Returns the current available screen width (horizontal resolution) in pixels. */ CB_Screen.getAvailableWidth = function() { if (screen &amp;&amp; screen.availWidth &amp;&amp; !isNaN(screen.availWidth)) { CB_Screen._screenAvailableWidth = screen.availWidth; } return CB_Screen._screenAvailableWidth; } /** * Gets the current available screen height (vertical resolution). Uses the [window.screen.availHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/availHeight} property internally, when possible. * @function * @returns {number} Returns the current available screen height (vertical resolution) in pixels. */ CB_Screen.getAvailableHeight = function() { if (screen &amp;&amp; screen.availHeight &amp;&amp; !isNaN(screen.availHeight)) { CB_Screen._screenAvailableHeight = screen.availHeight; } return CB_Screen._screenAvailableHeight; } /** * Gets the previous available screen width (horizontal resolution). Useful when the resolution (screen size and/or orientation) changed. Uses the [window.screen.availWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/availWidth} property internally, when possible. * @function * @returns {number} Returns the previous available screen width (horizontal resolution) in pixels. */ CB_Screen.getAvailableWidthPrevious = function() { if (CB_Screen._previousScreenAvailableWidth === 0) { CB_Screen._previousScreenAvailableWidth = CB_Screen.getAvailableWidth(); } return CB_Screen._previousScreenAvailableWidth; } /** * Gets the previous available screen height (vertical resolution). Useful when the resolution (screen size and/or orientation) changed. Uses the [window.screen.availHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/availHeight} property internally, when possible. * @function * @returns {number} Returns the previous available screen height (vertical resolution) in pixels. */ CB_Screen.getAvailableHeightPrevious = function() { if (CB_Screen._previousScreenAvailableHeight === 0) { CB_Screen._previousScreenAvailableHeight = CB_Screen.getAvailableHeight(); } return CB_Screen._previousScreenAvailableHeight; } /** * Gets the current window width (horizontal resolution). Internally, uses the [window.innerWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth} if possible and fallbacks to [document.documentElement.clientWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth} or [document.body.clientWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth} property otherwise, when possible. * @function * @returns {number} Returns the current window width (horizontal resolution) in pixels. */ CB_Screen.getWindowWidth = function() { if (window &amp;&amp; window.innerWidth &amp;&amp; !isNaN(window.innerWidth)) { CB_Screen._windowWidth = window.innerWidth; } else if (document &amp;&amp; document.documentElement &amp;&amp; document.documentElement.clientWidth &amp;&amp; !isNaN(document.documentElement.clientWidth) &amp;&amp; document.documentElement.clientWidth &gt; 0) { CB_Screen._windowWidth = document.documentElement.clientWidth; } else if (document &amp;&amp; document.body &amp;&amp; document.body.clientWidth &amp;&amp; !isNaN(document.body.clientWidth) &amp;&amp; document.body.clientWidth &gt; 0) { CB_Screen._windowWidth = document.body.clientWidth; } return CB_Screen._windowWidth; } /** * Gets the current window height (vertical resolution). Internally, uses the [window.innerHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight} if possible and fallbacks to [document.documentElement.clientHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight} or [document.body.clientHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight} property otherwise, when possible. * @function * @returns {number} Returns the current window height (vertical resolution) in pixels. */ CB_Screen.getWindowHeight = function() { if (window &amp;&amp; window.innerHeight &amp;&amp; !isNaN(window.innerHeight)) { CB_Screen._windowHeight = window.innerHeight; } else if (document &amp;&amp; document.documentElement &amp;&amp; document.documentElement.clientHeight &amp;&amp; !isNaN(document.documentElement.clientHeight) &amp;&amp; document.documentElement.clientHeight &gt; 0) { CB_Screen._windowHeight = document.documentElement.clientHeight; } else if (document &amp;&amp; document.body &amp;&amp; document.body.clientHeight &amp;&amp; !isNaN(document.body.clientHeight) &amp;&amp; document.body.clientHeight &gt; 0) { CB_Screen._windowHeight = document.body.clientHeight; } return CB_Screen._windowHeight; } /** * Gets the previous window width (horizontal resolution). Useful when the resolution (screen size and/or orientation) or window size changed. Internally, uses the [window.innerWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth} if possible and fallbacks to [document.documentElement.clientWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth} or [document.body.clientWidth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth} property otherwise, when possible. * @function * @returns {number} Returns the previous window width (horizontal resolution) in pixels. */ CB_Screen.getWindowWidthPrevious = function() { if (CB_Screen._previousWindowWidth === 0) { CB_Screen._previousWindowWidth = CB_Screen.getWindowWidth(); } return CB_Screen._previousWindowWidth; } /** * Gets the previous window height (vertical resolution). Useful when the resolution (screen size and/or orientation) or window size changed. Internally, uses the [window.innerHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight} if possible and fallbacks to [document.documentElement.clientHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight} or [document.body.clientHeight]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight} property otherwise, when possible. * @function * @returns {number} Returns the previous window height (vertical resolution) in pixels. */ CB_Screen.getWindowHeightPrevious = function() { if (CB_Screen._previousWindowHeight === 0) { CB_Screen._previousWindowHeight = CB_Screen.getWindowHeight(); } return CB_Screen._previousWindowHeight; } /** * Gets the current color depth. Uses the [window.screen.colorDepth]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/colorDepth} property internally, when possible. * @function * @returns {number} Returns the current color depth. */ CB_Screen.getColorDepth = function() { if (screen &amp;&amp; screen.colorDepth &amp;&amp; !isNaN(screen.colorDepth)) { CB_Screen._screenColorDepth = screen.colorDepth; } return CB_Screen._screenColorDepth; } /** * Gets the current scroll left position (horizontal scroll) of the screen (main window). Uses the {@link CB_Elements.getScrollLeftById} function internally. * @function * @returns {number|null} Returns the current scroll left position (horizontal scroll) of the screen (main window). It could return null if something fails. */ CB_Screen.getScrollLeft = function() { CB_Screen._previousScrollLeft = CB_Screen._scrollLeft; return CB_Elements.getScrollLeftById ( window, //elementId function(scrollLeft, scrollLeftPrevious, scrollWidth, visiblePixels, scrollRelative, scrollRelativePrevious) //onScrollLeftChanges: { //If there is any defined function: if (typeof(CB_Screen._eventsHolder[&quot;onScrollLeft&quot;]) === &quot;function&quot;) { //Sets the new and old positions (just in case the function needs it): CB_Screen._previousScrollLeft = CB_Screen._scrollLeft; CB_Screen._scrollLeft = scrollLeft; //Executes the function: CB_Screen._eventsHolder[&quot;onScrollLeft&quot;](); } }, true, //fireFirstTime false, //fireAlways null, //timeoutMs true, //returnNullOnFail undefined //timeout ); } /** * Gets the current scroll top position (vertical scroll) of the screen (main window). Uses the {@link CB_Elements.getScrollTopById} function internally. * @function * @returns {number|null} Returns the current scroll top position (vertical scroll) of the screen (main window). It could return null if something fails. */ CB_Screen.getScrollTop = function() { CB_Screen._previousScrollTop = CB_Screen._scrollTop; return CB_Elements.getScrollTopById ( window, //elementId function(scrollTop, scrollTopPrevious, scrollHeight, visiblePixels, scrollRelative, scrollRelativePrevious) //onScrollTopChanges: { //If there is any defined function: if (typeof(CB_Screen._eventsHolder[&quot;onScrollTop&quot;]) === &quot;function&quot;) { //Sets the new and old positions (just in case the function needs it): CB_Screen._previousScrollTop = CB_Screen._scrollTop; CB_Screen._scrollTop = scrollTop; //Executes the function: CB_Screen._eventsHolder[&quot;onScrollTop&quot;](); } }, true, //fireFirstTime false, //fireAlways null, //timeoutMs true, //returnNullOnFail undefined //timeout ); } /** * Gets the current zoom level of the screen (main window). Uses [detect-zoom]{@link https://github.com/tombigel/detect-zoom} internally. * @function * @returns {number} Returns the current zoom level of the screen (main window). Default zoom level is 1 (one) even when it fails. * @todo Find a better and more-compatible way to detect zoom which supports as many web clients as possible. */ CB_Screen.getZoom = function() { //if (typeof(detectZoom) !== &quot;undefined&quot; &amp;&amp; detectZoom !== null &amp;&amp; detectZoom &amp;&amp; typeof(detectZoom.zoom) !== &quot;undefined&quot; &amp;&amp; detectZoom.zoom !== null &amp;&amp; detectZoom.zoom &amp;&amp; typeof(detectZoom.zoom) === &quot;function&quot;) if (typeof(detectZoom) !== &quot;undefined&quot; &amp;&amp; detectZoom !== null &amp;&amp; typeof(detectZoom.zoom) === &quot;function&quot;) { CB_Screen._zoom = detectZoom.zoom(); //if (CB_Screen._zoom === null || CB_Screen._zoom === 0 || !CB_Screen._zoom) { CB_Screen._zoom = 1; } if (!CB_Screen._zoom) { CB_Screen._zoom = 1; } //} else { CB_Screen._zoom = CB_Screen._previousZoom = 0; } } else { CB_Screen._zoom = CB_Screen._previousZoom = 1; } return CB_Screen._zoom; } /** * Gets the previous zoom level of the screen (main window). Useful when the zoom changed. Uses [detect-zoom]{@link https://github.com/tombigel/detect-zoom} internally. * @function * @returns {number} Returns the previous zoom level of the screen (main window). Default previous zoom level is 0 (zero) even when it fails. */ CB_Screen.getZoomPrevious = function() { return CB_Screen._previousZoom; } /** * Gets the current pixel ratio of the screen (main window). Uses [detect-zoom]{@link https://github.com/tombigel/detect-zoom} internally. * @function * @returns {number} Returns the current pixel ratio of the screen (main window). Default pixel ratio is 1 (one) even when it fails. * @todo Find a better and more-compatible way to detect pixel ratio which supports as many web clients as possible. */ CB_Screen.getPixelRatio = function() { //if (typeof(detectZoom) !== &quot;undefined&quot; &amp;&amp; detectZoom !== null &amp;&amp; detectZoom &amp;&amp; typeof(detectZoom.device) !== &quot;undefined&quot; &amp;&amp; detectZoom.device !== null &amp;&amp; detectZoom.device &amp;&amp; typeof(detectZoom.device) === &quot;function&quot;) if (typeof(detectZoom) !== &quot;undefined&quot; &amp;&amp; detectZoom !== null &amp;&amp; typeof(detectZoom.device) === &quot;function&quot;) { CB_Screen._pixelRatio = detectZoom.device(); //} else { CB_Screen._pixelRatio = CB_Screen._previousPixelRatio = 0; } //if (CB_Screen._pixelRatio === null || CB_Screen._pixelRatio === 0 || !CB_Screen._pixelRatio) { CB_Screen._pixelRatio = 1; } if (!CB_Screen._pixelRatio) { CB_Screen._pixelRatio = 1; } } else { CB_Screen._pixelRatio = CB_Screen._previousPixelRatio = 1; } return CB_Screen._pixelRatio; } /** * Gets the previous pixel ratio of the screen (main window). Useful when the zoom/pixel-ratio changed. Uses [detect-zoom]{@link https://github.com/tombigel/detect-zoom} internally. * @function * @returns {number} Returns the previous pixel ratio of the screen (main window). Default previous pixel ratio is 0 (zero) even when it fails. * @todo Find a better and more-compatible way to detect pixel ratio which supports as many web clients as possible. */ CB_Screen.getPixelRatioPrevious = function() { return CB_Screen._previousPixelRatio; } /** * Tells whether the screen (main window) is in landscape position. * @function * @returns {boolean} Returns whether the screen is in landscape position. */ CB_Screen.isLandscape = function() { var isLandscape = false; if (CB_Screen.getWindowWidth() &gt; CB_Screen.getWindowHeight()) { isLandscape = true; } //If it's not the first time and position has been changed, calls the onOrientationChange function (if any): if (CB_Screen._isLandscape !== null &amp;&amp; CB_Screen._isLandscape !== isLandscape) { //If there is any defined function: if (typeof(CB_Screen._eventsHolder[&quot;onOrientationChange&quot;]) === &quot;function&quot;) { //Sets the new position (just in case the function needs it): CB_Screen._isLandscape = isLandscape; //Executes the function: CB_Screen._eventsHolder[&quot;onOrientationChange&quot;](); } } //Sets the new position: CB_Screen._isLandscape = isLandscape; return CB_Screen._isLandscape; } //Sets whether the web is visible (called every time that visibility changes): CB_Screen._visibilityChanged = function(e) { var isVisible = true; //By default is visible. //if (!e) { e = window.event; } e = CB_Events.normalize(e); // if (e.type === &quot;focus&quot; || e.type === &quot;focusin&quot;) { // isVisible = true; } // else if (e.type === &quot;blur&quot; || e.type === &quot;focusout&quot;) { // isVisible = false; } // else { var hidden = &quot;&quot;; if (typeof(document.hidden) !== &quot;undefined&quot;) { hidden = &quot;hidden&quot;; } else if (typeof(document.mozHidden) !== &quot;undefined&quot;) { hidden = &quot;mozHidden&quot;; } else if (typeof document.msHidden !== &quot;undefined&quot;) { hidden = &quot;msHidden&quot;; } else if (typeof document.webkitHidden !== &quot;undefined&quot;) { hidden = &quot;webkitHidden&quot;; } //if (hidden !== &quot;&quot;) { isVisible = document[hidden] ? false : true; } if (hidden !== &quot;&quot;) { isVisible = !document[hidden]; } } //Calls the onVisibilityChange function (if any): if (typeof(CB_Screen._eventsHolder[&quot;onVisibilityChange&quot;]) === &quot;function&quot;) { //Sets the new visibility (just in case the function needs it): CB_Screen._isVisible = isVisible; //Executes the function: CB_Screen._eventsHolder[&quot;onVisibilityChange&quot;](); } //Sets the new visibility: CB_Screen._isVisible = isVisible; } /** * Tells whether the main window is visible or not. * @function * @returns {boolean} Returns whether the main window is visible or not. */ CB_Screen.isVisible = function() { return CB_Screen._isVisible; } /* //Called every time that focus is lost: CB_Screen.focusLost = function() { //Focus has not been recovered (yet): CB_Screen.focusRecovered = false; //If focus is not recovered, set as not focused: setTimeout( function() { if (!CB_Screen.focusRecovered) { CB_Screen._focusChanged(false); } }, 500); return; } */ //Sets whether the web is focused (called every time that focus changes): CB_Screen._focusChanged = function(isFocused) { //If is focused, the focus has been recovered: //if (isFocused) { CB_Screen.focusRecovered = true; } //Calls the onFocusChange function (if any): if (typeof(CB_Screen._eventsHolder[&quot;onFocusChange&quot;]) === &quot;function&quot;) { //Sets whether is focused or not (just in case the function needs it): CB_Screen._isFocused = isFocused; //Executes the function: CB_Screen._eventsHolder[&quot;onFocusChange&quot;](); } //Sets whether is focused or not: CB_Screen._isFocused = isFocused; } /** * Tells whether the main window is focused or not. * @function * @returns {boolean} Returns whether the main window is focused or not. */ CB_Screen.isFocused = function() { return CB_Screen._isFocused; } /** * Sets the focus to the main window (if possible). * @function */ CB_Screen.focus = function() { //try { CB_Client.getWindow(true).focus(); } catch(E) {} CB_Client.getWindow(false).focus(); } /** * Sets a function to execute when the left scroll position (horizontal scroll) is changed in the screen (main window) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onScrollLeft = function(callbackFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onScrollLeft&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when the top scroll position (vertical scroll) is changed in the screen (main window) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onScrollTop = function(callbackFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onScrollTop&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when the screen (main window) orientation is changed (portrait or landscape) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onOrientationChange = function(callbackFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onOrientationChange&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when the screen (main window) visibility is changed or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onVisibilityChange = function(callbackFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onVisibilityChange&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when the screen (main window) focus is changed or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onFocusChange = function(callbackFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onFocusChange&quot;, callbackFunction, keepOldFunction); } /** * Sets a function to execute when the screen (main window) is resized ([onResize]{@link https://developer.mozilla.org/en-US/docs/Web/Events/resize} event) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onResize = function(callbackFunction, keepOldFunction, useCapture) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. //If a function has been sent: if (typeof(callbackFunction) === &quot;function&quot;) { //If able, adds the function given to the event: var functionToAdd = function() { CB_Screen.init(); //Updates screen properties. if (typeof(callbackFunction) === &quot;function&quot;) { return callbackFunction(); } return true; }; ///////CB_Screen._eventsHolder[&quot;onResize&quot;] = functionToAdd; CB_Events.add(window, &quot;resize&quot;, functionToAdd, useCapture, keepOldFunction, true); } //...but if the function given is null, it will cancel the event: else if (callbackFunction === null)/////// &amp;&amp; CB_Screen._eventsHolder[&quot;onResize&quot;] !== null) { //CB_Events.remove(window, &quot;resize&quot;, CB_Screen._eventsHolder[&quot;onResize&quot;], useCapture); CB_Events.removeByName(window, &quot;resize&quot;); ////////CB_Screen._eventsHolder[&quot;onResize&quot;] = null; } } //Sets a function to execute when window is resized or zoom is applied: CB_Screen._processOnResizeOrZoomFunction = function() { //If there is no function to process, exits: if (typeof(CB_Screen._eventsHolder[&quot;onResizeOrZoom&quot;]) !== &quot;function&quot;) { return; } //If this is the first time, set stored values: if (CB_Screen._storedScreenWidth === 0) { CB_Screen._storedScreenWidth = CB_Screen.getWidth(); } if (CB_Screen._storedScreenHeight === 0) { CB_Screen._storedScreenHeight = CB_Screen.getHeight(); } if (CB_Screen._storedScreenAvailableWidth === 0) { CB_Screen._storedScreenAvailableWidth = CB_Screen.getAvailableWidth(); } if (CB_Screen._storedScreenAvailableHeight === 0) { CB_Screen._storedScreenAvailableHeight = CB_Screen.getAvailableHeight(); } if (CB_Screen._storedWindowWidth === 0) { CB_Screen._storedWindowWidth = CB_Screen.getWindowWidth(); } if (CB_Screen._storedWindowHeight === 0) { CB_Screen._storedWindowHeight = CB_Screen.getWindowHeight(); } if (CB_Screen._storedZoom === 0) { CB_Screen._storedZoom = CB_Screen.getZoom(); } if (CB_Screen._storedPixelRatio === 0) { CB_Screen._storedPixelRatio = CB_Screen.getPixelRatio(); } //If the window has been resized or zoomed, stores the previous values: var windowResizedOrZoomed = false; if (CB_Screen._storedWindowWidth !== CB_Screen.getWindowWidth() || CB_Screen._storedWindowHeight !== CB_Screen.getWindowHeight() || CB_Screen._storedZoom !== CB_Screen.getZoom() || CB_Screen._storedPixelRatio !== CB_Screen.getPixelRatio()) { //Window has been resized or zoomed: windowResizedOrZoomed = true; //Stores the previous width and height: CB_Screen._previousWindowWidth = CB_Screen._storedWindowWidth; CB_Screen._previousWindowHeight = CB_Screen._storedWindowHeight; CB_Screen._previousScreenWidth = CB_Screen._storedScreenWidth; CB_Screen._previousScreenHeight = CB_Screen._storedScreenHeight; CB_Screen._previousScreenAvailableWidth = CB_Screen._storedScreenAvailableWidth; CB_Screen._previousScreenAvailableHeight = CB_Screen._storedScreenAvailableHeight; //If the zoom has been changed, stores the previous zoom and pixel ratio: if (CB_Screen._storedZoom !== CB_Screen.getZoom() || CB_Screen._storedPixelRatio !== CB_Screen.getPixelRatio()) { CB_Screen._previousZoom = CB_Screen._storedZoom; CB_Screen._previousPixelRatio = CB_Screen._storedPixelRatio; } //Stores the current window width and height: CB_Screen._storedScreenWidth = CB_Screen.getWidth(); CB_Screen._storedScreenHeight = CB_Screen.getHeight(); CB_Screen._storedScreenAvailableWidth = CB_Screen.getAvailableWidth(); CB_Screen._storedScreenAvailableHeight = CB_Screen.getAvailableHeight(); CB_Screen._storedWindowWidth = CB_Screen.getWindowWidth(); CB_Screen._storedWindowHeight = CB_Screen.getWindowHeight(); //Stores the current zoom and pixel ratio: CB_Screen._storedZoom = CB_Screen.getZoom(); CB_Screen._storedPixelRatio = CB_Screen.getPixelRatio(); } //If the window has been resized or zoomed, executes the function: if (windowResizedOrZoomed) { CB_Screen.init(); //It also refresh CB_Screen properties before calling the function. CB_Screen._eventsHolder[&quot;onResizeOrZoom&quot;](); //Executes the function. } } /** * Sets a function to execute when the screen (main window) is resized or the zoom is changed, or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onResizeOrZoom = function(onResizeOrZoomFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onResizeOrZoom&quot;, onResizeOrZoomFunction, keepOldFunction); } /** * Sets a function to execute when full screen mode is changed (enabled or disabled) or removes it. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. */ CB_Screen.onFullScreenChange = function(onFullScreenChangeFunction, keepOldFunction) { return CB_Screen._setSpecialEventFunction(&quot;onFullScreenChange&quot;, onFullScreenChangeFunction, keepOldFunction); } //Sets a function to execute when an event happens (a non-existing event on JavaScript): CB_Screen._setSpecialEventFunction = function(eventName, eventFunction, keepOldFunction) { //If no function has been sent, cancel all previous functions and exits: if (typeof(eventFunction) !== &quot;function&quot;) { if (eventFunction === null) { CB_Screen._eventsHolder[eventName] = null; } return; } //If not set, it keeps old function by default: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If we don't want to keep the old function: if (!keepOldFunction) { CB_Screen._eventsHolder[eventName] = eventFunction; } //...otherwise if we want to keep the old function, we keep it: else { //Stores old function: var eventFunctionOld = CB_Screen._eventsHolder[eventName]; //Stores old function of eventFunctionHolder. CB_Screen._eventsHolder[eventName] = function() //TODO: remember to use &quot;e&quot; in the case it uses parameters in the future. { if (typeof(eventFunctionOld) === &quot;function&quot;) { eventFunctionOld(); } eventFunction(); }; } } /** * Tells whether the web client is compatible with the [FullScreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} or not. * @function * @returns {boolean} Returns whether the web client is compatible with the [FullScreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} or not. */ CB_Screen.isFullScreenAPICompatible = function() { if (document.documentElement) { element = document.documentElement; } else { element = document.body; } var isFullScreenAPICompatible = false; //Gets the function compatible with Fullscreen API (if any): var callFullScreen = element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.oRequestFullScreen || element.msRequestFullscreen || element.msRequestFullScreen || element.webkitEnterFullScreen || element.webkitEnterFullscreen; if (typeof(callFullScreen) !== &quot;undefined&quot; &amp;&amp; callFullScreen) { isFullScreenAPICompatible = true; } return isFullScreenAPICompatible; } /** * Toggles between full screen and normal mode. Uses the [Fullscreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} and fallbacks to other methods internally, including [NW.js (formerly node-webkit)]{@link https://nwjs.io/} and [Electron (Electron.js)]{@link https://electronjs.org/} ones, when not available. Recommended to be called through an event fired by the user as onclick or ontouchstart, etc. * @function * @param {boolean} [useFullScreen=true] - If set to true, it will try to enable full screen mode. Otherwise, it will try to enable normal mode. * @param {Element} [element=document.documentElement|document.body] - Element which we want to use in full screen mode. By default uses the whole document body. Only used when the &quot;useFullScreen&quot; parameter is set to true. If an element is provided, it will use neither [NW.js (formerly node-webkit)]{@link https://nwjs.io/} nor [Electron (Electron.js)]{@link https://electronjs.org/} methods. * @param {boolean} [allowReload=false] - If set to true and &quot;useFullScreen&quot; is set to true but it fails to enable full screen normally, it will try to reload the entire current document again in a new bigger window. Useful for very old web clients. Only used when the &quot;useFullScreen&quot; parameter is set to true. */ CB_Screen.setFullScreen = function(useFullScreen, element, allowReload) { var documentBase = CB_Client.getDocumentBase(); //Defines default parameters: if (typeof(useFullScreen) === &quot;undefined&quot; || useFullScreen === null) { useFullScreen = true; } //By default, full screen mode will be used: var elementGiven = true; //Tells whether an element was given or not (useful for NW.js and Electron). if (typeof(element) === &quot;undefined&quot; || element === null) { //if (documentBase.documentElement) { element = documentBase.documentElement; } //else { element = documentBase.body; } if (document.documentElement) { element = document.documentElement; } else { element = document.body; } elementGiven = false; } //If we want full screen mode: if (useFullScreen) { var fullScreenApplied = false; if (!elementGiven) { //Tries to use NW.js (node-webkit) if available to enter full screen: if (CB_Client.isRunningOnNWjs()) { if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.Window &amp;&amp; typeof(nw.Window.get) === &quot;function&quot;) { try { var win = nw.Window.get(); if (win !== null) { win.enterFullscreen(); fullScreenApplied = win.isFullscreen; if (!fullScreenApplied) { win.enterKioskMode(); fullScreenApplied = win.isKioskMode; } } } catch(E) { fullScreenApplied = false; } } if (!fullScreenApplied &amp;&amp; typeof(require) === &quot;function&quot;) { var gui = require(&quot;nw.gui&quot;); if (typeof(gui) !== &quot;undefined&quot; &amp;&amp; gui !== null &amp;&amp; typeof(gui.Window) !== &quot;undefined&quot; &amp;&amp; gui.Window !== null &amp;&amp; typeof(gui.Window.get) === &quot;function&quot;) { try { var win = gui.Window.get(); if (win !== null) { win.enterFullscreen(); fullScreenApplied = win.isFullscreen; if (!fullScreenApplied) { win.enterKioskMode(); fullScreenApplied = win.isKioskMode; } } } catch(E) { fullScreenApplied = false; } } } } //Tries to use Electron (Electron.js) if available to enter full screen: if (CB_Client.isRunningOnElectron() &amp;&amp; typeof(require) === &quot;function&quot;) { try { fullScreenApplied = require(&quot;electron&quot;).remote.getCurrentWindow().setFullScreen(true); } catch(E) { try { fullScreenApplied = require(&quot;electron&quot;).remote.getCurrentWindow().setSimpleFullScreen(true); } catch(E) { fullScreenApplied = false; } } } } if (!fullScreenApplied) { //Gets the function compatible with Fullscreen API (if any): var callFullScreen = element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.oRequestFullScreen || element.msRequestFullscreen || element.msRequestFullScreen || element.webkitEnterFullScreen || element.webkitEnterFullscreen; //If there is any function compatible with Fullscreen API, we call it: if (typeof(callFullScreen) !== &quot;undefined&quot; &amp;&amp; callFullScreen) { if (Element.ALLOW_KEYBOARD_INPUT) { callFullScreen.call(element, Element.ALLOW_KEYBOARD_INPUT); //For Webkit. } else { callFullScreen.call(element); } fullScreenApplied = true; } //..otherwise, we try to use ActiveX (if it's not already in full screen): else if (typeof(window.ActiveXObject) !== &quot;undefined&quot;) { try { var wscript = new ActiveXObject(&quot;WScript.Shell&quot;); //If ActiveX object has been created: if (wscript !== null) { //ActiveX object working, so we press the key: wscript.SendKeys(&quot;{F11}&quot;); fullScreenApplied = true; } } //If ActiveX is not enabled or has not been accepted: catch(E) { fullScreenApplied = false; } } } //If the full screen mode has not been applied, we try to resize the window: if (!fullScreenApplied) { /* if (typeof(window.fullscreen) !== &quot;undefined&quot;) { try { window.fullscreen = true; } catch(E) { } } */ //if (typeof(top.window.outerWidth) !== &quot;undefined&quot; &amp;&amp; typeof(screen.availWidth) !== &quot;undefined&quot; &amp;&amp; top.window.outerWidth !== null &amp;&amp; screen.availWidth !== null) var screenAvailableWidth = CB_Screen.getAvailableWidth(); if (typeof(top.window.outerWidth) !== &quot;undefined&quot; &amp;&amp; top.window.outerWidth !== null &amp;&amp; screenAvailableWidth &gt; 0) { //top.window.outerWidth = screen.availWidth; top.window.outerWidth = screenAvailableWidth; } //if (typeof(top.window.outerHeight) !== &quot;undefined&quot; &amp;&amp; typeof(screen.availHeight) !== &quot;undefined&quot; &amp;&amp; top.window.outerHeight !== null &amp;&amp; screen.availHeight !== null) var screenAvailableHeight = CB_Screen.getAvailableHeight(); if (typeof(top.window.outerHeight) !== &quot;undefined&quot; &amp;&amp; top.window.outerHeight !== null &amp;&amp; screenAvailableHeight &gt; 0) { //top.window.outerHeight = screen.availHeight; top.window.outerHeight = screenAvailableHeight; } /* var hdiff; window.resizeTo(screen.width/2,screen.height/2) window.moveTo(0,10) hdiff=window.screenTop; window.moveTo(-6,-hdiff+6); window.resizeTo(screen.width+13,screen.height+hdiff+26) */ var screenWidth = CB_Screen.getWidth(); var screenHeight = CB_Screen.getHeight(); try { //window.moveTo(0, 0); //GIVES PROBLEMS WHEN YOU USE THE SCRIPT ON AN IFRAME!!! //window.resizeTo(screenWidth, screenHeight); //GIVES PROBLEMS WHEN YOU USE THE SCRIPT ON AN IFRAME!!! } catch(E) {} ////////////////// //If the full screen mode is still not applied and we allow to reload web: if (allowReload &amp;&amp; !(/iPad|iPhone|iPod/.test(navigator.userAgent) &amp;&amp; !window.MSStream || navigator.platform &amp;&amp; /iPad|iPhone|iPod/.test(navigator.platform))) //Checks whether it is not iOS. { var currentWindow = window.self; currentWindow.opener = window.self; var newWindow = window.open(&quot;&quot; + window.location, &quot;CB_fullScreenWindow&quot;, &quot;type=fullWindow, fullscreen=yes, scrollbars=auto, toolbar=no, location=no, directories=no, status=no, menubar=no, resizable=no, channelmode=1&quot;); //currentWindow.location.href = &quot;about:blank&quot;; newWindow.focus(); //currentWindow.close(); //newWindow.focus(); } } } //...otherwise, if we want normal screen mode (not full screen): else { var fullScreenLeft = false; if (!elementGiven) { //Tries to use NW.js (node-webkit) if available to leave full screen: if (CB_Client.isRunningOnNWjs()) { if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.Window &amp;&amp; typeof(nw.Window.get) === &quot;function&quot;) { try { var win = nw.Window.get(); if (win !== null) { win.leaveFullscreen(); fullScreenLeft = !win.isFullscreen; if (!fullScreenLeft) { win.leaveKioskMode(); fullScreenLeft = !win.isKioskMode; } } } catch(E) { fullScreenLeft = false; } } if (!fullScreenLeft &amp;&amp; typeof(require) === &quot;function&quot;) { var gui = require(&quot;nw.gui&quot;); if (typeof(gui) !== &quot;undefined&quot; &amp;&amp; gui !== null &amp;&amp; typeof(gui.Window) !== &quot;undefined&quot; &amp;&amp; gui.Window !== null &amp;&amp; typeof(gui.Window.get) === &quot;function&quot;) { try { var win = gui.Window.get(); if (win !== null) { win.leaveFullscreen(); fullScreenLeft = !win.isFullscreen; if (!fullScreenLeft) { win.leaveKioskMode(); fullScreenLeft = !win.isKioskMode; } } } catch(E) { fullScreenLeft = false; } } } } //Tries to use Electron (Electron.js) if available to leave full screen: if (CB_Client.isRunningOnElectron() &amp;&amp; typeof(require) === &quot;function&quot;) { try { fullScreenLeft = require(&quot;electron&quot;).remote.getCurrentWindow().setFullScreen(true); } catch(E) { try { fullScreenLeft = require(&quot;electron&quot;).remote.getCurrentWindow().setSimpleFullScreen(true); } catch(E) { fullScreenLeft = false; } } } } if (!fullScreenLeft) { //Gets the function compatible with Fullscreen API (if any): var cancelFullScreen = documentBase.exitFullscreen || documentBase.cancelFullScreen || documentBase.mozCancelFullScreen || documentBase.webkitCancelFullScreen || documentBase.oCancelFullScreen || documentBase.msExitFullscreen || documentBase.msExitFullScreen || documentBase.msCancelFullScreen || documentBase.webkitExitFullScreen || documentBase.webkitExitFullscreen; var useDocumentBase = true; if (typeof(cancelFullScreen) === &quot;undefined&quot; || cancelFullScreen === null) { cancelFullScreen = document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.webkitCancelFullScreen || document.oCancelFullScreen || document.msExitFullscreen || document.msExitFullScreen || document.msCancelFullScreen || document.webkitExitFullScreen || document.webkitExitFullscreen; useDocumentBase = false; } //If there is any function compatible with Fullscreen API, we call it: if (typeof(cancelFullScreen) !== &quot;undefined&quot; &amp;&amp; cancelFullScreen) { cancelFullScreen.call(useDocumentBase ? documentBase : document); } //..otherwise, we try to use ActiveX (if it's not in full screen already): else if (typeof(window.ActiveXObject) !== &quot;undefined&quot; &amp;&amp; !CB_Screen.isFullScreen()) { try { var wscript = new ActiveXObject(&quot;WScript.Shell&quot;); //If ActiveX object has been created: if (wscript !== null) { //ActiveX object working, so we press the key: wscript.SendKeys(&quot;{F11}&quot;); } } //If ActiveX is not enabled or has not been accepted: catch(E) {} } } } } /** * Tells whether we are in full screen mode or not. Uses the [Fullscreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} and fallbacks to other methods internally, including [NW.js (formerly node-webkit)]{@link https://nwjs.io/} and [Electron (Electron.js)]{@link https://electronjs.org/} ones, when not available. * @function * @param {number} [allowedWidthMarginPercentage=CB_Configuration.CrossBase.CB_Screen_isFullScreen_ALLOWED_WIDTH_MARGIN_PERCENTAGE] - Allowed width margin, in percentage, of the total screen available to detect whether it is in full screen or not. Needed by old web clients without [Fullscreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} support, mainly. * @param {number} [allowedHeightMarginPercentage=CB_Configuration.CrossBase.CB_Screen_isFullScreen_ALLOWED_HEIGHT_MARGIN_PERCENTAGE] - Allowed height margin, in percentage, of the total screen available to detect whether it is in full screen or not. Needed by old web clients without [Fullscreen API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API} support, mainly. * @returns {boolean} Returns whether we are in full screen mode or not. */ CB_Screen.isFullScreen = function(allowedWidthMarginPercentage, allowedHeightMarginPercentage) { //Gets the variable compatible with Fullscreen API (if any): var documentBase = CB_Client.getDocumentBase(); /* var isFullScreenApplied = (documentBase.fullScreenElement &amp;&amp; documentBase.fullScreenElement !== null) || (documentBase.fullscreenElement &amp;&amp; documentBase.fullscreenElement !== null) || (documentBase.msFullscreenElement &amp;&amp; documentBase.msFullscreenElement !== null) || documentBase.fullScreen || documentBase.mozFullScreen || documentBase.fullScreen || documentBase.webkitIsFullScreen || documentBase.oIsFullScreen || documentBase.msIsFullscreen || documentBase.msIsFullScreen || documentBase.webkitDisplayingFullScreen || documentBase.webkitDisplayingFullscreen; */ var isFullScreenApplied = false; //Tries to use NW.js (node-webkit) to detect whether we are in fullscreen mode or not: if (CB_Client.isRunningOnNWjs()) { if (typeof(nw) !== &quot;undefined&quot; &amp;&amp; nw !== null &amp;&amp; nw.Window &amp;&amp; typeof(nw.Window.get) === &quot;function&quot;) { try { var win = nw.Window.get(); if (win !== null) { isFullScreenApplied = win.isFullscreen || win.isKioskMode; } } catch(E) { isFullScreenApplied = false; } } if (!isFullScreenApplied &amp;&amp; typeof(require) === &quot;function&quot;) { var gui = require(&quot;nw.gui&quot;); if (typeof(gui) !== &quot;undefined&quot; &amp;&amp; gui !== null &amp;&amp; typeof(gui.Window) !== &quot;undefined&quot; &amp;&amp; gui.Window !== null &amp;&amp; typeof(gui.Window.get) === &quot;function&quot;) { try { var win = gui.Window.get(); if (win !== null) { if (win !== null) { isFullScreenApplied = win.isFullscreen || win.isKioskMode; } } } catch(E) { isFullScreenApplied = false; } } } } //Tries to use Electron (Electron.js) to detect whether we are in fullscreen mode or not: if (CB_Client.isRunningOnElectron() &amp;&amp; typeof(require) === &quot;function&quot;) { try { isFullScreenApplied = (require(&quot;electron&quot;).remote.getCurrentWindow().isFullScreen() === true); } catch(E) { isFullScreenApplied = false; } } if (!isFullScreenApplied) { isFullScreenApplied = documentBase.fullScreenElement || documentBase.fullscreenElement || documentBase.msFullscreenElement || documentBase.fullScreen || documentBase.mozFullScreen || documentBase.fullScreen || documentBase.webkitIsFullScreen || documentBase.oIsFullScreen || documentBase.msIsFullscreen || documentBase.msIsFullScreen || documentBase.webkitDisplayingFullScreen || documentBase.webkitDisplayingFullscreen; //var useDocumentBase = true; if (typeof(isFullScreenApplied) === &quot;undefined&quot; || isFullScreenApplied === null) { /* isFullScreenApplied = (document.fullScreenElement &amp;&amp; document.fullScreenElement !== null) || (document.fullscreenElement &amp;&amp; document.fullscreenElement !== null) || (document.msFullscreenElement &amp;&amp; document.msFullscreenElement !== null) || document.fullScreen || document.mozFullScreen || window.fullScreen || document.webkitIsFullScreen || document.oIsFullScreen || document.msIsFullscreen || document.msIsFullScreen || document.webkitDisplayingFullScreen || document.webkitDisplayingFullscreen; */ isFullScreenApplied = document.fullScreenElement || document.fullscreenElement || document.msFullscreenElement || document.fullScreen || document.mozFullScreen || window.fullScreen || document.webkitIsFullScreen || document.oIsFullScreen || document.msIsFullscreen || document.msIsFullScreen || document.webkitDisplayingFullScreen || document.webkitDisplayingFullscreen; //useDocumentBase = false; } //If there is not compatibility with Fullscreen API, we use other methods: if (typeof(isFullScreenApplied) === &quot;undefined&quot; || isFullScreenApplied === null) { if (CB_Client.getBrowser() === &quot;Explorer&quot;) //Only IE since Chrome would do false positives: { //if (typeof(window.screenTop) !== &quot;undefined&quot; &amp;&amp; window.screenTop !== null &amp;&amp; !window.screenTop) if (window.screenTop) { isFullScreenApplied = true; } //else if (typeof(window.screenY) !== &quot;undefined&quot; &amp;&amp; window.screenY !== null &amp;&amp; !window.screenY) else if (window.screenY) { isFullScreenApplied = true; } } if (&quot;standalone&quot; in window.navigator &amp;&amp; window.navigator.standalone) //For some WebKit browsers. { isFullScreenApplied = true; } if (typeof(document.fullscreenElement) !== &quot;undefined&quot;) { if (document.fullscreenElement === null) { isFullScreenApplied = false; } } } //If there is still not compatibility with Fullscreen API and the methods above didn't work, we use other methods: if (typeof(isFullScreenApplied) === &quot;undefined&quot; || isFullScreenApplied === null) //if (typeof(isFullScreenApplied) === &quot;undefined&quot; || isFullScreenApplied === null) { //If the web client is not compatible with Fullscreen API (except the ones which are but don't detect full screen mode when we press F11): var element = documentBase.body; if (documentBase.documentElement) { element = documentBase.documentElement; } //TODO: Add more browsers in callFullScreen that are compatible with Fullscreen API but don't detect fullscreen when you press F11. var callFullScreen = element.mozRequestFullScreen;// || element.msRequestFullScreen; if (typeof(callFullScreen) === &quot;undefined&quot;) { //We will check the size of the window (having mind zoom level): var currentZoom = CB_Screen.getZoom(); //Gets the available screen size (or the screen size if it's not avaiable): var screenAvailableWidth_ = CB_Screen.getAvailableWidth(); //if (typeof(screenAvailableWidth_) === &quot;undefined&quot; || screenAvailableWidth_ === null || screenAvailableWidth_ === 0) { screenAvailableWidth_ = CB_Screen.getWidth(); } if (!screenAvailableWidth_) { screenAvailableWidth_ = CB_Screen.getWidth(); } var screenAvailableHeight_ = CB_Screen.getAvailableHeight(); //if (typeof(screenAvailableHeight_) === &quot;undefined&quot; || screenAvailableHeight_ === null || screenAvailableHeight_ === 0) { screenAvailableHeight_ = CB_Screen.getHeight(); } if (!screenAvailableHeight_) { screenAvailableHeight_ = CB_Screen.getHeight(); } //Gets the previous available screen size (or the previous screen size if it's not available): var previousScreenAvailableWidth_ = CB_Screen.getAvailableWidthPrevious(); //if (typeof(previousScreenAvailableWidth_) === &quot;undefined&quot; || previousScreenAvailableWidth_ === null || previousScreenAvailableWidth_ === 0) { previousScreenAvailableWidth_ = CB_Screen.getWidthPrevious(); } if (!previousScreenAvailableWidth_) { previousScreenAvailableWidth_ = CB_Screen.getWidthPrevious(); } var previousScreenAvailableHeight_ = CB_Screen.getAvailableHeightPrevious(); //if (typeof(previousScreenAvailableHeight_) === &quot;undefined&quot; || previousScreenAvailableHeight_ === null || previousScreenAvailableHeight_ === 0) { previousScreenAvailableHeight_ = CB_Screen.getHeightPrevious(); } if (!previousScreenAvailableHeight_) { previousScreenAvailableHeight_ = CB_Screen.getHeightPrevious(); } /* //Sets an allowed margin: var allowedWidthMargin = 0.034 * CB_Screen.getWidth();//50; //Maximum width margin allowed. if (allowedWidthMargin &lt;= 0) { allowedWidthMargin = 50; } var allowedHeightMargin = 0.035 * CB_Screen.getHeight(); //42; //Maximum height margin allowed. if (allowedHeightMargin &lt;= 0) { allowedHeightMargin = 42; } */ //Determine whether zoom affects screen available size or not: var zoomAffectsScreenSize = false; //If the page has not been zoomed yet: if (CB_Screen.getZoomPrevious() === 0) { zoomAffectsScreenSize = false; } //...otherwise, if has already been zoomed: else { //If screen available size changed form last time, zoom affects it: if (screenAvailableWidth_ !== previousScreenAvailableWidth_)// &amp;&amp; previousScreenAvailableWidth_ !== CB_Screen._storedScreenAvailableWidth) { zoomAffectsScreenSize = true; } if (screenAvailableHeight_ !== previousScreenAvailableHeight_)// &amp;&amp; previousScreenAvailableHeight_ !== CB_Screen._storedScreenAvailableHeight) { zoomAffectsScreenSize = true; } } //If it's Internet Explorer, zooms will affect the screen available size: //TODO: Add more browsers here that zoom affects the screen available size (specially the ones which are not compatible with the Fullscreen API or they don't think they are in Fullscreen mode when you press F11). //if (typeof(document.attachEvent) !== &quot;undefined&quot; &amp;&amp; document.attachEvent) if (CB_Client.getBrowser() === &quot;Explorer&quot; || typeof(document.msFullscreenElement) !== &quot;undefined&quot;) { zoomAffectsScreenSize = true; } if (CB_Client.getBrowser() === &quot;Chrome&quot;) //Chrome versions not compatible with FullScreen API. { zoomAffectsScreenSize = false;//true; } //If the zoom affects the screen available size: if (zoomAffectsScreenSize) { //We try to calculate the real screen available size (having in mind the zoom): screenAvailableWidth_ *= currentZoom; screenAvailableHeight_ *= currentZoom; } //Sets an allowed margin: if (typeof(allowedWidthMarginPercentage) === &quot;undefined&quot; || allowedWidthMarginPercentage === null || isNaN(allowedWidthMarginPercentage) || allowedWidthMarginPercentage &lt; 0 || allowedWidthMarginPercentage &gt;= 100) { allowedWidthMarginPercentage = CB_Configuration[CB_BASE_NAME].CB_Screen_isFullScreen_ALLOWED_WIDTH_MARGIN_PERCENTAGE; } if (typeof(allowedHeightMarginPercentage) === &quot;undefined&quot; || allowedHeightMarginPercentage === null || isNaN(allowedHeightMarginPercentage) || allowedHeightMarginPercentage &lt; 0 || allowedHeightMarginPercentage &gt;= 100) { allowedHeightMarginPercentage = CB_Configuration[CB_BASE_NAME].CB_Screen_isFullScreen_ALLOWED_HEIGHT_MARGIN_PERCENTAGE; } var allowedWidthMargin = (allowedWidthMarginPercentage / 100) * screenAvailableWidth_;//50; //Maximum width margin allowed. if (allowedWidthMargin &lt;= 0) { allowedWidthMargin = 50; } var allowedHeightMargin = (allowedHeightMarginPercentage / 100) * screenAvailableHeight_; //42; //Maximum height margin allowed. if (allowedHeightMargin &lt;= 0) { allowedHeightMargin = 42; } //We get the real window size (having in mind the zoom): var windowWidth = CB_Screen.getWindowWidth() * currentZoom; var windowHeight = CB_Screen.getWindowHeight() * currentZoom; //We round the sizes having in mind that zoom can be not exact: windowWidth = Math.ceil(windowWidth); windowHeight = Math.ceil(windowHeight); screenAvailableWidth_ = Math.floor(screenAvailableWidth_); screenAvailableHeight_ = Math.floor(screenAvailableHeight_); //If it's full screen (having in mind allowed margin): if (Math.ceil(windowWidth + allowedWidthMargin) &gt;= screenAvailableWidth_ &amp;&amp; Math.ceil(windowHeight + allowedHeightMargin) &gt;= screenAvailableHeight_) { isFullScreenApplied = true; } else { isFullScreenApplied = false; } } else { isFullScreenApplied = false; } //If the web client is compatible with Fullscreen API (except the ones which are but don't detect full screen mode when we press F11), it's not in full screen mode. } //Casts the variable to boolean type: //isFullScreenApplied = (isFullScreenApplied) ? true : false; isFullScreenApplied = !!(isFullScreenApplied); //If it's not the first time and full screen mode has been changed, calls the onFullScreenChange function (if any): if (CB_Screen._isFullScreen !== null &amp;&amp; CB_Screen._isFullScreen !== isFullScreenApplied) { //If there is any defined function: if (typeof(CB_Screen._eventsHolder[&quot;onFullScreenChange&quot;]) === &quot;function&quot;) { //Sets the new position (just in case the function needs it): CB_Screen._isFullScreen = isFullScreenApplied; //Executes the function: CB_Screen._eventsHolder[&quot;onFullScreenChange&quot;](); } } } //Sets the new position: CB_Screen._isFullScreen = isFullScreenApplied; return CB_Screen._isFullScreen;//isFullScreenApplied; } CB_Screen.unlockOrientation_unsetOrientation_timeout = null; /** * Alias for {@link CB_Screen.unlockOrientation}. * @function CB_Screen.unsetOrientation * @see {@link CB_Screen.unlockOrientation} */ /** * Function that unlocks the screen orientation. Using the [unlock]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/unlock} function and fallbacks to the [unlockOrientation]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/unlockOrientation} function of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation} internally. * @function * @param {function} [onError] - Callback function that will be called if the orientation has not been unlocked successfully. Unique parameter received will be an error object (probably a [DOMException]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMException}, depending on the client) with the error. * @returns {boolean} Returns the same that the [unlock]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/unlock} function returns (undefined, normally), if available. Otherwise, returns the same boolean as the [unlockOrientation]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/unlockOrientation} function (true if the unlocking action has been performed successfully), if available. Otherwise, returns false when the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation} is not available. */ CB_Screen.unlockOrientation = CB_Screen.unsetOrientation = function(onError) { clearTimeout(CB_Screen.unlockOrientation_unsetOrientation_timeout); var orientationBefore = CB_Screen.getOrientation(); var onErrorCalled = false; try { var returnValue = false; orientationObject = CB_Screen.getOrientationObject(); if (orientationObject !== null &amp;&amp; typeof(orientationObject.unlock) !== &quot;undefined&quot; &amp;&amp; orientationObject.unlock !== null) { try { returnValue = orientationObject.unlock(); //Attaching an error-catch to prevent Chrome desktop exception. } catch(E) { returnValue = false; } } else if (typeof(screen) !== &quot;undefined&quot; &amp;&amp; screen !== null) { //Using IF because of Firefox bug (&quot;TypeError: 'mozUnlockOrientation' called on an object that does not implement interface Screen.&quot;): if (screen.unlockOrientation) { returnValue = screen.unlockOrientation(); } else if (screen.mozUnlockOrientation) { returnValue = screen.mozUnlockOrientation(); } else if (screen.webkitUnlockOrientation) { returnValue = screen.webkitUnlockOrientation(); } else if (screen.oUnlockOrientation) { returnValue = screen.oUnlockOrientation(); } else if (screen.msUnlockOrientation) { returnValue = screen.msUnlockOrientation(); } else if (typeof(Screen) !== &quot;undefined&quot; &amp;&amp; Screen !== null &amp;&amp; Screen.msUnlockOrientation) { returnValue = Screen.msUnlockOrientation(); } else if (screen.khtmlUnlockOrientation) { returnValue = screen.khtmlUnlockOrientation(); } /* else if (screen.orientation &amp;&amp; screen.orientation.unlock) { return screen.orientation.unlock(); } */ } if (returnValue === false &amp;&amp; typeof(onError) === &quot;function&quot;) { onErrorCalled = true; onError({ message: &quot;Orientation mode could not be unlocked.&quot; }); } } catch(E) { if (!onErrorCalled &amp;&amp; typeof(onError) === &quot;function&quot;) { onErrorCalled = true; onError({ message: &quot;Orientation mode could not be unlocked.&quot; }); } returnValue = false; } //If no error happened, checks after some time: if (!onErrorCalled) { CB_Screen.unlockOrientation_unsetOrientation_timeout = setTimeout ( function() { if (onErrorCalled) { return; } var orientationNow = CB_Screen.getOrientation(); if (orientationNow === orientationBefore) //Orientation is the same one. { if (typeof(onError) === &quot;function&quot;) { onErrorCalled = true; onError({ message: &quot;Orientation did not change after trying to unlock it (it is still '&quot; + orientationBefore + &quot;').&quot; }); } } }, 1000 //Unlocking process can take some time so it waits a while. ); } return returnValue; } /** * Alias for {@link CB_Screen.lockOrientation}. * @function CB_Screen.setOrientation * @see {@link CB_Screen.lockOrientation} */ /** * Function that forces a desired screen orientation. Using the [lock]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/lock} function and fallbacks to the [lockOrientation]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation} function of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation} internally. * @function * @param {'default'|'any'|'natural'|'landscape'|'portrait'|'portrait-primary'|'portrait-secondary'|'landscape-primary'|'landscape-secondary'} orientationMode - Desired orientation. Internally, &quot;default&quot; and &quot;natural&quot; will be exchanged and &quot;any&quot; will be transformed to &quot;default&quot;, depending on the internal function used. Values &quot;default&quot;, &quot;any&quot; and &quot;natural&quot; are not recommended because they are not supported in all web clients. * @param {function} [onSuccess] - Callback function with no parameters that will be called if the orientation has been set successfully. * @param {function} [onError] - Callback function that will be called if the orientation has not been set successfully. Unique parameter received will be an error object (probably a [DOMException]{@link https://developer.mozilla.org/en-US/docs/Web/API/DOMException}, depending on the client) with the error. * @returns {boolean} Returns the same [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise} that the [lock]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/lock} function returns, if available. Otherwise, returns the same boolean as the [lockOrientation]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation} function (true if the locking action has been performed successfully), if available. Otherwise, returns false when the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation} is not available. * @todo Transform values of &quot;default&quot;, &quot;any&quot; and &quot;natural&quot; to &quot;portrait&quot;, &quot;landscape&quot;, etc. when the web clients do not support it (calculating current orientation and trying to guess natural/default one, etc.). */ CB_Screen.lockOrientation = CB_Screen.setOrientation = function(orientationMode, onSuccess, onError) { clearTimeout(CB_Screen.unlockOrientation_unsetOrientation_timeout); try { var returnValue = false; orientationMode = CB_trim(orientationMode).toLowerCase(); var orientationObject = CB_Screen.getOrientationObject(); if (orientationObject !== null &amp;&amp; typeof(orientationObject.lock) !== &quot;undefined&quot; &amp;&amp; orientationObject.lock !== null) { if (orientationMode === &quot;default&quot;) { orientationMode = &quot;natural&quot;; } //return orientationObject.lock(orientationMode).then(onSuccess)[&quot;catch&quot;](typeof(onError) === &quot;function&quot; ? onError : function() {}); //Attaching an error-catch to prevent Chrome desktop exception. try { returnValue = orientationObject.lock(orientationMode).then(onSuccess)[&quot;catch&quot;](typeof(onError) === &quot;function&quot; ? onError : function() {}); //Attaching an error-catch to prevent Chrome desktop exception. return returnValue; } catch(E) { try { returnValue = orientationObject.lock(orientationMode); //Attaching an error-catch to prevent Chrome desktop exception. } catch(E) { returnValue = false; } } } else if (typeof(screen) !== &quot;undefined&quot; &amp;&amp; screen !== null) { if (orientationMode === &quot;natural&quot;) { orientationMode = &quot;default&quot;; } else if (orientationMode === &quot;any&quot;) { orientationMode = &quot;default&quot;; } //Using IF because of Firefox bug (TypeError: 'mozLockOrientation' called on an object that does not implement interface Screen.): if (screen.lockOrientation) { returnValue = screen.lockOrientation(orientationMode); } else if (screen.mozLockOrientation) { returnValue = screen.mozLockOrientation(orientationMode); } else if (screen.webkitLockOrientation) { returnValue = screen.webkitLockOrientation(orientationMode); } else if (screen.oLockOrientation) { returnValue = screen.oLockOrientation(orientationMode); } else if (screen.msLockOrientation) { returnValue = screen.msLockOrientation(orientationMode); } else if (typeof(Screen) !== &quot;undefined&quot; &amp;&amp; Screen !== null &amp;&amp; Screen.msLockOrientation) { returnValue = Screen.msLockOrientation(orientationMode); } else if (screen.khtmlLockOrientation) { returnValue = screen.khtmlLockOrientation(orientationMode); } } if (returnValue === true &amp;&amp; typeof(onSucess) === &quot;function&quot;) { onSuccess(); } else if (returnValue === false &amp;&amp; typeof(onError) === &quot;function&quot;) { onError({ message: &quot;Orientation mode could not be locked.&quot; }); } return returnValue; } catch(E) { if (typeof(onError) === &quot;function&quot;) { onError({ message: &quot;Orientation mode could not be locked.&quot; }); } return false; } } /** * Gets the [screen orientation object]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation} of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}. * @function * @returns {Object} Returns the [screen orientation object]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation} of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}. */ CB_Screen.getOrientationObject = function() { if (typeof(screen) !== &quot;undefined&quot;) { var orientationObject = screen.orientation || screen.mozOrientation || screen.webkitOrientation || screen.oOrientation || screen.msOrientation || screen.khtmlOrientation || null; if (typeof(orientationObject) !== &quot;undefined&quot; &amp;&amp; orientationObject !== null) { return orientationObject; } } return null; } CB_Screen.getOrientation_map = //* Map and map implementation by Christian Maniewski from: https://github.com/chmanie/o9n/blob/master/index.js { '90': 'landscape-primary', '-90': 'landscape-secondary', '0': 'portrait-primary', '180': 'portrait-secondary' }; CB_Screen.getOrientation_getMql = function() //* Function by Christian Maniewski from: https://github.com/chmanie/o9n/blob/master/index.js { if (typeof(window.matchMedia) !== &quot;function&quot;) { return {}; } return window.matchMedia('(orientation: landscape)'); }; /** * Gets the current orientation from the [screen orientation object]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation} of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}. * @function * @returns {string} Returns a string with the current orientation from the [screen orientation object]{@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation} of the [Screen Orientation API]{@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}. If cannot be found, it will return &quot;landscape-primary&quot; as default. */ CB_Screen.getOrientation = function() { var orientationObject = CB_Screen.getOrientationObject(); var orientation = &quot;&quot;; if (orientationObject !== null) { if (typeof(orientationObject) === &quot;string&quot;) { orientation = orientationObject; } else if (typeof(orientationObject.type) === &quot;string&quot;) { orientation = orientationObject.type; } } if (orientation === &quot;&quot;) { orientation = CB_Screen.getOrientation_map[window.orientation + &quot;&quot;] || (CB_Screen.getOrientation_getMql().matches ? &quot;landscape-primary&quot; : &quot;portrait-primary&quot;); } return orientation; //TODO: Think about using CB_trim(); } /** * Sets the [Viewport]{@link https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag} meta tag dynamically with the desired options. If the [Viewport]{@link https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag} meta tag already exists, it will be updated. Otherwise, it will create a new one (and append it to the [HEAD]{@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head} tag, if found). * @function * @param {string|integer} [width] - Desired value for the &quot;width&quot; parameter. * @param {string|integer} [height] - Desired value for the &quot;height&quot; parameter. * @param {string|boolean} [userScalable='no'] - Desired value for the &quot;user-scalable&quot; parameter. * @param {number} [initialScale] - Desired value for the &quot;initial-scale&quot; parameter. * @param {number} [minimumScale] - Desired value for the &quot;minimum-scale&quot; parameter. * @param {number} [maximumScale] - Desired value for the &quot;maximum-scale&quot; parameter. * @param {string|number} [targetDensityDPI] - Desired value for the &quot;target-densitydpi&quot; parameter. * @param {string} [shrinkToFit] - Desired value for the &quot;shrink-to-fit&quot; parameter. * @returns {Node|null} Returns the DOM element which belongs to the [Viewport]{@link https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag} meta tag affected (it will have been just created if no one existed before). If a [Viewport]{@link https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag} meta tag could not be created or modified, returns null. */ CB_Screen.setViewport = function(width, height, userScalable, initialScale, minimumScale, maximumScale, targetDensityDPI, shrinkToFit) { //Finds the meta tag viewport (if any): var viewport = CB_Elements.id(&quot;viewport&quot;); if (typeof(viewport) === &quot;undefined&quot; || viewport === null) { //if (typeof(document.querySelector) !== &quot;undefined&quot; &amp;&amp; document.querySelector !== null &amp;&amp; document.querySelector) if (document.querySelector) { viewport = document.querySelector(&quot;meta[name=viewport]&quot;); } else { var metaTags = CB_Elements.tag(&quot;meta&quot;, document, false); for (var x = metaTags.length - 1; x &gt;= 0; x--) //Finds the last one. { if (metaTags[x].name.toLowerCase() === &quot;viewport&quot;) { viewport = metaTags[x]; break; } } } } //Prepare the given parameters: width = CB_trim(width); height = CB_trim(height); userScalable = CB_trim(userScalable).toLowerCase(); initialScale = CB_trim(initialScale); minimumScale = CB_trim(minimumScale); maximumScale = CB_trim(maximumScale); targetDensityDPI = CB_trim(targetDensityDPI); if (shrinkToFit === true) { shrinkToFit = &quot;yes&quot;; } else if (shrinkToFit === false) { shrinkToFit = &quot;no&quot;; } shrinkToFit = CB_trim(shrinkToFit); //Sets the content for the meta tag viewport (according to the parameters given): var viewportContent = &quot;&quot;; if (width !== &quot;&quot;) { viewportContent += &quot;width=&quot; + width; } if (height !== &quot;&quot;) { if (CB_trim(viewportContent) !== &quot;&quot;) { viewportContent += &quot;, &quot;; } viewportContent += &quot;height=&quot; + height; } if (userScalable &amp;&amp; userScalable !== &quot;no&quot; &amp;&amp; userScalable !== 0 &amp;&amp; userScalable !== &quot;0&quot;) { userScalable = 1; } //userScalable = &quot;yes&quot;; } else { userScalable = 0; } //userScalable = &quot;no&quot;; } if (CB_trim(viewportContent) !== &quot;&quot;) { viewportContent += &quot;, &quot;; } viewportContent += &quot;user-scalable=&quot; + (userScalable === 0 ? &quot;no&quot; : &quot;yes&quot;); viewportContent += &quot;, user-scalable=&quot; + userScalable; if (initialScale !== &quot;&quot;) { viewportContent += &quot;, initial-scale=&quot; + initialScale; } if (minimumScale !== &quot;&quot;) { viewportContent += &quot;, minimum-scale=&quot; + minimumScale; } if (maximumScale !== &quot;&quot;) { viewportContent += &quot;, maximum-scale=&quot; + maximumScale; } if (targetDensityDPI !== &quot;&quot;) { viewportContent += &quot;, target-densitydpi=&quot; + targetDensityDPI; } if (shrinkToFit !== &quot;&quot;) { viewportContent += &quot;, shrink-to-fit=&quot; + shrinkToFit; } //If the meta tag already exists, just updates it: if (typeof(viewport) !== &quot;undefined&quot; &amp;&amp; viewport !== null &amp;&amp; typeof(viewport.setAttribute) !== &quot;undefined&quot; &amp;&amp; viewport.setAttribute !== null) { viewport.setAttribute(&quot;content&quot;, viewportContent); return viewport; } //...otherwise, it will create it: else { viewport = document.createElement('meta'); viewport.name = &quot;viewport&quot;; viewport.id = &quot;viewport&quot;; viewport.content = viewportContent; var headTag = CB_Elements.tag(&quot;head&quot;, document, false); if (typeof(headTag) !== &quot;undefined&quot; &amp;&amp; headTag !== null &amp;&amp; typeof(headTag[0]) !== &quot;undefined&quot; &amp;&amp; headTag[0] !== null) { headTag[0].appendChild(viewport); return viewport; } } return null; } /** * Keeps the screen awake and prevents it from turning off. Uses different methods internally: [Apache Cordova's Insomnia plugin]{@link https://github.com/EddyVerbruggen/Insomnia-PhoneGap-Plugin}, [Standby API]{@link https://lists.w3.org/Archives/Public/public-device-apis/2014Feb/att-0001/Standby_API_Specification.pdf}, [Mozilla's Wake Lock API]{@link https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/API/Wake_Lock_API}, [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/}, [old W3C's Wake Lock API]{@link https://w3.org/TR/2016/WD-wake-lock-20160714/}, [NoSleep.js library]{@link https://github.com/richtr/NoSleep.js?utm_source=recordnotfound.com} (it should be activated by an event fired by the user as onclick or ontouchstart, etc.)... * @function * @param {function} [callbackOk] - Function that will be called if the action has been performed successfully, without parameters. * @param {function} [callbackError] - Function that will be called if the action has not been performed successfully, without parameters. * @returns {boolean} If it uses the [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/} internally, it will return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}. Otherwise, it will return a boolean depending on whether the internal method has been called successfully or not. The fact that the internal method has been called successfully does not mean that the action will perform successfully so it is recommended to relay on the &quot;callbackOk&quot; and &quot;callbackError&quot; functions and ignore this returning value. * @todo Pay attention since many internal functions as the [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/} are still experimental and not well-tested. */ CB_Screen.keepAwake = function(callbackOk, callbackError) { //Using Apache Cordova's Insomnia plugin: if (typeof(window.plugins) !== &quot;undefined&quot; &amp;&amp; typeof(window.plugins.insomnia) !== &quot;undefined&quot; &amp;&amp; typeof(window.plugins.insomnia.allowSleepAgain) !== &quot;undefined&quot;) { try { window.plugins.insomnia.keepAwake(callbackOk, callbackError); return true; } catch(E) { } } //Using Standby API: if (window.navigator &amp;&amp; typeof(navigator.wakeLock) !== &quot;undefined&quot; &amp;&amp; navigator.wakeLock !== null &amp;&amp; typeof(navigator.wakeLock.request) !== &quot;undefined&quot;) { try { navigator.wakeLock.request(&quot;display&quot;).then(callbackOk, callbackError); //navigator.wakeLock.request(&quot;screen&quot;).then(callbackOk, callbackError); return true; } catch(E) { } } //Using Mozilla's Wake Lock API: if (window.navigator &amp;&amp; typeof(window.navigator.requestWakeLock) !== &quot;undefined&quot;) //So far, only works in Firefox/Firefox OS. { try { CB_Screen._screenLock = window.navigator.requestWakeLock(&quot;screen&quot;); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return CB_Screen._screenLock; } catch(E) { } } //Using the W3C's Wake Lock API: if (window.navigator &amp;&amp; typeof(window.navigator.getWakeLock) !== &quot;undefined&quot;) { return navigator.getWakeLock(&quot;screen&quot;).then ( function(wakeLock) { var request = wakeLock.createRequest(); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } }, callbackError ); } //Using the old W3C's Wake Lock API: if (typeof(screen) !== &quot;undefined&quot; &amp;&amp; screen !== null &amp;&amp; typeof(screen.keepAwake) !== &quot;undefined&quot;) { try { screen.keepAwake = true; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return true; } catch(E) { } } //Using NoSleep.js library (it should be activated by an event fired by the user as onclick or ontouchstart, etc.): if (typeof(NoSleep) !== &quot;undefined&quot;) { //if (typeof(CB_Screen._noSleep) === &quot;undefined&quot; || CB_Screen._noSleep === null) { CB_Screen._noSleep = new NoSleep(); } if (CB_Screen._noSleep) { CB_Screen._noSleep.disable(); } //Fix. Source: https://github.com/richtr/NoSleep.js/issues/75. CB_Screen._noSleep = new NoSleep(); //Needs to create a new one to work on some iOS versions. Source: https://github.com/richtr/NoSleep.js/issues/75. //Fix for iOS (Source: https://github.com/richtr/NoSleep.js/issues/75): if (/iPad|iPhone|iPod/.test(navigator.userAgent) &amp;&amp; !window.MSStream || navigator.platform &amp;&amp; /iPad|iPhone|iPod/.test(navigator.platform)) //Checks whether it is iOS. { CB_Events.add ( document, &quot;visibilitychange&quot;, function() { if (CB_Screen._noSleepEnabled === true &amp;&amp; document.visibilityState === &quot;visible&quot;) { CB_Screen.keepAwake(); //CB_Screen.keepAwake(callbackOk, callbackError); } }, true, true, false ); } try { CB_Screen._noSleep.enable(); CB_Screen._noSleepEnabled = true; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return true; } catch(E) {} } if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } return false; } //Function that lets the screen sleep again (also uses Apache Cordova with insomnia plugin): /** * Lets the screen sleep again and stops preventing it from turning off. Uses different methods internally: [Apache Cordova's Insomnia plugin]{@link https://github.com/EddyVerbruggen/Insomnia-PhoneGap-Plugin}, [Standby API]{@link https://lists.w3.org/Archives/Public/public-device-apis/2014Feb/att-0001/Standby_API_Specification.pdf}, [Mozilla's Wake Lock API]{@link https://developer.mozilla.org/en-US/docs/Archive/B2G_OS/API/Wake_Lock_API}, [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/}, [old W3C's Wake Lock API]{@link https://w3.org/TR/2016/WD-wake-lock-20160714/}, [NoSleep.js library]{@link https://github.com/richtr/NoSleep.js?utm_source=recordnotfound.com} (it should be activated by an event fired by the user as onclick or ontouchstart, etc.)... * @function * @param {function} [callbackOk] - Function that will be called if the action has been performed successfully, without parameters. * @param {function} [callbackError] - Function that will be called if the action has not been performed successfully, without parameters. * @returns {boolean} If it uses the [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/} internally, it will return a [Promise]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}. Otherwise, it will return a boolean depending on whether the internal method has been called successfully or not. The fact that the internal method has been called successfully does not mean that the action will perform successfully so it is recommended to relay on the &quot;callbackOk&quot; and &quot;callbackError&quot; functions and ignore this returning value. * @todo Pay attention since many internal functions as the [new W3C's Wake Lock API]{@link https://w3.org/TR/wake-lock/} are still experimental and not well-tested. */ CB_Screen.keepAwakeDisable = function(callbackOk, callbackError) { //Using Apache Cordova's Insomnia plugin: if (typeof(window.plugins) !== &quot;undefined&quot; &amp;&amp; typeof(window.plugins.insomnia) !== &quot;undefined&quot; &amp;&amp; typeof(window.plugins.insomnia.allowSleepAgain) !== &quot;undefined&quot;) { try { window.plugins.insomnia.allowSleepAgain(callbackOk, callbackError); return true; } catch(E) { } } //Using Standby API: if (window.navigator &amp;&amp; typeof(navigator.wakeLock) !== &quot;undefined&quot; &amp;&amp; navigator.wakeLock !== null &amp;&amp; typeof(navigator.wakeLock.release) !== &quot;undefined&quot;) { try { navigator.wakeLock.release(&quot;display&quot;); //navigator.wakeLock.release(&quot;screen&quot;); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return true; } catch(E) { } } //Using Mozilla's Wake Lock API: if (window.navigator &amp;&amp; typeof(window.navigator.requestWakeLock) !== &quot;undefined&quot;) //So far, only works in Firefox/Firefox OS. { if (typeof(lock) === &quot;undefined&quot; || lock === null) { if (typeof(CB_Screen._screenLock) !== &quot;undefined&quot; &amp;&amp; CB_Screen._screenLock !== null) { lock = CB_Screen._screenLock; } } if (typeof(lock.unlock) !== &quot;undefined&quot;) { try { if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return lock.unlock(); } catch(E) { } } } //Using the W3C's Wake Lock API: if (window.navigator &amp;&amp; typeof(window.navigator.getWakeLock) !== &quot;undefined&quot;) { navigator.getWakeLock(&quot;screen&quot;).then ( function(wakeLock) { var request = wakeLock.createRequest(); request.cancel(); //setTimeout(function() { request.cancel(); }, 10); if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } }, callbackError ); } //Using the old W3C's Wake Lock API: if (typeof(screen) !== &quot;undefined&quot; &amp;&amp; screen !== null &amp;&amp; typeof(screen.keepAwake) !== &quot;undefined&quot;) { try { screen.keepAwake = false; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return true; } catch(E) { } } //Using NoSleep.js library: if (typeof(NoSleep) !== &quot;undefined&quot;) { //if (typeof(CB_Screen._noSleep) === &quot;undefined&quot; || CB_Screen._noSleep === null) { CB_Screen._noSleep = new NoSleep(); } CB_Screen._noSleep = new NoSleep(); //Needs to create a new one to work on some iOS versions. Source: https://github.com/richtr/NoSleep.js/issues/75. try { CB_Screen._noSleep.disable(); CB_Screen._noSleepEnabled = false; if (typeof(callbackOk) === &quot;function&quot;) { callbackOk(); } return true; } catch(E) { } } if (typeof(callbackError) === &quot;function&quot;) { callbackError(); } return false; } } //End of the static class CB_Screen. //CB_ScreenFileLoaded = true; //This file has been loaded. //CB_filesNeeded[&quot;screen/CB_Screen.js&quot;] = true; //This file has been loaded. × Search results Close "},"CrossBase_audiovisual_audio_CB_Speaker.js.html":{"id":"CrossBase_audiovisual_audio_CB_Speaker.js.html","title":"Source: CrossBase/audiovisual/audio/CB_Speaker.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/audiovisual/audio/CB_Speaker.js /** * @file Speakers management. Contains the {@link CB_Speaker} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the speaker or speakers. It will return itself if it is tried to be instantiated. It can also use [timbre.js]{@link https://mohayonao.github.io/timbre.js/}, [Band.js]{@link https://github.com/meenie/band.js/} and [jsfx]{@link https://github.com/loov/jsfx}. * @namespace * @todo Check whether the path used to play silent sounds as a workaround (through the internal &quot;_playBlankFilesSilently&quot; method) is right or not (now it uses the {@link CB_scriptPath} variable). * @todo getCopy and filterProperties methods (similar to the ones from {@link CB_GraphicSprites} and {@link CB_GraphicSpritesScene}). */ var CB_Speaker = CB_Speakers = function() { return CB_Speaker; }; { CB_Speaker.initialized = false; //It will tells whether the object has been initialized or not. CB_Speaker._silentAudioFilePlayed = false; //Defines whether a silent audio file has already been played when the user has clicked (hack for some web clients that doesn't start playing sounds unless the first sound is played when the user has clicked). CB_Speaker._silentAudioFilePlayedWAAPI = false; //Defines whether a silent audio file has already been played using WAAPI when the user has clicked (hack for some web clients that doesn't start playing sounds unless the first sound is played when the user has clicked). CB_Speaker._volume = CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; //Volume of the speaker. CB_Speaker._volumeBeforeMute = CB_Speaker._volume; //Stores the volume which was set before muting. CB_Speaker._audioFileSpritesPool = null; //CB_AudioFileSpritesPool object. CB_Speaker._timbreJSObject = null; //Stores the timbre.js object (if any). CB_Speaker._bandJSObject = null; //Stores the Band.js object (if any). CB_Speaker._jsfxObject = null; //Stores the jsfx object (if any). //Initializes all values: CB_Speaker.init = function() { if (CB_Speaker.initialized) { return CB_Speaker; } //Sets that the object has already been initialized: CB_Speaker.initialized = true; //Plays the blank sound silently, if able (workaround for some web clients): try { CB_Speaker._playBlankFilesSilently(); } catch(E) {} //Gets and stores the timbre.js object (if any): CB_Speaker._timbreJSObject = (typeof(T) !== &quot;undefined&quot; &amp;&amp; T !== null) ? T : null; //Gets and stores the Band.js object (if any): CB_Speaker._bandJSObject = (typeof(BandJS) !== &quot;undefined&quot; &amp;&amp; BandJS !== null) ? BandJS : null; //Gets and stores the jsfx object (if any): CB_Speaker._jsfxObject = (typeof(jsfx) !== &quot;undefined&quot; &amp;&amp; jsfx !== null) ? jsfx : null; return CB_Speaker; } //Function that plays a silent sound the first time the user clicks: CB_Speaker._playBlankFilesSilently = function() //Note: hack for some web clients that doesn't start playing sounds unless the first sound is played when the user has clicked. { var silentAudioFiles = new Array(2); silentAudioFiles[&quot;AAPI&quot;] = new Array(3); silentAudioFiles[&quot;WAAPI&quot;] = new Array(6); var destroySilentAudioFile = function(API, extension, needsLoaded) { setTimeout ( function() { if (typeof(silentAudioFiles) !== &quot;undefined&quot; &amp;&amp; typeof(silentAudioFiles[API]) !== &quot;undefined&quot; &amp;&amp; typeof(silentAudioFiles[API][extension]) !== &quot;undefined&quot; &amp;&amp; silentAudioFiles[API][extension] !== null) { if (!needsLoaded || silentAudioFiles[API][extension].getStatusString() === &quot;LOADED&quot;) { silentAudioFiles[API][extension].destructor(true, false, true, false); silentAudioFiles[API][extension] = null; } } }, 100 ); }; var createSilentAudioFile = function(filePath, API, extension, dataURI) { extension = extension.toLowerCase(); silentAudioFiles[API][extension] = null; if (extension === &quot;mp3&quot; &amp;&amp; CB_AudioDetector.isAudioFormatSupported(&quot;audio/mpeg;&quot;, dataURI) === &quot;&quot;) { return; } if (extension === &quot;ogg&quot; &amp;&amp; CB_AudioDetector.isAudioFormatSupported(&quot;audio/ogg&quot;, dataURI) === &quot;&quot;) { return; } if (extension === &quot;wav&quot; &amp;&amp; CB_AudioDetector.isAudioFormatSupported(&quot;audio/wav&quot;, dataURI) === &quot;&quot;) { return; } API = API.toUpperCase(); silentAudioFiles[API][extension] = new CB_AudioFile ( filePath, //filePath &quot;CB_blank_sound_&quot; + API, //id { autoLoad: true, autoPlay: false,//(API === &quot;AAPI&quot;), loop: false, volume: 1 }, //options API, //API function() { destroySilentAudioFile(API, extension, true); }, //callbackOk function(error) { destroySilentAudioFile(API, extension); } //callbackError ); }; /* createSilentAudioFile(&quot;data:audio/mpeg;base64,/+MYxAAKK2IBQAgEdwIP//+P/9/9/o0//8jer//U/////5znO/V/U7T6Mc7aTnOedyEnDix6/nIyl/ylPLJ19Z2bn3//8q+2/+MYxBIJC2YcAABHTJcyCOjsDMyORiF3iDM4QSB0UtUNwSAIrB7NiRnrpo///Iv/XYeqPVUJ4FTLUuUTe0LEAi9Ox3/x8uue/+MYxCgMSAYuUABEAltFTREVAxMEDCpuSOUJUV3C90k6gTk9S6Eto//xd3+pOj/2fSN///pnc/fDinSZYWGVjATdhJIbRen//+MYxDEJ2AYySAhEAkaFv3Nq/L7P/Wzdf6tifb1Pdb//V2vF1lWCRy3Acql0khff///MKkIMQma8KhCvkLkL6////////kKE/+MYxEQKaAIuSAhEliEQn4UQvZjCgIEaxvCgI2pMQU1FMy45OS4zqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq/+MYxFUKU2IEIABHFaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq&quot;, &quot;WAAPI&quot;, &quot;mp3&quot;, true); createSilentAudioFile(&quot;data:audio/ogg;base64,T2dnUwACAAAAAAAAAAA3ZwAAAAAAAFG/+m4BHgF2b3JiaXMAAAAAAoA+AAAAAAAAagQBAAAAAACpAU9nZ1MAAAAAAAAAAAAAN2cAAAEAAABzQvG4Dy3/////////////////tgN2b3JiaXMdAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAwNzA2MjIAAAAAAQV2b3JiaXMhQkNWAQBAAAAYQhAqBa1jjjrIFSGMGaKgQsopxx1C0CGjJEOIOsY1xxhjR7lkikLJgdCQVQAAQAAApBxXUHJJLeecc6MYV8xx6CDnnHPlIGfMcQkl55xzjjnnknKOMeecc6MYVw5yKS3nnHOBFEeKcacY55xzpBxHinGoGOecc20xt5JyzjnnnHPmIIdScq4155xzpBhnDnILJeecc8YgZ8xx6yDnnHOMNbfUcs4555xzzjnnnHPOOeecc4wx55xzzjnnnHNuMecWc64555xzzjnnHHPOOeeccyA0ZBUAkAAAoKEoiuIoDhAasgoAyAAAEEBxFEeRFEuxHMvRJA0IDVkFAAABAAgAAKBIhqRIiqVYjmZpniZ6oiiaoiqrsmnKsizLsuu6LhAasgoASAAAUFEUxXAUBwgNWQUAZAAACGAoiqM4juRYkqVZngeEhqwCAIAAAAQAAFAMR7EUTfEkz/I8z/M8z/M8z/M8z/M8z/M8z/M8DQgNWQUAIAAAAIIoZBgDQkNWAQBAAAAIIRoZQ51SElwKFkIcEUMdQs5DqaWD4CmFJWPSU6xBCCF87z333nvvgdCQVQAAEAAAYRQ4iIHHJAghhGIUJ0RxpiAIIYTlJFjKeegkCN2DEEK4nHvLuffeeyA0ZBUAAAgAwCCEEEIIIYQQQggppJRSSCmmmGKKKcccc8wxxyCDDDLooJNOOsmkkk46yiSjjlJrKbUUU0yx5RZjrbXWnHOvQSljjDHGGGOMMcYYY4wxxhgjCA1ZBQCAAAAQBhlkkEEIIYQUUkgppphyzDHHHANCQ1YBAIAAAAIAAAAcRVIkR3IkR5IkyZIsSZM8y7M8y7M8TdRETRVV1VVt1/ZtX/Zt39Vl3/Zl29VlXZZl3bVtXdZdXdd1Xdd1Xdd1Xdd1Xdd1XdeB0JBVAIAEAICO5DiO5DiO5EiOpEgKEBqyCgCQAQAQAICjOIrjSI7kWI4lWZImaZZneZaneZqoiR4QGrIKAAAEABAAAAAAAICiKIqjOI4kWZamaZ6neqIomqqqiqapqqpqmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpAqEhqwAACQAAHcdxHEdxHMdxJEeSJCA0ZBUAIAMAIAAAQ1EcRXIsx5I0S7M8y9NEz/RcUTZ1U1dtIDRkFQAACAAgAAAAAAAAx3M8x3M8yZM8y3M8x5M8SdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TQNCQ1YCAGQAAJACz0IpLUYCHIiYo9h777333ntlPJKISe0x9NQxB7FnxiNmlKPYKc8cQgxi6Dx0SjGIKfVSMsYgxthjDCGUGAgNWSEAhGYAGCQJkDQNkDQNAAAAAAAAACRPAzRRBDRPBAAAAAAAAABJ8wBN9ABNFAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkDwN8EQR0EQRAAAAAAAAADRRBERRBUTVBAAAAAAAAABNFAFPFQHRVAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkDQP0EQR8EQRAAAAAAAAADRRBETVBDxRBQAAAAAAAABNFAHRVAFRFQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQ4AAAEWAiFhqwIAOIEAAyOY1kAAOBIkqYBAIAjSZoGAACapokiAABYmiaKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAkwoA4WGrAQAogAADIaiaQDLAlgWQNMAmgbwPIAnAkwTAAgAAChwAAAIsEFTYnGAQkNWAgBRAAAGRZEky/I8aJqmiSI0TdNEEZ7neaIIz/M804Qoep5pQhQ9zzRhmqJomkAUTVMAAECBAwBAgA2aEosDFBqyEgAICQAwKIpleZ4oiqJpqqrrQtM8TxRF0TRV1XWhaZ4niqJomqrquvA8TzRF0zRNVXVdeJ4omqZpqqrqui48TxRN0zRV1XVdF54niqZpmqrqurIMURRF0zRNVXVdWQaiaJqmqaquK8tAFE1TVV3XdWUZiKJpqqrruq4sA9NUTVV1XVmWZYBpqqrryrIsA1TVdV1Xlm0boKqu67qybNsA13VdWZZl2wbgurIsy7YtAADgwAEAIMAIOsmosggbTbjwABQasiIAiAIAAIxRSjGlDGMSSimhYUxKSaVUUlJKqZRKQkoplVJJSSmlUjJKKaXWUiUllZJSqqSUVFJKBQCAHTgAgB1YCIWGrAQA8gAACEKQYowx56SUSjHmnHNSSqUYc845KSVjjDnnnJSSMcacc05KyZhzzjknpWTMOeeck1I655xzEEoppXTOOQillFJC6ByEUkopnXMOQgEAQAUOAAABNopsTjASVGjISgAgFQDA4DiWpWma5nmiaEmS5nmi54miqVqS5Hmi6Hmiaao8zxNFURRNU1WJouiJoiiapqqSZVE0TdNUVddly6Jomqapqq4L0xRFVXVd2YVpiqJpuq4sQ7ZVU1VdV7Zh26apqq4ry8B1XVeWbR24ruvKsq0LAABPcAAAKrBhdYSTorHAQkNWAgAZAAAEIQgppRBSSiGklEJIKYWQAACAAQcAgAATykChISsBgFQAAABCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGE0DnnnHPOOeecc84555xzzjnnnHPOOeecc84555xzzjnnnHPOOeecc84555xzzjnnnHPOOeecc04AIHaFA8BOhA2rI5wUjQUWGrISAAgHAACMMcY5i7XWWmullFISaq211lozhZSS0GKMMcYYMwYhpRZjjDHGmDHnqMUYY4wxxtZKiS3GGGOMMbZWSowxxhhjjDHG2GKLMcYYY4wxxhZjjDHGGGOMMcYYY4wxxhhjjDHGFmOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjC3GGGOMMcYYY4wxxhhjjAUAmDw4AEAl2DjDStJZ4WhwoSErAYDcAADAGKUYc8w5CCGUUkIpqbXOOQchhFJKKSmVllJMGXPOOQihlFJCKSm1lDrnHIRSSkkppZRSS611DkIIoZRSSkkppZRaCiGEUkpJJaWUUmqttRRCCKWUklJKKaWUWmsxlBJSKaWklFIqqaXWUksllJJKSimllFJqLbXWSimppJRSSimllFpsLYVSUioppZZSSqm1GFsspZWUUkoppdRaiq21FltKKaXUUksppdZiS62llFJqKaXUUmqpxdhaaymllFpKLbWUUoqttRZTSq2llFpqraUWW0qtpZZSai21lFJrrcUWW2stpZZSSim11mJLMbaWWkkppZZaS63F1mJrrbXUWkstpdRiizHG2GJsLaaUUmoptVQAANCBAwBAgBGVFmKnGVcegSMKGSagQkNWAgBkAAAEMk0yJyk1wiSnGJTSnHNKKaWUhsiSDFIMqiOTMScpZ4g0hhSkninymFIMYghJhU4xh60mH0voINagjBEupRgAAABBAICAkAAAAwQFMwDA4ABh5ECgI4DAoQ0AMBAhM4FBITQ4yASAB4gIqQAgMUFRutAFIUSQLoIsHrhw4sYTN5zQoQ0EAAAAAAAEAD4AABIKICAimrkKiwuMDI0Njg6PDxABAAAAAAACgA8AgCQECIiIZq7C4gIjQ2ODo8PjAyQAABBAAAAAAAAEEICAgAAAAAAAQAAAAICAT2dnUwAEDwkAAAAAAAA3ZwAAAgAAAEwW7hoGL1ZMVFNKBK13s5KD1btZaQCACKlDa/uped/er1NrjA5L/p035k7vI9Z8WJl/md3aOsn43Qrat/pI/QAMkOtjfaR+ADbIAxBVoqqwKKP5sl5vP3zbnfeeM90tX0dP/5nSPnrktBxk1diqs1FLYOo6PxtS+5e/L7E0PIwYHsaR+D8+rodbNe999Lb7B973+kj9AAxAn+sj9QMwAABUiapyQ89A/5b2iI3GO+ypcWTO5kbAIK40ufM/x3+Pxq39827Kw9/+OlIaxHkx3zzPV1J2PW45vNc9DxHel3pM/QAs0NC3eiz9AGyQByCqqipUiuaRKr185Uv6/Tkuu0aT8vxqdrRzqSyKduKQKR7Gc8vyTO0Vb0PMzKaMMBf/MtMf2f7c/DtdS8qPWvemJALex3rs/AAUkOhrPZZ+ABbIAxCiqnKF1ayx6fTzPvz9vf1b/7f5WuevW0udiwni8oyHVc5z68bZyr3LnrHuu6aOFK5t8Wzr8bvx/+VjmqpBTaHUAd5Xejs/AAVE+1KPnR+ABgBAlApRFb0dvfXgEI+/DrPs6tWvEuQd5z/n0ic/h07Hs5PvG76ms6e+prM59p9cs8PJ3s/W7fBlF70B&quot;, &quot;WAAPI&quot;, &quot;ogg&quot;, true); createSilentAudioFile(&quot;data:audio/wav;base64,UklGRuwgAABXQVZFZm10IBAAAAABAAIAgD4AAAD6AAAEABAAZGF0YcggAAAAAAEAAAD+/wEAAgD+////AgAAAP7/AQACAP////8AAAAAAQAAAP//AAABAAAA//8AAAEAAAD/////AAACAAIA/v/8/wEABQAAAPv///8EAAIA/f/+/wMAAQD9////AgABAP//AAAAAAAAAQAAAAAA///+/wEAAwAAAPz/AAAFAP///P8CAAMA/v/9/wIAAgD+////AgABAP7///8CAAEA/v///wEAAQABAP7//v8DAAIA/f/+/wIAAQAAAAAA/v8AAAMA///+/wIAAQD+////AgABAP3///8EAAIA/P/+/wQAAAD9/wIAAQD9/wEABAD+//z/AgACAP//AAAAAP//AQACAP///v///wEAAwD///3/AQACAAAA/////wAAAgAAAP7/AQAAAP//AQAAAP//AQABAP7/AAADAP7//f8DAAIA/f///wIAAAD//wEAAAD//wEAAQD/////AQABAP////8BAAEA/////wEAAQAAAP///v8CAAMA/f/+/wIAAQAAAP////8AAAIAAQD+//7/AQADAAAA/f8AAAIAAAD//wAAAAD//wAAAQABAAAA/v8AAAMAAAD8////BAABAP3/AAACAP////8CAAAA/v8AAAEAAQAAAP7/AAACAP///v8CAAIA/f///wMA///+/wIAAgD+//7/AgACAP///f///wQAAgD8////BAAAAPz/AAADAAEA///+////AwADAPz/+/8DAAYA/v/6/wEABQAAAP3///8BAAEAAAD//wAAAAD//wIAAgD9//7/AwACAP3//v8DAAIA/f/9/wMABAD+//z/AQAEAAAA/f/+/wIAAgD9////BAAAAPz/AgAFAPz/+/8EAAMA/P///wQA///9/wMAAgD8//7/AwACAP///v8AAAMAAAD9/wAAAgAAAP///////wIAAwD///3/AAACAAAA//8AAAAA//8BAAIA/v///wIA///+/wMAAgD8//7/BAABAPz/AQADAP7///8BAP//AAACAP///v8CAAEA//8AAP//AAACAP///v8CAAEA/f8BAAMA/v///wIA///+/wIAAgD+//7/AQADAAEA/P/+/wUAAgD7////BAD///z/AgAEAP7//f8CAAIA///+////AgACAP7//v8CAAEA//8AAAAA//8AAAEAAAABAP///f8DAAMA/f/9/wIAAwD+////AQD//wAAAgAAAP3/AAADAP///v8BAAEA//8AAAIA///+/wEAAgD///3/AgADAP3//v8DAAIA/f///wMAAAD+/wAAAQAAAP////8CAAIA/f/+/wMAAgD+////AQD//wAAAgD///7/AQABAAEAAQD9////BAAAAPz/AQADAP7//v8DAAEA/f8AAAIAAAD//wAAAAAAAAEA/////wIAAAD+/wEAAgD///7/AAACAAEA/v///wIAAQD+/wAAAQD//wAAAQD/////AgABAP7/AAABAP//AAABAP//AAABAP//AAABAAAA//8AAAEA//8AAAIA///+/wIAAgD9////BAD///v/AgAEAP7//v8DAAEA/P8AAAQA///9/wEAAQD//wAAAQAAAP//AQACAP///f8AAAMAAAD9/wAAAwABAP3//v8DAAIA/f/+/wMAAwD9//z/AgAEAP7//P8CAAMA/////wEAAAD+/wEAAgD+//7/AQABAAAAAQAAAP7/AAACAAAA/v///wEAAQAAAP//AAABAP////8CAAIA/v/9/wEAAwAAAP7///8BAAIAAAD///////8CAAIA/v/+/wIAAQD+/wEAAQD9/wAABAAAAP3/AAABAP//AAACAP///v8CAAIA///+/wAAAQAAAAAAAAAAAP//AAADAAAA/P8AAAQAAAD8/wAAAwAAAP7/AAACAAAA/v8AAAIAAQD+//7/AQACAAAA//8AAAAAAAAAAAAAAAAAAP//AAADAAAA/f///wEAAgD///7/AQACAAAA/v8BAAEA/f8AAAMAAAD9/wAABAAAAP3/AAABAAAA//8AAAEAAAAAAAEA///9/wIABAD9//3/AwACAP7//v8AAAIAAgD9//7/BAABAP3/AAABAP7/AAAEAAAA/P///wMAAgD///7///8BAAEA//8AAAIA///9/wIABAD+//z/AQACAAAAAAAAAP////8CAAEA/v///wEAAgAAAP7///8CAAEA/f8AAAMAAAD9/wAABAAAAP3///8BAAEAAAAAAP//AAACAAAA/v8AAAEA//8AAAIAAAD//wAA//8AAAMAAAD7////BgACAPv///8DAAAA//8BAAAA/f8AAAQAAAD9/wAAAwAAAP3/AAABAAAAAQD/////AwABAPv///8GAAEA+v///wUAAQD8/wAAAwD///7/AgABAP3/AAADAP////8CAAAA/v///wEAAgAAAP3///8EAAIA/P/+/wMAAgD+//7/AQACAAAA/v///wMAAQD9////AgAAAP7/AQACAAAA/////wEAAAD//wAAAQAAAP7/AAACAAEA///+/wEAAgAAAP///v///wMAAgD+////AQAAAAAAAQD+////BAAAAPz/AQADAP7//v8DAAAA/v8CAAAA/v8BAAIA/f/+/wUAAAD7/wIABAD+//3/AgABAP7/AQABAP7///8CAAMA/v/8/wIABAD+//z/AwADAPz///8EAAEA/P///wQAAQD9//7/AgADAP///v8AAAEAAQAAAP////8AAAAAAAACAAAA/f8BAAMA/v/+/wMAAAD8/wEAAwAAAP////8AAAEAAAAAAAAA//8AAAEAAAABAAAA/v///wIAAQD+/wAAAQD//wAAAQAAAP////8AAAIAAQD+////AgABAP7/AAABAP7/AAADAAAA/P8AAAUAAAD8/wEAAgD//wAAAAD+/wAAAwAAAP3/AQACAP7///8CAAEA//8AAAAA//8BAAEA/f/+/wMAAwD///7/AAACAAAA/v8BAAEA/v///wIAAQD+/wAAAgD/////AgABAP7///8AAP//AQADAP7//f8DAAIA/v///wEAAAD//wEAAAD+/wEAAgD+////AwAAAP3/AQACAP7///8CAAAA//8BAAAA//8AAAEAAAD+/wEAAgD+////AgABAP7/AAABAP7/AAADAAAA/P///wUAAgD7//3/BAADAP7//f8AAAQAAQD7//7/BQADAPv//f8EAAMA/v/9/wEAAgD//wAAAQD///7/AQADAP///v8BAAAA//8BAAEA/v/+/wMAAwD+//7/AAAAAAEAAQD+////AgAAAP//AQAAAP7/AQADAP///v8AAAAAAAAAAAAA//8BAAIA/////wEAAAD//wEAAAD9/wEABAD///3/AQABAP//AQABAP7///8DAAEA/f///wEAAAABAAIA/v/9/wMABAD8//v/BAAEAP3//v8CAAEA//8AAAEA///+/wAAAwABAPz/AAAFAAAA+////wQAAQD9////AgACAP////8BAAAA/v8AAAMAAAD8/wAABQAAAPv/AQAEAP7//f8CAAEA//8BAAAA/v8BAAIA///+/wAAAQAAAAAAAAAAAAAA//8AAAIAAAD9/wAAAwAAAP7///8CAAEA/v8AAAEA/////wIAAgD+//7/AAACAAIA/f/9/wQAAwD9////AQD+/wAAAwD///7/AgAAAP7/AgACAP3//f8DAAMA/f/+/wMAAQD9/wAAAwD///3/AAACAAEAAAD/////AQACAP///f8AAAIAAAD//wEAAQD+/wAAAwD///3/AQABAP//AQABAP7///8DAAEA/f///wEAAgAAAP7/AAABAAAA/v8AAAMA///+/wIAAgD+//7/AQABAP////8BAAIAAAD+////AgABAP///////wEAAgAAAP7/AAACAP///v8CAAIA/f/9/wMAAwD+//7/AQABAAAAAAAAAAAA/////wEAAgD///7/AQACAAAA////////AgACAP3//v8EAAIA/P/+/wMAAgD+//3/AQAEAAAA/P8AAAMAAAD+////AQACAAAA/f8AAAMAAAD+////AgACAP7//v8BAAIA///+/wEAAQAAAAAAAAAAAP//AQACAP7//v8CAAAA/f8CAAQA/v/9/wEAAQABAAEA/f/+/wMAAgD///7/AAABAAAAAAAAAAAAAAAAAAAAAAABAAAA/v8AAAIAAAD+/wAAAwAAAPz/AAAEAAAA/f8BAAIA/v///wIAAAD+/wAAAgAAAP7/AQACAP///v8AAAIAAAD//wAA//8AAAIAAAD+/wEAAgD+////AwAAAPz/AAAEAAAA/f8AAAIAAQD+//7/AgACAP///v8AAAEAAAABAAAA/v8AAAIAAAD//wAAAAD//wEAAgD+////AgAAAP//AAABAP////8BAAEAAAD+/wAAAgAAAP////8AAAEAAQD///7/AQADAAAA/f///wIAAAD//wIAAQD9//7/AwADAP7//f8AAAIAAgAAAP7//v8BAAIAAAD///////8BAAMAAAD8////BAACAPz//f8DAAMA/v/9/wIAAwD///7///8BAAIA///9/wEABAD///3/AgABAP7/AAAAAP//AQACAP///v8BAAEA/////wAAAgAAAP7/AAACAAEA/f///wMA/////wMA///8/wIABAD+//7/AgD///7/BAABAPv/AAAEAAAA/v8AAAAA//8CAAEA/f8AAAIAAAAAAP////8CAAEA/f///wQAAQD8////BAACAPz//f8DAAIA/v8AAAEA//8AAAIAAAD9/wAAAwD///3/AgADAP7//v8CAAEA/////wAAAgAAAP3/AQAEAP7//P8CAAMA///+/wAAAQAAAAAAAAAAAP//AAACAAAA/v///wIAAQD+/wAAAQD//wAAAgAAAP3/AAACAAAAAAAAAP//AAABAAAA/////wAAAwABAPz///8EAAEA/P/+/wMAAwD///3/AAADAAAA/f8AAAIAAQD///7/AAACAAEA/v/+/wMAAgD9////AwAAAPz/AAADAAAAAAAAAP7/AAADAAEA/f///wEAAAABAAAA/v8BAAMA///9/wEAAgD///7/AAACAAEA/////wAAAQABAP7//v8DAAIA/f/+/wIAAgD/////AAAAAAEAAAD+////AwACAPz///8FAAAA+/8AAAQAAAD+/wAAAAABAAIA///9/wEABAD///v/AAAFAAIA+//9/wUABAD8//z/AgADAP///v8AAAEAAQAAAP//AAAAAAAAAQAAAP//AAAAAAAAAgAAAPz/AAAFAAAA/P8BAAIA/v8AAAIA/////wEAAAD//wEAAQD//wAAAAD//wEAAgD///3/AQADAP///f8BAAQA/v/7/wMABgD9//v/AwACAP3/AQADAP7//f8CAAIA/////wAAAQAAAP//AgABAPz///8EAAAA/f8BAAIA///+/wEAAgD///7/AQACAP7///8DAP///f8CAAMA/v/9/wEAAwABAP3//v8CAAMA///9/wAAAgACAP///f8AAAIAAQD//wAAAAAAAAEA/////wIAAAD8/wEABgD+//r/AgAFAP///f8BAAEA//8AAAAA//8BAAEA/v8AAAMAAAD9/wAAAwAAAP3/AAACAAAA//8AAAAAAQABAP7//v8CAAMA/v/8/wIABAD///z/AAAEAAAA/P///wQAAQD8/wAABAAAAPz/AAAEAAAA/P///wMAAgD+//7/AgACAP7//v8BAAIAAAD///////8BAAIA///+/wEAAgAAAP////8AAAEA/////wIAAQD+/wAAAQD//wEAAQD9/wAAAwD///7/AgABAP7/AAABAP//AAABAP////8CAAEA/v8AAAIAAAD+////AQABAAAA//8AAAEAAAABAAAA/v///wEAAgD///7/AQACAP///v8CAAEA/f8AAAIAAAAAAAAA/////wIAAgD9//7/AwABAP7/AAACAP///v8CAAIA/f/+/wIAAgD///7/AQABAP////8AAAIAAQD+////AQABAAAA/////wEAAQD//wAAAQD/////AQAAAAAAAQD///7/AgADAP7//f8AAAIAAgD+//3/AQAEAAEA+//+/wUAAwD7//z/BQADAPz///8CAP//AAADAP///P8BAAMA///+/wEAAgAAAP////8AAAEAAAD/////AQADAP///P8BAAUA///7/wEABAD///3/AAACAAEA/////wEAAgD///3/AQACAP////8BAAEA/////wEAAgAAAP3///8CAAEA//8AAAEA//8AAAEA/////wEAAQD//wAAAQAAAAEA///9/wEABAD///v/AQAFAAAA/P8AAAQAAAD8////AwABAP7/AAABAAAAAQABAP7//f8BAAMAAAD///////8CAAMA/v/8/wEAAgAAAAEA///9/wEAAwD///7/AQABAAAAAAD//wAAAQD/////AQABAP////8CAAEA/v///wIAAQD+////AQABAAAA/////wIAAgD9//7/AwACAP7//v8AAAIAAgD+//3/AQADAAAA//8AAP//AAABAAEAAAD+////AgACAP7//v8CAAEA//8AAAEA///+/wEAAgAAAP7///8DAAEA/f///wIAAAD+/wEAAQD//wEAAAD+/wIAAgD9//7/AwABAP3/AAADAAAA/v8AAAEAAAAAAAAA//8AAAEAAAAAAAAAAAAAAP//AAACAAEA/f/+/wQAAQD9/wAAAQAAAAAAAAD//wAAAgD/////AgAAAP////8AAAEAAAAAAAAAAQABAP7///8BAAEA/////wEAAAAAAAEA/////wIAAQD+////AAAAAAEAAAD//wEAAQD//wAAAQAAAP///v8AAAQAAQD8////AgAAAAAAAQD/////AQABAP///v8BAAIA/////wEAAAD//wEAAQD+////AgABAP////8AAAEAAQD///7/AQADAP///f8CAAIA/f8AAAIA/////wEAAQD//wAAAQD//wAAAAAAAAAA//8BAAEA//8AAAAA//8BAAIA/v/9/wIAAwD///3/AAADAAEA/f///wMAAAD9/wAAAgABAP////8BAAEA/////wAA//8AAAMAAAD+/wEAAQD//wAAAAD//wAAAAAAAAMAAAD7/wEABQD+//3/AgABAP7///8CAAEA////////AQACAAAA/f/+/wMAAwD+//3/AgADAP7//f8BAAIAAAD/////AAACAAEA/////wAAAAAAAAEAAQD+//7/AgADAP///f8AAAIAAQD/////AQABAP////8BAAAA//8BAAEA/////wEAAQD/////AAABAAEA/////wEAAAD//wEAAAD+/wEAAwD///3/AQACAP////8BAAEA///+/wIAAwD9//3/AgADAAAA/v///wAAAgABAP3///8DAAEA/f8AAAMA///+/wEAAQD/////AQABAP////8BAAIA///9/wEAAgD/////AQABAP////8BAAEA/////wAAAQABAP///v8AAAMAAQD9/wAAAgAAAP//AAAAAP//AQAAAP//AQABAP////8BAAEAAAD///7/AgACAP3//v8DAAIA/f///wMAAAD+/wEAAQD+////AgABAP////8BAAIA///9/wAAAwABAP7//v8BAAQA///7/wEAAwD//wAAAgD+//3/AgADAP///f8AAAMAAQD+////AAAAAAEAAQD/////AQAAAAAAAgD///3/AQADAP///v8BAAAA//8BAAIA///9/wEAAwD///7/AQABAP////8AAAEAAQAAAP////8AAAEAAgD+//z/AgAEAAAA/f/+/wEAAwABAPz//v8EAAIA/f/+/wEAAQABAAAA/v8AAAMAAAD8/wAAAwAAAP//AQAAAP7/AQACAP7//v8CAAIA/////wEAAAD+/wAAAgAAAP//AAAAAAAAAQAAAP//AAAAAAAAAQABAP7//v8DAAIA/f/+/wIAAgAAAAAA/v///wMAAAD9/wAAAgAAAP//AgABAP7//v8AAAMAAQD8////BQABAPv/AAAEAP///f8CAAIA/v///wIAAgD+//3/AQACAAEA///+/wAAAgACAP///f8AAAIAAQD///7/AAACAAAA//8AAAAAAAABAAAA//8AAAAAAAABAAAA/v///wIAAgD///7/AAACAAEA///+/wAAAgABAP7//v8CAAMA///9/wAAAwAAAP3/AAACAAAA/v8AAAMAAAD9/wAAAgAAAP//AQAAAP7/AQABAP7/AAACAAAA//8AAAEAAAD//wAAAQAAAP//AAABAAAAAAD/////AwACAPz//f8FAAMA+//+/wMAAgD///7/AAABAAEA/////wEAAAAAAAEA///+/wEAAgAAAP//AAAAAAAAAgAAAPz///8EAAIA/P///wMAAAD//wEAAAD+/wAAAgAAAP//AAAAAAAAAQAAAP//AAABAAAA//8BAAAA//8BAAAA//8BAAEA/////wAAAAABAAEA///+/wAAAgABAP////8AAAAAAQAAAP7/AAADAAAA/f8BAAIA/////wAAAQAAAP//AQABAP7//v8EAAIA+////wUAAQD8////AgD//wAAAgD///7/AQACAP////8BAP////8CAAAA/v8BAAIA/v/+/wMAAgD9////AgAAAP//AQAAAP//AQABAP7///8DAAAA/P8BAAUA///7/wEAAwD/////AAAAAAEAAAD//wEAAQD9////BAABAPz///8EAAEA/f///wIAAAD+/wIAAQD9/wEAAwD+//3/AgACAP7///8CAAAA/v8AAAIAAQD9////AwAAAP7/AAABAP////8CAAEA/////wAAAgAAAP3/AAACAAAAAAAAAP7/AAAEAAAA+/8AAAQAAAD+/wAAAAD//wEAAgD///7/AAABAAAAAAABAP7//v8DAAMA///8//7/BAADAP3//f8CAAIA//8AAAAA//8BAAEA/////wAAAQABAP////8BAAAA//8BAAIA/v/9/wMAAwD9//3/AgADAP7//v8CAAEA/v///wIAAQD//wAA/////wIAAQD+////AgABAP////8AAAEAAQD/////AgAAAP3/AQADAP///f8BAAMAAAD+//7/AQACAP////8BAAEAAAD/////AQABAP7///8CAAEA/////wEAAQD/////AAABAAAA/////wAAAwABAP3//v8BAAMAAAD9/wAAAgD/////AwAAAPv/AQAFAP///P8BAAMA/v/+/wMAAQD9////AwAAAP3/AQADAP7//f8EAAMA+//9/wQAAwD9//7/AgAAAAAAAQD/////AQAAAP//AgACAPz//v8FAAEA+v///wUAAgD9//7/AgADAP///P8AAAMA/////wIA///+/wMAAQD9/wAAAQD//wEAAgD+//3/AQAEAAAA+/8AAAUAAAD8/wEAAwD+//7/AQABAAAAAAAAAP//AAABAAAA//8AAAEAAAAAAP////8BAAEA///+/wEABAABAPv//f8FAAMA/P/9/wMAAwD9//7/AwACAP3//v8DAAEA/v8AAAEA/////wIAAQD9////BAAAAPz/AgAEAP3//P8CAAMAAAD+////AgABAP7///8CAAEA/f8AAAMA/////wIA///9/wIAAwD+//7/AQABAAEA///9/wEABAAAAPz///8EAAEA/P///wMAAQD+////AgACAP7//f8BAAMAAAD+/wAAAAAAAAIAAQD9//3/BAAFAPz/+v8DAAYA/v/7/wEABAAAAP3/AAABAAAAAQAAAP7/AAADAAAA/P8AAAQAAAD9/wEAAgD//wAAAAD+/wAAAwAAAP3/AQACAP7/AAADAP///P8BAAQA///8/wAAAwABAP7///8CAAAA/v8BAAEA/////wEAAQD//wAAAQAAAP7///8EAAEA+////wUAAQD8/wAAAgD/////AgABAP3///8DAAEA/v///wEAAQAAAP////8BAAIA///+/wEAAQAAAAAAAAD//wAAAQD//wAAAgD///7/AgABAP7/AQACAP7///8CAAAA//8BAAAA/v8BAAMA/v/9/wIAAwD+//7/AwAAAP3/AgACAPz///8FAP//+/8DAAUA/P/7/wMABAD///3///8DAAIA/f/+/wMAAQD8/wAABAD///7/AgABAP3///8DAAEA/f///wMAAQD+/wAAAQD/////AQABAAAA/v///wMAAQD9////AwABAP3///8DAAEA/f///wIAAQD/////AAABAAIA///9/wEAAwAAAP3///8CAAEAAAD/////AQACAP///f8BAAIA/////wEAAQD//wAAAQD+////AgAAAP//AQAAAP7/AgAEAPv/+/8GAAQA+//+/wQAAAD9/wIAAQD9/wAAAwAAAP7/AAABAAAAAAAAAP//AAACAAAA/f///wMAAgD9//7/AwACAP7//v8BAAIAAAD9////BAABAPz/AAADAAAA//8AAP7/AAAEAAAA/P8AAAMAAAD+/wAAAAD//wIAAgD9//7/BAACAPz//v8CAAAAAAACAP///v8CAAEA/f8AAAQA///7/wEABgAAAPr///8FAAEA/P8AAAQA///8/wEABAD///z/AQADAP////8BAAAAAAAAAP7/AQADAP3//f8DAAIA//8AAAAA/v8AAAMAAQD+//3/AQAEAP7//f8DAAIA/P///wYAAQD6////BAAAAP7/AQAAAP//AQABAP////8BAAEAAAD+/wAABAD///v/AQAFAAAA+////wQAAgD+//7/AAABAAEAAQD+//3/AwAEAP7//P8AAAMAAQD///7///8DAAIA/f/+/wIAAgD///7/AQACAP///v8AAAEAAAAAAAAA//8BAAIA///+/wAAAgAAAP7/AAABAAAAAAABAAAA/v8AAAMAAAD8/wAAAwAAAP//AAAAAAAAAQAAAP//AQD///7/AwADAP3//P8DAAQA/v/9/wAAAgABAP//AAABAAAA//8AAAAA//8BAAEA/v8AAAMAAQD9//7/AgABAP7///8CAAEA//8AAAAAAAAAAP////8CAAEA/f8AAAQAAAD7/wAABQAAAPz///8DAAIA/v/+/wEA&quot;, &quot;WAAPI&quot;, &quot;wav&quot;, true); */ var silentAudioFilePlay = function() { if (!CB_Speaker._silentAudioFilePlayed) { CB_Speaker._silentAudioFilePlayed = true; /////CB_Speaker.playFileBase(CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/sounds/blank&quot;); if (CB_AudioDetector.isAPISupported(&quot;AAPI&quot;, false)) { createSilentAudioFile(CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/sounds/blank.mp3&quot;, &quot;AAPI&quot;, &quot;mp3&quot;); createSilentAudioFile(CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/sounds/blank.mp3&quot;, &quot;AAPI&quot;, &quot;ogg&quot;); createSilentAudioFile(CB_scriptPath + CB_Configuration[CB_BASE_NAME].SCRIPT_PATH + &quot;audiovisual/audio/sounds/blank.mp3&quot;, &quot;AAPI&quot;, &quot;wav&quot;); } } if (!CB_Speaker._silentAudioFilePlayedWAAPI &amp;&amp; CB_AudioDetector.isAPISupported(&quot;WAAPI&quot;, false)) { createSilentAudioFile(&quot;data:audio/mpeg;base64,/+MYxAAKK2IBQAgEdwIP//+P/9/9/o0//8jer//U/////5znO/V/U7T6Mc7aTnOedyEnDix6/nIyl/ylPLJ19Z2bn3//8q+2/+MYxBIJC2YcAABHTJcyCOjsDMyORiF3iDM4QSB0UtUNwSAIrB7NiRnrpo///Iv/XYeqPVUJ4FTLUuUTe0LEAi9Ox3/x8uue/+MYxCgMSAYuUABEAltFTREVAxMEDCpuSOUJUV3C90k6gTk9S6Eto//xd3+pOj/2fSN///pnc/fDinSZYWGVjATdhJIbRen//+MYxDEJ2AYySAhEAkaFv3Nq/L7P/Wzdf6tifb1Pdb//V2vF1lWCRy3Acql0khff///MKkIMQma8KhCvkLkL6////////kKE/+MYxEQKaAIuSAhEliEQn4UQvZjCgIEaxvCgI2pMQU1FMy45OS4zqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq/+MYxFUKU2IEIABHFaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq&quot;, &quot;WAAPI&quot;, &quot;mp3&quot;, true); createSilentAudioFile(&quot;data:audio/ogg;base64,T2dnUwACAAAAAAAAAAA3ZwAAAAAAAFG/+m4BHgF2b3JiaXMAAAAAAoA+AAAAAAAAagQBAAAAAACpAU9nZ1MAAAAAAAAAAAAAN2cAAAEAAABzQvG4Dy3/////////////////tgN2b3JiaXMdAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAwNzA2MjIAAAAAAQV2b3JiaXMhQkNWAQBAAAAYQhAqBa1jjjrIFSGMGaKgQsopxx1C0CGjJEOIOsY1xxhjR7lkikLJgdCQVQAAQAAApBxXUHJJLeecc6MYV8xx6CDnnHPlIGfMcQkl55xzjjnnknKOMeecc6MYVw5yKS3nnHOBFEeKcacY55xzpBxHinGoGOecc20xt5JyzjnnnHPmIIdScq4155xzpBhnDnILJeecc8YgZ8xx6yDnnHOMNbfUcs4555xzzjnnnHPOOeecc4wx55xzzjnnnHNuMecWc64555xzzjnnHHPOOeeccyA0ZBUAkAAAoKEoiuIoDhAasgoAyAAAEEBxFEeRFEuxHMvRJA0IDVkFAAABAAgAAKBIhqRIiqVYjmZpniZ6oiiaoiqrsmnKsizLsuu6LhAasgoASAAAUFEUxXAUBwgNWQUAZAAACGAoiqM4juRYkqVZngeEhqwCAIAAAAQAAFAMR7EUTfEkz/I8z/M8z/M8z/M8z/M8z/M8z/M8DQgNWQUAIAAAAIIoZBgDQkNWAQBAAAAIIRoZQ51SElwKFkIcEUMdQs5DqaWD4CmFJWPSU6xBCCF87z333nvvgdCQVQAAEAAAYRQ4iIHHJAghhGIUJ0RxpiAIIYTlJFjKeegkCN2DEEK4nHvLuffeeyA0ZBUAAAgAwCCEEEIIIYQQQggppJRSSCmmmGKKKcccc8wxxyCDDDLooJNOOsmkkk46yiSjjlJrKbUUU0yx5RZjrbXWnHOvQSljjDHGGGOMMcYYY4wxxhgjCA1ZBQCAAAAQBhlkkEEIIYQUUkgppphyzDHHHANCQ1YBAIAAAAIAAAAcRVIkR3IkR5IkyZIsSZM8y7M8y7M8TdRETRVV1VVt1/ZtX/Zt39Vl3/Zl29VlXZZl3bVtXdZdXdd1Xdd1Xdd1Xdd1Xdd1XdeB0JBVAIAEAICO5DiO5DiO5EiOpEgKEBqyCgCQAQAQAICjOIrjSI7kWI4lWZImaZZneZaneZqoiR4QGrIKAAAEABAAAAAAAICiKIqjOI4kWZamaZ6neqIomqqqiqapqqpqmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpmqZpAqEhqwAACQAAHcdxHEdxHMdxJEeSJCA0ZBUAIAMAIAAAQ1EcRXIsx5I0S7M8y9NEz/RcUTZ1U1dtIDRkFQAACAAgAAAAAAAAx3M8x3M8yZM8y3M8x5M8SdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TdM0TQNCQ1YCAGQAAJACz0IpLUYCHIiYo9h777333ntlPJKISe0x9NQxB7FnxiNmlKPYKc8cQgxi6Dx0SjGIKfVSMsYgxthjDCGUGAgNWSEAhGYAGCQJkDQNkDQNAAAAAAAAACRPAzRRBDRPBAAAAAAAAABJ8wBN9ABNFAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkDwN8EQR0EQRAAAAAAAAADRRBERRBUTVBAAAAAAAAABNFAFPFQHRVAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkDQP0EQR8EQRAAAAAAAAADRRBETVBDxRBQAAAAAAAABNFAHRVAFRFQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQ4AAAEWAiFhqwIAOIEAAyOY1kAAOBIkqYBAIAjSZoGAACapokiAABYmiaKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAkwoA4WGrAQAogAADIaiaQDLAlgWQNMAmgbwPIAnAkwTAAgAAChwAAAIsEFTYnGAQkNWAgBRAAAGRZEky/I8aJqmiSI0TdNEEZ7neaIIz/M804Qoep5pQhQ9zzRhmqJomkAUTVMAAECBAwBAgA2aEosDFBqyEgAICQAwKIpleZ4oiqJpqqrrQtM8TxRF0TRV1XWhaZ4niqJomqrquvA8TzRF0zRNVXVdeJ4omqZpqqrqui48TxRN0zRV1XVdF54niqZpmqrqurIMURRF0zRNVXVdWQaiaJqmqaquK8tAFE1TVV3XdWUZiKJpqqrruq4sA9NUTVV1XVmWZYBpqqrryrIsA1TVdV1Xlm0boKqu67qybNsA13VdWZZl2wbgurIsy7YtAADgwAEAIMAIOsmosggbTbjwABQasiIAiAIAAIxRSjGlDGMSSimhYUxKSaVUUlJKqZRKQkoplVJJSSmlUjJKKaXWUiUllZJSqqSUVFJKBQCAHTgAgB1YCIWGrAQA8gAACEKQYowx56SUSjHmnHNSSqUYc845KSVjjDnnnJSSMcacc05KyZhzzjknpWTMOeeck1I655xzEEoppXTOOQillFJC6ByEUkopnXMOQgEAQAUOAAABNopsTjASVGjISgAgFQDA4DiWpWma5nmiaEmS5nmi54miqVqS5Hmi6Hmiaao8zxNFURRNU1WJouiJoiiapqqSZVE0TdNUVddly6Jomqapqq4L0xRFVXVd2YVpiqJpuq4sQ7ZVU1VdV7Zh26apqq4ry8B1XVeWbR24ruvKsq0LAABPcAAAKrBhdYSTorHAQkNWAgAZAAAEIQgppRBSSiGklEJIKYWQAACAAQcAgAATykChISsBgFQAAABCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGE0DnnnHPOOeecc84555xzzjnnnHPOOeecc84555xzzjnnnHPOOeecc84555xzzjnnnHPOOeecc04AIHaFA8BOhA2rI5wUjQUWGrISAAgHAACMMcY5i7XWWmullFISaq211lozhZSS0GKMMcYYMwYhpRZjjDHGmDHnqMUYY4wxxtZKiS3GGGOMMbZWSowxxhhjjDHG2GKLMcYYY4wxxhZjjDHGGGOMMcYYY4wxxhhjjDHGFmOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjC3GGGOMMcYYY4wxxhhjjAUAmDw4AEAl2DjDStJZ4WhwoSErAYDcAADAGKUYc8w5CCGUUkIpqbXOOQchhFJKKSmVllJMGXPOOQihlFJCKSm1lDrnHIRSSkkppZRSS611DkIIoZRSSkkppZRaCiGEUkpJJaWUUmqttRRCCKWUklJKKaWUWmsxlBJSKaWklFIqqaXWUksllJJKSimllFJqLbXWSimppJRSSimllFpsLYVSUioppZZSSqm1GFsspZWUUkoppdRaiq21FltKKaXUUksppdZiS62llFJqKaXUUmqpxdhaaymllFpKLbWUUoqttRZTSq2llFpqraUWW0qtpZZSai21lFJrrcUWW2stpZZSSim11mJLMbaWWkkppZZaS63F1mJrrbXUWkstpdRiizHG2GJsLaaUUmoptVQAANCBAwBAgBGVFmKnGVcegSMKGSagQkNWAgBkAAAEMk0yJyk1wiSnGJTSnHNKKaWUhsiSDFIMqiOTMScpZ4g0hhSkninymFIMYghJhU4xh60mH0voINagjBEupRgAAABBAICAkAAAAwQFMwDA4ABh5ECgI4DAoQ0AMBAhM4FBITQ4yASAB4gIqQAgMUFRutAFIUSQLoIsHrhw4sYTN5zQoQ0EAAAAAAAEAD4AABIKICAimrkKiwuMDI0Njg6PDxABAAAAAAACgA8AgCQECIiIZq7C4gIjQ2ODo8PjAyQAABBAAAAAAAAEEICAgAAAAAAAQAAAAICAT2dnUwAEDwkAAAAAAAA3ZwAAAgAAAEwW7hoGL1ZMVFNKBK13s5KD1btZaQCACKlDa/uped/er1NrjA5L/p035k7vI9Z8WJl/md3aOsn43Qrat/pI/QAMkOtjfaR+ADbIAxBVoqqwKKP5sl5vP3zbnfeeM90tX0dP/5nSPnrktBxk1diqs1FLYOo6PxtS+5e/L7E0PIwYHsaR+D8+rodbNe999Lb7B973+kj9AAxAn+sj9QMwAABUiapyQ89A/5b2iI3GO+ypcWTO5kbAIK40ufM/x3+Pxq39827Kw9/+OlIaxHkx3zzPV1J2PW45vNc9DxHel3pM/QAs0NC3eiz9AGyQByCqqipUiuaRKr185Uv6/Tkuu0aT8vxqdrRzqSyKduKQKR7Gc8vyTO0Vb0PMzKaMMBf/MtMf2f7c/DtdS8qPWvemJALex3rs/AAUkOhrPZZ+ABbIAxCiqnKF1ayx6fTzPvz9vf1b/7f5WuevW0udiwni8oyHVc5z68bZyr3LnrHuu6aOFK5t8Wzr8bvx/+VjmqpBTaHUAd5Xejs/AAVE+1KPnR+ABgBAlApRFb0dvfXgEI+/DrPs6tWvEuQd5z/n0ic/h07Hs5PvG76ms6e+prM59p9cs8PJ3s/W7fBlF70B&quot;, &quot;WAAPI&quot;, &quot;ogg&quot;, true); createSilentAudioFile(&quot;data:audio/wav;base64,UklGRuwgAABXQVZFZm10IBAAAAABAAIAgD4AAAD6AAAEABAAZGF0YcggAAAAAAEAAAD+/wEAAgD+////AgAAAP7/AQACAP////8AAAAAAQAAAP//AAABAAAA//8AAAEAAAD/////AAACAAIA/v/8/wEABQAAAPv///8EAAIA/f/+/wMAAQD9////AgABAP//AAAAAAAAAQAAAAAA///+/wEAAwAAAPz/AAAFAP///P8CAAMA/v/9/wIAAgD+////AgABAP7///8CAAEA/v///wEAAQABAP7//v8DAAIA/f/+/wIAAQAAAAAA/v8AAAMA///+/wIAAQD+////AgABAP3///8EAAIA/P/+/wQAAAD9/wIAAQD9/wEABAD+//z/AgACAP//AAAAAP//AQACAP///v///wEAAwD///3/AQACAAAA/////wAAAgAAAP7/AQAAAP//AQAAAP//AQABAP7/AAADAP7//f8DAAIA/f///wIAAAD//wEAAAD//wEAAQD/////AQABAP////8BAAEA/////wEAAQAAAP///v8CAAMA/f/+/wIAAQAAAP////8AAAIAAQD+//7/AQADAAAA/f8AAAIAAAD//wAAAAD//wAAAQABAAAA/v8AAAMAAAD8////BAABAP3/AAACAP////8CAAAA/v8AAAEAAQAAAP7/AAACAP///v8CAAIA/f///wMA///+/wIAAgD+//7/AgACAP///f///wQAAgD8////BAAAAPz/AAADAAEA///+////AwADAPz/+/8DAAYA/v/6/wEABQAAAP3///8BAAEAAAD//wAAAAD//wIAAgD9//7/AwACAP3//v8DAAIA/f/9/wMABAD+//z/AQAEAAAA/f/+/wIAAgD9////BAAAAPz/AgAFAPz/+/8EAAMA/P///wQA///9/wMAAgD8//7/AwACAP///v8AAAMAAAD9/wAAAgAAAP///////wIAAwD///3/AAACAAAA//8AAAAA//8BAAIA/v///wIA///+/wMAAgD8//7/BAABAPz/AQADAP7///8BAP//AAACAP///v8CAAEA//8AAP//AAACAP///v8CAAEA/f8BAAMA/v///wIA///+/wIAAgD+//7/AQADAAEA/P/+/wUAAgD7////BAD///z/AgAEAP7//f8CAAIA///+////AgACAP7//v8CAAEA//8AAAAA//8AAAEAAAABAP///f8DAAMA/f/9/wIAAwD+////AQD//wAAAgAAAP3/AAADAP///v8BAAEA//8AAAIA///+/wEAAgD///3/AgADAP3//v8DAAIA/f///wMAAAD+/wAAAQAAAP////8CAAIA/f/+/wMAAgD+////AQD//wAAAgD///7/AQABAAEAAQD9////BAAAAPz/AQADAP7//v8DAAEA/f8AAAIAAAD//wAAAAAAAAEA/////wIAAAD+/wEAAgD///7/AAACAAEA/v///wIAAQD+/wAAAQD//wAAAQD/////AgABAP7/AAABAP//AAABAP//AAABAP//AAABAAAA//8AAAEA//8AAAIA///+/wIAAgD9////BAD///v/AgAEAP7//v8DAAEA/P8AAAQA///9/wEAAQD//wAAAQAAAP//AQACAP///f8AAAMAAAD9/wAAAwABAP3//v8DAAIA/f/+/wMAAwD9//z/AgAEAP7//P8CAAMA/////wEAAAD+/wEAAgD+//7/AQABAAAAAQAAAP7/AAACAAAA/v///wEAAQAAAP//AAABAP////8CAAIA/v/9/wEAAwAAAP7///8BAAIAAAD///////8CAAIA/v/+/wIAAQD+/wEAAQD9/wAABAAAAP3/AAABAP//AAACAP///v8CAAIA///+/wAAAQAAAAAAAAAAAP//AAADAAAA/P8AAAQAAAD8/wAAAwAAAP7/AAACAAAA/v8AAAIAAQD+//7/AQACAAAA//8AAAAAAAAAAAAAAAAAAP//AAADAAAA/f///wEAAgD///7/AQACAAAA/v8BAAEA/f8AAAMAAAD9/wAABAAAAP3/AAABAAAA//8AAAEAAAAAAAEA///9/wIABAD9//3/AwACAP7//v8AAAIAAgD9//7/BAABAP3/AAABAP7/AAAEAAAA/P///wMAAgD///7///8BAAEA//8AAAIA///9/wIABAD+//z/AQACAAAAAAAAAP////8CAAEA/v///wEAAgAAAP7///8CAAEA/f8AAAMAAAD9/wAABAAAAP3///8BAAEAAAAAAP//AAACAAAA/v8AAAEA//8AAAIAAAD//wAA//8AAAMAAAD7////BgACAPv///8DAAAA//8BAAAA/f8AAAQAAAD9/wAAAwAAAP3/AAABAAAAAQD/////AwABAPv///8GAAEA+v///wUAAQD8/wAAAwD///7/AgABAP3/AAADAP////8CAAAA/v///wEAAgAAAP3///8EAAIA/P/+/wMAAgD+//7/AQACAAAA/v///wMAAQD9////AgAAAP7/AQACAAAA/////wEAAAD//wAAAQAAAP7/AAACAAEA///+/wEAAgAAAP///v///wMAAgD+////AQAAAAAAAQD+////BAAAAPz/AQADAP7//v8DAAAA/v8CAAAA/v8BAAIA/f/+/wUAAAD7/wIABAD+//3/AgABAP7/AQABAP7///8CAAMA/v/8/wIABAD+//z/AwADAPz///8EAAEA/P///wQAAQD9//7/AgADAP///v8AAAEAAQAAAP////8AAAAAAAACAAAA/f8BAAMA/v/+/wMAAAD8/wEAAwAAAP////8AAAEAAAAAAAAA//8AAAEAAAABAAAA/v///wIAAQD+/wAAAQD//wAAAQAAAP////8AAAIAAQD+////AgABAP7/AAABAP7/AAADAAAA/P8AAAUAAAD8/wEAAgD//wAAAAD+/wAAAwAAAP3/AQACAP7///8CAAEA//8AAAAA//8BAAEA/f/+/wMAAwD///7/AAACAAAA/v8BAAEA/v///wIAAQD+/wAAAgD/////AgABAP7///8AAP//AQADAP7//f8DAAIA/v///wEAAAD//wEAAAD+/wEAAgD+////AwAAAP3/AQACAP7///8CAAAA//8BAAAA//8AAAEAAAD+/wEAAgD+////AgABAP7/AAABAP7/AAADAAAA/P///wUAAgD7//3/BAADAP7//f8AAAQAAQD7//7/BQADAPv//f8EAAMA/v/9/wEAAgD//wAAAQD///7/AQADAP///v8BAAAA//8BAAEA/v/+/wMAAwD+//7/AAAAAAEAAQD+////AgAAAP//AQAAAP7/AQADAP///v8AAAAAAAAAAAAA//8BAAIA/////wEAAAD//wEAAAD9/wEABAD///3/AQABAP//AQABAP7///8DAAEA/f///wEAAAABAAIA/v/9/wMABAD8//v/BAAEAP3//v8CAAEA//8AAAEA///+/wAAAwABAPz/AAAFAAAA+////wQAAQD9////AgACAP////8BAAAA/v8AAAMAAAD8/wAABQAAAPv/AQAEAP7//f8CAAEA//8BAAAA/v8BAAIA///+/wAAAQAAAAAAAAAAAAAA//8AAAIAAAD9/wAAAwAAAP7///8CAAEA/v8AAAEA/////wIAAgD+//7/AAACAAIA/f/9/wQAAwD9////AQD+/wAAAwD///7/AgAAAP7/AgACAP3//f8DAAMA/f/+/wMAAQD9/wAAAwD///3/AAACAAEAAAD/////AQACAP///f8AAAIAAAD//wEAAQD+/wAAAwD///3/AQABAP//AQABAP7///8DAAEA/f///wEAAgAAAP7/AAABAAAA/v8AAAMA///+/wIAAgD+//7/AQABAP////8BAAIAAAD+////AgABAP///////wEAAgAAAP7/AAACAP///v8CAAIA/f/9/wMAAwD+//7/AQABAAAAAAAAAAAA/////wEAAgD///7/AQACAAAA////////AgACAP3//v8EAAIA/P/+/wMAAgD+//3/AQAEAAAA/P8AAAMAAAD+////AQACAAAA/f8AAAMAAAD+////AgACAP7//v8BAAIA///+/wEAAQAAAAAAAAAAAP//AQACAP7//v8CAAAA/f8CAAQA/v/9/wEAAQABAAEA/f/+/wMAAgD///7/AAABAAAAAAAAAAAAAAAAAAAAAAABAAAA/v8AAAIAAAD+/wAAAwAAAPz/AAAEAAAA/f8BAAIA/v///wIAAAD+/wAAAgAAAP7/AQACAP///v8AAAIAAAD//wAA//8AAAIAAAD+/wEAAgD+////AwAAAPz/AAAEAAAA/f8AAAIAAQD+//7/AgACAP///v8AAAEAAAABAAAA/v8AAAIAAAD//wAAAAD//wEAAgD+////AgAAAP//AAABAP////8BAAEAAAD+/wAAAgAAAP////8AAAEAAQD///7/AQADAAAA/f///wIAAAD//wIAAQD9//7/AwADAP7//f8AAAIAAgAAAP7//v8BAAIAAAD///////8BAAMAAAD8////BAACAPz//f8DAAMA/v/9/wIAAwD///7///8BAAIA///9/wEABAD///3/AgABAP7/AAAAAP//AQACAP///v8BAAEA/////wAAAgAAAP7/AAACAAEA/f///wMA/////wMA///8/wIABAD+//7/AgD///7/BAABAPv/AAAEAAAA/v8AAAAA//8CAAEA/f8AAAIAAAAAAP////8CAAEA/f///wQAAQD8////BAACAPz//f8DAAIA/v8AAAEA//8AAAIAAAD9/wAAAwD///3/AgADAP7//v8CAAEA/////wAAAgAAAP3/AQAEAP7//P8CAAMA///+/wAAAQAAAAAAAAAAAP//AAACAAAA/v///wIAAQD+/wAAAQD//wAAAgAAAP3/AAACAAAAAAAAAP//AAABAAAA/////wAAAwABAPz///8EAAEA/P/+/wMAAwD///3/AAADAAAA/f8AAAIAAQD///7/AAACAAEA/v/+/wMAAgD9////AwAAAPz/AAADAAAAAAAAAP7/AAADAAEA/f///wEAAAABAAAA/v8BAAMA///9/wEAAgD///7/AAACAAEA/////wAAAQABAP7//v8DAAIA/f/+/wIAAgD/////AAAAAAEAAAD+////AwACAPz///8FAAAA+/8AAAQAAAD+/wAAAAABAAIA///9/wEABAD///v/AAAFAAIA+//9/wUABAD8//z/AgADAP///v8AAAEAAQAAAP//AAAAAAAAAQAAAP//AAAAAAAAAgAAAPz/AAAFAAAA/P8BAAIA/v8AAAIA/////wEAAAD//wEAAQD//wAAAAD//wEAAgD///3/AQADAP///f8BAAQA/v/7/wMABgD9//v/AwACAP3/AQADAP7//f8CAAIA/////wAAAQAAAP//AgABAPz///8EAAAA/f8BAAIA///+/wEAAgD///7/AQACAP7///8DAP///f8CAAMA/v/9/wEAAwABAP3//v8CAAMA///9/wAAAgACAP///f8AAAIAAQD//wAAAAAAAAEA/////wIAAAD8/wEABgD+//r/AgAFAP///f8BAAEA//8AAAAA//8BAAEA/v8AAAMAAAD9/wAAAwAAAP3/AAACAAAA//8AAAAAAQABAP7//v8CAAMA/v/8/wIABAD///z/AAAEAAAA/P///wQAAQD8/wAABAAAAPz/AAAEAAAA/P///wMAAgD+//7/AgACAP7//v8BAAIAAAD///////8BAAIA///+/wEAAgAAAP////8AAAEA/////wIAAQD+/wAAAQD//wEAAQD9/wAAAwD///7/AgABAP7/AAABAP//AAABAP////8CAAEA/v8AAAIAAAD+////AQABAAAA//8AAAEAAAABAAAA/v///wEAAgD///7/AQACAP///v8CAAEA/f8AAAIAAAAAAAAA/////wIAAgD9//7/AwABAP7/AAACAP///v8CAAIA/f/+/wIAAgD///7/AQABAP////8AAAIAAQD+////AQABAAAA/////wEAAQD//wAAAQD/////AQAAAAAAAQD///7/AgADAP7//f8AAAIAAgD+//3/AQAEAAEA+//+/wUAAwD7//z/BQADAPz///8CAP//AAADAP///P8BAAMA///+/wEAAgAAAP////8AAAEAAAD/////AQADAP///P8BAAUA///7/wEABAD///3/AAACAAEA/////wEAAgD///3/AQACAP////8BAAEA/////wEAAgAAAP3///8CAAEA//8AAAEA//8AAAEA/////wEAAQD//wAAAQAAAAEA///9/wEABAD///v/AQAFAAAA/P8AAAQAAAD8////AwABAP7/AAABAAAAAQABAP7//f8BAAMAAAD///////8CAAMA/v/8/wEAAgAAAAEA///9/wEAAwD///7/AQABAAAAAAD//wAAAQD/////AQABAP////8CAAEA/v///wIAAQD+////AQABAAAA/////wIAAgD9//7/AwACAP7//v8AAAIAAgD+//3/AQADAAAA//8AAP//AAABAAEAAAD+////AgACAP7//v8CAAEA//8AAAEA///+/wEAAgAAAP7///8DAAEA/f///wIAAAD+/wEAAQD//wEAAAD+/wIAAgD9//7/AwABAP3/AAADAAAA/v8AAAEAAAAAAAAA//8AAAEAAAAAAAAAAAAAAP//AAACAAEA/f/+/wQAAQD9/wAAAQAAAAAAAAD//wAAAgD/////AgAAAP////8AAAEAAAAAAAAAAQABAP7///8BAAEA/////wEAAAAAAAEA/////wIAAQD+////AAAAAAEAAAD//wEAAQD//wAAAQAAAP///v8AAAQAAQD8////AgAAAAAAAQD/////AQABAP///v8BAAIA/////wEAAAD//wEAAQD+////AgABAP////8AAAEAAQD///7/AQADAP///f8CAAIA/f8AAAIA/////wEAAQD//wAAAQD//wAAAAAAAAAA//8BAAEA//8AAAAA//8BAAIA/v/9/wIAAwD///3/AAADAAEA/f///wMAAAD9/wAAAgABAP////8BAAEA/////wAA//8AAAMAAAD+/wEAAQD//wAAAAD//wAAAAAAAAMAAAD7/wEABQD+//3/AgABAP7///8CAAEA////////AQACAAAA/f/+/wMAAwD+//3/AgADAP7//f8BAAIAAAD/////AAACAAEA/////wAAAAAAAAEAAQD+//7/AgADAP///f8AAAIAAQD/////AQABAP////8BAAAA//8BAAEA/////wEAAQD/////AAABAAEA/////wEAAAD//wEAAAD+/wEAAwD///3/AQACAP////8BAAEA///+/wIAAwD9//3/AgADAAAA/v///wAAAgABAP3///8DAAEA/f8AAAMA///+/wEAAQD/////AQABAP////8BAAIA///9/wEAAgD/////AQABAP////8BAAEA/////wAAAQABAP///v8AAAMAAQD9/wAAAgAAAP//AAAAAP//AQAAAP//AQABAP////8BAAEAAAD///7/AgACAP3//v8DAAIA/f///wMAAAD+/wEAAQD+////AgABAP////8BAAIA///9/wAAAwABAP7//v8BAAQA///7/wEAAwD//wAAAgD+//3/AgADAP///f8AAAMAAQD+////AAAAAAEAAQD/////AQAAAAAAAgD///3/AQADAP///v8BAAAA//8BAAIA///9/wEAAwD///7/AQABAP////8AAAEAAQAAAP////8AAAEAAgD+//z/AgAEAAAA/f/+/wEAAwABAPz//v8EAAIA/f/+/wEAAQABAAAA/v8AAAMAAAD8/wAAAwAAAP//AQAAAP7/AQACAP7//v8CAAIA/////wEAAAD+/wAAAgAAAP//AAAAAAAAAQAAAP//AAAAAAAAAQABAP7//v8DAAIA/f/+/wIAAgAAAAAA/v///wMAAAD9/wAAAgAAAP//AgABAP7//v8AAAMAAQD8////BQABAPv/AAAEAP///f8CAAIA/v///wIAAgD+//3/AQACAAEA///+/wAAAgACAP///f8AAAIAAQD///7/AAACAAAA//8AAAAAAAABAAAA//8AAAAAAAABAAAA/v///wIAAgD///7/AAACAAEA///+/wAAAgABAP7//v8CAAMA///9/wAAAwAAAP3/AAACAAAA/v8AAAMAAAD9/wAAAgAAAP//AQAAAP7/AQABAP7/AAACAAAA//8AAAEAAAD//wAAAQAAAP//AAABAAAAAAD/////AwACAPz//f8FAAMA+//+/wMAAgD///7/AAABAAEA/////wEAAAAAAAEA///+/wEAAgAAAP//AAAAAAAAAgAAAPz///8EAAIA/P///wMAAAD//wEAAAD+/wAAAgAAAP//AAAAAAAAAQAAAP//AAABAAAA//8BAAAA//8BAAAA//8BAAEA/////wAAAAABAAEA///+/wAAAgABAP////8AAAAAAQAAAP7/AAADAAAA/f8BAAIA/////wAAAQAAAP//AQABAP7//v8EAAIA+////wUAAQD8////AgD//wAAAgD///7/AQACAP////8BAP////8CAAAA/v8BAAIA/v/+/wMAAgD9////AgAAAP//AQAAAP//AQABAP7///8DAAAA/P8BAAUA///7/wEAAwD/////AAAAAAEAAAD//wEAAQD9////BAABAPz///8EAAEA/f///wIAAAD+/wIAAQD9/wEAAwD+//3/AgACAP7///8CAAAA/v8AAAIAAQD9////AwAAAP7/AAABAP////8CAAEA/////wAAAgAAAP3/AAACAAAAAAAAAP7/AAAEAAAA+/8AAAQAAAD+/wAAAAD//wEAAgD///7/AAABAAAAAAABAP7//v8DAAMA///8//7/BAADAP3//f8CAAIA//8AAAAA//8BAAEA/////wAAAQABAP////8BAAAA//8BAAIA/v/9/wMAAwD9//3/AgADAP7//v8CAAEA/v///wIAAQD//wAA/////wIAAQD+////AgABAP////8AAAEAAQD/////AgAAAP3/AQADAP///f8BAAMAAAD+//7/AQACAP////8BAAEAAAD/////AQABAP7///8CAAEA/////wEAAQD/////AAABAAAA/////wAAAwABAP3//v8BAAMAAAD9/wAAAgD/////AwAAAPv/AQAFAP///P8BAAMA/v/+/wMAAQD9////AwAAAP3/AQADAP7//f8EAAMA+//9/wQAAwD9//7/AgAAAAAAAQD/////AQAAAP//AgACAPz//v8FAAEA+v///wUAAgD9//7/AgADAP///P8AAAMA/////wIA///+/wMAAQD9/wAAAQD//wEAAgD+//3/AQAEAAAA+/8AAAUAAAD8/wEAAwD+//7/AQABAAAAAAAAAP//AAABAAAA//8AAAEAAAAAAP////8BAAEA///+/wEABAABAPv//f8FAAMA/P/9/wMAAwD9//7/AwACAP3//v8DAAEA/v8AAAEA/////wIAAQD9////BAAAAPz/AgAEAP3//P8CAAMAAAD+////AgABAP7///8CAAEA/f8AAAMA/////wIA///9/wIAAwD+//7/AQABAAEA///9/wEABAAAAPz///8EAAEA/P///wMAAQD+////AgACAP7//f8BAAMAAAD+/wAAAAAAAAIAAQD9//3/BAAFAPz/+v8DAAYA/v/7/wEABAAAAP3/AAABAAAAAQAAAP7/AAADAAAA/P8AAAQAAAD9/wEAAgD//wAAAAD+/wAAAwAAAP3/AQACAP7/AAADAP///P8BAAQA///8/wAAAwABAP7///8CAAAA/v8BAAEA/////wEAAQD//wAAAQAAAP7///8EAAEA+////wUAAQD8/wAAAgD/////AgABAP3///8DAAEA/v///wEAAQAAAP////8BAAIA///+/wEAAQAAAAAAAAD//wAAAQD//wAAAgD///7/AgABAP7/AQACAP7///8CAAAA//8BAAAA/v8BAAMA/v/9/wIAAwD+//7/AwAAAP3/AgACAPz///8FAP//+/8DAAUA/P/7/wMABAD///3///8DAAIA/f/+/wMAAQD8/wAABAD///7/AgABAP3///8DAAEA/f///wMAAQD+/wAAAQD/////AQABAAAA/v///wMAAQD9////AwABAP3///8DAAEA/f///wIAAQD/////AAABAAIA///9/wEAAwAAAP3///8CAAEAAAD/////AQACAP///f8BAAIA/////wEAAQD//wAAAQD+////AgAAAP//AQAAAP7/AgAEAPv/+/8GAAQA+//+/wQAAAD9/wIAAQD9/wAAAwAAAP7/AAABAAAAAAAAAP//AAACAAAA/f///wMAAgD9//7/AwACAP7//v8BAAIAAAD9////BAABAPz/AAADAAAA//8AAP7/AAAEAAAA/P8AAAMAAAD+/wAAAAD//wIAAgD9//7/BAACAPz//v8CAAAAAAACAP///v8CAAEA/f8AAAQA///7/wEABgAAAPr///8FAAEA/P8AAAQA///8/wEABAD///z/AQADAP////8BAAAAAAAAAP7/AQADAP3//f8DAAIA//8AAAAA/v8AAAMAAQD+//3/AQAEAP7//f8DAAIA/P///wYAAQD6////BAAAAP7/AQAAAP//AQABAP////8BAAEAAAD+/wAABAD///v/AQAFAAAA+////wQAAgD+//7/AAABAAEAAQD+//3/AwAEAP7//P8AAAMAAQD///7///8DAAIA/f/+/wIAAgD///7/AQACAP///v8AAAEAAAAAAAAA//8BAAIA///+/wAAAgAAAP7/AAABAAAAAAABAAAA/v8AAAMAAAD8/wAAAwAAAP//AAAAAAAAAQAAAP//AQD///7/AwADAP3//P8DAAQA/v/9/wAAAgABAP//AAABAAAA//8AAAAA//8BAAEA/v8AAAMAAQD9//7/AgABAP7///8CAAEA//8AAAAAAAAAAP////8CAAEA/f8AAAQAAAD7/wAABQAAAPz///8DAAIA/v/+/wEA&quot;, &quot;WAAPI&quot;, &quot;wav&quot;, true); if (typeof(CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) === &quot;undefined&quot; || CB_AudioFile_API[&quot;WAAPI&quot;].audioContext === null) { if (typeof(window.AudioContext) !== &quot;undefined&quot; || typeof(window.webkitAudioContext) !== &quot;undefined&quot;) { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext = new (window.AudioContext || window.webkitAudioContext)(); //Hack (source: https://stackoverflow.com/questions/56768576/safari-audiocontext-suspended-even-with-onclick-creation/56770254#56770254): try { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.createGain(); } catch (createGainError) { CB_console(&quot;Error creating a GainNode for the AudioContext: &quot; + createGainError); } try { CB_AudioFile_API[&quot;WAAPI&quot;].audioContext.resume(); } catch (audioContextResumeError) { CB_console(&quot;Error resuming AudioContext: &quot; + audioContextResumeError); } if (!CB_AudioFile_API[&quot;WAAPI&quot;].audioContext) { return null; } } } var extensions = [ &quot;mp3&quot;, &quot;ogg&quot;, &quot;wav&quot; ]; var allNull = true; for (var x = 0; x &lt; 3; x++) { if (silentAudioFiles[&quot;WAAPI&quot;][extensions[x]] !== null) { allNull = false; if (silentAudioFiles[&quot;WAAPI&quot;][extensions[x]].getStatusString() === &quot;UNCHECKED&quot;) { new function(x) { var finishedChecking = function(error, checkedFine) { silentAudioFiles[&quot;WAAPI&quot;][extensions[x]].destructor(true, false, true, false); silentAudioFiles[&quot;WAAPI&quot;][extensions[x]] = null; }; silentAudioFiles[&quot;WAAPI&quot;][extensions[x]].checkPlaying(function() { finishedChecking(&quot;&quot;, true); }, finishedChecking, false, true, false); }(x); } } } //If all objects are null it means all have either played or failed: if (allNull) { CB_Speaker._silentAudioFilePlayedWAAPI = true; } } }; CB_Events.add(document, &quot;click&quot;, silentAudioFilePlay, true, true, false); //CB_Events.add(document, &quot;touchstart&quot;, silentAudioFilePlay, true, true, false); } //Applies the current volume to all objects: CB_Speaker._applyVolume = function(volume, isMuteOrUnmute, forceSetVolumeProperty, functionToExecute, audioFiles, avoidSanitize) { //If there is no sprites pool object, just exits: if (typeof(CB_Speaker._audioFileSpritesPool) === &quot;undefined&quot; || CB_Speaker._audioFileSpritesPool === null) { return; } if (!avoidSanitize) { volume = CB_Speaker.sanitizeVolume(volume, true); //Uses CB_Speaker._volume if the value is not valid. } //If we want either to mute or unmute: if (isMuteOrUnmute) { //If volume is zero, we want to mute: if (volume === 0) { CB_Speaker._audioFileSpritesPool.muteAll(functionToExecute, audioFiles); } //...otherwise, we want to unmute: else { CB_Speaker._audioFileSpritesPool.unmuteAll(functionToExecute, audioFiles); } } //...otherwise, we just set the volume given: else { CB_Speaker._audioFileSpritesPool.setVolumeAll(volume, forceSetVolumeProperty, functionToExecute, audioFiles); } } /** * Sanitizes the volume (it does not allow values greater than 100 or lower than 0). * @function * @param {number} [volume=CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME|CB_Speaker._volume] - The desired volume to be sanitized. If not given, it will use the current volume if the &quot;useSpeakerVolumeIfNaN&quot; parameter is set to true or the default volume otherwise. * @param {boolean} [useSpeakerVolumeIfNaN=false] - If it is set to true and no valid volume is received in the &quot;volume&quot; parameter, it will use the current volume ({@link CB_Speaker._volume}). Otherwise, if it is set to false and no valid volume is received in the &quot;volume&quot; parameter, it will use the default volume which is set in the {@link CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME} constant. * @returns {number} Returns the volume sanitized (it does not allow values greater than 100 or lower than 0). */ CB_Speaker.sanitizeVolume = function(volume, useSpeakerVolumeIfNaN) { volume = parseInt(volume); if (isNaN(volume)) { volume = useSpeakerVolumeIfNaN ? CB_Speaker._volume : CB_Configuration[CB_BASE_NAME].CB_Speaker_DEFAULT_VOLUME; } //Sets the volume within their limits if it is beyond them: if (volume &gt; 100) { volume = 100; } else if (volume &lt; 0) { volume = 0; } return volume; } /** * Sets the given volume. * @function * @param {number} [volume=CB_Speaker._volume] - The desired volume to be used (it will be sanitized internally by calling the {@link CB_Speaker.sanitizeVolume} function with the volume as the unique parameter). If not given, it will use the current volume. If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will also be used as a parameter to call the {@link CB_AudioFileSpritesPool#setVolumeAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). * @param {boolean} [avoidApplyingVolume=false] - If it is set to true, the volume will not be applied (by calling the {@link CB_Speaker._applyVolume} internal function, which will also use the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool}, if any) and just the {@link CB_Speaker._volume} internal property will be set. * @param {boolean} [forceSetVolumeProperty=false] - If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as a parameter to call the {@link CB_AudioFileSpritesPool#setVolumeAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). * @param {function} [functionToExecute] - A callback function. If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as the &quot;onSetVolume&quot; parameter to call the {@link CB_AudioFileSpritesPool#setVolumeAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is true, it will be used as the &quot;onMute&quot; parameter to call the {@link CB_AudioFileSpritesPool#muteAll} method or as the &quot;onUnmute&quot; parameter to call the {@link CB_AudioFileSpritesPool#unmuteAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). * @param {array} [audioFiles] - An array containing the CB_AudioFile objects that we want to affect (if not set and the &quot;avoidApplyingVolume&quot; is set to false, it will affect all the CB_AudioFile objects of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool}, if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as the &quot;audioFiles&quot; parameter to call the {@link CB_AudioFileSpritesPool#setVolumeAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is true, it will be used as the &quot;audioFiles&quot; parameter to call the {@link CB_AudioFileSpritesPool#muteAll} method or as the &quot;audioFiles&quot; parameter to call the {@link CB_AudioFileSpritesPool#unmuteAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool} (if any). * @param {boolean} [saveForUnmute=false] - If it is set to true, the given volume will be saved to be restored later when the {@link CB_Speaker.unmute} method is called. * @param {boolean} [isMuteOrUnmute=false] - If it is set to true and the volume given is zero, the action performed internally will be muting (by calling the {@link CB_AudioFileSpritesPool#muteAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool}, if any). Otherwise, if it is set to true and the volume given is not zero, the action performed internally will be unmuting (by calling the {@link CB_AudioFileSpritesPool#unmuteAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool}, if any). If it is set to false, the action performed will be set the volume given (by calling the {@link CB_AudioFileSpritesPool#setVolumeAll} method of the internal {@link CB_AudioFileSpritesPool} object defined in {@link CB_Speaker._audioFileSpritesPool}, if any). * @returns {number} Returns the current volume being used after setting it. * @todo Also affect BandJS, jsfx and timbre.js. */ CB_Speaker.setVolume = function(volume, avoidApplyingVolume, forceSetVolumeProperty, functionToExecute, audioFiles, saveForUnmute, isMuteOrUnmute) { volume = CB_Speaker.sanitizeVolume(volume); if ((saveForUnmute || volume === 0) &amp;&amp; CB_Speaker._volume &gt; 0) { CB_Speaker._volumeBeforeMute = CB_Speaker._volume; } //Only saves it if the current volume is more than zero. CB_Speaker._volume = volume; if (!avoidApplyingVolume) { CB_Speaker._applyVolume(volume, isMuteOrUnmute, forceSetVolumeProperty, functionToExecute, audioFiles, true); } return CB_Speaker._volume; } /** * Mutes the speaker. Calls the {@link CB_Speaker.setVolume} function internally, with 0 (zero) as the &quot;volume&quot; parmeter, null as the &quot;forceSetVolumeProperty&quot; parameter and true for both &quot;saveForUnmute&quot; and &quot;isMuteOrUnmute&quot; parameters. * @function * @param {boolean} [avoidApplyingVolume=false] - Used as a parameter to call the {@link CB_Speaker.setVolume} function internally. * @param {function} [onMute] - Used as as the &quot;functionToExecute&quot; parameter to call the {@link CB_Speaker.setVolume} function internally. * @param {array} [audioFiles] - Used as a parameter to call the {@link CB_Speaker.setVolume} function internally. * @returns {number} Returns the result of the internal call to the {@link CB_Speaker.setVolume} function. * @todo Also affect BandJS, jsfx and timbre.js. */ CB_Speaker.mute = function(avoidApplyingVolume, onMute, audioFiles) { return CB_Speaker.setVolume(0, avoidApplyingVolume, null, onMute, audioFiles, true, true); } /** * Restores the audio volume after muting it. If the current volume is 0 (zero, muted) or the &quot;ignoreVolume&quot; parameter is set to true, calls the {@link CB_Speaker.setVolume} function internally, with the previously-saved volume before muting it as the &quot;volume&quot; parmeter, null as the &quot;forceSetVolumeProperty&quot; parameter, false for the &quot;saveForUnmute&quot; parameter and true for the &quot;isMuteOrUnmute&quot; parameter. * @function * @param {boolean} [avoidApplyingVolume=false] - Used as a parameter to call the {@link CB_Speaker.setVolume} function internally, if the &quot;ignoreVolume&quot; parameter is set to true. * @param {function} [onUnmute] - Used as as the &quot;functionToExecute&quot; parameter to call the {@link CB_Speaker.setVolume} function internally, if the &quot;ignoreVolume&quot; parameter is set to true. * @param {array} [audioFiles] - Used as a parameter to call the {@link CB_Speaker.setVolume} function internally, if the &quot;ignoreVolume&quot; parameter is set to true. * @param {boolean} [ignoreVolume=false] - If set to true, it will try to perform the muting action even when the current volume is not 0 (zero, muted). * @returns {number} Returns the current volume. * @todo Also affect BandJS, jsfx and timbre.js. */ CB_Speaker.unmute = function(avoidApplyingVolume, onUnmute, audioFiles, ignoreVolume) { if (CB_Speaker._volume === 0 || ignoreVolume) { CB_Speaker.setVolume(CB_Speaker._volumeBeforeMute, avoidApplyingVolume, null, onUnmute, audioFiles, false, true); } return CB_Speaker._volume; } /** * Tells the current volume. * @function * @param {boolean} [avoidSanitize=false] - If set to true, it will not call the {@link CB_Speaker.sanitizeVolume} function internally before returning the volume. * @returns {number} Returns the current volume. */ CB_Speaker.getVolume = function(avoidSanitize) { if (!avoidSanitize) { CB_Speaker._volume = CB_Speaker.sanitizeVolume(CB_Speaker._volume); } return CB_Speaker._volume; } /** * Sets the desired {@link CB_AudioFileSpritesPool} object. * @function * @param {CB_AudioFileSpritesPool} audioFileSpritesPool - The desired {@link CB_AudioFileSpritesPool} object to manage all audio files. * @returns {CB_AudioFileSpritesPool|null} Returns the current {@link CB_AudioFileSpritesPool} object after setting it (if any) or null otherwise. */ CB_Speaker.setAudioFileSpritesPool = function(audioFileSpritesPool) { //if (typeof(audioFileSpritesPool) !== &quot;undefined&quot; &amp;&amp; audioFileSpritesPool !== null &amp;&amp; audioFileSpritesPool instanceof CB_AudioFileSpritesPool) if (audioFileSpritesPool instanceof CB_AudioFileSpritesPool) { CB_Speaker._audioFileSpritesPool = audioFileSpritesPool; } return CB_Speaker._audioFileSpritesPool; } /** * Returns the current {@link CB_AudioFileSpritesPool} object (if any). * @function * @returns {CB_AudioFileSpritesPool|null} Returns the current {@link CB_AudioFileSpritesPool} object (if any) or null otherwise. */ CB_Speaker.getAudioFileSpritesPool = function() { return CB_Speaker._audioFileSpritesPool || null; } /** * Returns the [timbre.js]{@link https://mohayonao.github.io/timbre.js/} object (if any). Useful for functional processing and synthesizing audio. * @function * @returns {Object|null} Returns the current [timbre.js]{@link https://mohayonao.github.io/timbre.js/} object (if any) or null otherwise. * @todo timbre.js should have into account the CB_Speaker._volume */ CB_Speaker.getTimbreJSObject = function() { return CB_Speaker._timbreJSObject || null; } /** * Returns a new [Band.js]{@link https://github.com/meenie/band.js/} object (if possible). Useful for managing music composition. * @function * @returns {Object|null} Returns a new [Band.js]{@link https://github.com/meenie/band.js/} object (if possible) or null otherwise. * @todo Band.js should have into account the CB_Speaker._volume */ CB_Speaker.getBandJSObject = function() { return CB_Speaker._bandJSObject ? new CB_Speaker._bandJSObject() : null; } /** * Returns the [jsfx]{@link https://github.com/loov/jsfx} object (if any). Useful for managing sound effects generation. * @function * @returns {Object|null} Returns the current [jsfx]{@link https://github.com/loov/jsfx} object (if any) or null otherwise. * @todo jsfx should have into account the CB_Speaker._volume */ CB_Speaker.getJsfxObject = function() { return CB_Speaker._jsfxObject || null; } } //End of the static class CB_Speaker. × Search results Close "},"CrossBase_general_CB_others.js.html":{"id":"CrossBase_general_CB_others.js.html","title":"Source: CrossBase/general/CB_others.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/general/CB_others.js /** * @file Miscellaneous code. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; * @todo Think about a 'CB_symmetricInterval' function, similar to {@link CB_symmetricCall} but calling the callback function automatically. */ /** * Callback that is called by {@link CB_symmetricCall}. * @callback CB_symmetricCall_CALLBACK * @param {integer} expectedCallingTime - The timestamp in milliseconds that represents when the callback should have been called (it will be more or less accurate depending on many factors as the platform used, code performance, etc.). */ var CB_symmetricCallLastTimes = {}; //Array that stores the last times of every function. /** * Calls the given function once through the native [setTimeout]{@link https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function internally but having in mind the time taken when the function was called previously so it can be called multiple times and respect a symmetric interval between each call (simulates [requestAnimationFrame]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}). * @function * @param {CB_symmetricCall_CALLBACK} callbackFunction - Function that will be called every time, receiving as the unique parameter the time (timestamp in milliseconds returned by the [performance.now]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance/now} method, which could have been polyfilled automatically by CrossBrowdy) when it is called, being &quot;this&quot; the same &quot;this&quot; of the scope where it was called. * @param {integer} timeMs - Milliseconds between one call to the function and the next one. The accuracy will depend on many factors as the platform used, code performance, etc. * @param {string} [id=callbackFunction.toString()] - String that will identify this symmetric interval. Recommended to avoid possible problems. * @returns {number|null} Returns a numeric identifier generated by an internal call to the native [setTimeout]{@link https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout} function (can be cleared/cancelled with [clearTimeout]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout}). Returns null if the given &quot;callbackFunction&quot; is not a valid function. */ //* Source: Based on requestAnimationFrame polyfill by Erik M�ller. function CB_symmetricCall(callbackFunction, timeMs, id) { if (typeof(callbackFunction) !== &quot;function&quot;) { return null; } var now = window.performance.now(); //Can be polyfilled (https://gist.github.com/jalbam/cc805ac3cfe14004ecdf323159ecf40e) id = id || callbackFunction; if (typeof(CB_symmetricCallLastTimes[id]) === &quot;undefined&quot; || CB_symmetricCallLastTimes[id] === null) { var nextTime = now + timeMs; //First time, it lasts the given milliseconds. CB_symmetricCallLastTimes[id] = 0; } else { //var lastTime = CB_symmetricCallLastTimes[id]; /* var timeToCall = Math.max(lastTime + timeMs, now);//Math.max(0, timeMs - (now - lastTime)); var id = setTimeout(callbackFunction, timeToCall - now);//, timeToCall); lastTime = timeToCall;//now + timeToCall; */ //var timeToCall = Math.max(0, timeMs - (now - lastTime)); //var timeToCall = Math.max(0, timeMs - (now - CB_symmetricCallLastTimes[id])); var nextTime = Math.max(CB_symmetricCallLastTimes[id] + timeMs, now); } var that = this; return setTimeout ( function() { //callbackFunction.call(that, CB_symmetricCallLastTimes[id] = now + timeToCall); callbackFunction.call(that, CB_symmetricCallLastTimes[id] = nextTime); }, //timeToCall nextTime - now ); } /** * Clears the stored last time used by {@link CB_symmetricCall} for a given symmetric interval identifier. * @function * @param {string} id - String that identifies this symmetric interval. * @returns {boolean|null} Returns null if the given &quot;id&quot; is not a valid string. Returns false if the stored time did not exist for the given &quot;id&quot; or it was cleared already. Returns true otherwise, after clearing it. */ function CB_symmetricCallClear(id) { id = id + &quot;&quot;; if (id === &quot;&quot;) { return null; } if (typeof(CB_symmetricCallLastTimes[id]) === &quot;undefined&quot; || CB_symmetricCallLastTimes[id] === null) { return false; } CB_symmetricCallLastTimes[id] = null; return true; } × Search results Close "},"CrossBase_input_CB_Touch.js.html":{"id":"CrossBase_input_CB_Touch.js.html","title":"Source: CrossBase/input/CB_Touch.js","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Source: CrossBase/input/CB_Touch.js /** * @file Touch events management. Contains the {@link CB_Touch} static class. * @author Joan Alba Maldonado &lt;workindalian@gmail.com&gt; */ /** * Static class to manage the [touch events]{@link https://developer.mozilla.org/en-US/docs/Web/API/Touch_events}. It will return itself if it is tried to be instantiated. It can also use [Pressure.js]{@link https://pressurejs.com/} and [Hammer.js]{@link https://hammerjs.github.io/}. * @namespace */ var CB_Touch = function() { return CB_Touch; }; { CB_Touch._data = null; //Stores the information about the touch points. CB_Touch._force = null; //Stores the force of the touch point (just one, using Pressure.js). /** * Default value for the force attribute if no one is detected. * @var * @readonly * @type {number} * @default */ CB_Touch.DEFAULT_FORCE = 1; //Default value for the force attribute if no one is detected. CB_Touch._hammerJSObject = null; //Stores the Hammer.js object (if any). CB_Touch._pressureJSObject = null; //Stores the Pressure.js object (if any). CB_Touch.initialized = false; //It will tells whether the object has been initialized or not. //Initializes all values: CB_Touch.init = function() { if (CB_Touch.initialized) { return CB_Touch; } //The object has been initialized: CB_Touch.initialized = true; //Gets the touch data constantly: CB_Events.add(document, &quot;touchstart&quot;, function(e) { CB_Touch._data = CB_Touch.normalizeEvent(e) || null; }, true, true, false); CB_Events.add(document, &quot;touchenter&quot;, function(e) { CB_Touch._data = CB_Touch.normalizeEvent(e) || null; }, true, true, false); CB_Events.add(document, &quot;touchmove&quot;, function(e) { CB_Touch._data = CB_Touch.normalizeEvent(e) || null; }, true, true, false); CB_Events.add(document, &quot;touchend&quot;, function(e) { CB_Touch._force = 0; CB_Touch._data = null; }, true, true, false); CB_Events.add(document, &quot;touchleave&quot;, function(e) { CB_Touch._force = 0; CB_Touch._data = null; }, true, true, false); //Gets and stores the Hammer.js object (if any): CB_Touch._hammerJSObject = (typeof(Hammer) !== &quot;undefined&quot; &amp;&amp; Hammer !== null) ? Hammer : null; if (typeof(Hammer) !== &quot;undefined&quot; &amp;&amp; Hammer !== null &amp;&amp; Hammer.defaults) { //Chromium workaround (Chrome, Opera...) for Android thanks to Desiderius77, found on https://github.com/hammerjs/hammer.js/issues/1130#issuecomment-378851243. Hammer.defaults.inputClass = ((CB_Client.get() === &quot;Chrome&quot; || CB_Client.get() === &quot;Opera&quot;) &amp;&amp; Hammer.SUPPORT_POINTER_EVENTS) ? Hammer.PointerEventInput : Hammer.TouchInput; } //Gets and stores the Pressure.js object (if any): CB_Touch._pressureJSObject = (typeof(Pressure) !== &quot;undefined&quot; &amp;&amp; Pressure !== null) ? Pressure : null; //Gets the touch force (using pressure.js) constantly: if (CB_Touch._pressureJSObject !== null &amp;&amp; typeof(CB_Touch._pressureJSObject.set) === &quot;function&quot;) { CB_Touch._pressureJSObject.set ( document, { //start: function(event) { }, end: function() { CB_Touch._force = 0; }, //startDeepPress: function(event) { }, //endDeepPress: function() { }, change: function(force, event) { CB_Touch._force = typeof(force) !== &quot;undefined&quot; &amp;&amp; !isNaN(force) ? force : null; }//, //unsupported: function() { } } ); } return CB_Touch; } //Allows for interpolating a value from one range of values to another: //* Source: Pressure.js by Stuart Yamartino and Arduino documentation: https://www.arduino.cc/en/Reference/Map CB_Touch._map = function _map(x, in_min, in_max, out_min, out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; }; /** * Normalizes the given &quot;force&quot; property value across different clients. The new attached methods and properties may include polyfills, etc. This function is called by {@link CB_Touch.normalizePoint} automatically. * @function * @param {number} force - Force value to be normalized. * @returns {Event} Returns the force value normalized. * @todo Not all web clients are the same, so not all should be normalized. */ //* Source: Pressure.js by Stuart Yamartino. CB_Touch.normalizeForce = function(force) { //TODO: not all web clients are the same! so not all should normalize. if (typeof(force) === &quot;undefined&quot; || force === null || isNaN(force)) { return CB_Touch.DEFAULT_FORCE; } force = CB_Touch._map(force, 1, 3, 0, 1); force = force &gt; 0.999 ? 1 : force; force = Math.abs(force); return force; } /** * Tries to return the [touch event]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent} object with some properties normalized (since different clients can use different values), when possible. It also calls the {@link CB_Events.normalize} and {@link CB_Touch.normalizePoints} functions internally. Some properties affected could be [targetTouches]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/targetTouches}, [touches]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches}, [changedTouches]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/changedTouches}, etc. * @function * @param {Event} e - [Touch event]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent} object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). * @returns {Event} Returns the [touch event]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent} object normalized. * @todo Add more properties and methods to normalize (if needed) */ CB_Touch.normalizeEvent = function(e) { e = CB_Events.normalize(e); //TODO: add more properties and methods to normalize (if needed). //Normalize the points: e.targetTouches = CB_Touch.normalizePoints(e.targetTouches); e.touches = CB_Touch.normalizePoints(e.touches); e.changedTouches = CB_Touch.normalizePoints(e.changedTouches); return e; } /** * Normalizes a given list of points. Calls {@link CB_Touch.normalizePoint} internally. This function is called by {@link CB_Touch.normalizeEvent} automatically. * @function * @param {TouchList|array} points - [TouchList]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchList} or array with the points ([Touch objects]{@link https://developer.mozilla.org/en-US/docs/Web/API/Touch}) to be normalized. * @returns {TouchList|array} Returns the given points normalized. */ CB_Touch.normalizePoints = function(points) { if (typeof(points) === &quot;undefined&quot; || points === null || typeof(points) === &quot;undefined&quot; || points === null) { return []; } for (var x = 0; x &lt; points.length; x++) { points[x] = CB_Touch.normalizePoint(points[x]); } return points; } /** * Normalizes a given point. Calls {@link CB_Touch.normalizeForce} internally. This function is called by {@link CB_Touch.normalizePoints} automatically. * @function * @param {Touch} point - [Touch object]{@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} to be normalized. * @returns {Touch} Returns the given point normalized. */ CB_Touch.normalizePoint = function(point) { if (typeof(point) !== &quot;undefined&quot; &amp;&amp; point !== null) { if (typeof(point.force) === &quot;undefined&quot; || point.force === null || isNaN(point.force)) { if (typeof(point.webkitForce) !== &quot;undefined&quot; &amp;&amp; point.webkitForce !== null &amp;&amp; !isNaN(point.webkitForce)) { point.force = point.webkitForce; } else if (CB_Touch._force !== null) { point.force = CB_Touch._force; } //Uses force detected by Pressure.js. else { e.force = CB_Touch.DEFAULT_FORCE; } } point.force = CB_Touch.normalizeForce(point.force); } return point; } /** * Returns the last [touch event]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent} object (if any), processed by {@link CB_Touch.normalizeEvent} internally, which was used in the last touch event fired, if that touch event was [touchstart]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event}, [touchenter]{@link https://w3.org/TR/2011/WD-touch-events-20110505/#the-touchenter-event} or [touchmove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchmove_event}. The [touchend]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchend_event} and [touchleave]{@link https://w3.org/TR/2011/WD-touch-events-20110505/#the-touchleave-event} events set it to &quot;null&quot;. * @function * @returns {Event|null} Returns the last [touch event]{@link https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent} affected, if any. */ CB_Touch.getData = function() { return CB_Touch._data; } /** * Returns the maximum of touch points supported by the device (if possible). * @function * @returns {integer|null} Maximum touch points supported by the device (if possible). If it cannot be detected, returns null. */ CB_Touch.getMaxTouchPoints = function() { if (window.navigator) { if (window.navigator.maxTouchPoints) { return window.navigator.maxTouchPoints; } else if (window.navigator.msMaxTouchPoints) { return window.navigator.msMaxTouchPoints; } } return null; } /** * Sets a function to execute when the [onTouchStart]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onStart = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchstart&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the [onTouchEnd]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchend_event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onEnd = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchend&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the [onTouchCancel]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchcancel_event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onCancel = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchcancel&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the [onTouchEnter]{@link https://w3.org/TR/2011/WD-touch-events-20110505/#the-touchenter-event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onEnter = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchenter&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the [onTouchLeave]{@link https://w3.org/TR/2011/WD-touch-events-20110505/#the-touchleave-event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onLeave = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchleave&quot;, callbackFunction, keepOldFunction, useCapture, target); } /** * Sets a function to execute when the [onTouchMove]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchmove_event} event is fired or removes it. More information: [Touch events]{@link https://developer.mozilla.org/en-US/docs/DOM/Touch_events}. * @function * @param {function|null} callbackFunction - The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the {@link CB_Touch.normalizeEvent} function). If a null value is used, the event will be removed. * @param {boolean} [keepOldFunction=true] - Defines whether we want to keep any possible previous event listener for the same target and event name or not. * @param {boolean} [useCapture=false] - Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the [addEventListener]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener} method and will be used as its third parameter. * @param {Object} [target=document] - The target where we want to attach the event listener. */ CB_Touch.onMove = function(callbackFunction, keepOldFunction, useCapture, target) { return CB_Touch._setEvent(&quot;touchmove&quot;, callbackFunction, keepOldFunction, useCapture, target); } //Sets a function to execute when a touch event happens: CB_Touch._setEvent = function(eventName, eventFunction, keepOldFunction, useCapture, target) { //If they are not set, use default values for optional parameters: if (typeof(keepOldFunction) === &quot;undefined&quot; || keepOldFunction === null) { keepOldFunction = true; } //If not set, it keeps old function by default. if (typeof(target) === &quot;undefined&quot; || target === null) { target = document; } //If a function has been sent: if (typeof(eventFunction) === &quot;function&quot;) { //If able, adds the function given to the event: CB_Events.add ( target, eventName, function(e) { e = CB_Touch.normalizeEvent(e); //TODO. if (typeof(eventFunction) === &quot;function&quot;) { return eventFunction(e); } return true; }, useCapture, keepOldFunction, true ); } //...but if the function given is null, it will cancel the event: else if (eventFunction === null)// &amp;&amp; eventFunctionHolder !== null) { CB_Events.removeByName(target, eventName); } } /** * Returns the [Hammer.js]{@link https://hammerjs.github.io/} object (if any). Useful for managing touch gestures. * @function * @returns {Object} Returns the [Hammer.js]{@link https://hammerjs.github.io/} object (if any). */ CB_Touch.getHammerJSObject = function() { return CB_Touch._hammerJSObject; } /** * Returns the [Pressure.js]{@link https://pressurejs.com/} object (if any). Useful for managing [Force Touch/3D Touch]{@link https://en.wikipedia.org/wiki/Force_Touch} and [Pointer Pressure]{@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure} features. * @function * @returns {Object} Returns the [Pressure.js]{@link https://pressurejs.com/} object (if any). */ CB_Touch.getPressureJSObject = function() { return CB_Touch._pressureJSObject; } CB_Touch._delayTimeout = {}; CB_Touch._delayPerforming = {}; CB_Touch._delayMsDefault = 200; /** * First time, this function will return true. Next calls, with same index, returns false during the previously-defined time set in the previous call and true after that delay. After the first call, next calls of this function with same index will be ignored (returning always false) until the delay provided expires. If it is called after a previous call with the same index and the delay of the previous call already expired, it will act as it was the first call again. Useful, for example, to prevent the [onTouchStart]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event} event to fire twice or more when a layer (container) is closed and behind there is another one with also the [onTouchStart]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event} event. * @function * @param {integer} [delayMs=CB_Touch._delayMsDefault] - Delay desired in milliseconds. For same indexes, this parameter will be ignored if there was a previous call to this function whose delay did not expire yet. * @param {integer|string} [index=0] - Desired index to identify the process. * @returns {boolean} First time, this function will return true. Next calls with the same index, returns false during the given time and true after that delay. After the first call, next calls with same index of this function will be ignored (returning always false) until the delay provided expires. If it is called after a previous call with the same index and the delay of the previous call already expired, it will act as it was the first call again. */ CB_Touch.delay = function(delayMs, index) { if (!index) { index = 0; } if (CB_Touch._delayPerforming[index]) { return false; } clearTimeout(CB_Touch._delayTimeout[index]); CB_Touch._delayPerforming[index] = true; if (typeof(delayMs) === &quot;undefined&quot; || delayMs === null || isNaN(delayMs)) { delayMs = CB_Touch._delayMsDefault; } CB_Touch._delayTimeout[index] = setTimeout(function() { CB_Touch._delayPerforming[index] = false; }, delayMs); return true; } } × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Global Members &lt;constant&gt; CB_BASE_NAME :string Keeps the name of the CrossBase module. Type: string Default Value: CrossBase Source: CrossBase/CrossBase.js, line 49 &lt;readonly&gt; CB_CREDITS_DEFAULT :string Default credits. Type: string Source: CrossBrowdy.js, line 298 &lt;constant&gt; CB_NAME :string Keeps the name of the script (the main script will use this name with the &quot;.js&quot; extension). Case sensitive. Type: string Default Value: CrossBrowdy Source: CrossBrowdy.js, line 17 &lt;constant&gt; CB_OPTIONS :Object Two-dimensional object defined by the user with the desired options for CrossBrowdy and its modules. The options supported are the ones used by the CB_Configuration object. First-level indexes should belong to the module name (or to &quot;CrossBrowdy&quot;, for general options) and second-level indexes should belong to the option name. Example: { CrossBrowdy: { CB_console_ALLOW_ALERTS: false }, CrossBase: { SLCANVAS_LOAD : true, FLASHCANVAS_LOAD : true } } Type: Object Default Value: undefined Source: CrossBrowdy.js, line 33 &lt;readonly&gt; CB_scriptPath :string It will contain the CrossBrowdy path when it finally loads. Type: string Default Value: CB_scriptPathCalculate(); Source: CrossBrowdy.js, line 144 &lt;constant&gt; CB_this :Object Keeps the CrossBrowdy &quot;this&quot; context. Type: Object Source: CrossBrowdy.js, line 31 &lt;constant&gt; CB_VERSION :string CrossBrowdy version. Type: string Source: CrossBrowdy.js, line 24 Methods CB_addCredits(credits) → {string} Attaches the given credits to the default ones (to CB_CREDITS_DEFAULT). Parameters: Name Type Description credits string Path to the JS file. Source: CrossBrowdy.js, line 312 Returns: Returns the default credits after attaching the given ones. Type string CB_baseToBase(number [, baseSymbolsOrigin] [, baseSymbolsDestiny] [, unsigned] [, minusSymbolOrigin] [, minusSymbolDestiny] [, prefixOrigin] [, prefixDestiny]) → {string} Converts a given number which is already in a desired base into another chosen base. Note: Uses CB_baseToInt and CB_intToBase internally. Parameters: Name Type Argument Default Description number string A string containing the number which is already in the desired base and that we want to convert into the another chosen base. Used as the &quot;number&quot; parameter for calling both CB_intToBase and CB_baseToInt functions internally. baseSymbolsOrigin array | integer &lt;optional&gt; CB_baseSymbols.66 Used as the &quot;baseSymbols&quot; parameter when calling the CB_baseToInt function internally. baseSymbolsDestiny array | integer &lt;optional&gt; CB_baseSymbols.66 Used as the &quot;baseSymbols&quot; parameter when calling the CB_intToBase function internally. unsigned boolean &lt;optional&gt; false Determines whether to treat the input and output numbers as unsigned or not. Used as the &quot;unsigned&quot; parameter for calling both CB_intToBase and CB_baseToInt functions internally. minusSymbolOrigin string &lt;optional&gt; '-'|'0' Used as the &quot;minusSymbol&quot; parameter when calling the CB_baseToInt function internally. minusSymbolDestiny string &lt;optional&gt; '-'|'0' Used as the &quot;minusSymbol&quot; parameter when calling the CB_intToBase function internally. prefixOrigin prefix &lt;optional&gt; '0'|'0x'|'' Used as the &quot;prefix&quot; parameter when calling the CB_baseToInt function internally. prefixDestiny prefix &lt;optional&gt; '0'|'0x'|'' Used as the &quot;prefix&quot; parameter when calling the CB_intToBase function internally. Source: CrossBase/general/CB_data.js, line 1420 To Do: Think about accepting a decimal symbol to separate decimals and support float numbers. Returns: Returns the returning value of the internal call to the CB_intToBase function. Type string CB_baseToInt(number [, baseSymbols] [, unsigned] [, minusSymbol] [, prefix]) → {integer} Converts a given number which is already in a desired base into an integer (decimal base). Note: It can return wrong values when the value exceeds the maximum allowed by a number in the client's JavaScript engine. It can also depend on the &quot;baseSymbols&quot; used. Parameters: Name Type Argument Default Description number string A string containing the number which is already in the desired base and that we want to convert to an integer. baseSymbols array | integer &lt;optional&gt; CB_baseSymbols.66 Array with the desired symbols, using only one per index (their value will correspond to their index). The base (radix) will be the total number of indexes. It should be the base which is already being used by the given number. If an integer greater or equal than 2 is provided, it will try to use it as an index of the CB_baseSymbols object and use it if found or use it as a parameter to call the CB_baseSymbols.get function otherwise. If not provided or the integer is lower than 2, it will use base 66 (defined in the CB_baseSymbols._66 property of the CB_baseSymbols object). It is recommended not to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). The properties of the CB_baseSymbols object or the CB_baseSymbols.get function can be used for this parameter. unsigned boolean &lt;optional&gt; false Determines whether to treat the input and output numbers as unsigned or not. minusSymbol string &lt;optional&gt; '-'|'0' Determines the minus symbol or string for the input, to mark negative numbers. If not provided, it will be '-' for bases equal or lower than 16 (hexadecimal) or '0' (zero character) otherwise. This parameter is ignored if the &quot;unsigned&quot; parameter is set to true. prefix prefix &lt;optional&gt; '0'|'0x'|'' Determines the prefix for the input. If not provided, it will be '0' (zero character) for base 8 (octal), '0x' for base 16 (hexadecimal) or nothing (empty string) for all the others. Use an empty string to avoid using anything. Source: CrossBase/general/CB_data.js, line 1348 To Do: Think about allowing to return a string, for bigger numbers (to exceed the limit for integers). Internally, it would need to perform operations comparisons, multiplications with strings, etc. Think about allowing to specify the base for the integer. Think about accepting a decimal symbol to separate decimals and support float numbers. Returns: Returns the integer number in decimal base. Type integer CB_br2nl(string) → {string} Changes &lt;br /&gt;'s, &lt;br/&gt;'s and &lt;br&gt;'s for new lines (\\n) in a given string. Parameters: Name Type Description string string The string we want to modify. Source: CrossBase/general/CB_data.js, line 441 Returns: Returns the string with all the occurrences replaced or an empty string if the element given was not a string. Type string CB_brToNl() Alias for CB_br2nl. Source: CrossBase/general/CB_data.js, line 430 See: CB_br2nl CB_combineArraysOrObjects( [arrayOrObjectA] [, arrayOrObjectB], avoidDuplicatedValuesInArray [, modifyArrayOrObjectA]) → {array|Object} Returns a combined array or object from two arrays or objects. Using the following rules: If they both are arrays (numeric indexes), it will keep all elements (attaching the elements of the second array after the elements of the first one). Otherwise, if either of them is not an array (it should be an associative array which is an object in JavaScript), it will merge the elements (overwritting those whose index is the same and keeping the ones from the second array/object): Parameters: Name Type Argument Default Description arrayOrObjectA array | Object | string | null | undefined &lt;optional&gt; []|{} One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectB&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectB&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectB&quot; is an array or it will be an empty object otherwise. arrayOrObjectB array | Object | string | null | undefined &lt;optional&gt; []|{} One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectA&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectA&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectA&quot; is an array or it will be an empty object otherwise. avoidDuplicatedValuesInArray boolean Tells whether to avoid or allow items with duplicated values in the returned array or not. Only applies when both arrays to combine are numeric arrays. modifyArrayOrObjectA boolean &lt;optional&gt; false Parameter that will be used in the case that CB_combineJSON or CB_combineArraysOrObjects is called. If set to true, it will modify the original &quot;arrayOrObjectA&quot; array or object. Source: CrossBase/general/CB_data.js, line 1006 Returns: Type array | Object CB_combineAutomatically( [a] [, b] [, avoidDuplicatedValuesInArray] [, modifyArrayOrObjectA]) → {*} Tries to combine two given values guessing the best way to do it and returns their combination. Using the following rules: If both values are either undefined or null, returns null. Otherwise, if both values are boolean, returns the AND operation for the two of them (a &amp;&amp; b). Otherwise, if either of the two is a string (not empty) and is not JSON valid, combines them as URL (GET) parameters using CB_combineURIParameters. Otherwise, if either of them is JSON valid, combines them as JSON using CB_combineJSON (passing the received avoidDuplicatedValuesInArray value as a parameter). Otherwise, combines them as arrays or objects using CB_combineArraysOrObjects (passing the received &quot;avoidDuplicatedValuesInArray&quot; value as a parameter). Parameters: Name Type Argument Default Description a * &lt;optional&gt; null|[]|{} First value. It can be optional if &quot;b&quot; is a valid value, defined and not null. b * &lt;optional&gt; null|[]|{} Second value. It can be optional if &quot;a&quot; is a valid value, defined and not null. avoidDuplicatedValuesInArray boolean &lt;optional&gt; false Parameter that will be used in the case that CB_combineJSON or CB_combineArraysOrObjects is called. modifyArrayOrObjectA boolean &lt;optional&gt; false Parameter that will be used in the case that CB_combineJSON or CB_combineArraysOrObjects is called. If set to true, it will modify the original &quot;a&quot; array or object. Source: CrossBase/general/CB_data.js, line 951 Returns: Type * CB_combineJSON() Alias for CB_combineArraysOrObjects. Source: CrossBase/general/CB_data.js, line 1088 See: CB_combineArraysOrObjects CB_combineURIParameters(parametersA, parametersB) → {string} Combines two strings as URL (GET) parameters. If either &quot;parametersA&quot; or &quot;parametersB&quot; is not a string, internally it will use the native JSON.stringify method if available or otherwise it will use JSON 3 instead. Parameters: Name Type Description parametersA string String with the desired parameter or parameters. It can be optional if &quot;parametersB&quot; is a valid string. It will trim any &quot;&amp;&quot; and &quot;?&quot; character at the beginning and at the end, and finally use &quot;&amp;&quot; to concatenate the two strings (if needed). parametersB string String with the desired parameter or parameters. It can be optional if &quot;parametersA&quot; is a valid string. It will trim any &quot;&amp;&quot; and &quot;?&quot; character at the beginning and at the end, and finally use &quot;&amp;&quot; to concatenate the two strings (if needed). Source: CrossBase/general/CB_data.js, line 980 Returns: For example, if parametersA is &quot;parameter1=value1&amp;parameter2=value2&quot; and parametersB is &quot;parameter3=value3&amp;what=ever&quot; then it will return &quot;parameter1=value1&amp;parameter2=value2&amp;parameter3=value3&amp;what=ever&quot;. Type string CB_combineURLParameters() Alias for CB_combineURIParameters. Source: CrossBase/general/CB_data.js, line 968 See: CB_combineURIParameters CB_console(message) Alias for the &quot;console&quot; function which fallbacks to a DOM element with &quot;CB_console&quot; id (its CSS &quot;style&quot; attribute will be modified if needed, which means that its &quot;display&quot; property will be set to &quot;block&quot; if it is &quot;none&quot; and its &quot;visibility&quot; property to &quot;visible&quot; regardless its previous value) or even to an alert when it is not available (&quot;alert&quot; will only be used as a fallback in the case that the CB_console_ALLOW_ALERTS parameter is set to true). Parameters: Name Type Description message string Message to display Source: CrossBrowdy.js, line 324 To Do: When &quot;console&quot; is not available and it gets polyfilled, allow more parameters (use &quot;arguments&quot;). CB_copyObject(element [, onlyOwn]) → {object} Returns an object copied from the given one. Parameters: Name Type Argument Default Description element object The element whose properties and values we want to copy. It should be an object. onlyOwn boolean &lt;optional&gt; false If the &quot;element&quot; given is not an object, this parameter will be ignored. Otherwise, if it is set to true, it will only have into account the properties which the object has as their own property and have not been inherited (using the Object.hasOwnProperty method). Source: CrossBase/general/CB_data.js, line 836 Returns: Returns an object copied from the given one. Returns an empty object if the given &quot;element&quot; was not an object. Type object CB_countDecimalDigits() Alias for CB_countDecimalPart. Source: CrossBase/general/CB_data.js, line 597 See: CB_countDecimalPart CB_countDecimalPart(number) → {integer} Returns the number of decimals of the given number. It also works with numbers in exponential notation (as for example '1e-13' which would be 0.0000000000001). Parameters: Name Type Description number integer | float | string The number whose decimals we want to count. It can be a string. Source: CrossBase/general/CB_data.js, line 618 Returns: Returns zero in the case a non-valid number has been provided. Otherwise, it returns the number of decimals counted. Type integer CB_countDecimals() Alias for CB_countDecimalPart. Source: CrossBase/general/CB_data.js, line 592 See: CB_countDecimalPart CB_countIntegerDigits() Alias for CB_countIntegerPart. Source: CrossBase/general/CB_data.js, line 643 See: CB_countIntegerPart CB_countIntegerPart(number) → {integer} Returns the number of integer digits (the number of digits that belong to the integer part) of the given number. It also works with numbers in exponential notation (as for example '1e-13' which would be 0.0000000000001). Parameters: Name Type Description number integer | float | string The number whose integer digits (the digits that belong to the integer part) we want to count. It can be a string. Source: CrossBase/general/CB_data.js, line 654 Returns: Returns zero in the case a non-valid number has been provided. Otherwise, it returns the number of integer digits (the number of digits that belong to the integer part) counted. Type integer CB_credits( [credits] [, html] [, showPrefix]) → {string} Returns the credits with the desired format. Parameters: Name Type Argument Default Description credits string &lt;optional&gt; CB_CREDITS_DEFAULT Desired credits to be shown. html boolean &lt;optional&gt; true Strips all HTML tags (if any) when it is false. showPrefix boolean &lt;optional&gt; true Defines whether to show the &quot;[CB]&quot; prefix for every line or not (it will remove all &quot;[CB]&quot; occurrences if it is false). Source: CrossBrowdy.js, line 1121 Returns: Type string CB_forceString(element) → {string} Returns back the given element if it is a string or an empty string otherwise. Parameters: Name Type Description element * The element that will be checked. Source: CrossBase/general/CB_data.js, line 237 Returns: Type string CB_forEach(array, callback [, thisArg] [, extendedDOM]) → {array|undefined} Implementation of the Array.forEach method for browsers that do not support it natively. Executes a function for each element of a given array. Parameters: Name Type Argument Default Description array array Desired array. callback function Function that will be executed for each element of the given array. Following the same rules as the native Array.forEach method, it will receive three arguments: currentValue, currentIndex and the array given. thisArg * &lt;optional&gt; Value that will be passed as &quot;this&quot; every time the function is called. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 135 Returns: If the &quot;extendedDOM&quot; parameter is set to false, returns the given &quot;array&quot; again. Otherwise, returns undefined. Type array | undefined CB_getBase64StringObject() → {Object} Returns the &quot;Base64String&quot; object (used by the base64-string library included in lz-string), if any. Useful for compressing/decompressing base64 code. Source: CrossBase/general/CB_data.js, line 1494 Returns: Returns the &quot;Base64String&quot; object (used by the base64-string library included in lz-string) if available or null otherwise. Type Object CB_getCookie(index) → {string|null} Returns, from its index, a previous stored cookie. Parameters: Name Type Description index string The index whose value we want to retrieve. Source: CrossBase/general/CB_data.js, line 808 Returns: Returns null when the value cannot be found. Type string | null CB_getDatum(index [, forceCookie] [, unescapeIndex]) → {string|null} Gets, from its index, a previous value stored. It will try to get it using Web Storage API (localStorage). It can use localStorage as a fallback or cookies instead. Parameters: Name Type Argument Default Description index string The index whose value we want to retrieve. forceCookie boolean &lt;optional&gt; false Forces to use cookies instead of Web Storage API (localStorage). unescapeIndex boolean &lt;optional&gt; false Applies the unescape function to the value before returning it. Only applies when cookies are used. Source: CrossBase/general/CB_data.js, line 777 Returns: Returns null when the value cannot be found. Type string | null CB_getJSONPropertyValue(JSONObject, property [, returnValueOnFail]) → {*} Gets the value of a desired property of a given JSON object. Uses the CB_getValueIndex function internally. Parameters: Name Type Argument Description JSONObject Object | string The JSON object from which we want to get the value. If it is a string, it will try to parse it to create a real object from it. Used as the &quot;object&quot; parameter when calling the CB_getValueIndex function internally. property string The property whose value we want to retrieve. If not provided, the given object will be returned again. Used as the &quot;index&quot; parameter when calling the CB_getValueIndex function internally. returnValueOnFail * &lt;optional&gt; The value we want it to return in the case it cannot be parsed. If not provided, undefined will be returned. Used as the &quot;returnValueOnFail&quot; parameter when calling the CB_getValueIndex function internally. Source: CrossBase/general/CB_data.js, line 856 Returns: Returns the given &quot;JSONObject&quot; again (after trying to parse it if it was a string, if possible) if the &quot;property&quot; value was not given. Returns the value from the given object which belongs to the desired property or the value of &quot;returnValueOnFail&quot; otherwise if it cannot be found. Type * CB_getLZStringObject() → {Object} Returns the &quot;LZString&quot; object (used by the lz-string library), if any. Useful for compressing/decompressing strings. Source: CrossBase/general/CB_data.js, line 1483 Returns: Returns the &quot;LZString&quot; object (used by the lz-string library) if available or null otherwise. Type Object CB_getValueIndex(object, index [, returnValueOnFail]) → {*} Gets the value from a given object which belongs to the desired index or returns the value of &quot;returnValueOnFail&quot; if it cannot be found. Parameters: Name Type Argument Description object Object The object from which we want to get the value. index string The index whose value we want to retrieve. returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that the property cannot be found. If not provided, undefined will be returned. Source: CrossBase/general/CB_data.js, line 822 Returns: Returns the value from a given object which belongs to the desired index or the value of &quot;returnValueOnFail&quot; otherwise if it cannot be found. Type * CB_getValuePath(object, path [, splitString]) → {*} Returns the value of a desired path in an object or an empty string if it cannot be found. Parameters: Name Type Argument Default Description object Object The object where we want to find the path. path string The path that will be search in the given object to retrieve the value. It should use the string defined in the &quot;splitString&quot; parameter to separate items. If it is empty or not provided, it will just return the given &quot;object&quot; again. splitString string &lt;optional&gt; &quot;.&quot; The string that will be used to separate one item from another one. By default, it will be a dot (&quot;.&quot;) so, for example, a given &quot;path&quot; with a value of &quot;hello.world&quot; will indicate the &quot;object.hello.world&quot; path. Source: CrossBase/general/CB_data.js, line 683 Returns: Returns the value of a desired path in an object or an empty string if it cannot be found. If the &quot;path&quot; parameter is empty or not provided, it will just return the given &quot;object&quot; again. Type * CB_includeJSFile(filepath [, callbackOk] [, callbackError] [, timeoutMs] [, asynchronously] [, fileId] [, fileRequires] [, notMandatory]) → {Object|null|false} Includes a JavaScript file to the current document. Parameters: Name Type Argument Default Description filepath string Path to the JS file. callbackOk CB_includeJSFile_CALLBACK &lt;optional&gt; Callback for when the file is included successfully. callbackError CB_includeJSFile_CALLBACK &lt;optional&gt; Callback for when there is any error including the file or it cannot be included after the defined timeout. timeoutMs integer &lt;optional&gt; CB_Configuration.CrossBrowdy.CB_includeJSFile_TIMEOUT_MS_DEFAULT Timeout in milliseconds to consider that the inclusion of the file has failed. asynchronously boolean &lt;optional&gt; true Defines whether to load the file asynchronously or not. fileId string &lt;optional&gt; Internal usage recommended only. fileRequires array &lt;optional&gt; Internal usage recommended only. notMandatory boolean &lt;optional&gt; false Internal usage recommended only. Source: CrossBrowdy.js, line 382 Returns: Returns null when the script file cannot be loaded yet as some required file has still not been loaded. Returns false when neither the 'HEAD' tag nor the document body can be found. Otherwise, returns an object whose two properties are 'scriptElement' (with the SCRIPT element just created) and 'timeoutFailure' (with the setTimeout ID created to check whether the file cannot be loaded after the given time). Type Object | null | false CB_indexOf(array, searchElement [, fromIndex] [, extendedDOM]) → {integer} Implementation of Array.indexOf method for arrays in browsers that do not support it natively. Returns the first index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. Parameters: Name Type Argument Default Description array array Desired array. searchElement * Element we want to search. Note that it is type sensitive. fromIndex integer &lt;optional&gt; 0 First index of the given array where the search will start. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 86 Returns: Type integer CB_init( [mainFunction] [, scriptPath] [, onErrorLoadingFile] [, showSplashScreen]) Starts CrossBrowdy. Parameters: Name Type Argument Default Description mainFunction CB_init_CALLBACK &lt;optional&gt; Callback for when CrossBrowdy is loaded successfully. Recommended. scriptPath string &lt;optional&gt; CB_scriptPathCalculate() Path where the main script is located. If not provided (it is undefined or null), it will try to calculate it calling the CB_scriptPathCalculate function internally. onErrorLoadingFile CB_includeRequiredFileErrorCallback &lt;optional&gt; Function to call when any of the required files fails to load (because of an error or because its timeout was fired). It could be called more than once, for each file which failed loading. If a function is provided, it will be stored in the global 'CB_initOnErrorLoadingFile' variable. showSplashScreen boolean &lt;optional&gt; CB_Configuration.CrossBrowdy.SHOW_SPLASH_SCREEN_DEFAULT Defines whether to show the splash screen or not. Source: CrossBrowdy.js, line 1047 CB_intToBase(number [, baseSymbols] [, unsigned] [, minusSymbol] [, prefix]) → {string} Converts a given integer into a desired base. Parameters: Name Type Argument Default Description number integer | string The integer that we want to convert to the desired base. For bigger numbers (up to 999999999999999934464 or even lower, depending on the client and the &quot;baseSymbols&quot; used), it is recommended to use a string which will allow to accept a slightly bigger number (up to 999999999999999999999999 or lower, depending on the client and the &quot;baseSymbols&quot; used). Really big numbers will not be codified properly even when passed as a string due to the limitations of JavaScript engines and maximum number allowed to be stored in a variable. baseSymbols array | integer &lt;optional&gt; CB_baseSymbols.66 Array with the desired symbols, using only one per index (their value will correspond to their index). The base (radix) will be the total number of indexes. If an integer greater or equal than 2 is provided, it will try to use it as an index of the CB_baseSymbols object and use it if found or use it as a parameter to call the CB_baseSymbols.get function otherwise. If not provided or the integer is lower than 2, it will use base 66 (defined in the CB_baseSymbols._66 property of the CB_baseSymbols object). It is recommended not to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). The properties of the CB_baseSymbols object or the CB_baseSymbols.get function can be used for this parameter. unsigned boolean &lt;optional&gt; false Determines whether to treat the input and output numbers as unsigned or not. minusSymbol string &lt;optional&gt; '-'|'0' Determines the minus symbol or string for the output, to mark negative numbers. If not provided, it will be '-' for bases equal or lower than 16 (hexadecimal) or '0' (zero character) otherwise. This parameter is ignored if the &quot;unsigned&quot; parameter is set to true. prefix prefix &lt;optional&gt; '0'|'0x'|'' Determines the prefix for the output. If not provided, it will be '0' (zero character) for base 8 (octal), '0x' for base 16 (hexadecimal) or nothing (empty string) for all the others. Use an empty string to avoid using anything. Source: CrossBase/general/CB_data.js, line 1287 To Do: Think about allowing the &quot;number&quot; parameter to be a very long string, for bigger numbers (to exceed the limit for integers). Internally, it would need to perform operations comparisons, divisions, remainder calculation with strings, etc. Think about allowing to specify the base for the integer (now it is 16 if it begins with &quot;0x&quot;, 8 if it begins with &quot;0&quot; and it is not a string or 10 otherwise, and newer clients can support '0b' for binaries, '0o' for octals, ). Think about accepting a decimal symbol to separate decimals and support float numbers. Returns: Returns an empty string in the case that the given number cannot be parsed as an integer. Otherwise, returns the given number in the desired base as a string. Type string CB_isArray(element [, extendedDOM]) → {boolean} Implementation of Array.isArray method for browsers that do not support it natively. Returns whether a given element is an array or not. Parameters: Name Type Argument Default Description element * The element we want to check. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 171 To Do: Think about a parameter to check whether the given array is a typed array (for example, 'Uint8Array') or not. Returns: Type boolean CB_isEmail(email) → {boolean} Tells whether a given email is valid or not. Not really precise. Parameters: Name Type Description email string Possible email that we want to validate. Source: CrossBase/general/CB_data.js, line 551 Returns: Type boolean CB_isFileLocal(filePath) → {boolean} Tries to guess whether a given file path (absolute or relative) is a local address or not. It will be assumed as local if the path uses the &quot;file:&quot; protocol or the current script is running locally and the path does not use the &quot;http:&quot;, &quot;https:&quot; or &quot;ftp:&quot; protocols. Parameters: Name Type Description filePath string The file path we want to check. Source: CrossBase/general/CB_data.js, line 465 Returns: Returns whether the given file path is a local address or not. Type boolean CB_isString(element) → {boolean} Returns whether a given element is a string or not. Parameters: Name Type Description element * The element we want to check. Source: CrossBase/general/CB_data.js, line 225 Returns: Type boolean CB_lastIndexOf(array, searchElement [, fromIndex] [, extendedDOM]) → {integer} Implementation of Array.lastIndexOf method for browsers that do not support it natively. Returns the last index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. Parameters: Name Type Argument Default Description array array Desired array. searchElement * Element we want to search. Note that it is type sensitive. fromIndex integer &lt;optional&gt; array.length - 1 First index of the given array where the search will start. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 37 To Do: Implement the &quot;fromIndex&quot; in the polyfill. Returns: Type integer CB_ltrim(element [, undesiredStrings]) → {string|array} Trims the left side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 361 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array CB_nl2br(string) → {string} Changes new lines (\\n) for &lt;br /&gt;'s in a given string. Parameters: Name Type Description string string The string we want to modify. Source: CrossBase/general/CB_data.js, line 415 Returns: Returns the string with all the occurrences replaced or an empty string if the element given was not a string. Type string CB_nlToBr() Alias for CB_nl2br. Source: CrossBase/general/CB_data.js, line 404 See: CB_nl2br CB_numberFormat(number [, decimals] [, stringify]) → {integer|float|string} Returns the given number with the desired decimals and make it a string if we want to (so it will be able to have trailing zeros). Uses decimal numeral system only. It will perform ceiling round automatically if needed. Parameters: Name Type Argument Default Description number integer | float | string The number that we want to format. It can be a string. decimals integer &lt;optional&gt; 2 The number of decimals we want to allow. stringify boolean &lt;optional&gt; false Set to true if we want it to return a string (filled with trailing zeros to reach the desired number of decimals). Source: CrossBase/general/CB_data.js, line 566 To Do: Allow to define a minimum length for the integer part of the &quot;number&quot; parameter, so it will fill with leading zeros if needed (when &quot;stringify&quot; is set to true). Think about allowing to define a maximum too. Returns: Returns zero in the case a non-valid number has been provided. Type integer | float | string CB_numberOfDecimalDigits() Alias for CB_countDecimalPart. Source: CrossBase/general/CB_data.js, line 607 See: CB_countDecimalPart CB_numberOfDecimals() Alias for CB_countDecimalPart. Source: CrossBase/general/CB_data.js, line 602 See: CB_countDecimalPart CB_numberOfIntegerDigits() Alias for CB_countIntegerPart. Source: CrossBase/general/CB_data.js, line 638 See: CB_countIntegerPart CB_parseJSON(objectString [, reviver] [, returnValueOnFail] [, acceptUndefinedOrNull] [, onError]) → {*} Tries to parse a given string to convert it into a JSON object. Internally it will use the native JSON.parse method or otherwise use JSON 3 instead. Parameters: Name Type Argument Default Description objectString string The JSON object we want to parse, in string format. First parameter when calling the JSON.parse method (or equivalent) reviver function &lt;optional&gt; Second parameter when calling the JSON.parse method (or equivalent). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case it cannot be parsed. If not provided, undefined will be returned. acceptUndefinedOrNull boolean &lt;optional&gt; false If it is set to true and the given objectString is undefined or null, an empty object ({}) will be used as the objectString. onError function &lt;optional&gt; Callback which will be called if it failed to be parsed (it will receive the &quot;objectString&quot; as the unique parameter). Source: CrossBase/general/CB_data.js, line 888 Returns: Returns the object parsed from the given string or the value of &quot;returnValueOnFail&quot; otherwise (which will be undefined if not provided). Type * CB_parseString(element) → {string} Returns back the given element as a string if it could be parsed or an empty string otherwise. Parameters: Name Type Description element * The element that will be checked. Source: CrossBase/general/CB_data.js, line 250 Returns: Type string CB_regularExpressionString(string [, allOccurrences] [, caseInsensitive]) → {RegExp} Returns a desired regular expression (escaping the string) using the native JavaScript's RegExp from a given string. Parameters: Name Type Argument Default Description string string The string (not a regular expression) that we want to use (special characters will be escaped). allOccurrences boolean &lt;optional&gt; false Defines whether we want the regular expression returned to match all occurrences of the given string or only first found. caseInsensitive boolean &lt;optional&gt; false Defines whether we want the regular expression returned to be case insensitive or not. Source: CrossBase/general/CB_data.js, line 1469 Returns: Returns the desired regular expression (escaping the string) using the native JavaScript's RegExp from a given string. Type RegExp CB_renderString(str [, JSONObject] [, forceVanilla] [, depthLevelMax]) → {str} Processes a given string as a template and returns it rendered (if possible) with the values of the given JSON object. Tries to use Handlebars as the first choice but if is is not available it will just replace all occurrences with vanilla JavaScript. Parameters: Name Type Argument Default Description str string The string we want to render. JSONObject Object &lt;optional&gt; CB_JSONData The JSON object which contains the values. If not provided, it will try to use the global CB_JSONData object in the case it exists. forceVanilla boolean &lt;optional&gt; false Forces vanilla JavaScript rendering instead of using Handlebars. depthLevelMax integer &lt;optional&gt; 10 Maximum depth level allowed to read the object to render the string. Only applies when it is rendered by vanilla JavaScript. For performance purposes. Source: CrossBase/general/CB_data.js, line 494 Returns: Type str CB_replaceAll(stringOrArray, stringOrArrayFind [, stringReplace] [, caseInsensitive]) → {string|array} Returns the string or array of strings with all the desired occurrences replaced. Calls itself recursively and calls the CB_regularExpressionString function internally. Parameters: Name Type Argument Default Description stringOrArray string | array An string or an array of strings whose content we want to replace. It can also be an array of arrays of strings (as many levels as you wish). If an array is given, it will not be modified and a copy from it will be generated and returned with the occurrences replaced. stringOrArrayFind string | array An string or an array of strings (not a regular expressions) that we want to find to be replaced (special characters will be escaped). stringReplace string &lt;optional&gt; &quot;&quot; The string that will replace &quot;stringFind&quot;. If not provided, it will be replaced as an empty string (it will just remove the occurrences found). caseInsensitive boolean &lt;optional&gt; false Defines whether we want to be case insensitive or not. Source: CrossBase/general/CB_data.js, line 1436 Returns: Returns the &quot;stringOrArray&quot; given with occurrences replaced. If the &quot;stringOrArray&quot; given was neither a string nor an array, it will be returned without being modified. Type string | array CB_rtrim(element [, undesiredStrings]) → {string|array} Trims the right side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 308 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array CB_scriptPathCalculate() → {string} Tries to calculate and returns the path where the script is located. Source: CrossBrowdy.js, line 1003 Returns: If it cannot be calculated, it will returns the value of CB_Configuration[CB_NAME].SCRIPT_PATH_DEFAULT. Type string CB_setCookie(index, value [, days] [, path]) → {boolean} Stores a cookie. Parameters: Name Type Argument Description index string | number The index where the value given will be stored. value string | number The value we want to store. It should be a string or a number. days integer &lt;optional&gt; The number of days after which the cookie will expire. It belongs to the &quot;expires=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. path string &lt;optional&gt; The path where the cookie will be stored. It belongs to the &quot;path=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. Source: CrossBase/general/CB_data.js, line 763 Returns: Returns true if the value has been stored successfully (not totally reliable, it should be checked with CB_getCookie after a while). Type boolean CB_setDatum(index, value [, days] [, path] [, forceCookie]) → {boolean} Stores a value using Web Storage API (localStorage). It can use localStorage as a fallback or cookies instead. Parameters: Name Type Argument Default Description index string | number The index where the value given will be stored. value string | number The value we want to store. It should be a string or a number. days integer &lt;optional&gt; The number of days after which the cookie will expire (in the case that cookies are used). It belongs to the &quot;expires=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. path string &lt;optional&gt; The path where the cookie will be stored (in the case that cookies are used). It belongs to the &quot;path=&quot; parameter of the cookie. If not provided, the parameter will not be used at all. forceCookie boolean &lt;optional&gt; false Forces to use cookies instead of Web Storage API (localStorage). Source: CrossBase/general/CB_data.js, line 717 Returns: Returns true if the value has been stored successfully (not totally reliable, it should be checked with CB_getDatum after a while). Type boolean CB_sizeOf(element [, onlyOwn]) → {integer} Returns the size of an object or array. Parameters: Name Type Argument Default Description element Object | array The element whose size we want to know. It should be an object or an array. onlyOwn boolean &lt;optional&gt; false If the &quot;element&quot; given is not an object, this parameter will be ignored. Otherwise, if it is set to true, it will only have into account the properties which the object has as their own property and have not been inherited (using the Object.hasOwnProperty method). Source: CrossBase/general/CB_data.js, line 206 Returns: If an object is provided, the size will be the number of its properties. Otherwise, if an array is given, the size will be the numbers of its indexes (Array.length property). Type integer CB_sizeof() Alias for CB_sizeOf. Source: CrossBase/general/CB_data.js, line 194 See: CB_sizeOf CB_stringifyJSON(objectOrValue [, replacer] [, space] [, returnValueOnFail] [, failIfUndefinedOrNull] [, onError]) → {string} Tries to create a JSON valid string from a given JSON object or value. Internally it will use the native JSON.stringify method or otherwise use JSON 3 instead. Parameters: Name Type Argument Default Description objectOrValue * The object or value that we want to stringify. First parameter when calling the JSON.stringify method (or equivalent). replacer function &lt;optional&gt; Second parameter when calling the JSON.stringify method (or equivalent). space string | integer &lt;optional&gt; Third parameter when calling the JSON.stringify method (or equivalent). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case it cannot be stringify. If not provided, undefined will be returned. failIfUndefinedOrNull boolean &lt;optional&gt; false If it is set to true and the returning value is undefined or null, the value of &quot;returnValueOnFail&quot; will be returned. onError function &lt;optional&gt; Callback which will be called if it failed to be stringified (it will receive the &quot;objectOrValue&quot; as the unique parameter). Source: CrossBase/general/CB_data.js, line 916 Returns: Returns the object stringified from the given object or value if possible or the value of &quot;returnValueOnFail&quot; otherwise (which will be undefined if not provided). Avoids returning undefined or null if &quot;failIfUndefinedOrNull&quot; is set to true, returning the value of &quot;returnValueOnFail&quot; instead. Type string CB_symmetricCall(callbackFunction, timeMs [, id]) → {number|null} Calls the given function once through the native setTimeout function internally but having in mind the time taken when the function was called previously so it can be called multiple times and respect a symmetric interval between each call (simulates requestAnimationFrame). Parameters: Name Type Argument Default Description callbackFunction CB_symmetricCall_CALLBACK Function that will be called every time, receiving as the unique parameter the time (timestamp in milliseconds returned by the performance.now method, which could have been polyfilled automatically by CrossBrowdy) when it is called, being &quot;this&quot; the same &quot;this&quot; of the scope where it was called. timeMs integer Milliseconds between one call to the function and the next one. The accuracy will depend on many factors as the platform used, code performance, etc. id string &lt;optional&gt; callbackFunction.toString() String that will identify this symmetric interval. Recommended to avoid possible problems. Source: CrossBase/general/CB_others.js, line 24 Returns: Returns a numeric identifier generated by an internal call to the native setTimeout function (can be cleared/cancelled with clearTimeout). Returns null if the given &quot;callbackFunction&quot; is not a valid function. Type number | null CB_symmetricCallClear(id) → {boolean|null} Clears the stored last time used by CB_symmetricCall for a given symmetric interval identifier. Parameters: Name Type Description id string String that identifies this symmetric interval. Source: CrossBase/general/CB_others.js, line 72 Returns: Returns null if the given &quot;id&quot; is not a valid string. Returns false if the stored time did not exist for the given &quot;id&quot; or it was cleared already. Returns true otherwise, after clearing it. Type boolean | null CB_trim(element [, undesiredStrings]) → {string|array} Trims a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 266 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array Type Definitions CB_includeJSFile_CALLBACK(filepath, callbackOk, callbackError, timeoutMs, asynchronously) Callback for when the file is included successfully or fails to load. Parameters: Name Type Description filepath string The 'filepath' parameter when CB_includeJSFile was called (if any). callbackOk CB_includeJSFile_CALLBACK The 'callbackOk' parameter when CB_includeJSFile was called (if any). callbackError CB_includeJSFile_CALLBACK The 'callbackError' parameter when CB_includeJSFile was called (if any). timeoutMs integer The 'timeoutMs' parameter when CB_includeJSFile was called (if any). asynchronously boolean The 'asynchronously' parameter when CB_includeJSFile was called (if any). Source: CrossBrowdy.js, line 359 CB_includeRequiredFileErrorCallback(filepath, callbackOk, callbackError, timeoutMs, asynchronously, filesRequested, filesLoaded) Callback for when the script is loaded successfully. Without parameters. Parameters: Name Type Description filepath string The 'filepath' parameter when CB_includeJSFile was called internally (if any). callbackOk CB_includeJSFile_CALLBACK The 'callbackOk' parameter when CB_includeJSFile was called internally (if any). callbackError CB_includeJSFile_CALLBACK The 'callbackError' parameter when CB_includeJSFile was called internally (if any). timeoutMs integer The 'timeoutMs' parameter when CB_includeJSFile was called internally (if any). asynchronously boolean The 'asynchronously' parameter when CB_includeJSFile was called (if any). filesRequested object Object whose indexes are all the filepaths of the script files requested so far and the value is true when the file is still loading (or to be loaded in the future), false if it was loaded successfully (the most likely) or null if it failed to load. filesLoaded array Numeric array whose values are the filepaths of the script files loaded successfully so far. Source: CrossBrowdy.js, line 484 CB_init_CALLBACK() Callback for when the script is loaded successfully. Without parameters. Source: CrossBrowdy.js, line 1034 CB_symmetricCall_CALLBACK(expectedCallingTime) Callback that is called by CB_symmetricCall. Parameters: Name Type Description expectedCallingTime integer The timestamp in milliseconds that represents when the callback should have been called (it will be more or less accurate depending on many factors as the platform used, code performance, etc.). Source: CrossBase/general/CB_others.js, line 8 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Classes Classes CB_AudioFile CB_AudioFile_API.AAPI CB_AudioFile_API.ACMP CB_AudioFile_API.SM2 CB_AudioFile_API.WAAPI CB_AudioFileCache CB_AudioFileSprites CB_AudioFileSpritesPool CB_Canvas CB_GraphicSprites CB_GraphicSpritesScene Namespaces CB_Arrays CB_AudioDetector CB_baseSymbols CB_Client CB_Collisions CB_Configuration CrossBase CrossBrowdy CB_Controllers CB_Controllers_Proprietary WII WII_U CB_Device AmbientLight Battery Location Motion Orientation Proximity Vibration CB_Elements CB_Events CB_Keyboard chars extended keys CB_Modules CB_Mouse CursorImage CB_Net Fetch REST Sockets SockJS XHR CB_Pointer CB_Screen CB_Speaker CB_Touch × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespaces Classes CB_AudioFile CB_AudioFile_API.AAPI CB_AudioFile_API.ACMP CB_AudioFile_API.SM2 CB_AudioFile_API.WAAPI CB_AudioFileCache CB_AudioFileSprites CB_AudioFileSpritesPool CB_Canvas CB_GraphicSprites CB_GraphicSpritesScene Namespaces CB_Arrays CB_AudioDetector CB_baseSymbols CB_Client CB_Collisions CB_Configuration CrossBase CrossBrowdy CB_Controllers CB_Controllers_Proprietary WII WII_U CB_Device AmbientLight Battery Location Motion Orientation Proximity Vibration CB_Elements CB_Events CB_Keyboard chars extended keys CB_Modules CB_Mouse CursorImage CB_Net Fetch REST Sockets SockJS XHR CB_Pointer CB_Screen CB_Speaker CB_Touch × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION CrossBrowdyYour cross-browser brodie! CrossBrowdy is an object-oriented JavaScript framework that allows to create multimedia apps, emulators, game engines, games and similar that will be compatible with any device. Main web site: http://crossbrowdy.com/ CrossBase/audiovisual/audio/CB_AudioDetector.js Audio formats and audio APIs support detection. Contains the CB_AudioDetector static class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 1 CrossBase/audiovisual/audio/CB_AudioFile.js Audio files management, including abstraction for different audio APIs. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Contains the CB_AudioFile class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 1 CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js Audio files management using &quot;AAPI&quot; (HTML5 Audio API). Contains the CB_AudioFile_API.AAPI class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1 CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js Audio files management using &quot;ACMP&quot; (Apache Cordova Media Plugin). Contains the CB_AudioFile_API.ACMP class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1 CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js Audio files management using &quot;SM2&quot; (SoundManager 2). Contains the CB_AudioFile_API.SM2 class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1 CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js Audio files management using &quot;WAAPI&quot; (HTML5 Web Audio API). Contains the CB_AudioFile_API.WAAPI class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1 CrossBase/audiovisual/audio/CB_AudioFileCache.js Audio files cache management. Contains the CB_AudioFileCache class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1 CrossBase/audiovisual/audio/CB_AudioFileSprites.js Audio sprites management. Contains the CB_AudioFileSprites class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1 CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js Audio sprites pool management. Contains the CB_AudioFileSpritesPool class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1 CrossBase/audiovisual/audio/CB_Speaker.js Speakers management. Contains the CB_Speaker static class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 1 CrossBase/audiovisual/image/canvas/CB_Canvas.js Canvas management (including emulation fallbacks). Contains the CB_Canvas class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 1 CrossBase/audiovisual/image/CB_GraphicSprites.js Group of graphic sprites management (2D or 3D). Contains the CB_GraphicSprites class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1 CrossBase/audiovisual/image/CB_GraphicSpritesScene.js Groups of graphic sprites management (2D or 3D). Internally, it manages CB_GraphicSprites objects. Contains the CB_GraphicSpritesScene class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 1 CrossBase/audiovisual/image/CB_Screen.js Screen management. Contains the CB_Screen static class. Author: Joan Alba Maldonado Source: CrossBase/audiovisual/image/CB_Screen.js, line 1 CrossBase/CrossBase.js Main CrossBase module file. Author: Joan Alba Maldonado Source: CrossBase/CrossBase.js, line 1 CrossBase/device/CB_Device.js Device management. Contains the CB_Device static class. Author: Joan Alba Maldonado Source: CrossBase/device/CB_Device.js, line 1 CrossBase/general/CB_Arrays.js Arrays management. Contains the CB_Arrays static class. Author: Joan Alba Maldonado Source: CrossBase/general/CB_Arrays.js, line 1 CrossBase/general/CB_Client.js Web client (browser or engine) management. Contains the CB_Client static class. Author: Joan Alba Maldonado Source: CrossBase/general/CB_Client.js, line 1 CrossBase/general/CB_Collisions.js Collisions management. Contains the CB_Collisions static class. Author: Joan Alba Maldonado Source: CrossBase/general/CB_Collisions.js, line 1 CrossBase/general/CB_data.js Data and related management. Author: Joan Alba Maldonado Source: CrossBase/general/CB_data.js, line 1 To Do: A function equivalent to htmlentities/htmlspecialchars (as in PHP). CrossBase/general/CB_Elements.js DOM elements management. Contains the CB_Elements static class. Author: Joan Alba Maldonado Source: CrossBase/general/CB_Elements.js, line 1 CrossBase/general/CB_Events.js Events management. Contains the CB_Events static class. Author: Joan Alba Maldonado Source: CrossBase/general/CB_Events.js, line 1 CrossBase/general/CB_others.js Miscellaneous code. Author: Joan Alba Maldonado Source: CrossBase/general/CB_others.js, line 1 To Do: Think about a 'CB_symmetricInterval' function, similar to CB_symmetricCall but calling the callback function automatically. CrossBase/input/CB_Keyboard.js Keyboard management (and other devices which also fire keyboard events as TV remote controls, game consoles' gamepads, etc.). Contains the CB_Keyboard static class. Author: Joan Alba Maldonado Source: CrossBase/input/CB_Keyboard.js, line 1 CrossBase/input/CB_Mouse.js Mouse and related management. Contains the CB_Mouse static class. Author: Joan Alba Maldonado Source: CrossBase/input/CB_Mouse.js, line 1 CrossBase/input/CB_Pointer.js Pointer management. Contains the CB_Pointer static class. Author: Joan Alba Maldonado Source: CrossBase/input/CB_Pointer.js, line 1 CrossBase/input/CB_Touch.js Touch events management. Contains the CB_Touch static class. Author: Joan Alba Maldonado Source: CrossBase/input/CB_Touch.js, line 1 CrossBase/input/controllers/CB_Controllers.js Controllers (gamepads, joysticks, remotes, etc.) management. Contains the CB_Controllers static class. Author: Joan Alba Maldonado Source: CrossBase/input/controllers/CB_Controllers.js, line 1 CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js Nintendo Wii remotes (Wiimotes) management. Contains the CB_Controllers_Proprietary.WII static class. Author: Joan Alba Maldonado Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js, line 1 CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js Nintendo Wii U gamepad and remotes (Wiimotes) management. Contains the CB_Controllers_Proprietary.WII_U static class. Author: Joan Alba Maldonado Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 1 CrossBase/net/CB_Net.js Management for things related with the net. Contains the CB_Net static class. Author: Joan Alba Maldonado Source: CrossBase/net/CB_Net.js, line 1 CrossBase/net/fetch/CB_Net_Fetch.js Fetch API management. Contains the CB_Net.Fetch static class. Author: Joan Alba Maldonado Source: CrossBase/net/fetch/CB_Net_Fetch.js, line 1 CrossBase/net/REST/CB_Net_REST.js REST client, services and related management. Contains the CB_Net.REST static class. Author: Joan Alba Maldonado Source: CrossBase/net/REST/CB_Net_REST.js, line 1 CrossBase/net/sockets/CB_Net_Sockets.js Sockets and related management. Contains the CB_Net.Sockets static class. Author: Joan Alba Maldonado Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 1 CrossBase/net/XHR/CB_Net_XHR.js XMLHttpRequest (XHR, AJAX) and related management. Contains the CB_Net.XHR static class. Author: Joan Alba Maldonado Source: CrossBase/net/XHR/CB_Net_XHR.js, line 1 CrossBrowdy.js Main CrossBrowdy file. Author: Joan Alba Maldonado Source: CrossBrowdy.js, line 3 To Do: Clear all timeouts before creating them (just in case). × Search results Close "},"CB_Arrays.html":{"id":"CB_Arrays.html","title":"Namespace: CB_Arrays","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Arrays CB_Arrays Static class to manage arrays. It will return itself if it is tried to be instantiated. Source: CrossBase/general/CB_Arrays.js, line 21 Methods &lt;static&gt; bsort(array [, reversed]) → {array} Sorts an array using the bubble sort (sinking sort) method. Internally, it uses the &quot;&gt;&quot; operator for comparing values as they will be treated as numbers. Parameters: Name Type Argument Default Description array array The array whose elements we want to sort. reversed boolean &lt;optional&gt; false Defines whether to sort in the reverse order or not. Source: CrossBase/general/CB_Arrays.js, line 399 To Do: Think about accepting a comparing function (as the &quot;sort&quot; method). Returns: Returns the array ordered. If another value which is not an array is given, it will be returned again. Type array &lt;static&gt; combine( [arrayOrObjectA] [, arrayOrObjectB], avoidDuplicatedValuesInArray [, modifyArrayOrObjectA]) → {array|Object} Returns a combined array or object from two arrays or objects. Using the following rules: If they both are arrays (numeric indexes), it will keep all elements (attaching the elements of the second array after the elements of the first one). Otherwise, if either of them is not an array (it should be an associative array which is an object in JavaScript), it will merge the elements (overwritting those whose index is the same and keeping the ones from the second array/object): Parameters: Name Type Argument Default Description arrayOrObjectA array | Object | string | null | undefined &lt;optional&gt; []|{} One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectB&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectB&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectB&quot; is an array or it will be an empty object otherwise. arrayOrObjectB array | Object | string | null | undefined &lt;optional&gt; []|{} One of the arrays (numeric indexes) or associative arrays (object) that we want to combine. If a string is provided, it will try to convert it into a new object (the string should be a JSON-valid string). It can be optional if &quot;arrayOrObjectA&quot; is a valid value and neither null nor undefined. If not provided but the &quot;arrayOrObjectA&quot; is provided, it will be a new empty array if the &quot;arrayOrObjectA&quot; is an array or it will be an empty object otherwise. avoidDuplicatedValuesInArray boolean Tells whether to avoid or allow items with duplicated values in the returned array or not. Only applies when both arrays to combine are numeric arrays. modifyArrayOrObjectA boolean &lt;optional&gt; false Parameter that will be used in the case that CB_combineJSON or CB_combineArraysOrObjects is called. If set to true, it will modify the original &quot;arrayOrObjectA&quot; array or object. Source: CrossBase/general/CB_data.js, line 1006 Returns: Type array | Object &lt;static&gt; copy(array) → {object} Returns an array copied from the given one. It will also make a copy of the arrays found in the values (if any), calling itself recursively. Parameters: Name Type Description array array The array whose values we want to copy. Source: CrossBase/general/CB_Arrays.js, line 237 Returns: Returns an array copied from the given one. Returns an empty array if the given &quot;array&quot; was not an array. Type object &lt;static&gt; count() Alias for CB_Arrays.sizeOf. Source: CrossBase/general/CB_Arrays.js, line 65 See: CB_Arrays.sizeOf &lt;static&gt; executeFunctionAll(array, functionEach [, delayBetweenEach] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing elements of a given array. Elements which are undefined or null will be skipped without calling the &quot;functionEach&quot; function. Parameters: Name Type Argument Default Description array array A numeric array containing the elements that we want to loop. functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Function that will be called for each element of the given array. As the first parameter it receives the element of the &quot;array&quot; provided being looped, as the second parameter the position of this element in the &quot;array&quot; provided, the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the element itself. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the setTimeout function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each item). returnSetTimeoutsArray boolean &lt;optional&gt; false Defines whether we want the method to return an integer or a numeric array with information of each setTimeout call. Returning an array with information of each setTimeout call is only useful when the setTimeout function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). delayBetweenEachAffectsFirst boolean &lt;optional&gt; false If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/general/CB_Arrays.js, line 167 Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the elements given in the &quot;array&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_Arrays.executeFunctionAll_OBJECT object for each element given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array &lt;static&gt; forEach(array, callback [, thisArg] [, extendedDOM]) → {array|undefined} Implementation of the Array.forEach method for browsers that do not support it natively. Executes a function for each element of a given array. Parameters: Name Type Argument Default Description array array Desired array. callback function Function that will be executed for each element of the given array. Following the same rules as the native Array.forEach method, it will receive three arguments: currentValue, currentIndex and the array given. thisArg * &lt;optional&gt; Value that will be passed as &quot;this&quot; every time the function is called. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 135 Returns: If the &quot;extendedDOM&quot; parameter is set to false, returns the given &quot;array&quot; again. Otherwise, returns undefined. Type array | undefined &lt;static&gt; indexOf(array, searchElement [, fromIndex] [, extendedDOM]) → {integer} Implementation of Array.indexOf method for arrays in browsers that do not support it natively. Returns the first index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. Parameters: Name Type Argument Default Description array array Desired array. searchElement * Element we want to search. Note that it is type sensitive. fromIndex integer &lt;optional&gt; 0 First index of the given array where the search will start. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 86 Returns: Type integer &lt;static&gt; insert() Alias for CB_Arrays.insertElement. Source: CrossBase/general/CB_Arrays.js, line 250 See: CB_Arrays.insertElement &lt;static&gt; insertElement(array [, index], item [, onInsert]) → {array} Inserts an element in the desired position of a given an array. Elements which are placed after it will be moved a position to the right (increasing their index). Parameters: Name Type Argument Default Description array array The array whose element we want to delete. index integer &lt;optional&gt; 0 Position of the element in the given array that we want to remove. item * Element (item) which belongs to the index which is being checked in the current iteration of the given array. onInsert CB_Arrays.removeDuplicated_PURGE_FUNCTION &lt;optional&gt; Function to call if the element is inserted, after inserting it. Source: CrossBase/general/CB_Arrays.js, line 269 Returns: Returns the new array (with the element inserted if it was possible). If no valid array is given, it will return an empty array. Type array &lt;static&gt; insertElementByPosition() Alias for CB_Arrays.insertElement. Source: CrossBase/general/CB_Arrays.js, line 255 See: CB_Arrays.insertElement &lt;static&gt; isArray(element [, extendedDOM]) → {boolean} Implementation of Array.isArray method for browsers that do not support it natively. Returns whether a given element is an array or not. Parameters: Name Type Argument Default Description element * The element we want to check. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 171 To Do: Think about a parameter to check whether the given array is a typed array (for example, 'Uint8Array') or not. Returns: Type boolean &lt;static&gt; lastIndexOf(array, searchElement [, fromIndex] [, extendedDOM]) → {integer} Implementation of Array.lastIndexOf method for browsers that do not support it natively. Returns the last index of a given element that exists in an array (starting from a certain index if desired) or -1 if not found. Parameters: Name Type Argument Default Description array array Desired array. searchElement * Element we want to search. Note that it is type sensitive. fromIndex integer &lt;optional&gt; array.length - 1 First index of the given array where the search will start. extendedDOM boolean &lt;optional&gt; false Defines whether the function is being called by a native function which was extended. Internal usage recommended only. Source: CrossBase/general/CB_data.js, line 37 To Do: Implement the &quot;fromIndex&quot; in the polyfill. Returns: Type integer &lt;static&gt; ltrim(element [, undesiredStrings]) → {string|array} Trims the left side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 361 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array &lt;static&gt; removeDuplicated(array [, purgeFunction] [, ignoreDuplicated]) → {array} Deletes duplicated and/or not desired values (with a checking function to purge) from a numeric array. Values can be of any type. Internally, loops through the given array backwards (from the last index to the first one). Parameters: Name Type Argument Default Description array array The array whose values we want to purge. purgeFunction CB_Arrays.removeDuplicated_PURGE_FUNCTION &lt;optional&gt; Callback that will be called for each item, being &quot;this&quot; the current item. It should return false when we want to keep the value or true otherwise. If the &quot;ignoreDuplicated&quot; parameter is set to true, all duplicated elements will be removed regardless of the returning value of the &quot;purgeFunction&quot; function. ignoreDuplicated boolean &lt;optional&gt; false If it is set to true, it will keep duplicated values (unless the given &quot;purgeFunction&quot; purge them). Source: CrossBase/general/CB_Arrays.js, line 300 Returns: Returns the array purged. If no valid array is given, it will return an empty array. Type array &lt;static&gt; removeElement(array [, element] [, onRemove]) → {array} Deletes a given element from an array. All occurrences will be deleted. Elements which were after a removed element will be moved a position to the left (decreasing their index). Parameters: Name Type Argument Description array array The array whose element we want to delete. element * &lt;optional&gt; The element we want to remove. All occurrences will be deleted. Note that it is type sensitive. onRemove CB_Arrays.removeDuplicated_PURGE_FUNCTION &lt;optional&gt; Function to call if the element is removed, before removing it. Source: CrossBase/general/CB_Arrays.js, line 350 Returns: Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. Type array &lt;static&gt; removeElementByIndex() Alias for CB_Arrays.removeElementByPosition. Source: CrossBase/general/CB_Arrays.js, line 320 See: CB_Arrays.removeElementByPosition &lt;static&gt; removeElementByPosition(array [, index] [, onRemove]) → {array} Deletes an element from an array which is placed in the desired position. Elements which were after it will be moved a position to the left (decreasing their index). Parameters: Name Type Argument Default Description array array The array whose element we want to delete. index integer &lt;optional&gt; 0 Position of the element in the given array that we want to remove. onRemove CB_Arrays.removeDuplicated_PURGE_FUNCTION &lt;optional&gt; Function to call if the element is removed, before removing it. Source: CrossBase/general/CB_Arrays.js, line 333 Returns: Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. Type array &lt;static&gt; removeElements(array, elements) → {array} Deletes the given elements from an array. All occurrences will be deleted. Elements which were after a removed element will be moved a position to the left (decreasing their index). Parameters: Name Type Description array array The array whose element we want to delete. elements array An array with the elements we want to remove. All occurrences will be deleted. Note that it is type sensitive. Source: CrossBase/general/CB_Arrays.js, line 363 Returns: Returns the new array (with the element removed if it was possible). If no valid array is given, it will return an empty array. Type array &lt;static&gt; replaceAll(stringOrArray, stringOrArrayFind [, stringReplace] [, caseInsensitive]) → {string|array} Returns the string or array of strings with all the desired occurrences replaced. Calls itself recursively and calls the CB_regularExpressionString function internally. Parameters: Name Type Argument Default Description stringOrArray string | array An string or an array of strings whose content we want to replace. It can also be an array of arrays of strings (as many levels as you wish). If an array is given, it will not be modified and a copy from it will be generated and returned with the occurrences replaced. stringOrArrayFind string | array An string or an array of strings (not a regular expressions) that we want to find to be replaced (special characters will be escaped). stringReplace string &lt;optional&gt; &quot;&quot; The string that will replace &quot;stringFind&quot;. If not provided, it will be replaced as an empty string (it will just remove the occurrences found). caseInsensitive boolean &lt;optional&gt; false Defines whether we want to be case insensitive or not. Source: CrossBase/general/CB_data.js, line 1436 Returns: Returns the &quot;stringOrArray&quot; given with occurrences replaced. If the &quot;stringOrArray&quot; given was neither a string nor an array, it will be returned without being modified. Type string | array &lt;static&gt; rtrim(element [, undesiredStrings]) → {string|array} Trims the right side of a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 308 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Think about optimizing (using a counter for the number of occurrences in the loop and trim all the occurrences when finished). Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array &lt;static&gt; sizeof() Alias for CB_Arrays.sizeOf. Source: CrossBase/general/CB_Arrays.js, line 60 See: CB_Arrays.sizeOf &lt;static&gt; sizeOf(element [, onlyOwn]) → {integer} Returns the size of an object or array. Parameters: Name Type Argument Default Description element Object | array The element whose size we want to know. It should be an object or an array. onlyOwn boolean &lt;optional&gt; false If the &quot;element&quot; given is not an object, this parameter will be ignored. Otherwise, if it is set to true, it will only have into account the properties which the object has as their own property and have not been inherited (using the Object.hasOwnProperty method). Source: CrossBase/general/CB_data.js, line 206 Returns: If an object is provided, the size will be the number of its properties. Otherwise, if an array is given, the size will be the numbers of its indexes (Array.length property). Type integer &lt;static&gt; sort(array [, reversed] [, comparingFunction]) → {array} Sorts the values of an array (using the native Array.sort method). Parameters: Name Type Argument Default Description array array The array whose elements we want to sort. reversed boolean &lt;optional&gt; false Defines whether to sort in the reverse order or not. Only applies when comparingFunction is not provided. comparingFunction function &lt;optional&gt; Comparing function with the same rules as the native Array.sort method. If provided, the &quot;reversed&quot; parameter will be ignored. Source: CrossBase/general/CB_Arrays.js, line 379 Returns: Returns the array ordered. If another value which is not an array is given, it will be returned again. Type array &lt;static&gt; trim(element [, undesiredStrings]) → {string|array} Trims a given string or array of strings (modifying the given array), taking off the desired strings or otherwise trimming spaces, tabs (&quot;\\t&quot;), new lines (&quot;\\n&quot;) and carriage returns (&quot;\\r&quot;). Case sensitive. Parameters: Name Type Argument Default Description element string | array The element that will be trimmed. It should be either a string or an array of strings. undesiredStrings string | array &lt;optional&gt; [ &quot; &quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\t&quot; ] String or an array with the strings that we want to trim off the given element. Source: CrossBase/general/CB_data.js, line 266 To Do: Accept a &quot;recursive&quot; parameter (boolean) to affect multiple levels (array of arrays of strings, etc.). Consider accepting objects instead of arrays in the &quot;element&quot; parameter. Returns: Returns the given element again if it was an string, a number (it will be casted to a string) or an array of strings, trimmed if it has been possible. If it was another type, returns an empty string. Type string | array executeAll() Alias for CB_Arrays#executeFunctionAll. Source: CrossBase/general/CB_Arrays.js, line 146 See: CB_Arrays#executeFunctionAll forEachDelay() Alias for CB_Arrays#executeFunctionAll. Source: CrossBase/general/CB_Arrays.js, line 151 See: CB_Arrays#executeFunctionAll Type Definitions executeFunctionAll_OBJECT Object used by the CB_Arrays#executeFunctionAll method when the &quot;returnSetTimeoutsArray&quot; parameter is set to true. Type: Object Properties: Name Type Description item * The element affected. setTimeoutReturningValue integer The returning value of calling the setTimeout internally or null if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. setTimeoutDelay number The value used as the second parameter when calling the setTimeout internally or zero if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. Source: CrossBase/general/CB_Arrays.js, line 137 executeFunctionAll_ON_FINISH_CALLBACK(array, itemsAffected, delayMaximum) Callback that is used when finishes all iterations after looping the array. Being &quot;this&quot; the array itself. Parameters: Name Type Description array array Whole array which was being looped. itemsAffected integer The number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null). delayMaximum integer The maximum &quot;delay&quot; used. Source: CrossBase/general/CB_Arrays.js, line 129 executeFunctionAll_ON_LOOP_CALLBACK(item, index, array, delay) → {number} Callback that is used for each iteration when looping the array. Being &quot;this&quot; the value itself. Parameters: Name Type Description item * Element (item) which belongs to the index which is being checked in the current iteration of the given array. index integer Index which is being checked in the current iteration. array array Whole array which is being looped. delay integer The &quot;delayBetweenEach&quot; used for this loop. Source: CrossBase/general/CB_Arrays.js, line 119 Returns: When used as a function to calculate the delay, it should return the delay desired as a number. Type number removeDuplicated_PURGE_FUNCTION(item, index, array) → {boolean} Callback that is used as the &quot;purgeFunction&quot; parameter of the CB_Arrays.removeDuplicated function. Being &quot;this&quot; the current element (item). It should return false when we want to keep the value or true otherwise. Parameters: Name Type Description item * Element (item) which belongs to the index which is being checked in the current iteration used in CB_Arrays.removeDuplicated. index integer Index which is being checked in the current iteration used in CB_Arrays.removeDuplicated. array array Whole array which is being checked. Source: CrossBase/general/CB_Arrays.js, line 282 Returns: It should return false when we want to keep the value or true otherwise. Type boolean × Search results Close "},"CB_AudioDetector.html":{"id":"CB_AudioDetector.html","title":"Namespace: CB_AudioDetector","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_AudioDetector CB_AudioDetector Static class to detect audio API and formats supported. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). It will return itself if it is tried to be instantiated. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 11 Methods &lt;static&gt; APIExists(audioAPI [, sanitize]) → {boolean} Returns whether a given audio API exists or not (without keeping into account whether it is supported or not). All existing ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. Parameters: Name Type Argument Default Description audioAPI string The audio API that we want to check. All existing ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). sanitize boolean &lt;optional&gt; true If set to true, the &quot;audioAPI&quot; given will be trimmed and converted to upper case. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 163 Returns: Returns whether the given audio API exists or not (without keeping into account whether it is supported or not). Type boolean &lt;static&gt; getPreferredAPI( [audioAPIs] [, allowEmulation] [, returnOnEmpty]) → {string|*} Calculates and returns the preferred audio API (from an array if it is given) for the current client, if any. Parameters: Name Type Argument Default Description audioAPIs array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS An array of strings with the audio APIs that we want to check, in order of preference. All existing ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). allowEmulation boolean &lt;optional&gt; !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT If set to true, it will also detect as supported emulated audio APIs (as &quot;WAAPI&quot; using waapisim.js instead of supported natively). returnOnEmpty boolean &lt;optional&gt; If set to true and no audio API is supported, it will return the value of this parameter instead of null. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 180 Returns: Returns a string with the preferred audio API (from an array if it is given) for the current client, if any. If no audio API is supported, it will return the value set in the &quot;returnOnEmpty&quot; parameter. Type string | * &lt;static&gt; getSupportedAPIs( [audioAPIs] [, allowEmulation]) → {array} Calculates and returns an array with the audio APIs supported (from an array if it is given) for the current client, if any. Parameters: Name Type Argument Default Description audioAPIs array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS An array of strings with the audio APIs that we want to check. All existing ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). allowEmulation boolean &lt;optional&gt; !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT If set to true, it will also detect as supported emulated audio APIs (as &quot;WAAPI&quot; using waapisim.js instead of supported natively). Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 224 Returns: Returns an array with the audio APIs supported (from an array if it is given) for the current client, if any. If no audio API is supported, an empty array will be returned. Type array &lt;static&gt; getSupportedAudioFormats( [audioFormats] [, supportLevels] [, dataURI]) → {array} Returns an array of strings with the audio formats that are supported (from an array if it is given) by the current client and ordered by support level. Uses the CB_AudioDetector.isAudioFormatSupported function internally. Parameters: Name Type Argument Default Description audioFormats array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS An array of strings with the audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') that we want to check. supportLevels array &lt;optional&gt; ['probably', 'maybe'] An array with the support level or support levels allowed. Two possible levels: &quot;probably&quot; and &quot;maybe&quot;. The &quot;probably&quot; audio formats are more likely to be supported than the &quot;maybe&quot; ones. dataURI boolean &lt;optional&gt; false Specifies whether we want to check the support for data URI audios or just for normal audio files. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 39 Returns: Returns an array of strings with the audio formats that are supported (from an array if it is given) and ordered by support level. Type array &lt;static&gt; isAPISupported(audioAPI [, allowEmulation]) → {boolean} Tells whether a given audio API is supported or not by the current client. Parameters: Name Type Argument Default Description audioAPI string The audio API that we want to check. All existing ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). allowEmulation boolean &lt;optional&gt; !!CB_Configuration[CB_BASE_NAME].CB_AudioDetector_allowEmulation_DEFAULT If set to true, it will detect as supported also emulated audio APIs (as &quot;WAAPI&quot; using waapisim.js instead of supported natively). Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 275 To Do: Have into account allowEmulation and detect whether emulation is being used if so (for example, detect whether waapisim.js is being used). Returns: Returns whether the given audio API is supported or not. Type boolean &lt;static&gt; isAudioFormatSupported(audioFormat [, dataURI]) → {string} Returns the support level of a given audio format by the current client. Parameters: Name Type Argument Default Description audioFormat string The audio format (it can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') that we want to check. dataURI boolean &lt;optional&gt; false Specifies whether we want to check the support for data URI audios or just for normal audio files. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 107 To Do: Think about using MediaSource.isTypeSupported(). Some web clients does not support data URIs for Audio element so we should take this into account. Take into account that data URIs may not be supported when WAAPI is being emulated. Returns: Returns the support level of the given audio format (it will return &quot;probably&quot;, &quot;maybe&quot; or an empty string which means not supported). The &quot;probably&quot; audio formats are more likely to be supported than the &quot;maybe&quot; ones. Type string &lt;static&gt; isSM2UsingFlash() → {boolean} Tells whether SoundManager 2 is using Adobe Flash (formerly Macromedia Flash) to emulate sound or not. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 340 Returns: Returns whether SoundManager 2 is using Adobe Flash (formerly Macromedia Flash) to emulate sound or not. Type boolean &lt;static&gt; isWAAPIUsingEmulation() → {boolean} Tells whether &quot;WAAPI&quot; (HTML5 Web Audio API) is using emulation (through WAAPISim) or not. Source: CrossBase/audiovisual/audio/CB_AudioDetector.js, line 329 Returns: Returns whether &quot;WAAPI&quot; (HTML5 Web Audio API) is using emulation (through WAAPISim) or not. Type boolean × Search results Close "},"CB_AudioFile.html":{"id":"CB_AudioFile.html","title":"Class: CB_AudioFile","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFile CB_AudioFile Class to manage an audio file. Internally, it uses one audio API object which belongs to the audio API being used (when the audio API is changed, it keeps the old audio API objects just in case they are needed in the future when the audio API is changed again). Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). new CB_AudioFile(filePath [, audioId] [, options] [, audioAPI] [, callbackOk] [, callbackError]) → {CB_AudioFile} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description filePath string The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioId string &lt;optional&gt; 'CB_AudioFile_' + CB_AudioFile._idUnique++ Desired identifier for the audio object (can be a different element depending on the audio API used). If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. options CB_AudioFile.OPTIONS &lt;optional&gt; CB_AudioFile#DEFAULT_OPTIONS Object with the desired options. audioAPI string &lt;optional&gt; CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null) The desired audio API to be used. If not provided, it will try to calculate the best one for the current client by calling the CB_AudioDetector.getPreferredAPI function internally. Audio API support will depend on the current client being used. All possible ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 23 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. Send the CB_AudioFile object itself as a parameter when calling both &quot;callbackOk&quot; and &quot;callbackError&quot;. Think about allowing to define 'useXHR' and 'useCache' options (used by CB_AudioFile_API.WAAPI objects). Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFile object. Type CB_AudioFile Members &lt;static, constant&gt; ABORTED :integer Status value for an audio file which has been aborted. This will happen when the audio file has been destroyed with the CB_AudioFile#destructor method. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 6 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 253 &lt;static, constant&gt; CHECKING :integer Status value for an audio file which is being checked currently. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 3 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 229 &lt;static, constant&gt; FAILED :integer Status value for an audio file which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 5 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 245 &lt;static, constant&gt; LOADED :integer Status value for an audio file which has been loaded. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 4 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 237 &lt;static, constant&gt; LOADING :integer Status value for an audio file which is loading. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 1 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 213 &lt;static, constant&gt; UNCHECKED :integer Status value for an audio file which has been not checked yet. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 2 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 221 &lt;static, constant&gt; UNLOADED :integer Status value for an audio file which is unloaded. Can be used to compare the value returned by the CB_AudioFile#getStatus method. Recommended for internal usage only. Type: integer Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 205 &lt;readonly&gt; audioAPI :string Defines the Audio API used for this audio file. Audio API support will depend on the current client being used. All possible ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 90 audioFileObject :CB_AudioFile_API.WAAPI|CB_AudioFile_API.SM2|CB_AudioFile_API.ACMP|CB_AudioFile_API.AAPI|Object It will store the current audio file object for the current audio API. The CB_AudioFile#load method will set the value of this property only after the audio file object (stored in its value) is loaded properly. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). When no audio API object is being set, it will contain a fake object with same methods and properties (defined in CB_AudioFile._audioFileObject_prototype). Recommended for internal usage only. Type: CB_AudioFile_API.WAAPI | CB_AudioFile_API.SM2 | CB_AudioFile_API.ACMP | CB_AudioFile_API.AAPI | Object Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 161 audioFileObjectLast :CB_AudioFile_API.WAAPI|CB_AudioFile_API.SM2|CB_AudioFile_API.ACMP|CB_AudioFile_API.AAPI|Object Stores the last audio file object created or reused, for the current API being used. The CB_AudioFile#load method will set the value of this property before knowing whether the audio file object (stored in its value) will be loaded properly or not. Used by the CB_AudioFile#load and CB_AudioFile#getProgress methods. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). When no audio API object is being set, it will contain a fake object with same methods and properties (defined in CB_AudioFile._audioFileObject_prototype). Recommended for internal usage only. Type: CB_AudioFile_API.WAAPI | CB_AudioFile_API.SM2 | CB_AudioFile_API.ACMP | CB_AudioFile_API.AAPI | Object Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 169 audioFileObjects :Object It will store the created audio file objects for the different audio APIs (for optimization purposes, to avoid creating more than one per API). Being each index the name of the audio API (&quot;WAAPI&quot;, &quot;AAPI&quot;, &quot;SM2&quot; or &quot;ACMP&quot;), their value will be an object which can be CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Recommended for internal usage only. Type: Object Default Value: {} Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 152 &lt;constant&gt; DEFAULT_OPTIONS :CB_AudioFile.OPTIONS Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: CB_AudioFile.OPTIONS Default Value: { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile.prototype.DEFAULT_VOLUME } Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 43 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 35 &lt;readonly&gt; filePath :string Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 81 &lt;readonly&gt; id :string Stores the identifier for the audio file. Type: string Default Value: 'CB_AudioFile_' + CB_AudioFile._idUnique++ Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 72 &lt;readonly&gt; loop :boolean Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the CB_AudioFile#play method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). Type: boolean Default Value: CB_AudioFile.prototype.DEFAULT_OPTIONS.loop Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 54 &lt;readonly&gt; volume :number Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile.prototype.DEFAULT_OPTIONS.volume Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 63 Methods checkPlaying( [callbackOk] [, callbackError] [, ignoreStatus] [, ignoreQueue] [, useCache]) → {boolean} Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the CB_AudioFile#play method the first time. Internally, uses the &quot;checkPlaying&quot; method of the used audio API object. The checking action will only be performed if the value of the &quot;status&quot; property of the used audio API object belongs to the CB_AudioFile.UNCHECKED or to the CB_AudioFile.CHECKING value. After checking, if the audio can be played, the &quot;status&quot; property of the used audio API object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the &quot;status&quot; property of the used audio API object will get the value of {CB_AudioFile.FAILED}. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the CB_AudioFile object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object itself. ignoreStatus boolean &lt;optional&gt; false If set to false and the audio status is neither &quot;UNCHECKED&quot; nor &quot;CHECKING&quot;, it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. ignoreQueue boolean &lt;optional&gt; false If set to false and there is already the maximum number of audio files being checked (defined internally, depending on the audio API), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. Some audio APIs will ignore this parameter as they do not use checking queues. useCache boolean &lt;optional&gt; false If set to true (not recommended) and the same audio file was checked previously, it will not perform the checking process again and it will do the same as the previous call. Some audio APIs will ignore this parameter as they do not use cache. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 575 Returns: Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. Type boolean destructor( [stopSound] [, keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) Destroys the audio file object and frees memory. Sets its current status to ABORTED (CB_AudioFile.ABORTED value). Parameters: Name Type Argument Default Description stopSound boolean &lt;optional&gt; false If set to true, it will also call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the CB_AudioFile#audioFileObject property). This method has the same parameters as the CB_AudioFile#stop method. keepStoppedUnaltered boolean &lt;optional&gt; false Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the CB_AudioFile#audioFileObject property). This method has the same parameters as the CB_AudioFile#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. avoidOnStop boolean &lt;optional&gt; false Used internally as the &quot;avoidOnStop&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the CB_AudioFile#audioFileObject property). This method has the same parameters as the CB_AudioFile#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. forceOnStop boolean &lt;optional&gt; false Used internally as the &quot;forceOnStop&quot; parameter to call the &quot;stop&quot; method of the internal audio file object for the current API (stored in the CB_AudioFile#audioFileObject property). This method has the same parameters as the CB_AudioFile#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 299 getCurrentTime() → {number} Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Internally, uses the &quot;getCurrentTime&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 788 Returns: Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. Type number getDuration() → {number} Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Internally, uses the &quot;getDuration&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 594 Returns: Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Type number getProgress() → {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Internally, uses the &quot;getProgress&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 944 Returns: Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number getStartAt( [numeric]) → {number|*} Tells the last &quot;startAt&quot; parameter value used by the CB_AudioFile#play or the CB_AudioFile#resume method (or used by the equivalents methods of the same name from the used audio API object). Internally, uses the &quot;lastStartAt&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description numeric boolean &lt;optional&gt; false If set to true, it will sanitize the returning value by returning zero instead of undefined, null or any other non-numeric value. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 915 Returns: Returns the last &quot;startAt&quot; value used by the CB_AudioFile#play or the CB_AudioFile#resume method (or used by the equivalents methods of the same name from the used audio API object). If we want it to be numeric always, the &quot;numeric&quot; parameter should be set to true. Type number | * getStatus( [realStatus]) → {number} Gets the current status of the audio file. Parameters: Name Type Argument Default Description realStatus boolean &lt;optional&gt; false If set to true, it will return the &quot;status&quot; property of the used audio API object instead of the &quot;status&quot; property of the current CB_AudioFile object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 800 Returns: Returns the current status of the audio file. It is a number, which should match the value of the CB_AudioFile.UNLOADED (still unloaded), CB_AudioFile.LOADING (loading), CB_AudioFile.UNCHECKED (not checked by calling the &quot;checkPlaying&quot; method yet), CB_AudioFile.CHECKING (being checked by the &quot;checkPlaying&quot; method), CB_AudioFile.LOADED (loaded), CB_AudioFile.FAILED (failed loading or failed to play or by any other reason) or CB_AudioFile.ABORTED (aborted because it was destroyed with the &quot;destructor&quot; method) property. Type number getStatusString( [realStatus]) → {string} Gets the current status of the audio file, as a string. Parameters: Name Type Argument Default Description realStatus boolean &lt;optional&gt; false If set to true, it will have in mind the &quot;status&quot; property of the used audio API object instead of the &quot;status&quot; property of the current CB_AudioFile object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 813 Returns: Returns the current status of the audio file, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the &quot;status&quot; property not recognized as any possible status). Type string getStopAt( [numeric]) → {number|*} Tells the last &quot;stopAt&quot; parameter value used by the CB_AudioFile#play or the CB_AudioFile#resume method (or used by the equivalents methods of the same name from the used audio API object). Internally, uses the &quot;lastStopAt&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description numeric boolean &lt;optional&gt; false If set to true, it will sanitize the returning value by returning zero instead of undefined, null or any other non-numeric value. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 930 Returns: Returns the last &quot;stopAt&quot; value used by the CB_AudioFile#play or the CB_AudioFile#resume method (or used by the equivalents methods of the same name from the used audio API object). If we want it to be numeric always, the &quot;numeric&quot; parameter should be set to true. Type number | * getVolume() → {number} Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Internally, uses the &quot;volume&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 732 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number getVolumeBeforeMute() → {number} Returns the volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that was set before the audio was muted. Internally, uses the &quot;volumeBeforeMute&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 721 Returns: Returns the volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that was set before the audio was muted. If the audio was not muted before, it will contain the default volume used in the &quot;volume&quot; property of the used audio API object. Type number isPaused() → {boolean} Tells whether the audio is paused or not. Internally, uses the &quot;paused&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 838 Returns: Returns whether the audio is paused or not. Type boolean isPlaying() → {boolean} Tells whether the audio file is playing or not. Internally, uses the CB_AudioFile#isStopped and CB_AudioFile#isPaused methods. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 827 Returns: Returns whether the audio file is playing or not. Type boolean isStopped() → {boolean} Tells whether the audio file is stopped or not. Internally, uses the &quot;stopped&quot; property of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 849 Returns: Returns whether the audio file is stopped or not. Type boolean load( [filePath] [, audioAPI] [, autoPlay] [, callbackOk] [, callbackError] [, ignoreOldValues] [, forceReload]) → {CB_AudioFile_API.WAAPI|CB_AudioFile_API.SM2|CB_AudioFile_API.ACMP|CB_AudioFile_API.AAPI|null} Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. This method will be called automatically if the &quot;autoLoad&quot; option was set to true when calling the CB_AudioFile#setAudioAPI method. The audio API used will be stored in the CB_AudioFile#audioAPI property.When this method is called, if the &quot;status&quot; property of the audio API object already has the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the CB_AudioFile.LOADING constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the CB_AudioFile.UNCHECKED constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the &quot;checkPlaying&quot; method of the audio API object after it). After it and only if the &quot;autoPlay&quot; is set to true, as the &quot;checkPlaying&quot; method of the audio API object will be called internally, it will have the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant) and finally the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) if all goes well.Although it is not recommended to do so, if this method is called when the audio API object has the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will call the &quot;checkPlaying&quot; method of the audio API object internally.Internally, it can use the CB_AudioFile#audioFileObjects property as a cache. Parameters: Name Type Argument Default Description filePath string &lt;optional&gt; CB_AudioFile#filePath The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioAPI string &lt;optional&gt; CB_AudioFile#audioAPI The desired audio API to be used. If not provided, it will try to use the previously-set one (in the CB_AudioFile#audioAPI property). All possible ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). autoPlay string &lt;optional&gt; false If set to true, it will start playing the audio automatically (by calling the CB_AudioFile#play method internally) unless the &quot;ignoreOldValues&quot; parameter is set to false and the previous audio was playing or paused. If set to true and the &quot;status&quot; property of the audio API object reaches to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will also call internally the &quot;checkPlaying&quot; method of the audio API object before anything. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object itself. ignoreOldValues string &lt;optional&gt; false If set to true, it will ignore the old values of the previous used audio API object. This means that it will neither continue playing if it was playing (changing the audio API on-the-fly) nor keep the paused status if it was paused nor copy its &quot;loop&quot; property to the new audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). forceReload string &lt;optional&gt; false Used internally as the &quot;forceReload&quot; parameter when calling the &quot;load&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 375 To Do: Think about using the &quot;forceReload&quot; just after the &quot;callbackError&quot; to match the parameter order of the &quot;load&quot; method of all the audio API objects. Returns: Returns the used audio API object or null otherwise. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Type CB_AudioFile_API.WAAPI | CB_AudioFile_API.SM2 | CB_AudioFile_API.ACMP | CB_AudioFile_API.AAPI | null mute( [onMute]) → {number} Mutes the audio file. Internally, uses the &quot;mute&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Description onMute function &lt;optional&gt; Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onMute&quot; parameter (with a wrapper function) to call the &quot;mute&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 761 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. Type number onStop(callbackFunction [, keepOldFunction]) → {boolean} Sets a function to execute when the audio file stops playing or removes it. Internally, uses the &quot;onStop&quot; method of the used audio API object (wrapping the given function). Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the CB_AudioFile object. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 877 Returns: Returns whether the event has been set or not (removed). Type boolean pause( [onPause] [, keepPausedUnaltered]) → {boolean} Pauses the audio when it is being played. Internally, uses the &quot;pause&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onPause&quot; parameter (with a wrapper function) to call the &quot;pause&quot; method of the audio API object. keepPausedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the &quot;paused&quot; property of the audio API object will not be set to true and it will remain with its current value. Used internally as the &quot;keepPausedUnaltered&quot; parameter to call the &quot;pause&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 695 Returns: Returns the returning value of the &quot;pause&quot; method of the audio API object. It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Type boolean play( [startAt] [, stopAt] [, loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError] [, isResume]) → {boolean|integer} Plays the audio. Internally, uses the &quot;play&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the &quot;play&quot; method of the audio API object. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the &quot;play&quot; method of the audio API object. loop boolean &lt;optional&gt; CB_AudioFile#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile#onStop method) will not be called. Used internally as the &quot;loop&quot; parameter to call the &quot;play&quot; method of the audio API object. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the &quot;play&quot; method of the audio API object. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the &quot;play&quot; method of the audio API object. onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. Used internally as the &quot;onPlayStart&quot; parameter to call the &quot;play&quot; method of the audio API object. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onLoadError&quot; parameter to call the &quot;play&quot; method of the audio API object. isResume boolean &lt;optional&gt; false If set to true (not recommended) and it is a looping audio, the next loop will use the value of the &quot;lastStartAt&quot; property of the audio API object as the &quot;startAt&quot; parameter when it calls the &quot;play&quot; method again automatically (internally). Recommended for internal usage only. Used internally as the &quot;isResume&quot; parameter to call the &quot;play&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 613 Returns: Returns the returning value of the &quot;play&quot; method of the audio API object. It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Type boolean | integer resume( [loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError]) → {boolean|integer} Resumes the audio (after being paused), starting from the same point it was paused previously. Internally, uses the &quot;resume&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile#onStop method) will not be called. Used internally as the &quot;loop&quot; parameter to call the &quot;resume&quot; method of the audio API object. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the &quot;resume&quot; method of the audio API object. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method of the used audio API object will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the &quot;resume&quot; method of the audio API object. onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. Used internally as the &quot;onPlayStart&quot; parameter to call the &quot;resume&quot; method of the audio API object. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onLoadError&quot; parameter to call the &quot;resume&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 656 Returns: Returns the returning value of the &quot;resume&quot; method of the audio API object. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Type boolean | integer setAudioAPI( [audioAPI] [, autoLoad] [, autoPlay] [, callbackOk] [, callbackError] [, ignoreOldValues] [, filePath] [, forceReload]) → {string} Sets the desired audio API. This method will also be called automatically by the constructor. If the &quot;autoLoad&quot; parameter is set to true, it will call the CB_AudioFile#load method internally, changing the audio API on-the-fly, and the audio will try to continue playing if it was playing at the moment of calling this method. Check the CB_AudioFile#load method documentation for more information. If the &quot;autoLoad&quot; parameter is set to true, it is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. The audio API used will be stored in the CB_AudioFile#audioAPI property. Parameters: Name Type Argument Default Description audioAPI string &lt;optional&gt; CB_AudioDetector.getPreferredAPI(undefined, false, null) || CB_AudioDetector.getPreferredAPI(undefined, true, null) The desired audio API to be used. If not provided, it will try to calculate the best one for the current client by calling the CB_AudioDetector.getPreferredAPI function internally. Audio API support will depend on the current client being used. All possible ones are defined in CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS. For example: &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Used internally as the &quot;audioAPI&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). autoLoad string &lt;optional&gt; true If set to false, it will not call the CB_AudioFile#load method internally and will only set the CB_AudioFile#audioAPI property (not recommended). autoPlay string &lt;optional&gt; false Used internally as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile object itself. Used internally as the &quot;callbackOk&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile object itself. Used internally as the &quot;callbackError&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). ignoreOldValues string &lt;optional&gt; false Used internally as the &quot;ignoreOldValues&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). filePath string &lt;optional&gt; CB_AudioFile#filePath Used internally as the &quot;filePath&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). forceReload string &lt;optional&gt; false Used internally as the &quot;forceReload&quot; parameter when calling the CB_AudioFile#load method internally (only when the &quot;autoLoad&quot; parameter is set to true). Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 321 To Do: Think about using the &quot;forceReload&quot; just after the &quot;callbackError&quot; to match the parameter order of the &quot;load&quot; method of all the audio API objects. Returns: Returns the desired audio API that has been tried to set, in upper case (successfully or not). Type string setVolume( [volume] [, forceSetVolumeProperty] [, onSetVolume]) → {number} Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Internally, uses the &quot;setVolume&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Used internally as the &quot;volume&quot; parameter to call the &quot;setVolume&quot; method of the audio API object. forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the &quot;volume&quot; property of the used audio API object even when the volume failed to be changed. Used internally as the &quot;forceSetVolumeProperty&quot; parameter to call the &quot;setVolume&quot; method of the audio API object. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onSetVolume&quot; parameter (with a wrapper function) to call the &quot;setVolume&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 747 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number stop( [keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) → {boolean} Stops the audio. Internally, uses the &quot;stop&quot; method of the used audio API object. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Default Description keepStoppedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the &quot;stopped&quot; property of the audio API object will not be set to true and it will remain with its current value. Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the &quot;stop&quot; method of the audio API object. avoidOnStop boolean &lt;optional&gt; false If set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile#onStop method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. Used internally as the &quot;avoidOnStop&quot; parameter to call the &quot;stop&quot; method of the audio API object. forceOnStop boolean &lt;optional&gt; false If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile#onStop method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Used internally as the &quot;forceOnStop&quot; parameter to call the &quot;stop&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 710 Returns: Returns the returning value of the &quot;stop&quot; method of the audio API object. It returns false if the stopping action cannot be performed at all (this could happen with the internal audio API has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Type boolean unmute( [onUnmute]) → {number} Restores audio after muting it (unmutes it). Internally, uses the &quot;unmute&quot; method of the used audio API object which uses its own &quot;volumeBeforeMute&quot; property. Possible internal audio API objects are CB_AudioFile_API.WAAPI object for &quot;WAAPI&quot; (HTML5 Web Audio API), CB_AudioFile_API.SM2 object for &quot;SM2&quot; (SoundManager 2), CB_AudioFile_API.ACMP object for &quot;ACMP&quot; (Apache Cordova Media Plugin) or CB_AudioFile_API.AAPI object for &quot;AAPI&quot; (HTML5 Audio API). Parameters: Name Type Argument Description onUnmute function &lt;optional&gt; Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onUnmute&quot; parameter (with a wrapper function) to call the &quot;unmute&quot; method of the audio API object. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 775 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number Type Definitions OPTIONS Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: Object Properties: Name Type Argument Default Description autoLoad boolean &lt;optional&gt; CB_AudioFile#DEFAULT_OPTIONS.autoLoad Value which will be used as the &quot;autoLoad&quot; parameter when calling the CB_AudioFile#setAudioAPI method internally (when the constructor is called). autoPlay boolean &lt;optional&gt; CB_AudioFile#DEFAULT_OPTIONS.autoPlay Value which will be used as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile#setAudioAPI method internally (when the constructor is called). loop boolean &lt;optional&gt; CB_AudioFile#DEFAULT_OPTIONS.loop Value that will be used for the CB_AudioFile#loop property. volume number &lt;optional&gt; CB_AudioFile#DEFAULT_OPTIONS.volume The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that will be used for the CB_AudioFile#volume property. Source: CrossBase/audiovisual/audio/CB_AudioFile.js, line 185 × Search results Close "},"CB_AudioFile_API.AAPI.html":{"id":"CB_AudioFile_API.AAPI.html","title":"Class: CB_AudioFile_API.AAPI","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFile_API.AAPI CB_AudioFile_API.AAPI Class to manage an audio file using &quot;AAPI&quot; (HTML5 Audio API). Used by the CB_AudioFile class internally and it shares most of its properties and methods. Recommended for internal usage only. new CB_AudioFile_API.AAPI(filePath [, audioId] [, options] [, callbackOk] [, callbackError]) → {CB_AudioFile_API.AAPI} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description filePath string The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioId string &lt;optional&gt; 'CB_AUDIOFILE_AAPI_' + CB_AudioFile_API.AAPI._idUnique++ Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. options CB_AudioFile_API.AAPI.OPTIONS &lt;optional&gt; CB_AudioFile_API.AAPI#DEFAULT_OPTIONS Object with the desired options. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 16 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFile_API.AAPI object. Type CB_AudioFile_API.AAPI Members &lt;readonly&gt; audioObject :HTMLAudioElement Stores the HTMLAudioElement object of the audio, used by the &quot;AAPI&quot; (HTML5 Audio API). Type: HTMLAudioElement Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 161 &lt;constant&gt; DEFAULT_OPTIONS :CB_AudioFile_API.AAPI.OPTIONS Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: CB_AudioFile_API.AAPI.OPTIONS Default Value: { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API.AAPI.prototype.DEFAULT_VOLUME } Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 44 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 36 &lt;readonly&gt; filePath :string Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 98 &lt;readonly&gt; id :string Stores the identifier for the audio file. Type: string Default Value: 'CB_AUDIOFILE_AAPI_' + CB_AudioFile_API.AAPI._idUnique++ Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 89 &lt;readonly&gt; lastStartAt :number Stores the last &quot;startAt&quot; parameter value used by the CB_AudioFile_API.AAPI#play or the CB_AudioFile_API.AAPI#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 143 &lt;readonly&gt; lastStopAt :number Stores the last &quot;stopAt&quot; parameter value used by the CB_AudioFile_API.AAPI#play or the CB_AudioFile_API.AAPI#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 152 &lt;readonly&gt; loop :boolean Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the CB_AudioFile_API.AAPI#play method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). Type: boolean Default Value: CB_AudioFile_API.AAPI.prototype.DEFAULT_OPTIONS.loop Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 62 &lt;readonly&gt; onStopFunction :function Function to call when the audio stops. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 134 &lt;readonly&gt; paused :boolean Tells whether the audio is paused or not. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 107 &lt;readonly&gt; pauseTime :number Stores the time (in milliseconds) when the audio has been paused. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 116 &lt;readonly&gt; status :integer Tells whether the file is unloaded (CB_AudioFile.UNLOADED), loading (CB_AudioFile.LOADING), unchecked (CB_AudioFile.UNCHECKED), checking (CB_AudioFile.CHECKING), loaded (CB_AudioFile.LOADED), failed (CB_AudioFile.FAILED) or aborted (CB_AudioFile.ABORTED). Type: integer Default Value: CB_AudioFile.UNLOADED Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 53 &lt;readonly&gt; stopped :boolean Tells whether the audio is stopped or not. Type: boolean Default Value: true Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 125 &lt;readonly&gt; volume :number Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.AAPI.prototype.DEFAULT_OPTIONS.volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 71 &lt;readonly&gt; volumeBeforeMute :number Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.AAPI#volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 80 Methods checkPlaying( [callbackOk] [, callbackError] [, ignoreStatus] [, ignoreQueue] [, useCache]) → {boolean} Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the CB_AudioFile_API.AAPI#play method the first time. The checking action will only be performed if the value of the CB_AudioFile_API.AAPI#status property belongs to the CB_AudioFile.UNCHECKED or to the CB_AudioFile.CHECKING value. After checking, if the audio can be played, the CB_AudioFile_API.AAPI#status of the object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the CB_AudioFile_API.AAPI#status property will get the value of {CB_AudioFile.FAILED}. Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. ignoreStatus boolean &lt;optional&gt; false If set to false and the CB_AudioFile_API.AAPI#status property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant) nor to the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. ignoreQueue boolean &lt;optional&gt; false If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. useCache boolean &lt;optional&gt; false This parameter will be ignored in this audio API. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 516 Returns: Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. Type boolean destructor( [stopSound] [, keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) Destroys the audio file object and frees memory. Sets its current CB_AudioFile_API.AAPI#status property to ABORTED (CB_AudioFile.ABORTED value). Parameters: Name Type Argument Default Description stopSound boolean &lt;optional&gt; false If set to true, it will also call the CB_AudioFile_API.AAPI#stop method. keepStoppedUnaltered boolean &lt;optional&gt; false Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the CB_AudioFile_API.AAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. avoidOnStop boolean &lt;optional&gt; false Used internally as the &quot;avoidOnStop&quot; parameter to call the CB_AudioFile_API.AAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. forceOnStop boolean &lt;optional&gt; false Used internally as the &quot;forceOnStop&quot; parameter to call the CB_AudioFile_API.AAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 254 getCurrentTime() → {number} Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1154 Returns: Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. Type number getDuration() → {number} Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 712 Returns: Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Type number getProgress() → {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1213 Returns: Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number load( [filePath] [, autoPlay] [, callbackOk] [, callbackError] [, forceReload]) → {CB_AudioFile_API.AAPI|null} Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter.When this method is called, if the CB_AudioFile_API.AAPI#status property already has the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the CB_AudioFile.LOADING constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the CB_AudioFile.UNCHECKED constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the CB_AudioFile_API.AAPI#checkPlaying method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the CB_AudioFile_API.AAPI#checkPlaying method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant) and finally the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) if all goes well. Parameters: Name Type Argument Default Description filePath string &lt;optional&gt; CB_AudioFile_API.AAPI#filePath The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. autoPlay string &lt;optional&gt; false If set to true, it will start playing the audio automatically (by calling the CB_AudioFile_API.AAPI#play method internally). If set to true and the CB_AudioFile_API.AAPI#status property reaches to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will also call internally the CB_AudioFile_API.AAPI#checkPlaying method. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.AAPI object itself. forceReload boolean &lt;optional&gt; false If set to false, the &quot;filePath&quot; has not been changed from the previously used and the CB_AudioFile_API.AAPI#status property belongs to the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 293 Returns: Returns the audio API object (if it was possible to create) or null otherwise. Type CB_AudioFile_API.AAPI | null mute( [onMute]) → {number} Mutes the audio file. Parameters: Name Type Argument Description onMute function &lt;optional&gt; Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.AAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1118 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. Type number onStop(callbackFunction [, keepOldFunction]) → {boolean} Sets a function to execute when the audio file stops playing or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the CB_AudioFile_API.AAPI object. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1176 Returns: Returns whether the event has been set or not (removed). Type boolean pause( [onPause] [, keepPausedUnaltered]) → {boolean} Pauses the audio when it is being played. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile_API.AAPI object. keepPausedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.AAPI#paused property will not be set to true and it will remain with its current value. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1024 Returns: It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Type boolean play( [startAt] [, stopAt] [, loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError] [, isResume] [, isLooping] [, startPlayingTime]) → {boolean|integer} Plays the audio. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.AAPI#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the CB_AudioFile_API.AAPI#lastStartAt property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the CB_AudioFile_API.AAPI#lastStartAt value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. stopAt number &lt;optional&gt; CB_AudioFile_API.AAPI#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the CB_AudioFile_API.AAPI#getDuration method (which should belong to the total duration of the audio, if it was calculated correctly). loop boolean &lt;optional&gt; CB_AudioFile_API.AAPI#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.AAPI#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.AAPI#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.AAPI object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.AAPI object. isResume boolean &lt;optional&gt; false If set to true (not recommended) and it is a looping audio, the next loop will use the value of the CB_AudioFile_API.AAPI#lastStartAt property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. isLooping boolean &lt;optional&gt; false Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. startPlayingTime integer &lt;optional&gt; Contains the time when the audio should start playing. Recommended for internal usage only. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 788 Returns: It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer resume( [loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError]) → {boolean|integer} Resumes the audio (after being paused), starting from the same point it was paused previously. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile_API.AAPI#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.AAPI#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the CB_AudioFile_API.AAPI#stop method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.AAPI#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.AAPI object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.AAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 997 Returns: Returns the returning value of the CB_AudioFile_API.AAPI#play method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer setVolume( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, saveForUnmute]) → {number} Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the CB_AudioFile_API.AAPI#volume property even when the volume failed to be changed. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.AAPI object. saveForUnmute boolean &lt;optional&gt; false If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the CB_AudioFile_API.AAPI#unmute method. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1080 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number stop( [keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) → {boolean} Stops the audio. Parameters: Name Type Argument Default Description keepStoppedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.AAPI#stopped property will not be set to true and it will remain with its current value. avoidOnStop boolean &lt;optional&gt; false If set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.AAPI#onStop method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. forceOnStop boolean &lt;optional&gt; false If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.AAPI#onStop method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1050 Returns: It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Type boolean unmute( [onUnmute]) → {number} Restores audio after muting it (unmutes it). Parameters: Name Type Argument Description onUnmute function &lt;optional&gt; Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.AAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 1136 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number Type Definitions OPTIONS Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: Object Properties: Name Type Argument Default Description autoLoad boolean &lt;optional&gt; CB_AudioFile_API.AAPI#DEFAULT_OPTIONS.autoLoad If set to false, it will not call the CB_AudioFile_API.AAPI#load method internally when the constructor is called (not recommended). autoPlay boolean &lt;optional&gt; CB_AudioFile_API.AAPI#DEFAULT_OPTIONS.autoPlay Value which will be used as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile_API.AAPI#load method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). loop boolean &lt;optional&gt; CB_AudioFile_API.AAPI#DEFAULT_OPTIONS.loop Value that will be used for the CB_AudioFile_API.AAPI#loop property. volume number &lt;optional&gt; CB_AudioFile_API.AAPI#DEFAULT_OPTIONS.volume The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that will be used for the CB_AudioFile_API.AAPI#volume property. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_AAPI.js, line 193 × Search results Close "},"CB_AudioFile_API.ACMP.html":{"id":"CB_AudioFile_API.ACMP.html","title":"Class: CB_AudioFile_API.ACMP","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFile_API.ACMP CB_AudioFile_API.ACMP Class to manage an audio file using &quot;ACMP&quot; (Apache Cordova Media Plugin). Used by the CB_AudioFile class internally and it shares most of its properties and methods. Recommended for internal usage only. new CB_AudioFile_API.ACMP(filePath [, audioId] [, options] [, callbackOk] [, callbackError]) → {CB_AudioFile_API.ACMP} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description filePath string The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioId string &lt;optional&gt; 'CB_AUDIOFILE_ACMP_' + CB_AudioFile_API.ACMP._idUnique++ Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. options CB_AudioFile_API.ACMP.OPTIONS &lt;optional&gt; CB_AudioFile_API.ACMP#DEFAULT_OPTIONS Object with the desired options. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 9 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFile_API.ACMP object. Type CB_AudioFile_API.ACMP Members &lt;constant&gt; DEFAULT_OPTIONS :CB_AudioFile_API.ACMP.OPTIONS Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: CB_AudioFile_API.ACMP.OPTIONS Default Value: { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API.ACMP.prototype.DEFAULT_VOLUME } Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 37 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 29 &lt;readonly&gt; filePath :string Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 91 &lt;readonly&gt; id :string Stores the identifier for the audio file. Type: string Default Value: 'CB_AUDIOFILE_ACMP_' + CB_AudioFile_API.ACMP._idUnique++ Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 82 &lt;readonly&gt; lastStartAt :number Stores the last &quot;startAt&quot; parameter value used by the CB_AudioFile_API.ACMP#play or the CB_AudioFile_API.ACMP#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 136 &lt;readonly&gt; lastStopAt :number Stores the last &quot;stopAt&quot; parameter value used by the CB_AudioFile_API.ACMP#play or the CB_AudioFile_API.ACMP#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 145 &lt;readonly&gt; loop :boolean Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the CB_AudioFile_API.ACMP#play method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). Type: boolean Default Value: CB_AudioFile_API.ACMP.prototype.DEFAULT_OPTIONS.loop Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 55 &lt;readonly&gt; mediaObject :Object Stores the Media object of the audio, used by the &quot;ACMP&quot; (Apache Cordova Media Plugin). Type: Object Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 154 &lt;readonly&gt; onStopFunction :function Function to call when the audio stops. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 127 &lt;readonly&gt; paused :boolean Tells whether the audio is paused or not. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 100 &lt;readonly&gt; pauseTime :number Stores the time (in milliseconds) when the audio has been paused. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 109 &lt;readonly&gt; position :number Stores the current position (in seconds) where the audio is playing (returned by the getCurrentPosition method), used by the &quot;ACMP&quot; (Apache Cordova Media Plugin). Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 163 &lt;readonly&gt; status :integer Tells whether the file is unloaded (CB_AudioFile.UNLOADED), loading (CB_AudioFile.LOADING), unchecked (CB_AudioFile.UNCHECKED), checking (CB_AudioFile.CHECKING), loaded (CB_AudioFile.LOADED), failed (CB_AudioFile.FAILED) or aborted (CB_AudioFile.ABORTED). Type: integer Default Value: CB_AudioFile.UNLOADED Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 46 &lt;readonly&gt; stopped :boolean Tells whether the audio is stopped or not. Type: boolean Default Value: true Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 118 &lt;readonly&gt; volume :number Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.ACMP.prototype.DEFAULT_OPTIONS.volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 64 &lt;readonly&gt; volumeBeforeMute :number Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.ACMP#volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 73 Methods checkPlaying( [callbackOk] [, callbackError] [, ignoreStatus] [, ignoreQueue] [, useCache] [, isSwapObject]) → {boolean} Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the CB_AudioFile_API.ACMP#play method the first time. The checking action will only be performed if the value of the CB_AudioFile_API.ACMP#status property belongs to the CB_AudioFile.UNCHECKED or to the CB_AudioFile.CHECKING value. After checking, if the audio can be played, the CB_AudioFile_API.ACMP#status of the object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the CB_AudioFile_API.ACMP#status property will get the value of {CB_AudioFile.FAILED}. Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. ignoreStatus boolean &lt;optional&gt; false If set to false and the CB_AudioFile_API.ACMP#status property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant) nor to the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. ignoreQueue boolean &lt;optional&gt; false This parameter will be ignored in this audio API. useCache boolean &lt;optional&gt; false This parameter will be ignored in this audio API. isSwapObject boolean &lt;optional&gt; false Defines whether the Media object to check is a swap object or the normal one (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 520 Returns: Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. Type boolean destructor( [stopSound] [, keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) Destroys the audio file object and frees memory. Sets its current CB_AudioFile_API.ACMP#status property to ABORTED (CB_AudioFile.ABORTED value). Parameters: Name Type Argument Default Description stopSound boolean &lt;optional&gt; false If set to true, it will also call the CB_AudioFile_API.ACMP#stop method. keepStoppedUnaltered boolean &lt;optional&gt; false Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the CB_AudioFile_API.ACMP#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. avoidOnStop boolean &lt;optional&gt; false Used internally as the &quot;avoidOnStop&quot; parameter to call the CB_AudioFile_API.ACMP#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. forceOnStop boolean &lt;optional&gt; false Used internally as the &quot;forceOnStop&quot; parameter to call the CB_AudioFile_API.ACMP#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 254 getCurrentTime() → {number} Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1065 Returns: Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. Type number getDuration( [mediaObject]) → {number} Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Parameters: Name Type Argument Default Description mediaObject Object &lt;optional&gt; CB_AudioFile_API.ACMP#mediaObject Media object whose audio duration we want to check. Used internally to check either normal or swap Media object (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 679 Returns: Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Type number getProgress() → {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1125 Returns: Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number load( [filePath] [, autoPlay] [, callbackOk] [, callbackError] [, forceReload]) → {CB_AudioFile_API.ACMP|null} Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter.When this method is called, if the CB_AudioFile_API.ACMP#status property already has the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the CB_AudioFile.LOADING constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the CB_AudioFile.UNCHECKED constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the CB_AudioFile_API.ACMP#checkPlaying method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the CB_AudioFile_API.ACMP#checkPlaying method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant) and finally the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) if all goes well. Parameters: Name Type Argument Default Description filePath string &lt;optional&gt; CB_AudioFile_API.ACMP#filePath The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. autoPlay string &lt;optional&gt; false If set to true, it will start playing the audio automatically (by calling the CB_AudioFile_API.ACMP#play method internally). If set to true and the CB_AudioFile_API.ACMP#status property reaches to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will also call internally the CB_AudioFile_API.ACMP#checkPlaying method. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.ACMP object itself. forceReload boolean &lt;optional&gt; false If set to false, the &quot;filePath&quot; has not been changed from the previously used and the CB_AudioFile_API.ACMP#status property belongs to the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 287 Returns: Returns the audio API object (if it was possible to create) or null otherwise. Type CB_AudioFile_API.ACMP | null mute( [onMute]) → {number} Mutes the audio file. Parameters: Name Type Argument Description onMute function &lt;optional&gt; Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.ACMP object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1029 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. Type number onStop(callbackFunction [, keepOldFunction]) → {boolean} Sets a function to execute when the audio file stops playing or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the CB_AudioFile_API.ACMP object. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1088 Returns: Returns whether the event has been set or not (removed). Type boolean pause( [onPause] [, keepPausedUnaltered]) → {boolean} Pauses the audio when it is being played. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile_API.ACMP object. keepPausedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.ACMP#paused property will not be set to true and it will remain with its current value. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 930 Returns: It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Type boolean play( [startAt] [, stopAt] [, loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError] [, isResume] [, isLooping] [, startPlayingTime]) → {boolean|integer} Plays the audio. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.ACMP#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the CB_AudioFile_API.ACMP#lastStartAt property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the CB_AudioFile_API.ACMP#lastStartAt value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. stopAt number &lt;optional&gt; CB_AudioFile_API.ACMP#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the CB_AudioFile_API.ACMP#getDuration method (which should belong to the total duration of the audio, if it was calculated correctly). loop boolean &lt;optional&gt; CB_AudioFile_API.ACMP#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.ACMP#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.ACMP#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.ACMP object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.ACMP object. isResume boolean &lt;optional&gt; false If set to true (not recommended) and it is a looping audio, the next loop will use the value of the CB_AudioFile_API.ACMP#lastStartAt property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. isLooping boolean &lt;optional&gt; false Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. startPlayingTime integer &lt;optional&gt; Contains the time when the audio should start playing. Recommended for internal usage only. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 702 Returns: It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer resume( [loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError]) → {boolean|integer} Resumes the audio (after being paused), starting from the same point it was paused previously. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile_API.ACMP#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.ACMP#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the CB_AudioFile_API.ACMP#stop method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.ACMP#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.ACMP object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.ACMP object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 901 Returns: Returns the returning value of the CB_AudioFile_API.ACMP#play method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer setVolume( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, saveForUnmute] [, mediaObject]) → {number} Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the CB_AudioFile_API.ACMP#volume property even when the volume failed to be changed. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.ACMP object. saveForUnmute boolean &lt;optional&gt; false If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the CB_AudioFile_API.ACMP#unmute method. Internal usage only recommended. mediaObject Object &lt;optional&gt; CB_AudioFile_API.ACMP#mediaObject Media object whose volume we want to set. Used internally to affect either normal or swap Media object (a swap object is stored internally as it is necessary due ACMP issues when looping a sprite near the end of the audio file). Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 984 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number stop( [keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) → {boolean} Stops the audio. Parameters: Name Type Argument Default Description keepStoppedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.ACMP#stopped property will not be set to true and it will remain with its current value. avoidOnStop boolean &lt;optional&gt; false If set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.ACMP#onStop method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. forceOnStop boolean &lt;optional&gt; false If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.ACMP#onStop method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 958 Returns: It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Type boolean unmute( [onUnmute]) → {number} Restores audio after muting it (unmutes it). Parameters: Name Type Argument Description onUnmute function &lt;optional&gt; Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.ACMP object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 1047 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number Type Definitions OPTIONS Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: Object Properties: Name Type Argument Default Description autoLoad boolean &lt;optional&gt; CB_AudioFile_API.ACMP#DEFAULT_OPTIONS.autoLoad If set to false, it will not call the CB_AudioFile_API.ACMP#load method internally when the constructor is called (not recommended). autoPlay boolean &lt;optional&gt; CB_AudioFile_API.ACMP#DEFAULT_OPTIONS.autoPlay Value which will be used as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile_API.ACMP#load method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). loop boolean &lt;optional&gt; CB_AudioFile_API.ACMP#DEFAULT_OPTIONS.loop Value that will be used for the CB_AudioFile_API.ACMP#loop property. volume number &lt;optional&gt; CB_AudioFile_API.ACMP#DEFAULT_OPTIONS.volume The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that will be used for the CB_AudioFile_API.ACMP#volume property. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_ACMP.js, line 193 × Search results Close "},"CB_AudioFile_API.SM2.html":{"id":"CB_AudioFile_API.SM2.html","title":"Class: CB_AudioFile_API.SM2","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFile_API.SM2 CB_AudioFile_API.SM2 Class to manage an audio file using &quot;SM2&quot; (SoundManager 2). Used by the CB_AudioFile class internally and it shares most of its properties and methods. Recommended for internal usage only. new CB_AudioFile_API.SM2(filePath [, audioId] [, options] [, callbackOk] [, callbackError]) → {CB_AudioFile_API.SM2} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description filePath string The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioId string &lt;optional&gt; 'CB_AUDIOFILE_SM2_' + CB_AudioFile_API.SM2._idUnique++ Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. options CB_AudioFile_API.SM2.OPTIONS &lt;optional&gt; CB_AudioFile_API.SM2#DEFAULT_OPTIONS Object with the desired options. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 16 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFile_API.SM2 object. Type CB_AudioFile_API.SM2 Members &lt;constant&gt; DEFAULT_OPTIONS :CB_AudioFile_API.SM2.OPTIONS Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: CB_AudioFile_API.SM2.OPTIONS Default Value: { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API.SM2.prototype.DEFAULT_VOLUME } Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 44 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 36 &lt;readonly&gt; filePath :string Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 98 &lt;readonly&gt; id :string Stores the identifier for the audio file. Type: string Default Value: 'CB_AUDIOFILE_SM2_' + CB_AudioFile_API.SM2._idUnique++ Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 89 &lt;readonly&gt; lastStartAt :number Stores the last &quot;startAt&quot; parameter value used by the CB_AudioFile_API.SM2#play or the CB_AudioFile_API.SM2#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 143 &lt;readonly&gt; lastStopAt :number Stores the last &quot;stopAt&quot; parameter value used by the CB_AudioFile_API.SM2#play or the CB_AudioFile_API.SM2#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 152 &lt;readonly&gt; loop :boolean Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the CB_AudioFile_API.SM2#play method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). Type: boolean Default Value: CB_AudioFile_API.SM2.prototype.DEFAULT_OPTIONS.loop Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 62 &lt;readonly&gt; onStopFunction :function Function to call when the audio stops. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 134 &lt;readonly&gt; paused :boolean Tells whether the audio is paused or not. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 107 &lt;readonly&gt; pauseTime :number Stores the time (in milliseconds) when the audio has been paused. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 116 &lt;readonly&gt; soundObject :Object Stores the &quot;SMSound&quot; object (returned by the createSound method) of the audio, used by the &quot;SM2&quot; (SoundManager 2). Type: Object Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 161 &lt;readonly&gt; status :integer Tells whether the file is unloaded (CB_AudioFile.UNLOADED), loading (CB_AudioFile.LOADING), unchecked (CB_AudioFile.UNCHECKED), checking (CB_AudioFile.CHECKING), loaded (CB_AudioFile.LOADED), failed (CB_AudioFile.FAILED) or aborted (CB_AudioFile.ABORTED). Type: integer Default Value: CB_AudioFile.UNLOADED Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 53 &lt;readonly&gt; stopped :boolean Tells whether the audio is stopped or not. Type: boolean Default Value: true Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 125 &lt;readonly&gt; volume :number Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.SM2.prototype.DEFAULT_OPTIONS.volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 71 &lt;readonly&gt; volumeBeforeMute :number Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.SM2#volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 80 Methods checkPlaying( [callbackOk] [, callbackError] [, ignoreStatus] [, ignoreQueue] [, useCache]) → {boolean} Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the CB_AudioFile_API.SM2#play method the first time. The checking action will only be performed if the value of the CB_AudioFile_API.SM2#status property belongs to the CB_AudioFile.UNCHECKED or to the CB_AudioFile.CHECKING value. After checking, if the audio can be played, the CB_AudioFile_API.SM2#status of the object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the CB_AudioFile_API.SM2#status property will get the value of {CB_AudioFile.FAILED}. Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. ignoreStatus boolean &lt;optional&gt; false If set to false and the CB_AudioFile_API.SM2#status property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant) nor to the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. ignoreQueue boolean &lt;optional&gt; false If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. useCache boolean &lt;optional&gt; false This parameter will be ignored in this audio API. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 514 Returns: Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. Type boolean destructor( [stopSound] [, keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) Destroys the audio file object and frees memory. Sets its current CB_AudioFile_API.SM2#status property to ABORTED (CB_AudioFile.ABORTED value). Parameters: Name Type Argument Default Description stopSound boolean &lt;optional&gt; false If set to true, it will also call the CB_AudioFile_API.SM2#stop method. keepStoppedUnaltered boolean &lt;optional&gt; false Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the CB_AudioFile_API.SM2#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. avoidOnStop boolean &lt;optional&gt; false Used internally as the &quot;avoidOnStop&quot; parameter to call the CB_AudioFile_API.SM2#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. forceOnStop boolean &lt;optional&gt; false Used internally as the &quot;forceOnStop&quot; parameter to call the CB_AudioFile_API.SM2#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 259 getCurrentTime() → {number} Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1140 Returns: Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. Type number getDuration() → {number} Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 698 Returns: Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Type number getProgress() → {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1233 Returns: Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number load( [filePath] [, autoPlay] [, callbackOk] [, callbackError] [, forceReload]) → {CB_AudioFile_API.SM2|null} Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter.When this method is called, if the CB_AudioFile_API.SM2#status property already has the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the CB_AudioFile.LOADING constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the CB_AudioFile.UNCHECKED constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the CB_AudioFile_API.SM2#checkPlaying method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the CB_AudioFile_API.SM2#checkPlaying method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant) and finally the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) if all goes well. Parameters: Name Type Argument Default Description filePath string &lt;optional&gt; CB_AudioFile_API.SM2#filePath The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. autoPlay string &lt;optional&gt; false If set to true, it will start playing the audio automatically (by calling the CB_AudioFile_API.SM2#play method internally). If set to true and the CB_AudioFile_API.SM2#status property reaches to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will also call internally the CB_AudioFile_API.SM2#checkPlaying method. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.SM2 object itself. forceReload boolean &lt;optional&gt; false If set to false, the &quot;filePath&quot; has not been changed from the previously used and the CB_AudioFile_API.SM2#status property belongs to the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 299 Returns: Returns the audio API object (if it was possible to create) or null otherwise. Type CB_AudioFile_API.SM2 | null mute( [onMute]) → {number} Mutes the audio file. Parameters: Name Type Argument Description onMute function &lt;optional&gt; Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1104 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. Type number onStop(callbackFunction [, keepOldFunction]) → {boolean} Sets a function to execute when the audio file stops playing or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the CB_AudioFile_API.SM2 object. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1196 Returns: Returns whether the event has been set or not (removed). Type boolean pause( [onPause] [, keepPausedUnaltered]) → {boolean} Pauses the audio when it is being played. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile_API.SM2 object. keepPausedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.SM2#paused property will not be set to true and it will remain with its current value. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 995 Returns: It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Type boolean play( [startAt] [, stopAt] [, loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError] [, isResume] [, isLooping] [, startPlayingTime]) → {boolean|integer} Plays the audio. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.SM2#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the CB_AudioFile_API.SM2#lastStartAt property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the CB_AudioFile_API.SM2#lastStartAt value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. stopAt number &lt;optional&gt; CB_AudioFile_API.SM2#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the CB_AudioFile_API.SM2#getDuration method (which should belong to the total duration of the audio, if it was calculated correctly). loop boolean &lt;optional&gt; CB_AudioFile_API.SM2#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.SM2#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.SM2#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.SM2 object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.SM2 object. isResume boolean &lt;optional&gt; false If set to true (not recommended) and it is a looping audio, the next loop will use the value of the CB_AudioFile_API.SM2#lastStartAt property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. isLooping boolean &lt;optional&gt; false Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. startPlayingTime integer &lt;optional&gt; Contains the time when the audio should start playing. Recommended for internal usage only. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 772 Returns: It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer resume( [loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError]) → {boolean|integer} Resumes the audio (after being paused), starting from the same point it was paused previously. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile_API.SM2#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.SM2#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the CB_AudioFile_API.SM2#stop method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.SM2#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.SM2 object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.SM2 object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 966 Returns: Returns the returning value of the CB_AudioFile_API.SM2#play method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer setVolume( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, saveForUnmute]) → {number} Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the CB_AudioFile_API.SM2#volume property even when the volume failed to be changed. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.SM2 object. saveForUnmute boolean &lt;optional&gt; false If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the CB_AudioFile_API.SM2#unmute method. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1066 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number stop( [keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) → {boolean} Stops the audio. Parameters: Name Type Argument Default Description keepStoppedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.SM2#stopped property will not be set to true and it will remain with its current value. avoidOnStop boolean &lt;optional&gt; false If set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.SM2#onStop method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. forceOnStop boolean &lt;optional&gt; false If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.SM2#onStop method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1036 Returns: It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Type boolean unmute( [onUnmute]) → {number} Restores audio after muting it (unmutes it). Parameters: Name Type Argument Description onUnmute function &lt;optional&gt; Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.SM2 object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 1122 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number Type Definitions OPTIONS Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: Object Properties: Name Type Argument Default Description autoLoad boolean &lt;optional&gt; CB_AudioFile_API.SM2#DEFAULT_OPTIONS.autoLoad If set to false, it will not call the CB_AudioFile_API.SM2#load method internally when the constructor is called (not recommended). autoPlay boolean &lt;optional&gt; CB_AudioFile_API.SM2#DEFAULT_OPTIONS.autoPlay Value which will be used as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile_API.SM2#load method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). loop boolean &lt;optional&gt; CB_AudioFile_API.SM2#DEFAULT_OPTIONS.loop Value that will be used for the CB_AudioFile_API.SM2#loop property. volume number &lt;optional&gt; CB_AudioFile_API.SM2#DEFAULT_OPTIONS.volume The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that will be used for the CB_AudioFile_API.SM2#volume property. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_SM2.js, line 198 × Search results Close "},"CB_AudioFile_API.WAAPI.html":{"id":"CB_AudioFile_API.WAAPI.html","title":"Class: CB_AudioFile_API.WAAPI","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFile_API.WAAPI CB_AudioFile_API.WAAPI Class to manage an audio file using &quot;WAAPI&quot; (HTML5 Web Audio API). Used by the CB_AudioFile class internally and it shares most of its properties and methods. Recommended for internal usage only. Uses Base64Binary internally. Some old clients can use this audio API thanks to AudioContext-MonkeyPatch and WAAPISim. new CB_AudioFile_API.WAAPI(filePath [, audioId] [, options] [, callbackOk] [, callbackError]) → {CB_AudioFile_API.WAAPI} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.) if the &quot;autoPlay&quot; option is set to true, as some web clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description filePath string The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. audioId string &lt;optional&gt; 'CB_AUDIOFILE_WAAPI_' + CB_AudioFile_API.WAAPI._idUnique++ Desired identifier for the audio object. If not provided, an automatic unique ID will be calculated. Note that it is not case sensitive and it should be unique for each object. options CB_AudioFile_API.WAAPI.OPTIONS &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS Object with the desired options. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 21 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Note that the &quot;id&quot; is not case sensitive and it should be unique for each object. Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFile_API.WAAPI object. Type CB_AudioFile_API.WAAPI Members &lt;readonly&gt; buffer :AudioBuffer Stores the &quot;buffer&quot; (AudioBuffer object) of the audio, used by the &quot;WAAPI&quot; (HTML5 Web Audio API). Type: AudioBuffer Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 175 &lt;constant&gt; DEFAULT_OPTIONS :CB_AudioFile_API.WAAPI.OPTIONS Keeps the default options when an object is created. Format: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: CB_AudioFile_API.WAAPI.OPTIONS Default Value: { autoLoad: true, autoPlay: false, loop: false, volume: CB_AudioFile_API.WAAPI.prototype.DEFAULT_VOLUME } Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 49 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 41 &lt;readonly&gt; filePath :string Stores the path of the audio file or the data URI. NOTE: Only some clients with some audio APIs will support data URIs. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 103 &lt;readonly&gt; gainNode :GainNode Stores the &quot;gain node&quot; (GainNode object created with the createGain method) of the audio, used by the &quot;WAAPI&quot; (HTML5 Web Audio API). Type: GainNode Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 185 &lt;readonly&gt; id :string Stores the identifier for the audio file. Type: string Default Value: 'CB_AUDIOFILE_WAAPI_' + CB_AudioFile_API.WAAPI._idUnique++ Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 94 &lt;readonly&gt; lastStartAt :number Stores the last &quot;startAt&quot; parameter value used by the CB_AudioFile_API.WAAPI#play or the CB_AudioFile_API.WAAPI#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 148 &lt;readonly&gt; lastStopAt :number Stores the last &quot;stopAt&quot; parameter value used by the CB_AudioFile_API.WAAPI#play or the CB_AudioFile_API.WAAPI#resume method. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 157 &lt;readonly&gt; loop :boolean Defines whether the file loops by default when the audio is played or not. Its value will be modified automatically whenever the CB_AudioFile_API.WAAPI#play method is called, getting the value from the &quot;loop&quot; parameter (but only if contains a boolean). Type: boolean Default Value: CB_AudioFile_API.WAAPI.prototype.DEFAULT_OPTIONS.loop Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 67 &lt;readonly&gt; onStopFunction :function Function to call when the audio stops. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 139 &lt;readonly&gt; paused :boolean Tells whether the audio is paused or not. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 112 &lt;readonly&gt; pauseTime :number Stores the time (in milliseconds) when the audio has been paused. Type: number Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 121 &lt;readonly&gt; progressDownloading :number Progress of the loading process (or downloading through XHR) the audio data, used by the &quot;WAAPI&quot; (HTML5 Web Audio API). Internal usage only recommended (use the CB_AudioFile_API.WAAPI#getProgress method instead to know the progress). Type: number Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 194 &lt;readonly&gt; source :AudioBufferSourceNode Stores the &quot;source&quot; (AudioBufferSourceNode object) of the audio, used by the &quot;WAAPI&quot; (HTML5 Web Audio API). Type: AudioBufferSourceNode Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 166 &lt;readonly&gt; status :integer Tells whether the file is unloaded (CB_AudioFile.UNLOADED), loading (CB_AudioFile.LOADING), unchecked (CB_AudioFile.UNCHECKED), checking (CB_AudioFile.CHECKING), loaded (CB_AudioFile.LOADED), failed (CB_AudioFile.FAILED) or aborted (CB_AudioFile.ABORTED). Type: integer Default Value: CB_AudioFile.UNLOADED Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 58 &lt;readonly&gt; stopped :boolean Tells whether the audio is stopped or not. Type: boolean Default Value: true Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 130 &lt;readonly&gt; volume :number Stores the volume of this audio. Accepted values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.WAAPI.prototype.DEFAULT_OPTIONS.volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 76 &lt;readonly&gt; volumeBeforeMute :number Stores the volume of this audio before it was muted (to restore it later). Valid values go from 0 to MAX_VOLUME, where MAX_VOLUME is 100 if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is false or otherwise MAX_VOLUME is the returning value of the CB_Speaker.getVolume function. Type: number Default Value: CB_AudioFile_API.WAAPI#volume Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 85 Methods checkPlaying( [callbackOk] [, callbackError] [, ignoreStatus] [, ignoreQueue] [, useCache]) → {boolean} Checks whether the audio can be played or not. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Also recommended to use before calling the CB_AudioFile_API.WAAPI#play method the first time. The checking action will only be performed if the value of the CB_AudioFile_API.WAAPI#status property belongs to the CB_AudioFile.UNCHECKED or to the CB_AudioFile.CHECKING value. After checking, if the audio can be played, the CB_AudioFile_API.WAAPI#status of the object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the CB_AudioFile_API.WAAPI#status property will get the value of {CB_AudioFile.FAILED}. Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been checked successfully, being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been checked successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. ignoreStatus boolean &lt;optional&gt; false If set to false and the CB_AudioFile_API.WAAPI#status property does not belong neither to the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant) nor to the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant), it will fail calling the &quot;callbackError&quot; function (if any). If set to true, it will try to perform the checking action regardless the status of the audio. ignoreQueue boolean &lt;optional&gt; false If set to false and there is already the maximum number of audio files being checked (defined internally), the function will exit and it will call itself automatically again and again until the checking process can be performed (when its queue turn has been reached). This is done for performance purposes. useCache boolean &lt;optional&gt; false If set to true (not recommended) and the same audio file was checked previously, it will not perform the checking process again and it will do the same as the previous call. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 720 Returns: Returns false if the checking could not be performed and failed. If it returns true, it can mean either the checking has been processed successfully or it will fail in the future, so it is recommended to ignore the returning value and use the callback functions instead. Type boolean decodeAudioData(binaryData [, callbackOk] [, callbackError]) → {undefined|Promise} Decodes binary audio data given. Internal usage only recommended. Parameters: Name Type Argument Description binaryData ArrayBuffer ArrayBuffer with the audio data to be decoded. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio data has been decoded successfully, being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio data has not been decoded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 665 Returns: Returns the returning value of calling the BaseAudioContext.decodeAudioData function, which returns void (undefined) or a Promise (whose methods &quot;then&quot; and &quot;catch&quot; will have already been used internally by this function). Type undefined | Promise destructor( [stopSound] [, keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) Destroys the audio file object and frees memory. Sets its current CB_AudioFile_API.WAAPI#status property to ABORTED (CB_AudioFile.ABORTED value). Parameters: Name Type Argument Default Description stopSound boolean &lt;optional&gt; false If set to true, it will also call the CB_AudioFile_API.WAAPI#stop method. keepStoppedUnaltered boolean &lt;optional&gt; false Used internally as the &quot;keepStoppedUnaltered&quot; parameter to call the CB_AudioFile_API.WAAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. avoidOnStop boolean &lt;optional&gt; false Used internally as the &quot;avoidOnStop&quot; parameter to call the CB_AudioFile_API.WAAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. forceOnStop boolean &lt;optional&gt; false Used internally as the &quot;forceOnStop&quot; parameter to call the CB_AudioFile_API.WAAPI#stop method. If the &quot;stopSound&quot; parameter is not set to true, this parameter will be ignored as the &quot;stop&quot; method will not be called. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 288 getCurrentTime() → {number} Gets the current time (in milliseconds) which belongs to the position where the audio is currently playing or where it has been paused. Note that some audio APIs and clients could give wrong values. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1276 Returns: Returns the current time (in milliseconds). Note that some audio APIs and clients could give wrong values. Type number getDuration() → {number} Tells the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 889 Returns: Returns the duration of the audio (in milliseconds). Note that some clients might not calculate the duration correctly and, in this case, a zero (0) value would be returned. Type number getProgress() → {number} Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1352 Returns: Returns a number representing the percentage of the loading progress for the audio file (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number load( [filePath] [, autoPlay] [, callbackOk] [, callbackError] [, forceReload] [, useXHR] [, useCache]) → {CB_AudioFile_API.WAAPI|null} Loads the desired audio file with the desired options. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some web clients may need this at least the first time in order to be able to play the audio. Uses Base64Binary internally. This method will be called automatically by the constructor if the &quot;autoLoad&quot; option was set to true in its given &quot;options&quot; parameter.When this method is called, if the CB_AudioFile_API.WAAPI#status property already has the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) and the &quot;forceReload&quot; parameter is not set to true, it will exit calling the given &quot;callbackOk&quot; function (if any) immediately. Otherwise, regardless the status, the status will be set to &quot;LOADING&quot; (defined in the CB_AudioFile.LOADING constant). After it, it will reach the &quot;UNCHECKED&quot; (defined in the CB_AudioFile.UNCHECKED constant). If the &quot;autoPlay&quot; parameter is not set to true, this will be the final status (and it will be necessary to call the CB_AudioFile_API.WAAPI#checkPlaying method after it). After it and only if the &quot;autoPlay&quot; is set to true, as the CB_AudioFile_API.WAAPI#checkPlaying method will be called internally, it will have the &quot;CHECKING&quot; status (defined in the CB_AudioFile.CHECKING constant) and finally the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant) if all goes well. Parameters: Name Type Argument Default Description filePath string &lt;optional&gt; CB_AudioFile_API.WAAPI#filePath The path of the audio file or a data URI. NOTE: Only some clients with some audio APIs will support data URIs. autoPlay string &lt;optional&gt; false If set to true, it will start playing the audio automatically (by calling the CB_AudioFile_API.WAAPI#play method internally). If set to true and the CB_AudioFile_API.WAAPI#status property reaches the &quot;UNCHECKED&quot; status (defined in the CB_AudioFile.UNCHECKED constant), it will also call internally the CB_AudioFile_API.WAAPI#checkPlaying method. callbackOk function &lt;optional&gt; Function with no parameters to be called when the audio has been loaded successfully, being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. callbackError function &lt;optional&gt; Function to be called if the audio has not been loaded successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object itself. forceReload boolean &lt;optional&gt; false If set to false, the &quot;filePath&quot; has not been changed from the previously used and the CB_AudioFile_API.WAAPI#status property belongs to the &quot;LOADED&quot; status (defined in the CB_AudioFile.LOADED constant), it will exit the method without loading the audio file again (calling the &quot;callbackOk&quot; function, if any). useXHR boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.useXHR Defines whether to use or not XHR (AJAX) to load the audio file. useCache boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.useCache Defines whether to try to use or not a cache for performance purposes. If set to true and the audio file was loaded before, it will try to use the cache (if possible) to accelerate the loading process. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 355 Returns: Returns the audio API object (if it was possible to create) or null otherwise. Type CB_AudioFile_API.WAAPI | null mute( [onMute]) → {number} Mutes the audio file. Parameters: Name Type Argument Description onMute function &lt;optional&gt; Callback function which will be called if it has been possible to mute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1240 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). If all goes well, the returning value should be zero (0). Note that, even when it returns a zero (0) value, this does not always mean that the mute has been applied successfully. Type number onStop(callbackFunction [, keepOldFunction]) → {boolean} Sets a function to execute when the audio file stops playing or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. No parameters will be received, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1315 Returns: Returns whether the event has been set or not (removed). Type boolean pause( [onPause] [, keepPausedUnaltered]) → {boolean} Pauses the audio when it is being played. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. keepPausedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.WAAPI#paused property will not be set to true and it will remain with its current value. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1139 Returns: It returns false if the audio is already paused or it is stopped or if it cannot be paused. Returns true otherwise. Type boolean play( [startAt] [, stopAt] [, loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError] [, isResume] [, isLooping] [, startPlayingTime]) → {boolean|integer} Plays the audio. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the CB_AudioFile_API.WAAPI#lastStartAt property (which belongs to the &quot;startAt&quot; value the last time that this method was called). If, even using the CB_AudioFile_API.WAAPI#lastStartAt value is still greather than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the CB_AudioFile_API.WAAPI#getDuration method (which should belong to the total duration of the audio, if it was calculated correctly). loop boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.WAAPI#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.WAAPI#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object. isResume boolean &lt;optional&gt; false If set to true (not recommended) and it is a looping audio, the next loop will use the value of the CB_AudioFile_API.WAAPI#lastStartAt property as the &quot;startAt&quot; parameter when it calls this method again automatically (internally). Recommended for internal usage only. isLooping boolean &lt;optional&gt; false Used to determine whether this method was called automatically again by itself because it is looping the audio. Recommended for internal usage only. startPlayingTime integer &lt;optional&gt; Contains the time when the audio should start playing. Recommended for internal usage only. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 909 Returns: It returns false if the duration is 0 (&quot;startAt&quot; and &quot;stopAt&quot; are the same number), returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer resume( [loop] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onLoadError]) → {boolean|integer} Resumes the audio (after being paused), starting from the same point it was paused previously. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined (through the CB_AudioFile_API.WAAPI#onStop method) will not be called. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the CB_AudioFile_API.WAAPI#stop method will be called immediately. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the CB_AudioFile_API.WAAPI#stop method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. If the audio is looping, this will be called only once when the audio starts playing the first time and it will not be called next loops. onLoadError function &lt;optional&gt; Function to be called if the audio cannot be played successfully. It will not be called if the audio is not paused or is stopped. The first and unique parameter will be a string describing the error found (if it could be determined), being &quot;this&quot; the CB_AudioFile_API.WAAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1111 Returns: Returns the returning value of the CB_AudioFile_API.WAAPI#play method which is called internally. It returns false if the audio is not paused or it is stopped, returns &quot;-1&quot; if the audio cannot be played and an error is detected or returns true otherwise. Note that even when it returns true there can be a non-detectable error and maybe the audio is not played. Type boolean | integer setVolume( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, saveForUnmute]) → {number} Sets the desired volume for the audio file (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the CB_AudioFile_API.WAAPI#volume property even when the volume failed to be changed. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. saveForUnmute boolean &lt;optional&gt; false If set to true (not recommended), it will save internally the current volume before setting it so it will restore the same volume again after calling the CB_AudioFile_API.WAAPI#unmute method. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1201 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number stop( [keepStoppedUnaltered] [, avoidOnStop] [, forceOnStop]) → {boolean} Stops the audio. Parameters: Name Type Argument Default Description keepStoppedUnaltered boolean &lt;optional&gt; false If set to true (not recommended), the CB_AudioFile_API.WAAPI#stopped property will not be set to true and it will remain with its current value. avoidOnStop boolean &lt;optional&gt; false If set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.WAAPI#onStop method), it will be called after stopping the audio (or after trying to do it, at least) but only if either the &quot;forceOnStop&quot; parameter is set to true or if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. If set to true, the &quot;onStop&quot; function (if any) will not be called at all. forceOnStop boolean &lt;optional&gt; false If it is set to true and the &quot;avoidOnStop&quot; parameter is set to false and there is an &quot;onStop&quot; function defined (through the CB_AudioFile_API.WAAPI#onStop method), it will be called regardless the audio was stopped before or not. If set to false, the &quot;onStop&quot; function (if any) will only be called if the &quot;keepStoppedUnaltered&quot; parameter is set to false and the audio was not already stopped before. This parameter will be ignored if the &quot;avoidOnStop&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1172 Returns: It returns false if the stopping action cannot be performed at all (this could happen when the audio has not been loaded properly, for example). Returns true otherwise (this only means that it has been tried to be stopped but it could not be successfully). Type boolean unmute( [onUnmute]) → {number} Restores audio after muting it (unmutes it). Parameters: Name Type Argument Description onUnmute function &lt;optional&gt; Callback function which will be called if it has been possible to unmute the audio file (or at least it was possible to try it). It will not receive any parameters, being &quot;this&quot; the CB_AudioFile_API.WAAPI object. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 1258 Returns: Returns the current volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Type number Type Definitions OPTIONS Object with the options for an audio file. The format is the following one: { autoLoad: boolean, autoPlay: boolean, loop: boolean, volume: number }. Type: Object Properties: Name Type Argument Default Description autoLoad boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.autoLoad If set to false, it will not call the CB_AudioFile_API.WAAPI#load method internally when the constructor is called (not recommended). autoPlay boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.autoPlay Value which will be used as the &quot;autoPlay&quot; parameter when calling the CB_AudioFile_API.WAAPI#load method internally, only when the &quot;autoLoad&quot; is set to true (when the constructor is called). loop boolean &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.loop Value that will be used for the CB_AudioFile_API.WAAPI#loop property. volume number &lt;optional&gt; CB_AudioFile_API.WAAPI#DEFAULT_OPTIONS.volume The desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise) that will be used for the CB_AudioFile_API.WAAPI#volume property. Source: CrossBase/audiovisual/audio/CB_AudioFile_API_WAAPI.js, line 223 × Search results Close "},"CB_AudioFileCache.html":{"id":"CB_AudioFileCache.html","title":"Class: CB_AudioFileCache","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFileCache CB_AudioFileCache Class to manage a cache with multiple CB_AudioFile objects (they should be the same sound although they can be in different formats). This is not only useful for performance purposes but also for being able to play the same sound simultaneously and multiple times in different audio APIs and clients. new CB_AudioFileCache( [dataObject]) → {CB_AudioFileCache} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Description dataObject CB_AudioFileCache.DATA_OBJECT &lt;optional&gt; Object with the desired data and options for the audio files cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 55 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFileCache object. Type CB_AudioFileCache Members &lt;static, constant&gt; ABORTED :integer Status value for an audio file cache which has been aborted. This will happen when the audio file cache has been destroyed with the CB_AudioFileCache#destructor method. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 6 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 354 &lt;static, constant&gt; CHECKING :integer Status value for an audio file cache which is being checked currently. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 3 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 330 &lt;static, constant&gt; checkManually_DEFAULT :boolean Default value for the CB_AudioFileCache#checkManually property. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 386 &lt;static, constant&gt; checkManuallyOnCheckingFailed_DEFAULT :boolean Default value for the CB_AudioFileCache#checkManuallyOnCheckingFailed property. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 410 &lt;static, constant&gt; checkManuallyOnNeededCreated_DEFAULT :boolean Default value for the CB_AudioFileCache#checkManuallyOnNeededCreated property. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 394 &lt;static, constant&gt; checkManuallyOnPlayingFailed_DEFAULT :boolean Default value for the CB_AudioFileCache#checkManuallyOnPlayingFailed property. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 402 &lt;static, constant&gt; FAILED :integer Status value for an audio file cache which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 5 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 346 &lt;static, constant&gt; LOADED :integer Status value for an audio file cache which has been loaded. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 4 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 338 &lt;static, constant&gt; LOADING :integer Status value for an audio file cache which is loading. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 1 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 314 &lt;static, constant&gt; maximumAudioFiles_DEFAULT :integer|null Default value for the CB_AudioFileCache#maximumAudioFiles property. Type: integer | null Default Value: null Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 370 &lt;static, constant&gt; minimumAudioFiles_DEFAULT :integer Default value for the CB_AudioFileCache#minimumAudioFiles property. Type: integer Default Value: 2 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 362 &lt;static, constant&gt; retries_DEFAULT :integer Default value for the CB_AudioFileCache#retries property. Type: integer Default Value: 1 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 378 &lt;static, constant&gt; UNCHECKED :integer Status value for an audio file cache which has not been checked yet. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 2 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 322 &lt;static, constant&gt; UNLOADED :integer Status value for audio file cache which is unloaded. Can be used to compare the value returned by the CB_AudioFileCache#getStatus method. Recommended for internal usage only. Type: integer Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 306 &lt;readonly&gt; audioFiles :array Numeric array containing all the CB_AudioFile objects created internally. Internal usage only recommended. Type: array Default Value: [] Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 220 &lt;readonly&gt; audioFilesCreated :integer Total number of CB_AudioFile objects created internally (optimization purposes, to avoid using CB_AudioFileCache#audioFiles.length). Internal usage only recommended. Type: integer Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 229 &lt;readonly&gt; audioFilesFree :array Stack that stores the indexes (belonged to the CB_AudioFileCache#audioFiles array) of the free CB_AudioFile objects. Internal usage only recommended. Type: array Default Value: [] Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 238 &lt;readonly&gt; audioFilesFreePointer :integer Pointer for the CB_AudioFileCache#audioFilesFree stack (for optimization purposes). Internal usage only recommended. Type: integer Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 247 &lt;readonly&gt; checkManually :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually). Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManually_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 166 &lt;readonly&gt; checkManuallyOnCheckingFailed :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 193 &lt;readonly&gt; checkManuallyOnNeededCreated :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when creates a new CB_AudioFile object needed. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 175 &lt;readonly&gt; checkManuallyOnPlayingFailed :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 184 &lt;constant&gt; DEFAULT_VOLUME :number Keeps the default volume. If the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT property is true, this will keep the result of calling the CB_Speaker.getVolume function. Otherwise, it will use the value of the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME variable. Type: number Default Value: CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 67 &lt;readonly&gt; duration :number Stores the minimum duration found among all the CB_AudioFile objects. Internal usage only recommended. Type: number Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 265 &lt;readonly&gt; durationMaximum :number Stores the maximum duration found among all the CB_AudioFile objects. Internal usage only recommended. Type: number Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 274 &lt;readonly&gt; id :string Stores the identifier for the audio files cache. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 86 &lt;readonly&gt; maximumAudioFiles :integer|null Maximum CB_AudioFile objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the CB_AudioFileCache#minimumAudioFiles property, allowing 1 minimum. Internal usage only recommended. Type: integer | null Default Value: CB_AudioFileCache.maximumAudioFiles_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 130 &lt;readonly&gt; minimumAudioFiles :integer Minimum CB_AudioFile objects to create internally. It must be an integer being 1 the minimum. Internal usage only recommended. Type: integer Default Value: CB_AudioFileCache.minimumAudioFiles_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 121 &lt;readonly&gt; minimumAudioFilesFree :integer New CB_AudioFile objects will be created internally when the number of free CB_AudioFile objects reaches this limit. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. Type: integer Default Value: parseInt(CB_AudioFileCache#minimumAudioFiles * 0.25 + 0.5) Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 139 &lt;readonly&gt; newAudioFilesWhenNeeded :integer Number of new CB_AudioFile objects to create internally when the minimum limit of free CB_AudioFile objects (CB_AudioFileCache#minimumAudioFilesFree) is reached. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. Type: integer Default Value: Math.min(parseInt(CB_AudioFileCache#minimumAudioFiles * 0.1 + 0.5), 1) Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 148 &lt;readonly&gt; onError :function Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current CB_AudioFileCache object. Internal usage only recommended. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 211 &lt;readonly&gt; onLoad :function Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the CB_AudioFile objects that still need to be checked, if any, being &quot;this&quot; the current CB_AudioFileCache object. Internal usage only recommended. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 202 &lt;readonly&gt; preferredAPIs :array Stores an array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Internal usage only recommended. Type: array Default Value: CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 95 &lt;readonly&gt; preferredFormats :array Stores an array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. Internal usage only recommended. Type: array Default Value: CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 104 &lt;readonly&gt; retries :integer Number of retries to try to load a CB_AudioFile object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. Internal usage only recommended. Type: integer Default Value: CB_AudioFileCache.retries_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 157 &lt;readonly&gt; soundInstancesQueued :Object Object with sound instance identifiers (integers created by the CB_AudioFileCache#play method) which are going to play (this way we can cancel the sound before it starts playing). Each property name is the identifier of the sound instance and the value will be an object with &quot;cancelled&quot; (boolean, to know whether the sound instance was cancelled or not) and &quot;object&quot; (containing the CB_AudioFile object used) properties. Internal usage only recommended. Type: Object Default Value: {} Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 256 &lt;readonly&gt; status :integer Tells whether the cache is unloaded (CB_AudioFileCache.UNLOADED), loading (CB_AudioFileCache.LOADING), unchecked (CB_AudioFileCache.UNCHECKED), checking (CB_AudioFileCache.CHECKING), loaded (CB_AudioFileCache.LOADED), failed (CB_AudioFileCache.FAILED) or aborted (CB_AudioFileCache.ABORTED). Type: integer Default Value: CB_AudioFileCache.UNLOADED Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 70 &lt;readonly&gt; URIs :CB_AudioFileCache.URIS_OBJECT Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. Internal usage only recommended. Type: CB_AudioFileCache.URIS_OBJECT Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 112 Methods cancelSoundInstance(soundInstanceId [, cancel] [, affectWithObjectAssociated]) → {boolean} Cancels (to prevent it starts playing) or enables a sound instance (created by the CB_AudioFileCache#play method), by its identifier. Parameters: Name Type Argument Default Description soundInstanceId integer The identifier (integer) of the sound instance we want to affect. cancel boolean &lt;optional&gt; false Defines whether we want to cancel it or enable it. affectWithObjectAssociated boolean &lt;optional&gt; false If set to true, it will also affect the sound instance even it has a CB_AudioFile object associated. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1642 Returns: Returns true if the sound instance has been modified or false otherwise. Type boolean cancelSoundInstances( [cancel] [, affectWithObjectAssociated]) → {integer} Cancels (to prevent they start playing) or enables all sound instances (created by the CB_AudioFileCache#play method). Parameters: Name Type Argument Default Description cancel boolean &lt;optional&gt; false Defines whether we want to cancel them or enable them. affectWithObjectAssociated boolean &lt;optional&gt; false If set to true, it will also affect the sound instances which have a CB_AudioFile object associated. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1623 Returns: Returns the number of sound instances modified. Type integer checkPlayingAll( [callbackOk] [, callbackError] [, ignoreQueue]) → {integer} Checks whether each CB_AudioFile object whose CB_AudioFile#getStatus method returns the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) can be played or not. After checking, if the audio can be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.FAILED. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). It will call the CB_AudioFileCache#clearAudioFiles method internally after finishing. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). Parameters: Name Type Argument Default Description callbackOk CB_AudioFileCache.checkPlayingAll_CALLBACK_OK &lt;optional&gt; A function which will be called if all the CB_AudioFile objects whose CB_AudioFile#getStatus method returned the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) could finally be checked successfully and all can be played, being &quot;this&quot; the CB_AudioFileCache object itself. callbackError CB_AudioFileCache.checkPlayingAll_CALLBACK_ERROR &lt;optional&gt; A function which will be called if not all the CB_AudioFile objects whose CB_AudioFile#getStatus method returned the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) could finally be checked successfully and any cannot be played, being &quot;this&quot; the CB_AudioFileCache object itself. This function will be called immediately if the method was previously called and it is still running currently. ignoreQueue boolean &lt;optional&gt; false Used internally as the &quot;ignoreQueue&quot; parameter when calling the CB_AudioFile#checkPlaying method of each CB_AudioFile object. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1989 To Do: Think about implementing an &quot;audioFiles&quot; parameter. Returns: Returns the number of CB_AudioFile objects whose status belonged to the &quot;unchecked&quot; value (the value of the CB_AudioFile#UNCHECKED property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of the audio file cache is not loaded (the CB_AudioFileCache#status property does not belong to the value set in the CB_AudioFileCache.LOADED property) nor unchecked (the CB_AudioFileCache#status property does not belong to the value set in the CB_AudioFileCache.UNCHECKED property). Type integer clearAudioFiles( [avoidCallingCheckCacheLoaded]) → {array} Cleans the array of the CB_AudioFile objects (taking off the undefined or null ones) which is in the CB_AudioFileCache#audioFiles property, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Internal usage only recommended. Parameters: Name Type Argument Default Description avoidCallingCheckCacheLoaded boolean &lt;optional&gt; false If set to false and neither the CB_AudioFileCache#checkPlayingAll nor the CB_AudioFileCache#setAudioAPIAll methods are being executed, it will call the CB_AudioFileCache#_checkCacheLoaded internal method which will call the &quot;onLoad&quot; function defined in the CB_AudioFileCache#onLoad property if the number of needed CB_AudioFile objects has been reached (after performing the cleaning process). Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1037 Returns: Returns the value of the CB_AudioFileCache#audioFiles property. Type array clearSoundInstances( [clearWithObjectAssociated]) → {integer} Clears the sound instances (created by the CB_AudioFileCache#play method) which have been cancelled. Parameters: Name Type Argument Default Description clearWithObjectAssociated boolean &lt;optional&gt; false If set to true, it will also clear the sound instances which have a CB_AudioFile object associated. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1591 Returns: Returns the number of cleared sound instances. Type integer createAudioFile( [URIs] [, preferredAPIs] [, preferredFormats] [, audioObject] [, callbackOk] [, callbackError] [, storeURIsList] [, checkAutomatically]) → {CB_AudioFile|null} Creates one internal CB_AudioFile object (inside the CB_AudioFileCache#audioFiles property). This method is already called by the CB_AudioFileCache#createAudioFiles method and other methods automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Internal usage only recommended. Parameters: Name Type Argument Default Description URIs CB_AudioFileCache.URIS_OBJECT &lt;optional&gt; CB_AudioFileCache#URIs Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. It will try to calculate and use the best audio format for the current client and use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. preferredAPIs array &lt;optional&gt; CB_AudioFileCache#preferredAPIs Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). It will try to calculate and use the best one for the current client. preferredFormats array &lt;optional&gt; CB_AudioFileCache#preferredFormats Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. audioObject CB_AudioFile &lt;optional&gt; A CB_AudioFile object that we want to reuse instead of creating a new one (for performance purposes). callbackOk function &lt;optional&gt; Function with no parameters that will be called once the CB_AudioFile object is created and loaded successfully (or after it has been checked successfully, depending on the desired option), being &quot;this&quot; the CB_AudioFileCache object itself. callbackError function &lt;optional&gt; Function called when any error is produced during creation, loading or checking process, etc. The unique parameter will be a string describing the error (if it was possible to be determined), being &quot;this&quot; the CB_AudioFileCache object itself. storeURIsList boolean &lt;optional&gt; false If set to true, it will store internally the valid supported &quot;URIs&quot; from the given ones (needed by the CB_AudioFileCache#setAudioAPIAll method, for example). Internal usage only recommended. checkAutomatically boolean &lt;optional&gt; false If set to true (not recommended), it will call the CB_AudioFile#checkPlaying method automatically. Otherwise, it will perform according to the value set at the CB_AudioFileCache#checkManually property. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 664 Returns: If it fails, it returns null. Otherwise, returns the CB_AudioFile that has been created or reused. Type CB_AudioFile | null createAudioFiles(minimumAudioFiles [, setAsLoaded]) → {integer} Creates the desired number of internal CB_AudioFile objects (inside the CB_AudioFileCache#audioFiles property). This method is already called by the CB_AudioFileCache#load method automatically (unless the &quot;disableAutoLoad&quot; property has been set to true in the &quot;dataObject&quot; given). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Default Description minimumAudioFiles integer Minimum CB_AudioFile objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the CB_AudioFileCache#minimumAudioFiles property. setAsLoaded boolean &lt;optional&gt; false If the CB_AudioFile objects already created internally (before calling this method) does not reach the number given in the &quot;minimumAudioFiles&quot;, this parameter will be ignored. Otherwise, if set to true, it will set the CB_AudioFileCache.status property as &quot;LOADED&quot; (the value of the CB_AudioFileCache#LOADED property) after reaching the desired number. If set to false, the CB_AudioFileCache.status property will be set as &quot;LOADED&quot; CB_AudioFileCache#LOADED property) if the CB_AudioFileCache#checkManually property is set to true or set as &quot;UNCHECKED&quot; if the CB_AudioFileCache#checkManually property is set to false. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 582 Returns: Returns the number of CB_AudioFile objects which are intended to be created (they could fail). Type integer destroyAll( [stopSounds]) → {integer} Destroys all the CB_AudioFile objects and frees memory, by calling CB_AudioFile#destructor(stopSounds, false, true). Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used internally as the &quot;stopSound&quot; parameter when calling the CB_AudioFile#destructor method of each CB_AudioFile object. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1950 To Do: Think about implementing an &quot;audioFiles&quot; parameter. Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#destructor has been called. Type integer destructor( [stopSounds] [, preventAbortedStatus]) Destroys the audio file cache object, including all the internal CB_AudioFile objects, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of the audio file cache object as ABORTED (CB_AudioFileCache.ABORTED value). Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSound&quot; parameter when calling internally the CB_AudioFile#destructor method for all the CB_AudioFile objects. preventAbortedStatus boolean &lt;optional&gt; false If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not assign the value of CB_AudioFileCache.ABORTED to the CB_AudioFileCache#status property). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 456 errorFunction( [message] [, avoidFailing]) → {boolean} Calls the error function which should be set in the CB_AudioFileCache#onError property (if any), being &quot;this&quot; the CB_AudioFileCache object itself. Internal usage only recommended. Parameters: Name Type Argument Default Description message string &lt;optional&gt; The message describing the error that will be sent to the set CB_AudioFileCache#onError function (if any) as the first and unique parameter. avoidFailing boolean &lt;optional&gt; false If set to true, it will not set the CB_AudioFileCache#status property to &quot;FAILED&quot; (the value of the CB_AudioFile#FAILED property). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2854 Returns: Returns true if the CB_AudioFileCache#onError function could be called or false otherwise. Type boolean executeAll() Alias for CB_AudioFileCache#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1869 See: CB_AudioFileCache#executeFunctionAll executeFunctionAll(functionEach [, delayBetweenEach] [, audioFiles] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing CB_AudioFile objects or on the desired ones (if provided). Calls the CB_Arrays.executeFunctionAll function internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Function that will be called for each CB_AudioFile object. As the first parameter it receives the CB_AudioFile object of the &quot;audioFiles&quot; being looped, as the second parameter the position of this CB_AudioFile object in the &quot;audioFiles&quot; array provided (or, if not provided, in the array of the CB_AudioFileCache#audioFiles property), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the CB_AudioFile object itself. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the setTimeout function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each CB_AudioFile object). audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to loop. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. returnSetTimeoutsArray boolean &lt;optional&gt; false Defines whether we want the method to return an integer or a numeric array with information of each setTimeout call. Returning an array with information of each setTimeout call is only useful when the setTimeout function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). delayBetweenEachAffectsFirst boolean &lt;optional&gt; false If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1891 To Do: Think about only allowing CB_AudioFile objects (in the &quot;audioFiles&quot; parameter) which are already in the cache (identify them by their ID), to avoid problems. Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_AudioFile objects given in the &quot;audioFiles&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array forEach() Alias for CB_AudioFileCache#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1874 See: CB_AudioFileCache#executeFunctionAll getAudioFileBySoundInstanceId(soundInstanceId [, avoidCancelled]) → {CB_AudioFile|null} Gets the CB_AudioFile object associated to a given sound instance ID (created by the CB_AudioFileCache#play method), if any, or null otherwise. Parameters: Name Type Argument Default Description soundInstanceId integer The identifier (integer) of the sound instance we want to get. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not return the CB_AudioFile object if its sound instance has been cancelled. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1665 Returns: Returns the CB_AudioFile object associated to a given sound instance ID, if any, or null otherwise. Type CB_AudioFile | null getAudioFilePosition(id) → {integer} Tells the position of a desired CB_AudioFile object (by its identifier) in the CB_AudioFileCache#audioFiles property or -1 otherwise. Parameters: Name Type Description id string The identifier of the CB_AudioFile object (belongs to its CB_AudioFile#id property) whose position we want to find. Note that the identifier is not case sensitive and it should be unique for each object. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1447 Returns: Returns the position of a desired CB_AudioFile object (by its identifier) in the CB_AudioFileCache#audioFiles property or -1 otherwise. Type integer getAudioFiles( [copy]) → {array} Gets an array with all the CB_AudioFile objects. Parameters: Name Type Argument Default Description copy boolean &lt;optional&gt; false If set to true, instead of returning the CB_AudioFileCache#audioFiles property directly, it will return a new copy of it. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2677 Returns: Returns an array with all the CB_AudioFile objects. Type array getAudioFilesBusy() → {array} Gets an array with the busy CB_AudioFile objects (the objects which are not available and ready to use). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2723 Returns: Returns an array with the busy CB_AudioFile objects (the objects which are not available and ready to use). Type array getAudioFilesFree() → {array} Gets an array with the free CB_AudioFile objects (the objects which are available and ready to use). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2702 Returns: Returns an array with the free CB_AudioFile objects (the objects which are available and ready to use). Type array getAudioFilesFreeNumber() → {integer} Tells the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2665 Returns: Returns the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Type integer getAudioFilesNumber( [real]) → {integer} Tells the number of CB_AudioFile objects created. Parameters: Name Type Argument Default Description real boolean &lt;optional&gt; false If set to true, instead of returning the value of the CB_AudioFileCache#audioFilesCreated property, it will return the value of the &quot;length&quot; property of the CB_AudioFileCache#audioFiles array which are the real number of CB_AudioFile objects used. If all went well, the returning value should be always the same regardless of this parameter. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2745 Returns: Returns the number of CB_AudioFile objects created. Type integer getDuration( [maximum]) → {number} Tells the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the CB_AudioFile objects. Parameters: Name Type Argument Default Description maximum boolean &lt;optional&gt; false If set to true, instead of returning the value of the CB_AudioFileCache#duration property (which belongs to the minimum duration found among all the CB_AudioFile objects), it will return the value of CB_AudioFileCache#durationMaximum property (which belongs to the maximum duration found among all the CB_AudioFile objects). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2758 Returns: Returns the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the CB_AudioFile objects. Type number getFreeAudioFile( [popIt]) → {CB_AudioFileCache.getFreeAudioFile_OBJECT} Returns a free CB_AudioFile object, if any (from the CB_AudioFileCache#audioFilesFree property). Note that this will call the internal CB_AudioFileCache#_createNewAudioFilesIfNeeded method that could end creating a new CB_AudioFile object if needed. Parameters: Name Type Argument Default Description popIt boolean &lt;optional&gt; false If set to true, the CB_AudioFile object will also be &quot;popped&quot; (removed) from the CB_AudioFileCache#audioFilesFree property. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1406 Returns: Returns a CB_AudioFileCache.getFreeAudioFile_OBJECT object. Type CB_AudioFileCache.getFreeAudioFile_OBJECT getProgress( [countLoadedObjects] [, alsoUncheckedAndCheckingObjects]) → {number} Returns a number representing the percentage of the loading progress for the audio file cache (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Parameters: Name Type Argument Default Description countLoadedObjects boolean &lt;optional&gt; false If set to true, it will count the CB_AudioFile objects whose CB_AudioFile#getStatus method returns &quot;LOADED&quot; (the value of the CB_AudioFile#LOADED property), instead of just using the array's &quot;length&quot; of the CB_AudioFileCache#audioFiles property. alsoUncheckedAndCheckingObjects boolean &lt;optional&gt; false If set to true and the &quot;countLoadedObjects&quot; parameter is also true, it will also count the CB_AudioFile objects whose CB_AudioFile#getStatus method returns &quot;UNCHECKED&quot; (the value of the CB_AudioFile#UNCHECKED property) or &quot;CHECKING&quot; (the value of the CB_AudioFile#CHECKING property). If the &quot;countLoadedObjects&quot; parameter is false, this parameter will be ignored. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2773 To Do: Although it would be more accurate, it does not use the CB_AudioFile#getProgress method internally because the CB_AudioFile objects are not added to the CB_AudioFileCache#audioFiles property until they are loaded. It would be nice to code a way to be able to use it (perhaps a property where the CB_AudioFile objects loading are kept temporarily). Returns: Returns a number representing the percentage of the loading progress for the audio file cache (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number getStatus() → {number} Gets the current status of the audio file cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2827 Returns: Returns the current status of the audio file cache. It is a number, which should match the value of the CB_AudioFileCache.UNLOADED (still unloaded), CB_AudioFileCache.LOADING (loading), CB_AudioFileCache.UNCHECKED (not checked by calling the CB_AudioFileCache#checkPlayingAll method yet), CB_AudioFileCache.CHECKING (being checked by the CB_AudioFileCache#checkPlayingAll method), CB_AudioFileCache.LOADED (loaded), CB_AudioFileCache.FAILED (failed loading or failed to play or by any other reason) or CB_AudioFileCache.ABORTED (aborted because it was destroyed with the &quot;destructor&quot; method) property. Type number getStatusString() → {string} Gets the current status of the audio file cache, as a string. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2838 Returns: Returns the current status of the audio file cache, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the CB_AudioFileCache#status property not recognized as any possible status). Type string isAudioFileFree(id) → {boolean} Tells whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Parameters: Name Type Description id string The identifier of the CB_AudioFile object (belongs to its CB_AudioFile#id property) that we want to check. Note that the identifier is not case sensitive and it should be unique for each object. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1478 Returns: Returns whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Type boolean isAudioFileFreeByPosition(position) → {boolean} Tells whether a given numeric position of a CB_AudioFile object in the CB_AudioFileCache#audioFiles property is stored in the CB_AudioFileCache#audioFilesFree property or not (this means that the CB_AudioFile object in that position of the CB_AudioFileCache#audioFiles property is free). A free CB_AudioFile object is an object which is not being used and it is available to be used. Parameters: Name Type Description position integer Position of the CB_AudioFile object in the CB_AudioFileCache#audioFiles property that we want to check whether it is in the CB_AudioFileCache#audioFilesFree property or not. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1492 Returns: Returns whether the given numeric position of a CB_AudioFile object in the CB_AudioFileCache#audioFiles property is stored in the CB_AudioFileCache#audioFilesFree property or not (this means that the CB_AudioFile object in that position of the CB_AudioFileCache#audioFiles property is free). A free CB_AudioFile object is an object which is not being used and it is available to be used. Type boolean isPlaying() → {boolean} Tells whether any of the CB_AudioFile objects is playing or not. It uses the CB_AudioFile#isPlaying method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2646 Returns: Returns whether any of the CB_AudioFile objects is playing or not. Type boolean load(dataObject) → {CB_AudioFileCache|null} Loads the audio file cache with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Description dataObject CB_AudioFileCache.DATA_OBJECT Object with the desired data and options for the audio files cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 503 Returns: If a &quot;dataObject&quot; is given, it returns the current CB_AudioFileCache object. Otherwise, it returns null. Type CB_AudioFileCache | null muteAll( [onMute] [, audioFiles]) → {integer} Mutes all the existing CB_AudioFile objects or the desired ones (if provided). It uses the CB_AudioFile#mute method internally. Parameters: Name Type Argument Default Description onMute function &lt;optional&gt; Callback function which will be called for each audio file if it has been possible to mute it (or at least it was possible to try it), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onMute&quot; parameter to call the CB_AudioFile#mute method. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2303 Returns: Returns the number of calls to the CB_AudioFile#mute method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer pauseAll( [onPause] [, audioFiles]) → {integer} Tries to pause all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#pause method internally. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onPause&quot; parameter to call the CB_AudioFile#pause method of the CB_AudioFile object. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2234 Returns: Returns the number of calls to the CB_AudioFile#pause method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer play( [startAt] [, stopAt] [, loop] [, volume] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop] [, startPlayingTime] [, startAtOriginal] [, soundInstanceId] [, _callRecursivelyIfNotTooLateCalledObject]) → {integer|null} Plays a sound of the cache (if there is any free). If a sound cannot be played, this method can call itself internally again and again (with most of the given parameters being the same, depending on the circumstances) to try to play the sound until a desired time limit is reached. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greater than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the CB_AudioFile#play method of the free CB_AudioFile object (if any). stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the CB_AudioFile#play method of the free CB_AudioFile object (if any). loop boolean &lt;optional&gt; CB_AudioFile#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Used internally as the &quot;loop&quot; parameter to call the CB_AudioFile#play method of the free CB_AudioFile object (if any). volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume to play the audio. Used internally as the &quot;volume&quot; parameter to call the CB_AudioFile#setVolume method of the free CB_AudioFile object (if any), before playing it. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all. Used only when the audio is not able to play immediately. allowedRecursiveDelaySkipping boolean &lt;optional&gt; stopAt-startAt If provided (uses milliseconds) and the time expired trying to start playing the sound without success is still inside this amount of time provided, it will try to play the sound but skipping the part of the audio which should have already been played already. In other words, it will try to start playing the sound as if the previous non-played part (which should have been playing during the time which already expired) was already being playing silently. Only used when the time set in the &quot;allowedRecursiveDelay&quot; parameter has been reached and the audio did not start playing yet. The default value is the duration of the sound that we want to play (having in mind the real value of the &quot;startAt&quot; and &quot;stopAt&quot; parameters which are calculated internally and can be different from the provided ones in the case that they had any error). onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;soundInstanceId&quot; (the identifier of the sound instance used), &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile object used (if any). Used internally as the &quot;onPlayStart&quot; parameter (wrapped in another function) to call the CB_AudioFile#play method of the free CB_AudioFile object (if any). onStop function &lt;optional&gt; Function to call when the sound stops playing, with an unique parameter which belongs to the &quot;soundInstanceId&quot; (the identifier of the sound instance used), being &quot;this&quot; the CB_AudioFile object (if any). Used internally as the &quot;callbackFunction&quot; parameter (wrapped in a function) to call the CB_AudioFile#onStop method of the free CB_AudioFile object (if any), before playing it. startPlayingTime number &lt;optional&gt; CB_Device.getTiming() Used internally to calculate the amount of time (in milliseconds) expired without playing the sound. Internal usage only recommended. startAtOriginal number &lt;optional&gt; startAt Used internally to start playing the sound accurately and skipping the part which could not be played before, if the time expired without being played is still inside the amount of time provided in the &quot;allowedRecursiveDelaySkipping&quot; parameter. Internal usage only recommended. soundInstanceId integer &lt;optional&gt; CB_AudioFileCache._soundInstanceIdUnique++ The identifier of the sound instance that will be played. Used internally when the function is called recursively in the case that the sound could not be played immediately. Internal usage only recommended. _callRecursivelyIfNotTooLateCalledObject Object &lt;optional&gt; Object with just the &quot;called&quot; property (boolean). Used internally to know whether the current execution thread called already the _callRecursivelyIfNotTooLate internal method for the same sound instance or not. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1753 Returns: Returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. Type integer | null playAll( [startAt] [, stopAt] [, loop] [, volume] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onStop] [, includingPlaying]) → {integer} Tries to play all the CB_AudioFile objects by calling their CB_AudioFile#play method internally. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). It does not create sound instances. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Time in milliseconds where we want the audio to start at. If not provided or it is not a valid number, it will use zero (0) as default which belongs to the beginning of the audio. If the value provided is greater than the &quot;stopAt&quot; provided, it will use the value set in the &quot;lastStartAt&quot; property of the used audio API object (which belongs to the &quot;startAt&quot; value the last time that the &quot;play&quot; method was called). If, even using the &quot;lastStartAt&quot; value is still greater than the &quot;stopAt&quot; provided, it will use the same value as the &quot;stopAt&quot; which means it will not play and will stop immediately. Used internally as the &quot;startAt&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Time in milliseconds where we want the audio to stop at. If not provided or it is not a valid number, it will use the returning value of the &quot;getDuration&quot; method of the used audio API object (which should belong to the total duration of the audio, if it was calculated correctly). Used internally as the &quot;stopAt&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. loop boolean &lt;optional&gt; CB_AudioFile#loop Sets whether we want to play the audio looping (starting again and again) or just play it once. Note that at the end of each loop the &quot;onStop&quot; function defined will not be called. Used internally as the &quot;loop&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume to play the audio. Used internally as the &quot;volume&quot; parameter to call the CB_AudioFile#setVolume method of the CB_AudioFile object, before playing it. avoidDelayedPlay boolean &lt;optional&gt; false If set to false (recommended) and the audio failed previously or was aborted (destroyed), it will try to load it correctly again automatically and play it after that if possible (this can take some time so the audio could start playing after a delay). Otherwise, if set to true and the audio failed or was aborted (destroyed), the audio will not play at all and the &quot;stop&quot; method of the audio file object will be called immediately. Used internally as the &quot;avoidDelayedPlay&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT The maximum amount of time (in milliseconds) of delay that we accept before start playing the audio. If the amount of time is overcome, the audio will not play at all and the &quot;stop&quot; method will be called immediately. Used only when the &quot;avoidDelayedPlay&quot; parameter is set to false and the audio needs to be loaded because it failed previously or was aborted (destroyed). Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. onPlayStart function &lt;optional&gt; Function to be called when the audio starts playing successfully. The function will be called with the following parameters (in order): &quot;startAt&quot;, &quot;stopAt&quot;, &quot;startAtNextLoop&quot;, &quot;loop&quot;, &quot;avoidDelayedPlay&quot;, &quot;allowedRecursiveDelay&quot; and &quot;startPlayingTime&quot;, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onPlayStart&quot; parameter to call the CB_AudioFile#play method of the CB_AudioFile object. onStop function &lt;optional&gt; Function that will be called each time that a CB_AudioFile object stops playing. Used internally as the &quot;callbackFunction&quot; parameter to call the CB_AudioFile#onStop method of the CB_AudioFile object, before playing it. includingPlaying boolean &lt;optional&gt; false If set to true, it will call the CB_AudioFile#play method even for those CB_AudioFile objects which are currently playing. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2144 To Do: Think about implementing an &quot;audioFiles&quot; parameter. Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer playAndStopAll( [includingPlaying] [, delayBeforeStop]) → {integer} Plays silently and stops all CB_AudioFile objects after a desired time. It can be useful for some clients which need the CB_AudioFile#play method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls CB_AudioFileCache#playAll(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the CB_AudioFileCache#stopAll method. Parameters: Name Type Argument Default Description includingPlaying boolean &lt;optional&gt; false If set to true, it will call the CB_AudioFile#play method even for those CB_AudioFile objects which are currently playing. delayBeforeStop number &lt;optional&gt; 100 Delay (in milliseconds) before stopping the audio, that will be used as the second parameter of the setTimeout function when calling the CB_AudioFileCache#stopAll method. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2217 To Do: Think about implementing an &quot;audioFiles&quot; parameter. Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer purge(desiredNumber [, setAsMinimumAudioFiles] [, includePlaying] [, stopSounds] [, statuses]) → {integer} Tries to purge the audio file cache until it reaches a desired number of CB_AudioFile objects internally (set in the CB_AudioFileCache#audioFiles property), by removing and destroying some of the current CB_AudioFile objects. For performance purposes. Parameters: Name Type Argument Default Description desiredNumber integer The desired number of internal CB_AudioFile objects that we want to keep in the CB_AudioFileCache#audioFiles property. It mus be 1 or greater. setAsMinimumAudioFiles boolean &lt;optional&gt; false If set to true, it will set the value of the &quot;desiredNumber&quot; parameter to the CB_AudioFileCache#minimumAudioFiles property (only when there is a maximum defined in CB_AudioFileCache#maximumAudioFiles). includePlaying boolean &lt;optional&gt; false If it is set to true and removing non-playing CB_AudioFile objects was not enough to reach the desired number (defined in the &quot;desiredNumber&quot; parameter), it will also try to remove objects which are being playing currently. stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSound&quot; parameter when calling the CB_AudioFile#destructor method of each CB_AudioFile object removed. statuses array &lt;optional&gt; Array(CB_AudioFile.LOADING, CB_AudioFile.UNCHECKED, CB_AudioFile.CHECKING, CB_AudioFile.LOADED) Numeric array containing the statuses of the CB_AudioFile objects that we want this method to authorize to remove. This means that if the returning value of the CB_AudioFile#getStatus method of a CB_AudioFile object is not in this list, it will not be tried to be removed (unless they end removed by the CB_AudioFileCache#clearAudioFiles method called internally). Have in mind that this method will call the CB_AudioFileCache#clearAudioFiles method internally, which destroys the CB_AudioFile objects whose CB_AudioFile#getStatus method returns CB_AudioFile.ABORTED and CB_AudioFile.FAILED, so these two statuses need not be indicated. It will respect the order given. Possible values for this array are: CB_AudioFile.UNLOADED, CB_AudioFile.LOADING, CB_AudioFile.UNCHECKED, CB_AudioFile.CHECKING, CB_AudioFile.LOADED, CB_AudioFile.FAILED and CB_AudioFile.ABORTED. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1294 Returns: Returns the number of CB_AudioFile objects removed. Type integer removeAudioFile(audioObjectOrId [, reload] [, checkManually]) → {boolean|CB_AudioFile|null} If found, takes a given CB_AudioFile object off the CB_AudioFileCache#audioFiles property (and reloads it if we want to). NOTE: It does neither destroy nor remove the CB_AudioFile object so it can be used for other purposes (and if a CB_AudioFile object is given, it will be tried to be reused by the CB_AudioFileCache#createAudioFile method internally if it is called). Internal usage only recommended. Parameters: Name Type Argument Default Description audioObjectOrId CB_AudioFile | string The CB_AudioFile object or a string with its identifier (not case sensitive) that we want to remove from the CB_AudioFileCache#audioFiles property. If a CB_AudioFile object is given, its CB_AudioFile#id property (which should be unique always) must be set as it is used to identify the object. NOTE: It does neither destroy nor remove the CB_AudioFile object so it can be used for other purposes (and if a CB_AudioFile object is given, it will be tried to be reused by the CB_AudioFileCache#createAudioFile method internally if it is called). reload boolean &lt;optional&gt; false If it is set to true, the CB_AudioFileCache#createAudioFile method will be called automatically at the end of the process. If a CB_AudioFile object has been given (through the &quot;audioObjectOrId&quot; parameter) or found by its identifier, it will be tried to be reused by the CB_AudioFileCache#createAudioFile method (as its &quot;audioObject&quot; parameter). checkManually boolean &lt;optional&gt; false Only used when the &quot;reload&quot; parameter is set to true, to calculate the &quot;checkAutomatically&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1148 To Do: Think about calling the CB_AudioFileCache#createAudioFile method internally (when the &quot;reload&quot; parameter is set to true) only when the CB_AudioFile object has been found and removed from the CB_AudioFileCache#audioFiles property. Returns: Returns null if the given &quot;audioObjectOrId&quot; parameter is not a valid CB_AudioFile object or its CB_AudioFile#id property is not set or when the &quot;audioObjectOrId&quot; parameter is an empty string. Returns a CB_AudioFile object, the given one through the &quot;audioObjectOrId&quot; parameter of the first one removed (it should be the first and unique one removed as the ID must be unique), if the CB_AudioFileCache#createAudioFile method is called internally (it will reuse this CB_AudioFile object). Otherwise, returns true if the number of internal CB_AudioFile objects (inside the CB_AudioFileCache#audioFiles property) has decreased or false otherwise. Type boolean | CB_AudioFile | null resumeAll( [loop] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop] [, audioFiles]) → {array} Resumes all the existing CB_AudioFile objects or the desired ones (if provided), which are paused (and not stopped). It uses the CB_AudioFileCache#play method internally. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile#loop Used internally as the &quot;loop&quot; parameter to call the CB_AudioFileCache#play method. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used internally as the &quot;allowedRecursiveDelay&quot; parameter to call the CB_AudioFileCache#play method. allowedRecursiveDelaySkipping boolean &lt;optional&gt; CB_AudioFile#lastStopAt-CB_AudioFile#lastStartAt Used internally as the &quot;allowedRecursiveDelaySkipping&quot; parameter to call the CB_AudioFileCache#play method. onPlayStart function &lt;optional&gt; Used internally as the &quot;onPlayStart&quot; parameter to call the CB_AudioFileCache#play method. onStop function &lt;optional&gt; Used internally as the &quot;onStop&quot; parameter to call the CB_AudioFileCache#play method. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2251 Returns: Returns a numeric array containing all the return values of each internal call to the CB_AudioFileCache#play method. Type array setAudioAPIAll(preferredAPIs [, callbackOk] [, callbackError] [, mandatory] [, forceReload] [, audioFiles]) → {integer} Tries to change the audio API for all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFile#setAudioAPI method internally. This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. Parameters: Name Type Argument Default Description preferredAPIs array | string Array of strings with the preferred audio API or audio APIs, in order of preference. It also accepts a string with only one audio API. If more than one audio API is provided and setting an audio API fails for a CB_AudioFile object, it will try setting the next one and so on (this means that some of the CB_AudioFile objects could end with a different audio API). Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). callbackOk CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK &lt;optional&gt; Function that will be called when all the process was performed successfully, being &quot;this&quot; the CB_AudioFileCache object. callbackError CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR &lt;optional&gt; Function that will be called when any error happened, being &quot;this&quot; the CB_AudioFileCache object. This function will be called immediately if the method was previously called and it is still running currently. mandatory boolean &lt;optional&gt; false If set to true and any CB_AudioFile object could not perform successfully any call to its CB_AudioFile#setAudioAPI method for all desired audio APIs provided in the &quot;preferredAPIs&quot; parameter (this means that, internally, all the CB_AudioFile#setAudioAPI calls, one per desired audio API, have fired an error by calling the function defined in its &quot;callbackError&quot; parameter), the audio file cache will be set as &quot;FAILED&quot; (the CB_AudioFileCache#status property will be set to the value of CB_AudioFileCache.FAILED). forceReload string &lt;optional&gt; false Used internally as the &quot;forceReload&quot; parameter when calling the CB_AudioFile#setAudioAPI method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2368 Returns: Returns the number of calls to the CB_AudioFile#setAudioAPI method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer setVolumeAll( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, audioFiles]) → {integer} Sets the same volume for all the existing CB_AudioFile objects or the desired ones (if provided). It uses the CB_AudioFile#setVolume method internally. Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Desired volume (from 0 to the maximum value, where the maximum value will be the returning value of calling the CB_Speaker.getVolume function if the CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM property is set to true or it will be 100 otherwise). Used internally as the &quot;volume&quot; parameter to call the CB_AudioFile#setVolume method. forceSetVolumeProperty boolean &lt;optional&gt; false If set to true (not recommended), it will change the &quot;volume&quot; property of the used audio API object even when the volume was failed to be changed. Used internally as the &quot;forceSetVolumeProperty&quot; parameter to call the CB_AudioFile#setVolume method. onSetVolume function &lt;optional&gt; Callback function which will be called if it has been possible to set the volume (or at least it was possible to try it), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onSetVolume&quot; parameter to call the CB_AudioFile#setVolume method. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2331 Returns: Returns the number of calls to the CB_AudioFile#setVolume method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer stopAll( [audioFiles]) → {integer} Tries to stops all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#stop method internally. Parameters: Name Type Argument Default Description audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2203 Returns: Returns the number of calls to the CB_AudioFile#stop method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer unmuteAll( [onUnmute] [, audioFiles]) → {integer} Unmutes all the existing CB_AudioFile objects or the desired ones (if provided). It uses the CB_AudioFile#unmute method internally. Parameters: Name Type Argument Default Description onUnmute function &lt;optional&gt; Callback function which will be called for each audio file if it has been possible to unmute it (or at least it was possible to try it), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onUnmute&quot; parameter to call the CB_AudioFile#unmute method. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles A numeric array containing the CB_AudioFile objects that we want to affect. It should contain only CB_AudioFile objects which are already in the current audio file cache. If not provided, it will use all the CB_AudioFile objects contained in the cache. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2316 Returns: Returns the number of calls to the CB_AudioFile#unmute method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer Type Definitions checkPlayingAll_CALLBACK_ERROR(errorMessage, performedActions, uncheckedObjects) Callback function used by the CB_AudioFileCache#checkPlayingAll method that will be called when not all was performed successfully. Parameters: Name Type Description errorMessage string A string describing the error, if it could be determined. performedActions integer The number of CB_AudioFile objects that can be played. uncheckedObjects integer | undefined The number of CB_AudioFile objects that needed to be checked before calling this method (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1971 checkPlayingAll_CALLBACK_OK(performedActions, uncheckedObjects) Callback function used by the CB_AudioFileCache#checkPlayingAll method that will be called when all the process was performed successfully. Parameters: Name Type Description performedActions integer The number of CB_AudioFile objects that can be played. uncheckedObjects integer The number of CB_AudioFile objects that needed to be checked before calling this method. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1963 DATA_OBJECT Object with the desired data and options for the audio files cache. Type: Object Properties: Name Type Argument Default Description URIs CB_AudioFileCache.URIS_OBJECT Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. If a valid value is given, this will be added to the CB_AudioFileCache#URIs property. id string &lt;optional&gt; &quot;&quot; Desired identifier for the audio files cache. Internal usage only recommended. If a valid value is given, this will be added to the CB_AudioFileCache#id property. preferredAPIs array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileCache#preferredAPIs property. preferredFormats array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileCache#preferredFormats property. minimumAudioFiles integer &lt;optional&gt; CB_AudioFileCache.minimumAudioFiles_DEFAULT Minimum CB_AudioFile objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the CB_AudioFileCache#minimumAudioFiles property. maximumAudioFiles integer | null &lt;optional&gt; CB_AudioFileCache.maximumAudioFiles_DEFAULT Maximum CB_AudioFile objects that are allowed to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the CB_AudioFileCache#minimumAudioFiles property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileCache#maximumAudioFiles property. minimumAudioFilesFree integer &lt;optional&gt; parseInt(CB_AudioFileCache#minimumAudioFiles * 0.25 + 0.5) New CB_AudioFile objects will be created internally when the number of free CB_AudioFile objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the CB_AudioFileCache#minimumAudioFiles by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the CB_AudioFileCache#minimumAudioFilesFree property. newAudioFilesWhenNeeded integer &lt;optional&gt; Math.min(parseInt(CB_AudioFileCache#minimumAudioFiles * 0.1 + 0.5), 1) Number of new CB_AudioFile objects to create internally when the minimum limit of free CB_AudioFile objects (CB_AudioFileCache#minimumAudioFilesFree) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the CB_AudioFileCache#minimumAudioFiles by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileCache#newAudioFilesWhenNeeded property. retries integer &lt;optional&gt; CB_AudioFileCache.retries_DEFAULT Number of retries to try to load a CB_AudioFile object internally before trying to load the next possible one (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the CB_AudioFileCache#retries property. checkManually boolean &lt;optional&gt; CB_AudioFileCache.checkManually_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the CB_AudioFileCache#checkManually property. checkManuallyOnNeededCreated boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when creates a new CB_AudioFile object needed. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnNeededCreated property. checkManuallyOnPlayingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnPlayingFailed property. checkManuallyOnCheckingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnCheckingFailed property. onLoad function &lt;optional&gt; Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the CB_AudioFile objects that still need to be checked, if any, being &quot;this&quot; the current CB_AudioFileCache object. If a valid value is given, this will be added to the CB_AudioFileCache#onLoad property. onError function &lt;optional&gt; Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current CB_AudioFileCache object. If a valid value is given, this will be added to the CB_AudioFileCache#onError property. disableAutoLoad boolean &lt;optional&gt; false If set to true, it will not create automatically the CB_AudioFile objects by calling the CB_AudioFileCache#createAudioFiles method internally. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 23 executeFunctionAll_OBJECT Object used by the CB_AudioFileCache#executeFunctionAll method when the &quot;returnSetTimeoutsArray&quot; parameter is set to true. Type: Object Properties: Name Type Description item CB_AudioFile The CB_AudioFile affected. setTimeoutReturningValue integer The returning value of calling the setTimeout internally or null if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. setTimeoutDelay number The value used as the second parameter when calling the setTimeout internally or zero if it was not called, depending on the &quot;delayBetweenEach&quot; parameter. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1860 getFreeAudioFile_OBJECT Object returned by the CB_AudioFileCache#getFreeAudioFile method. Type: Object Properties: Name Type Description object CB_AudioFile | null Contains the CB_AudioFile object if found or null otherwise. index string | integer Contains the position of the CB_AudioFile object inside the CB_AudioFileCache#audioFiles property if found or &quot;-1&quot; otherwise. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 1392 setAudioAPIAll_CALLBACK_ERROR(error, errorsHappened, objectsChangedAPI, performedActions, actionsNeeded) Callback function used by the CB_AudioFileCache#setAudioAPIAll method that will be called when any error happened. Parameters: Name Type Description error string A string describing the error, if it was possible to be determined. errorsHappened integer The number of errors that happened, which could be greater than 1 if more than one internal call to the CB_AudioFile#setAudioAPI method failed. objectsChangedAPI integer The number of CB_AudioFile objects that actually changed its audio API. performedActions integer The number of CB_AudioFile objects that ended with a desired audio API, including those ones which were already using it. actionsNeeded integer The total number of CB_AudioFile objects that were considered to perform the action (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2346 setAudioAPIAll_CALLBACK_OK(objectsChangedAPI, performedActions, actionsNeeded) Callback function used by the CB_AudioFileCache#setAudioAPIAll method that will be called when all the process was performed successfully. Parameters: Name Type Description objectsChangedAPI integer The number of CB_AudioFile objects that actually changed its audio API. performedActions integer The number of CB_AudioFile objects that ended with a desired audio API, including those ones which were already using it. actionsNeeded integer The total number of CB_AudioFile objects that were considered to perform the action (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 2337 URIS_OBJECT Object whose property names are audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;') and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. Type: Object Properties: Name Type Description filePaths array Being the name of each property the audio format (it can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), the value will always be a numeric array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. Source: CrossBase/audiovisual/audio/CB_AudioFileCache.js, line 7 Example { &quot;audio/mp4&quot; : [ &quot;first/path/sound.m4a&quot;, &quot;alternative/path/sound.m4a&quot;, &quot;alternative/path/2/sound.mp4&quot;, ... ], &quot;audio/ogg&quot; : [ &quot;first/path/sound.opus&quot;, &quot;alternative/path/sound.ogg&quot;, &quot;alternative/path/2/sound.ogg&quot;, ... ], &quot;audio/mpeg&quot; : [ &quot;first/path/sound.mp3&quot;, &quot;alternative/path/sound.mp3&quot;, &quot;alternative/path/2/sound.mp3&quot;, ... ], &quot;audio/wav&quot; : [ &quot;first/path/sound.wav&quot;, &quot;alternative/path/sound.wav&quot;, &quot;alternative/path/2/sound.wav&quot;, ... ], ... } × Search results Close "},"CB_AudioFileSprites.html":{"id":"CB_AudioFileSprites.html","title":"Class: CB_AudioFileSprites","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFileSprites CB_AudioFileSprites Class to manage audio sprites of a CB_AudioFileCache object (used internally). new CB_AudioFileSprites( [dataObject]) → {CB_AudioFileSprites} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Description dataObject CB_AudioFileSprites.DATA_OBJECT &lt;optional&gt; Object with the desired data and options for the audio sprites. Although it can contain a &quot;sprites&quot; property, it will also be used as the first and unique parameter when calling the constructor of the CB_AudioFileCache object internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 67 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Think about using wrapper to replace &quot;this&quot; in callbacks (callbackOk, callbackError) to point to the CB_AudioFileSprites object itself. Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFileSprites object. Type CB_AudioFileSprites Members &lt;readonly&gt; audioFileCache :CB_AudioFileCache Contains the CB_AudioFileCache object. Internal usage only recommended. Type: CB_AudioFileCache Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 181 &lt;readonly&gt; id :string Stores the identifier for the audio file sprites object. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 80 &lt;readonly&gt; sprites :CB_AudioFileSprites.SPRITES_OBJECT Object with information about the sprites. Type: CB_AudioFileSprites.SPRITES_OBJECT Default Value: {} Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 89 &lt;readonly&gt; spriteSoundInstances :Object Object whose property names are the sprite identifiers (strings), including one called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, and their values are an array containing the sound instance identifiers (created by the CB_AudioFileSprites#play method). Internal usage only recommended. Type: Object Default Value: { &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; : [] } Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 98 Methods cancelSoundInstance(soundInstanceId [, cancel] [, affectWithObjectAssociated]) → {boolean} Cancels (to prevent it starts playing) or enables a sound instance (created by the CB_AudioFileCache#play method), by its identifier. Uses the CB_AudioFileCache#cancelSoundInstance method internally and returns its returning value. Parameters: Name Type Argument Default Description soundInstanceId integer Used as the &quot;soundInstanceId&quot; parameter when calling the CB_AudioFileCache#cancelSoundInstance method internally. cancel boolean &lt;optional&gt; false Used as the &quot;cancel&quot; parameter when calling the CB_AudioFileCache#cancelSoundInstance method internally. affectWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the CB_AudioFileCache#cancelSoundInstance method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 974 Returns: Returns true if the sound instance has been modified or false otherwise. Type boolean cancelSoundInstances( [cancel] [, affectWithObjectAssociated]) → {integer} Cancels (to prevent they start playing) or enables all sound instances (created by the CB_AudioFileCache#play method). Uses the CB_AudioFileCache#cancelSoundInstances method internally and returns its returning value. Parameters: Name Type Argument Default Description cancel boolean &lt;optional&gt; false Used as the &quot;cancel&quot; parameter when calling the CB_AudioFileCache#cancelSoundInstances method internally. affectWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the CB_AudioFileCache#cancelSoundInstances method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 960 Returns: Returns the number of sound instances modified. Type integer checkPlayingAll( [callbackOk] [, callbackError] [, ignoreQueue]) → {integer} Checks whether each CB_AudioFile object whose CB_AudioFile#getStatus method returns the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) can be played or not. After checking, if the audio can be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.FAILED. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). It will call the CB_AudioFileCache#clearAudioFiles method internally after finishing. Uses the CB_AudioFileCache#checkPlayingAll method internally and returns its returning value. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). Parameters: Name Type Argument Default Description callbackOk CB_AudioFileCache.checkPlayingAll_CALLBACK_OK &lt;optional&gt; Used as the &quot;callbackOk&quot; parameter when calling the CB_AudioFileCache#checkPlayingAll method internally. callbackError CB_AudioFileCache.checkPlayingAll_CALLBACK_ERROR &lt;optional&gt; Used as the &quot;callbackError&quot; parameter when calling the CB_AudioFileCache#checkPlayingAll method internally. ignoreQueue boolean &lt;optional&gt; false Used as the &quot;ignoreQueue&quot; parameter when calling the CB_AudioFileCache#checkPlayingAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1071 Returns: Returns the number of CB_AudioFile objects whose status belonged to the &quot;unchecked&quot; value (the value of the CB_AudioFile#UNCHECKED property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of the audio file cache is not loaded (the CB_AudioFileCache#status property does not belong to the value set in the CB_AudioFileCache.LOADED property). Type integer clearAudioFiles( [avoidCallingCheckCacheLoaded]) → {array} Cleans the array of the CB_AudioFile objects (taking off the undefined or null ones) which is in the CB_AudioFileCache#audioFiles property, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Uses the CB_AudioFileCache#clearAudioFiles method internally and returns its returning value. Internal usage only recommended. Parameters: Name Type Argument Default Description avoidCallingCheckCacheLoaded boolean &lt;optional&gt; false Used as the &quot;avoidCallingCheckCacheLoaded&quot; parameter when calling the CB_AudioFileCache#clearAudioFiles method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 856 Returns: Returns the value of the CB_AudioFileCache#audioFiles property. Type array clearSoundInstances( [clearWithObjectAssociated]) → {integer} Clears the sound instances (created by the CB_AudioFileCache#play method) which have been cancelled. Uses the CB_AudioFileCache#clearSoundInstances method internally and returns its returning value. Parameters: Name Type Argument Default Description clearWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;clearWithObjectAssociated&quot; parameter when calling the CB_AudioFileCache#clearSoundInstances method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 922 Returns: Returns the number of cleared sound instances. Type integer createAudioFile( [URIs] [, preferredAPIs] [, preferredFormats] [, audioObject] [, callbackOk] [, callbackError] [, storeURIsList] [, checkAutomatically]) → {CB_AudioFile|null} Creates one internal CB_AudioFile object (inside the CB_AudioFileCache#audioFiles property). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Uses the CB_AudioFileCache#createAudioFile method internally and returns its returning value. Internal usage only recommended. Parameters: Name Type Argument Default Description URIs CB_AudioFileCache.URIS_OBJECT &lt;optional&gt; CB_AudioFileCache#URIs Used as the &quot;URIs&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. preferredAPIs array &lt;optional&gt; CB_AudioFileCache#preferredAPIs Used as the &quot;preferredAPIs&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. preferredFormats array &lt;optional&gt; CB_AudioFileCache#preferredFormats Used as the &quot;preferredFormats&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. audioObject CB_AudioFile &lt;optional&gt; Used as the &quot;audioObject&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. callbackOk function &lt;optional&gt; Used as the &quot;callbackOk&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. callbackError function &lt;optional&gt; Used as the &quot;callbackError&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. storeURIsList boolean &lt;optional&gt; false Used as the &quot;storeURIsList&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. checkAutomatically boolean &lt;optional&gt; false Used as the &quot;checkAutomatically&quot; parameter when calling the CB_AudioFileCache#createAudioFile method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 844 Returns: If it fails, it returns null. Otherwise, returns the CB_AudioFile that has been created or reused. Type CB_AudioFile | null createAudioFiles(minimumAudioFiles) → {integer} Creates the desired number of internal CB_AudioFile objects (inside the CB_AudioFileCache#audioFiles property). Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Uses the CB_AudioFileCache#createAudioFiles method internally and returns its returning value. Parameters: Name Type Description minimumAudioFiles integer Used as the &quot;minimumAudioFiles&quot; parameter when calling the CB_AudioFileCache#createAudioFiles method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 825 Returns: Returns the number of CB_AudioFile objects which are intended to be created (they could fail). Type integer destroyAll( [stopSounds]) → {integer} Destroys all the CB_AudioFile objects and frees memory, by calling CB_AudioFile#destructor(stopSounds, false, true). Uses the CB_AudioFileCache#destroyAll method internally and returns its returning value. Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling the CB_AudioFileCache#destroyAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1057 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#destructor has been called. Type integer destructor( [stopSounds] [, preventAbortedStatus]) Destroys the audio file sprites object (removing all sprites, etc.), including the internal audio file cache object, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of the CB_AudioFileCache object as ABORTED (CB_AudioFileCache.ABORTED value). Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling internally the CB_AudioFileCache#destructor method of the CB_AudioFileCache object. preventAbortedStatus boolean &lt;optional&gt; false If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not assign the value of CB_AudioFileCache.ABORTED to the CB_AudioFileCache#status property). Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 238 executeAll() Alias for CB_AudioFileSprites#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1024 See: CB_AudioFileSprites#executeFunctionAll executeAllSprite() Alias for CB_AudioFileSprites#executeFunctionAllSprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 578 See: CB_AudioFileSprites#executeFunctionAllSprite executeAllSprites() Alias for CB_AudioFileSprites#executeFunctionAllSprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 606 See: CB_AudioFileSprites#executeFunctionAllSprites executeFunctionAll(functionEach [, delayBetweenEach] [, audioFiles] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing CB_AudioFile objects or on the desired ones (if provided). Uses the CB_AudioFileCache#executeFunctionAll method internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Used as the &quot;functionEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 Used as the &quot;delayBetweenEach&quot; parameter when calling the CB_AudioFileCache#executeFunctionAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#executeFunctionAll method internally. returnSetTimeoutsArray boolean &lt;optional&gt; false Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the CB_AudioFileCache#executeFunctionAll method internally. delayBetweenEachAffectsFirst boolean &lt;optional&gt; false Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the CB_AudioFileCache#executeFunctionAll method internally. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1045 Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_AudioFile objects given in the &quot;audioFiles&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array executeFunctionAllSprite(spriteId, functionEach [, delayBetweenEach] [, avoidCancelled] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Executes a desired function for all the CB_AudioFile objects used by the sound instances currently created that belong to a given sprite (by its ID). It calls the CB_AudioFileSprites#executeFunctionAll method internally and returns its returning value. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Used as the &quot;functionEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 Used as the &quot;delayBetweenEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not affect the CB_AudioFile objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsedBySpriteId method internally. returnSetTimeoutsArray boolean &lt;optional&gt; false Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEachAffectsFirst boolean &lt;optional&gt; false Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 600 Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_AudioFile objects used by the sound instances that belong to the given sprite identifier). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array executeFunctionAllSprites(functionEach [, delayBetweenEach] [, includeWithoutSpriteAssociated] [, avoidCancelled] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Executes a desired function for all the CB_AudioFile objects used by all the sound instances currently created. It calls the CB_AudioFileSprites#executeFunctionAll method internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Used as the &quot;functionEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 Used as the &quot;delayBetweenEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, it will also affect the CB_AudioFile objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsed method internally. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not affect the CB_AudioFile objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsed method internally. returnSetTimeoutsArray boolean &lt;optional&gt; false Used as the &quot;returnSetTimeoutsArray&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEachAffectsFirst boolean &lt;optional&gt; false Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 628 Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_AudioFile objects used by the sound instances that belong to the sprites). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array forEach() Alias for CB_AudioFileSprites#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1029 See: CB_AudioFileSprites#executeFunctionAll forEachSprite() Alias for CB_AudioFileSprites#executeFunctionAllSprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 611 See: CB_AudioFileSprites#executeFunctionAllSprites forEachSpriteById() Alias for CB_AudioFileSprites#executeFunctionAllSprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 583 See: CB_AudioFileSprites#executeFunctionAllSprite getAudioFileBySoundInstanceId(soundInstanceId [, avoidCancelled]) → {CB_AudioFile|null} Gets the CB_AudioFile object associated to a given sound instance ID (created by the CB_AudioFileCache#play method), if any, or null otherwise. Uses the CB_AudioFileCache#getAudioFileBySoundInstanceId method internally and returns its returning value. Parameters: Name Type Argument Default Description soundInstanceId integer Used as the &quot;soundInstanceId&quot; parameter when calling the CB_AudioFileCache#getAudioFileBySoundInstanceId method internally. avoidCancelled boolean &lt;optional&gt; false Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileCache#getAudioFileBySoundInstanceId method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 987 Returns: Returns the CB_AudioFile object associated to a given sound instance ID, if any, or null otherwise. Type CB_AudioFile | null getAudioFiles( [copy]) → {array} Gets an array with all the CB_AudioFile objects. Uses the CB_AudioFileCache#getAudioFiles method internally and returns its returning value. Parameters: Name Type Argument Default Description copy boolean &lt;optional&gt; false Used as the &quot;copy&quot; parameter when calling the CB_AudioFileCache#getAudioFiles method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1255 Returns: Returns an array with all the CB_AudioFile objects. Type array getAudioFilesBusy() → {array} Gets an array with the busy CB_AudioFile objects (the objects which are not available and ready to use). Uses the CB_AudioFileCache#getAudioFilesBusy method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1277 Returns: Returns an array with the busy CB_AudioFile objects (the objects which are not available and ready to use). Type array getAudioFilesFree() → {array} Gets an array with the free CB_AudioFile objects (the objects which are available and ready to use). Uses the CB_AudioFileCache#getAudioFilesFree method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1266 Returns: Returns an array with the free CB_AudioFile objects (the objects which are available and ready to use). Type array getAudioFilesFreeNumber() → {integer} Tells the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Uses the CB_AudioFileCache#getAudioFilesFreeNumber method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1243 Returns: Returns the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Type integer getAudioFilesNumber( [real]) → {integer} Tells the number of CB_AudioFile objects created. Uses the CB_AudioFileCache#getAudioFilesNumber method internally and returns its returning value. Parameters: Name Type Argument Default Description real boolean &lt;optional&gt; false Used as the &quot;real&quot; parameter when calling the CB_AudioFileCache#getAudioFilesNumber method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1289 Returns: Returns the number of CB_AudioFile objects created. Type integer getAudioFilesUsed( [oneDimension] [, includeWithoutSpriteAssociated] [, avoidCancelled]) → {CB_AudioFileSprites.getAudioFilesUsed_OBJECT|array} Returns the CB_AudioFile objects used by all the sounds instances currently created. Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If set to false, it will return an object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the CB_AudioFile objects used. Otherwise, if set to true, it will return a numeric array with the CB_AudioFile objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the CB_AudioFile objects whose sound instance ID is not associated to any sprite). includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, it will also return the CB_AudioFile objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#getSprites method internally. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not return the CB_AudioFile objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsedBySpriteId method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 545 Returns: Returns the CB_AudioFile objects used by all the sounds instances currently created. If the &quot;oneDimension&quot; parameter is set to false, it will return a CB_AudioFileSprites.getAudioFilesUsed_OBJECT object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the CB_AudioFile objects used. Otherwise, if the &quot;oneDimension&quot; parameter set to true, it will return a numeric array with the CB_AudioFile objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the CB_AudioFile objects whose sound instance ID is not associated to any sprite). Type CB_AudioFileSprites.getAudioFilesUsed_OBJECT | array getAudioFilesUsedBySpriteId(spriteId [, avoidCancelled]) → {array} Returns an array of the CB_AudioFile objects used by the sound instances that belong to a given sprite identifier. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not return the CB_AudioFile objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFileBySoundInstanceId method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 512 Returns: Returns an array of the CB_AudioFile objects used by the sound instances that belong to the given sprite identifier. Type array getDuration( [maximum]) → {number} Tells the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the CB_AudioFile objects. Uses the CB_AudioFileCache#getDuration method internally and returns its returning value. Parameters: Name Type Argument Default Description maximum boolean &lt;optional&gt; false Used as the &quot;maximum&quot; parameter when calling the CB_AudioFileCache#getDuration method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1301 Returns: Returns the duration (minimum or maximum) of the sound stored (in milliseconds). Although the audio file cache should always be used to cache the same sound only, the duration might not always be the same due the usage of different formats, file paths, etc. So this method returns either the minimum or the maximum duration found among all the CB_AudioFile objects. Type number getFreeAudioFile( [popIt]) → {CB_AudioFileCache.getFreeAudioFile_OBJECT} Returns a free CB_AudioFile object, if any (from the CB_AudioFileCache#audioFilesFree property). Note that this will call the internal CB_AudioFileCache#_createNewAudioFilesIfNeeded method that could end creating a new CB_AudioFile object if needed. Uses the CB_AudioFileCache#getFreeAudioFile method internally and returns its returning value. Parameters: Name Type Argument Default Description popIt boolean &lt;optional&gt; false Used as the &quot;popIt&quot; parameter when calling the CB_AudioFileCache#getFreeAudioFile method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 898 Returns: Returns a CB_AudioFileCache.getFreeAudioFile_OBJECT object. Type CB_AudioFileCache.getFreeAudioFile_OBJECT getProgress( [countLoadedObjects] [, alsoUncheckedAndCheckingObjects]) → {number} Returns a number representing the percentage of the loading progress for the audio file sprites object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Uses the CB_AudioFileCache#getProgress method internally and returns its returning value. Parameters: Name Type Argument Default Description countLoadedObjects boolean &lt;optional&gt; false Used as the &quot;countLoadedObjects&quot; parameter when calling the CB_AudioFileCache#getProgress method internally. alsoUncheckedAndCheckingObjects boolean &lt;optional&gt; false Used as the &quot;alsoUncheckedAndCheckingObjects&quot; parameter when calling the CB_AudioFileCache#getProgress method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1314 Returns: Returns a number representing the percentage of the loading progress for the audio file sprites object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number getSoundInstancesId( [oneDimension] [, includeWithoutSpriteAssociated]) → {Object|array} Returns the sound instances (their ID) used (stored in the CB_AudioFileSprites#spriteSoundInstances property). Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If set to true, it will return the CB_AudioFileSprites#spriteSoundInstances property directly (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated). Otherwise, if it is set to true, it will return a numeric array whose values are the sound instance IDs. includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, it will also return the sound instance identifiers which are not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#getSprites method internally. Only used when the &quot;oneDimension&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 477 Returns: Returns the sound instances (their ID) used (stored in the CB_AudioFileSprites#spriteSoundInstances property). If the &quot;oneDimension&quot; parameter is set to false, the property names of the returning object are the sprite identifiers (strings), including one called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, and their values are an array containing the sound instance IDs. If the &quot;oneDimension&quot; parameter is set to true, it will return a numeric array whose values are the sound instance identifiers (if the &quot;includeWithoutSpriteAssociated&quot; parameter it set to true, it will also include the sound instances which are not associated to any sprite). Type Object | array getSoundInstancesIdBySpriteId(spriteId) → {array} Returns an array of the sound instance identifiers (created by the CB_AudioFileSprites#play method) used by the given sprite identifier. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 460 Returns: Returns a numeric array of the sound instances (created by the CB_AudioFileSprites#play method) used by the given sprite identifier. Type array getSprite(spriteId) → {CB_AudioFileSprites.SPRITE_OBJECT} Returns a sprite by its ID. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 422 Returns: Returns the desired sprite or a fake object if it was not found. The fake object will be this one: { &quot;startAt&quot; : 0, &quot;stopAt&quot; : null, &quot;fake&quot; : true }. Type CB_AudioFileSprites.SPRITE_OBJECT getSprites( [includeWithoutSpriteAssociated]) → {CB_AudioFileSprites.SPRITES_OBJECT} Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). Parameters: Name Type Argument Default Description includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, the returning object will also contain a property called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; whose value will be an empty object (unless the property existed before in the object stored in the CB_AudioFileSprites#sprites property and had a value which is not an empty object). If set to false, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property unless the property existed before in the object stored in the CB_AudioFileSprites#sprites property. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 438 Returns: Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). Type CB_AudioFileSprites.SPRITES_OBJECT getStatus() → {number} Gets the current status of the audio file sprites object. Uses the CB_AudioFileCache#getStatus method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1325 Returns: Returns the current status of the audio file sprites object. It is a number, which should match the value of the CB_AudioFileCache.UNLOADED (still unloaded), CB_AudioFileCache.LOADING (loading), CB_AudioFileCache.UNCHECKED (not checked by calling the CB_AudioFileCache#checkPlayingAll method yet), CB_AudioFileCache.CHECKING (being checked by the CB_AudioFileCache#checkPlayingAll method), CB_AudioFileCache.LOADED (loaded), CB_AudioFileCache.FAILED (failed loading or failed to play or by any other reason) or CB_AudioFileCache.ABORTED (aborted because it was destroyed with the &quot;destructor&quot; method) property. Type number getStatusString() → {string} Gets the current status of the audio file sprites, as a string. Uses the CB_AudioFileCache#getStatusString method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1336 Returns: Returns the current status of the audio file sprites, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a value from the CB_AudioFileCache#status property not recognized as any possible status). Type string insertSprite(sprite, spriteId) → {boolean} Inserts the given sprite. It will keep the existing ones. If a sprite identifier already existed and it is given again (not recommended), it will be replaced by the new one (but keeping its current sound instances, if any). Parameters: Name Type Description sprite CB_AudioFileSprites.SPRITE_OBJECT Object with the desired sprite. spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 326 Returns: Returns true if the sprite has been inserted or false otherwise. Type boolean insertSprites(sprites) → {integer} Inserts the given sprites. It will keep the existing ones. If a sprite identifier already existed and it is given again (not recommended), it will be replaced by the new one (but keeping its current sound instances, if any). Parameters: Name Type Description sprites CB_AudioFileSprites.SPRITES_OBJECT Object with the desired sprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 304 Returns: Returns the number of sprites inserted. Type integer isAudioFileFree(id) → {boolean} Tells whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Uses the CB_AudioFileCache#isAudioFileFree method internally and returns its returning value. Parameters: Name Type Description id string Used as the &quot;id&quot; parameter when calling the CB_AudioFileCache#isAudioFileFree method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 910 Returns: Returns whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Type boolean isPausedSprite(spriteId) → {boolean} Tells whether a given sprite (by its ID) is paused or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will return true if any of them is paused. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 658 Returns: Returns whether a given sprite (by its ID) is paused or not. Type boolean isPlaying() → {boolean} Tells whether any of the CB_AudioFile objects is playing or not. Uses the CB_AudioFileCache#isPlaying method internally and returns its returning value. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1232 Returns: Returns whether any of the CB_AudioFile objects is playing or not. Type boolean isPlayingSprite(spriteId) → {boolean} Tells whether a given sprite (by its ID) is playing or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will return true if any of them is playing. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 640 Returns: Returns whether a given sprite (by its ID) is playing or not. Type boolean isStoppedSprite(spriteId [, checkAudioFileObjects]) → {boolean} Tells whether a given sprite (by its ID) is stopped or not. Note that there could be more than one sound instance (with a {@CB_AudioFile} object) by each sprite with different status (paused, stopped, etc.) and this method will only return true if all of them are stopped. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. checkAudioFileObjects boolean &lt;optional&gt; false If set to true, it will check all the {@CB_AudioFile} objects associated to the sprite. Doing so, as internally all stopped {@CB_AudioFile} objects are disassociated from their sound instances, this method should return false normally (unless something went wrong). Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 678 Returns: Returns whether a given sprite (by its ID) is stopped or not. As internally all stopped {@CB_AudioFile} objects are disassociated from their sound instances, this method should return false normally (unless something went wrong). Type boolean load(dataObject) → {CB_AudioFileSprites|null} Loads the audio file sprites with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Description dataObject CB_AudioFileSprites.DATA_OBJECT Object with the desired data and options for the audio file sprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 256 Returns: If a &quot;dataObject&quot; is given, it returns the current CB_AudioFileSprites object. Otherwise, it returns null. Type CB_AudioFileSprites | null muteAll( [onMute] [, audioFiles]) → {integer} Mutes all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileCache#muteAll method internally and returns its returning value. Parameters: Name Type Argument Default Description onMute function &lt;optional&gt; Used as the &quot;onMute&quot; parameter when calling the CB_AudioFileCache#muteAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#muteAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1176 Returns: Returns the number of calls to the CB_AudioFile#mute method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer muteSprite(spriteId [, onMute]) → {integer} Mutes all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) used by a given sprite identifier. Uses the CB_AudioFileSprites#muteAll method internally and returns its returning value. Parameters: Name Type Argument Description spriteId string The identifier for the sprite. onMute function &lt;optional&gt; Callback function which will be called for each audio file if it has been possible to mute it (or at least it was possible to try it), being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onMute&quot; parameter to call the CB_AudioFileSprites#muteAll method. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 768 Returns: Returns the number of calls to the CB_AudioFile#mute method that were performed internally. Type integer pauseAll( [onPause] [, audioFiles]) → {integer} Tries to pause all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#pause method internally. Uses the CB_AudioFileCache#pauseAll method internally and returns its returning value. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Used as the &quot;onPause&quot; parameter when calling the CB_AudioFileCache#pauseAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#pauseAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1129 Returns: Returns the number of calls to the CB_AudioFile#pause method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer pauseSprite(spriteId [, onPause]) → {integer} Pauses all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) which are playing used by a given sprite identifier. Uses the CB_AudioFileSprites#pauseAll method internally and returns its returning value. Parameters: Name Type Argument Description spriteId string The identifier for the sprite. onPause function &lt;optional&gt; Function without parameters to be called when the audio is paused successfully, being &quot;this&quot; the CB_AudioFile object. Used internally as the &quot;onPause&quot; parameter to call the CB_AudioFileSprites#pauseAll method. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 738 Returns: Returns the number of calls to the CB_AudioFile#pause method that were performed internally. Type integer play( [startAt] [, stopAt] [, loop] [, volume] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop] [, spriteId]) → {integer|null} Plays a sound of the cache (if there is any free), using a sprite if desired. If a sound cannot be played, this method can call itself internally again and again (with most of the given parameters being the same, depending on the circumstances) to try to play the sound until a desired time limit is reached. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). Uses the CB_AudioFileCache#play method internally and returns its returning value. Internal usage only recommended. To play a sprite, better use the CB_AudioFileSprites#playSprite method instead. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Used as the &quot;startAt&quot; parameter when calling the CB_AudioFileCache#play method internally. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Used as the &quot;stopAt&quot; parameter when calling the CB_AudioFileCache#play method internally. loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileCache#play method internally. volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileCache#play method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileCache#play method internally. allowedRecursiveDelaySkipping boolean &lt;optional&gt; stopAt-startAt Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the CB_AudioFileCache#play method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileCache#play method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileCache#play method internally. spriteId string &lt;optional&gt; '_WITHOUT_SPRITE_ASSOCIATED' The identifier for the sprite. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1007 Returns: Returns null if a sprite identifier was given but it could not be found. Otherwise, returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. Type integer | null playAll( [startAt] [, stopAt] [, loop] [, volume] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onStop] [, includingPlaying]) → {integer} Tries to play all the CB_AudioFile objects by calling their CB_AudioFile#play method internally. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). Uses the CB_AudioFileCache#playAll method internally and returns its returning value. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Used as the &quot;startAt&quot; parameter when calling the CB_AudioFileCache#playAll method internally. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Used as the &quot;stopAt&quot; parameter when calling the CB_AudioFileCache#playAll method internally. loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileCache#playAll method internally. volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileCache#playAll method internally. avoidDelayedPlay boolean &lt;optional&gt; false Used as the &quot;avoidDelayedPlay&quot; parameter when calling the CB_AudioFileCache#playAll method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileCache#playAll method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileCache#playAll method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileCache#playAll method internally. includingPlaying boolean &lt;optional&gt; false Used as the &quot;includingPlaying&quot; parameter when calling the CB_AudioFileCache#playAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1091 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer playAndStopAll( [includingPlaying] [, delayBeforeStop]) → {integer} Plays silently and stops all CB_AudioFile objects after a desired time. It can be useful for some clients which need the CB_AudioFile#play method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls CB_AudioFileCache#playAll(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the CB_AudioFileCache#stopAll method. Uses the CB_AudioFileCache#playAndStopAll method internally and returns its returning value. Parameters: Name Type Argument Default Description includingPlaying boolean &lt;optional&gt; false Used as the &quot;includingPlaying&quot; parameter when calling the CB_AudioFileCache#playAndStopAll method internally. delayBeforeStop number &lt;optional&gt; 100 Used as the &quot;delayBeforeStop&quot; parameter when calling the CB_AudioFileCache#playAndStopAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1116 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer playSprite(spriteId [, loop] [, volume] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop]) → {integer|null} Plays a sprite by its ID. If the sprite is found, uses the CB_AudioFileSprites#play method internally and returns its returning value. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. Used as the &quot;spriteId&quot; parameter when calling the CB_AudioFileSprites#play method internally. loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileSprites#play method internally. volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileSprites#play method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileSprites#play method internally. allowedRecursiveDelaySkipping boolean &lt;optional&gt; stopAt-startAt Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the CB_AudioFileSprites#play method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileSprites#play method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileSprites#play method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 711 Returns: Returns null if the sprite was not found. Otherwise, returns the sound instance ID used if there was one free or null otherwise. To get a sound instance returned does not mean necessarily that the sound started playing so it is necessary to use a callback function as the &quot;onPlayStart&quot; parameter for checking this. The sound instance created (if any), will be cancelled automatically once the sound is stopped. Type integer | null purge(desiredNumber [, setAsMinimumAudioFiles] [, includePlaying] [, stopSounds] [, statuses]) → {integer} Tries to purge the audio file cache until it reaches a desired number of CB_AudioFile objects internally (set in the CB_AudioFileCache#audioFiles property), by removing and destroying some of the current CB_AudioFile objects. For performance purposes. Uses the CB_AudioFileCache#purge method internally and returns its returning value. Parameters: Name Type Argument Default Description desiredNumber integer Used as the &quot;desiredNumber&quot; parameter when calling the CB_AudioFileCache#purge method internally. setAsMinimumAudioFiles boolean &lt;optional&gt; false Used as the &quot;setAsMinimumAudioFiles&quot; parameter when calling the CB_AudioFileCache#purge method internally. includePlaying boolean &lt;optional&gt; false Used as the &quot;includePlaying&quot; parameter when calling the CB_AudioFileCache#purge method internally. stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling the CB_AudioFileCache#purge method internally. statuses array &lt;optional&gt; Array(CB_AudioFile.LOADING, CB_AudioFile.UNCHECKED, CB_AudioFile.CHECKING, CB_AudioFile.LOADED) Used as the &quot;statuses&quot; parameter when calling the CB_AudioFileCache#purge method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 886 Returns: Returns the number of CB_AudioFile objects removed. Type integer removeAudioFile(audioObjectOrId [, reload] [, checkManually]) → {boolean|CB_AudioFile|null} If found, takes a given CB_AudioFile object off the CB_AudioFileCache#audioFiles property (and reloads it if we want to). NOTE: It does neither destroy nor remove the CB_AudioFile object so it can be used for other purposes (and if a CB_AudioFile object is given, it will be tried to be reused by the CB_AudioFileCache#createAudioFile method internally if it is called). Uses the CB_AudioFileCache#removeAudioFile method internally and returns its returning value. Internal usage only recommended. Parameters: Name Type Argument Default Description audioObjectOrId CB_AudioFile | string Used as the &quot;audioObjectOrId&quot; parameter when calling the CB_AudioFileCache#removeAudioFile method internally. reload boolean &lt;optional&gt; false Used as the &quot;reload&quot; parameter when calling the CB_AudioFileCache#removeAudioFile method internally. checkManually boolean &lt;optional&gt; false Used as the &quot;checkManually&quot; parameter when calling the CB_AudioFileCache#removeAudioFile method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 870 Returns: Returns null if the given &quot;audioObjectOrId&quot; parameter is not a valid CB_AudioFile object or its CB_AudioFile#id property is not set or when the &quot;audioObjectOrId&quot; parameter is an empty string. Returns a CB_AudioFile object, the given one through the &quot;audioObjectOrId&quot; parameter of the first one removed (it should be the first and unique one removed as the ID must be unique), if the CB_AudioFileCache#createAudioFile method is called internally (it will reuse this CB_AudioFile object). Otherwise, returns true if all goes well. Type boolean | CB_AudioFile | null removeSprite(spriteId) → {boolean} Removes a sprite by its ID. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 394 Returns: Returns true if the sprite has been deleted or false otherwise. Type boolean removeSprites() Removes all the sprites by clearing the CB_AudioFileSprites#sprites property. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 292 removeSpritesAll() Alias for CB_AudioFileSprites#removeSprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 283 See: CB_AudioFileSprites#removeSprites resumeAll( [loop] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop] [, audioFiles] [, spriteId]) → {array} Resumes all the existing CB_AudioFile objects or the desired ones (if provided), which are paused (and not stopped). Can be focused on just one sprite identifier if desired. Uses the CB_AudioFileCache#resumeAll method internally and returns its returning value. Internal usage only recommended. To resume a sprite, better use the CB_AudioFileSprites#resumeSprite method instead. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. allowedRecursiveDelaySkipping boolean &lt;optional&gt; CB_AudioFile#lastStopAt-CB_AudioFile#lastStartAt Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#resumeAll method internally. spriteId string &lt;optional&gt; '_WITHOUT_SPRITE_ASSOCIATED' The identifier for the sprite. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1147 Returns: Returns null if a sprite identifier was given but it could not be found. Otherwise, returns a numeric array containing all the return values of each internal call to the CB_AudioFileCache#play method. Type array resumeSprite(spriteId [, loop] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop]) → {array} Resumes all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) used by a given sprite identifier. Uses the CB_AudioFileSprites#resumeAll method internally and returns its returning value. Parameters: Name Type Argument Default Description spriteId string Used as the &quot;spriteId&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. allowedRecursiveDelaySkipping boolean &lt;optional&gt; stopAt-startAt Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 755 Returns: Returns null if the sprite identifier given could not be found. Otherwise, returns a numeric array containing all the return values of each internal call to the CB_AudioFileCache#play method (called through CB_AudioFileSprites#resumeAll). Type array setAudioAPIAll(preferredAPIs [, callbackOk] [, callbackError] [, mandatory] [, forceReload] [, audioFiles]) → {integer} Tries to change the audio API for all the existing CB_AudioFile objects or the desired ones (if provided). This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. Uses the CB_AudioFileCache#setAudioAPIAll method internally and returns its returning value. Parameters: Name Type Argument Default Description preferredAPIs array | string Used as the &quot;preferredAPIs&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. callbackOk CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK &lt;optional&gt; Used as the &quot;callbackOk&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. callbackError CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR &lt;optional&gt; Used as the &quot;callbackError&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. mandatory boolean &lt;optional&gt; false Used as the &quot;mandatory&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. forceReload string &lt;optional&gt; false Used as the &quot;forceReload&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#setAudioAPIAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1221 Returns: Returns the number of calls to the CB_AudioFile#setAudioAPI method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer setAudioAPISprite(spriteId, preferredAPIs [, callbackOk] [, callbackError] [, mandatory] [, forceReload]) → {integer} Tries to change the desired audio API of the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) used by a given sprite identifier. Uses the CB_AudioFileSprites#setAudioAPIAll method internally and returns its returning value. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. preferredAPIs array Used as the &quot;preferredAPIs&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. callbackOk CB_AudioFileCache.setAudioAPIAll_CALLBACK_OK &lt;optional&gt; Used as the &quot;callbackOk&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. callbackError CB_AudioFileCache.setAudioAPIAll_CALLBACK_ERROR &lt;optional&gt; Used as the &quot;callbackError&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. mandatory boolean &lt;optional&gt; false Used as the &quot;mandatory&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. forceReload string &lt;optional&gt; false Used as the &quot;forceReload&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 813 Returns: Returns the number of calls to the CB_AudioFile#setAudioAPI method that were performed internally. Type integer setStartAtSprite(spriteId, startAt) → {boolean} Sets when a sprite begins (stored in its &quot;startAt&quot; property), by sprite identifier. Parameters: Name Type Description spriteId string The identifier for the sprite. startAt number The time (in milliseconds) of the audio file where the audio sprite starts. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 351 Returns: Returns true if the sprite has been modified or false otherwise. Type boolean setStopAtSprite(spriteId, stopAt) → {boolean} Sets when a sprite ends (stored in its &quot;stopAt&quot; property), by sprite identifier. Parameters: Name Type Description spriteId string The identifier for the sprite. stopAt number The time (in milliseconds) of the audio file where the audio sprite ends. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 373 Returns: Returns true if the sprite has been modified or false otherwise. Type boolean setVolumeAll( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, audioFiles]) → {integer} Sets the same volume for all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileCache#setVolumeAll method internally and returns its returning value. Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileCache#setVolumeAll method internally. forceSetVolumeProperty boolean &lt;optional&gt; false Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the CB_AudioFileCache#setVolumeAll method internally. onSetVolume function &lt;optional&gt; Used as the &quot;onSetVolume&quot; parameter when calling the CB_AudioFileCache#setVolumeAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#setVolumeAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1204 Returns: Returns the number of calls to the CB_AudioFile#setVolume method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer setVolumeSprite(spriteId [, volume] [, forceSetVolumeProperty] [, onSetVolume]) → {integer} Sets the same desired volume to all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) used by a given sprite identifier. Uses the CB_AudioFileSprites#setVolumeAll method internally and returns its returning value. Parameters: Name Type Argument Default Description spriteId string The identifier for the sprite. volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. forceSetVolumeProperty boolean &lt;optional&gt; false Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. onSetVolume function &lt;optional&gt; Used as the &quot;onSetVolume&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 796 Returns: Returns the number of calls to the CB_AudioFile#setVolume method that were performed internally. Type integer stopAll( [audioFiles]) → {integer} Tries to stops all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#stop method internally. Uses the CB_AudioFileCache#stopAll method internally and returns its returning value. Parameters: Name Type Argument Default Description audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#stopAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1103 Returns: Returns the number of calls to the CB_AudioFile#stop method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer stopSprite(spriteId) → {integer} Stops all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) which are playing used by a given sprite identifier. Uses the CB_AudioFileSprites#stopAll method internally and returns its returning value. Parameters: Name Type Description spriteId string The identifier for the sprite. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 725 Returns: Returns the number of calls to the CB_AudioFile#stop method that were performed internally. Type integer unmuteAll( [onUnmute] [, audioFiles]) → {integer} Unmutes all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileCache#unmuteAll method internally and returns its returning value. Parameters: Name Type Argument Default Description onUnmute function &lt;optional&gt; Used as the &quot;onUnmute&quot; parameter when calling the CB_AudioFileCache#unmuteAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileCache#unmuteAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 1189 Returns: Returns the number of calls to the CB_AudioFile#unmute method that were performed (which should be the same number as the CB_AudioFile objects in the &quot;audioFiles&quot; parameter). Type integer unmuteSprite(spriteId [, onUnmute]) → {integer} Unmutes all the CB_AudioFile objects that belong to the sound instances (created by the CB_AudioFileSprites#play or the CB_AudioFileSprites#playSprite methods) used by a given sprite identifier. Uses the CB_AudioFileSprites#unmuteAll method internally and returns its returning value. Parameters: Name Type Argument Description spriteId string The identifier for the sprite. onUnmute function &lt;optional&gt; Used internally as the &quot;onUnmute&quot; parameter to call the CB_AudioFileSprites#unmuteAll method. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 781 Returns: Returns the number of calls to the CB_AudioFile#unmute method that were performed internally. Type integer Type Definitions DATA_OBJECT Object with the desired data and options for the audio sprites. It is almost identical to the CB_AudioFileCache.DATA_OBJECT but adding a &quot;sprites&quot; property. Type: Object Properties: Name Type Argument Default Description URIs CB_AudioFileCache.URIS_OBJECT Object whose property names audio formats and their value is an array of strings with the URIs (audio file paths or audio data URIs) of the audio files in order of preference. The best audio format for the current client will be tried to be calculated and it will use the first working URI (audio file path or data URI). The more audio formats and URIs provided the better, as it will help to maximize the compatibility with as many clients as possible (as some audio APIs and client just support some formats, or use absolute paths instead of relative ones, etc.). Even with different formats, all provided URIs should belong to the same audio (this means same sound or same music, with same length, etc.). NOTE: Only some clients with some audio APIs will support data URIs. If a valid value is given, this will be added to the CB_AudioFileCache#URIs property. sprites CB_AudioFileSprites.SPRITES_OBJECT &lt;optional&gt; Object with the desired sprites. It will be used as the first parameter to call the CB_AudioFileSprites#insertSprites method internally. It will be added (after being processed) to the CB_AudioFileCache#sprites property. id string &lt;optional&gt; &quot;&quot; Desired identifier for the audio file sprites object. Internal usage only recommended. If a valid value is given, this will be added to the CB_AudioFileSprites#id property as well as to the CB_AudioFileCache#id property of the internally-created CB_AudioFileCache object. preferredAPIs array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileCache#preferredAPIs property. preferredFormats array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileCache#preferredFormats property. minimumAudioFiles integer &lt;optional&gt; CB_AudioFileCache.minimumAudioFiles_DEFAULT Minimum CB_AudioFile objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the CB_AudioFileCache#minimumAudioFiles property. maximumAudioFiles integer &lt;optional&gt; CB_AudioFileCache.maximumAudioFiles_DEFAULT Maximum CB_AudioFile objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the CB_AudioFileCache#minimumAudioFiles property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileCache#maximumAudioFiles property. minimumAudioFilesFree integer &lt;optional&gt; parseInt(CB_AudioFileCache#minimumAudioFiles * 0.25 + 0.5) New CB_AudioFile objects will be created internally when the number of free CB_AudioFile objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the CB_AudioFileCache#minimumAudioFiles by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the CB_AudioFileCache#minimumAudioFilesFree property. newAudioFilesWhenNeeded integer &lt;optional&gt; Math.min(parseInt(CB_AudioFileCache#minimumAudioFiles * 0.1 + 0.5), 1) Number of new CB_AudioFile objects to create internally when the minimum limit of free CB_AudioFile objects (CB_AudioFileCache#minimumAudioFilesFree) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the CB_AudioFileCache#minimumAudioFiles by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileCache#newAudioFilesWhenNeeded property. retries integer &lt;optional&gt; CB_AudioFileCache.retries_DEFAULT Number of retries to try to load a CB_AudioFile object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the CB_AudioFileCache#retries property. checkManually boolean &lt;optional&gt; CB_AudioFileCache.checkManually_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the CB_AudioFileCache#checkManually property. checkManuallyOnNeededCreated boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when creates a new CB_AudioFile object needed. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnNeededCreated property. checkManuallyOnPlayingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnPlayingFailed property. checkManuallyOnCheckingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileCache#checkManuallyOnCheckingFailed property. onLoad function &lt;optional&gt; Desired function to be called once the cache has been loaded. The first and unique parameter will be an integer with the CB_AudioFile objects that still need to be checked, if any, being &quot;this&quot; the current CB_AudioFileCache object. If a valid value is given, this will be added to the CB_AudioFileCache#onLoad property. onError function &lt;optional&gt; Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current CB_AudioFileCache object. If a valid value is given, this will be added to the CB_AudioFileCache#onError property. disableAutoLoad boolean &lt;optional&gt; false If set to true, it will not create automatically the CB_AudioFile objects by calling the CB_AudioFileCache#createAudioFiles method internally. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 33 getAudioFilesUsed_OBJECT Object returned by the CB_AudioFileSprites#getAudioFilesUsed method. Each property names will be the sprites identifiers except the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated (if we wanted to include them). Type: Object Properties: Name Type Description spriteId CB_AudioFile Each property name will be a sprite identifier (it can be &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; for sound instances without a sprite associated, if we wanted to include them). The value will be a numeric array with the CB_AudioFile objects used. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 530 SPRITE_OBJECT An object representing an audio sprite which can contain, optionally, the &quot;startAt&quot; and &quot;stopAt&quot; properties with a numeric value (representing when the audio sprite starts and when it stops, respectively). If not set, the default &quot;startAt&quot; value will be 0 (zero) and the default &quot;stopAt&quot; value will be null (which means it will not stop until the end of the audio is reached unless it is paused or stopped before). The &quot;fake&quot; property should never be used as it is used internally to distinguish real sprites from fake ones (generated and returned by the CB_AudioFileSprites#getSprite method when a requested sprite is not found). Type: Object Properties: Name Type Argument Default Description startAt number &lt;optional&gt; 0 The time (in milliseconds) of the audio file where the audio sprite starts. If not provided, it will use the value of 0 (zero) which means that it will start from the beginning. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() The time (in milliseconds) of the audio file where the audio sprite stops. If not provided (not recommended), it will use the whole duration of the file (which means until it reaches its end). NOTE: Due to some possible problems between clients with different audio APIs calculating the duration of an audio file, it is recommended to always set the &quot;stopAt&quot; property even when we want it to stop at the end of the audio. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 7 Example { startAt: 10, stopAt: 20 } SPRITES_OBJECT Object whose property names the identifiers of each sprite (a case-sensitive string) and their value is a CB_AudioFileSprites.SPRITE_OBJECT object. Type: Object Properties: Name Type Description spriteInformation CB_AudioFileSprites.SPRITE_OBJECT Being the name of each property the identifier of a sprite (a string which cannot be &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; as it is a reserved name), the value will always be a CB_AudioFileSprites.SPRITE_OBJECT object. Source: CrossBase/audiovisual/audio/CB_AudioFileSprites.js, line 17 Example { &quot;whole_audio&quot; : {}, &quot;first_sprite&quot; : { stopAt: 10 }, &quot;second_sprite&quot; : { startAt: 10, stopAt: 20 }, &quot;third_sprite&quot; : { startAt: 20 }, ... } × Search results Close "},"CB_AudioFileSpritesPool.html":{"id":"CB_AudioFileSpritesPool.html","title":"Class: CB_AudioFileSpritesPool","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_AudioFileSpritesPool CB_AudioFileSpritesPool Class to manage many audio sprites stored in different groups, each with one CB_AudioFileSprites object (used internally). new CB_AudioFileSpritesPool( [dataObject]) → {CB_AudioFileSpritesPool} The constructor is recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Argument Description dataObject CB_AudioFileSpritesPool.DATA_OBJECT &lt;optional&gt; Object with the desired data and options for the groups of audio sprites. Each group will have a CB_AudioFileSprites object. Some of its properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) will be used as the default value to create internally the CB_AudioFileSprites objects when the value is not given in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object (set as the value of the CB_AudioFileSpritesPool.DATA_OBJECT#spritesGroups property). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 54 To Do: Do not allow to create one object with an &quot;id&quot; which has already been used (unless the value is undefined, null...). Method getCopy and static method filterProperties (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Returns: Returns a new CB_AudioFileSpritesPool object. Type CB_AudioFileSpritesPool Members &lt;static, constant&gt; ABORTED :integer Status value for an audio file sprites pool which has been aborted. This will happen when the audio file sprites pool has been destroyed with the CB_AudioFileSpritesPool#destructor method. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 6 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 276 &lt;static, constant&gt; CHECKING :integer Status value for an audio file sprites pool which is being checked currently. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 3 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 252 &lt;static, constant&gt; FAILED :integer Status value for an audio file sprites pool which failed to be loaded or failed for any other reason. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 5 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 268 &lt;static, constant&gt; LOADED :integer Status value for an audio file sprites pool which has been loaded. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 4 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 260 &lt;static, constant&gt; LOADING :integer Status value for an audio file sprites pool which is loading. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 1 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 236 &lt;static, constant&gt; UNCHECKED :integer Status value for an audio file sprites pool which has not been checked yet. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 2 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 244 &lt;static, constant&gt; UNLOADED :integer Status value for audio file sprites pool which is unloaded. Can be used to compare the value returned by the CB_AudioFileSpritesPool#getStatus method. Recommended for internal usage only. Type: integer Default Value: 0 Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 228 &lt;readonly&gt; audioFileSprites :Object Stores the internally-created CB_AudioFileSprites objects, using the name of each property as their group ID and the value being the CB_AudioFileSprites object itself. Internal usage only recommended. Type: Object Default Value: {} Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 203 &lt;readonly&gt; checkManually :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually). Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManually_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 140 &lt;readonly&gt; checkManuallyOnCheckingFailed :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 167 &lt;readonly&gt; checkManuallyOnNeededCreated :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when creates a new CB_AudioFile object needed. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 149 &lt;readonly&gt; checkManuallyOnPlayingFailed :boolean Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. Internal usage only recommended. Type: boolean Default Value: CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 158 &lt;readonly&gt; disableAutoLoad :boolean If set to true, it will not create automatically the CB_AudioFile objects by calling the CB_AudioFileCache#createAudioFiles method internally. Internal usage only recommended. Type: boolean Default Value: false Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 176 &lt;readonly&gt; id :string Stores the identifier for the audio file sprites pool object. Type: string Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 67 &lt;readonly&gt; maximumAudioFiles :integer|null Maximum CB_AudioFile objects that are to be created internally for each CB_AudioFileSprites object. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the CB_AudioFileCache#minimumAudioFiles property, allowing 1 minimum. Internal usage only recommended. Type: integer | null Default Value: CB_AudioFileCache.maximumAudioFiles_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 103 &lt;readonly&gt; minimumAudioFiles :integer Minimum CB_AudioFile objects to create internally for each CB_AudioFileSprites object. It must be an integer being 1 the minimum. Internal usage only recommended. Type: integer Default Value: CB_AudioFileCache.minimumAudioFiles_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 94 &lt;readonly&gt; minimumAudioFilesFree :integer New CB_AudioFile objects will be created internally for each CB_AudioFileSprites object when the number of free CB_AudioFile objects reaches this limit. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. Type: integer Default Value: parseInt(CB_AudioFileCache#minimumAudioFiles * 0.25 + 0.5) Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 112 &lt;readonly&gt; newAudioFilesWhenNeeded :integer Number of new CB_AudioFile objects to create internally for each CB_AudioFileSprites object when the minimum limit of free CB_AudioFile objects (CB_AudioFileCache#minimumAudioFilesFree) is reached. It must be an integer being 0 (zero) the minimum. Internal usage only recommended. Type: integer Default Value: Math.min(parseInt(CB_AudioFileCache#minimumAudioFiles * 0.1 + 0.5), 1) Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 121 &lt;readonly&gt; onError :function Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current CB_AudioFileSpritesPool object. If a function is set, it will always be called through the CB_AudioFileSpritesPool#errorFunction method whenever the &quot;onError&quot; event of an internally-created CB_AudioFileSprites object is fired. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 194 &lt;readonly&gt; onLoad :function Desired function to be called once the pool has been loaded. The first and unique parameter will be an integer with the CB_AudioFile objects that still need to be checked, if any, being &quot;this&quot; the current CB_AudioFileSpritesPool object. Type: function Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 185 &lt;readonly&gt; preferredAPIs :array Stores an array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Internal usage only recommended. Type: array Default Value: CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 76 &lt;readonly&gt; preferredFormats :array Stores an array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. Internal usage only recommended. Type: array Default Value: CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 85 &lt;readonly&gt; retries :integer Number of retries to try to load a CB_AudioFile object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. Internal usage only recommended. Type: integer Default Value: CB_AudioFileCache.retries_DEFAULT Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 130 Methods cancelSoundInstance(soundInstanceId [, cancel] [, affectWithObjectAssociated]) → {boolean} Cancels (to prevent it starts playing) or enables a sound instance (created by the CB_AudioFileCache#play method), by its identifier. Uses the CB_AudioFileSprites#cancelSoundInstance method internally. Parameters: Name Type Argument Default Description soundInstanceId integer Used as the &quot;soundInstanceId&quot; parameter when calling the CB_AudioFileSprites#cancelSoundInstance method internally. cancel boolean &lt;optional&gt; false Used as the &quot;cancel&quot; parameter when calling the CB_AudioFileSprites#cancelSoundInstance method internally. affectWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the CB_AudioFileSprites#cancelSoundInstance method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 900 Returns: Returns true if the sound instance has been modified or false otherwise. Type boolean cancelSoundInstances( [cancel] [, affectWithObjectAssociated]) → {integer} Cancels (to prevent they start playing) or enables all sound instances (created by the CB_AudioFileCache#play method). Uses the CB_AudioFileSprites#cancelSoundInstances method internally. Parameters: Name Type Argument Default Description cancel boolean &lt;optional&gt; false Used as the &quot;cancel&quot; parameter when calling the CB_AudioFileSprites#cancelSoundInstances method internally. affectWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;affectWithObjectAssociated&quot; parameter when calling the CB_AudioFileSprites#cancelSoundInstances method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 881 Returns: Returns the number of sound instances modified. Type integer checkPlayingAll( [callbackOk] [, callbackError] [, ignoreQueue] [, ignoreStatus]) → {integer} Checks whether each CB_AudioFile object whose CB_AudioFile#getStatus method returns the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) can be played or not. After checking, if the audio can be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.LOADED. Otherwise, if it cannot be played, the status of the CB_AudioFile object will get the value of CB_AudioFile.FAILED. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). It will call the CB_AudioFileCache#clearAudioFiles method internally after finishing each call to the CB_AudioFileSprites#checkPlayingAll method. Uses the CB_AudioFileSprites#checkPlayingAll method internally. Recommended to be called through a user-driven event (as onClick, onTouch, etc.). Parameters: Name Type Argument Default Description callbackOk CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_OK &lt;optional&gt; A function which will be called if all the CB_AudioFile objects whose CB_AudioFile#getStatus method returned the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) could finally be checked successfully and all can be played, being &quot;this&quot; the CB_AudioFileSpritesPool object itself. callbackError CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR &lt;optional&gt; A function which will be called if not all the CB_AudioFile objects whose CB_AudioFile#getStatus method returned the &quot;unchecked&quot; value (which belongs to the value of the CB_AudioFile#UNCHECKED property) could finally be checked successfully and any cannot be played, being &quot;this&quot; the CB_AudioFileSpritesPool object itself. This function will be called immediately if the method was previously called and it is still running currently. ignoreQueue boolean &lt;optional&gt; false Used as the &quot;ignoreQueue&quot; parameter when calling the CB_AudioFileSprites#checkPlayingAll method internally. ignoreStatus boolean &lt;optional&gt; false If it is set to false and the sprites pool object is loaded (the CB_AudioFileSpritesPool#getStatus method returns the value set in the CB_AudioFileSpritesPool.LOADED property), it will exit returning an error. Otherwise, if it is set to true, it will ignore the current sprites pool object status. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1038 Returns: Returns the number of CB_AudioFile objects whose status belonged to the &quot;unchecked&quot; value (the value of the CB_AudioFile#UNCHECKED property) before the execution of this method. It will return 0 (zero) if the method is tried to be executed while there is another previous call of it still running. It will also return 0 (zero) if the status of audio sprites pool is neither loaded (the CB_AudioFileSpritesPool#getStatus method does not returns the value set in the CB_AudioFileSpritesPool.LOADED property) nor unchecked (the CB_AudioFileSpritesPool#status method does not return the value set in the CB_AudioFileSpritesPool.UNCHECKED property). Type integer clearAudioFiles( [avoidCallingCheckCacheLoaded]) → {array} Cleans the arrays of the CB_AudioFile objects (taking off the undefined or null ones) which is in the CB_AudioFileCache#audioFiles property used by each CB_AudioFileSprites object, just keeping the valid ones and clearing (destroying and removing) the others. For performance purposes. Uses the CB_AudioFileSprites#clearAudioFiles method internally. Internal usage only recommended. Parameters: Name Type Argument Default Description avoidCallingCheckCacheLoaded boolean &lt;optional&gt; false Used as the &quot;avoidCallingCheckCacheLoaded&quot; parameter when calling the CB_AudioFileSprites#clearAudioFiles method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 809 Returns: Returns an object whose each property name is the sprites group ID and each value is the returning value of calling internally the CB_AudioFileSprites#clearAudioFiles method. Type array clearSoundInstances( [clearWithObjectAssociated]) → {integer} Clears the sound instances (created by the CB_AudioFileCache#play method) which have been cancelled. Uses the CB_AudioFileSprites#clearSoundInstances method internally. Parameters: Name Type Argument Default Description clearWithObjectAssociated boolean &lt;optional&gt; false Used as the &quot;clearWithObjectAssociated&quot; parameter when calling the CB_AudioFileSprites#clearSoundInstances method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 863 Returns: Returns the number of cleared sound instances. Type integer destroyAll( [stopSounds]) → {integer} Destroys all the CB_AudioFile objects and frees memory, by calling CB_AudioFile#destructor(stopSounds, false, true). Uses the CB_AudioFileSprites#destroyAll method internally. Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling the CB_AudioFileSprites#destroyAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 992 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#destructor has been called. Type integer destructor( [stopSounds] [, preventAbortedStatus]) Destroys the audio file sprites pool object (removing all sprites, etc.), including the internal audio file sprites objects, and frees memory. By default, unless the &quot;preventAbortedStatus&quot; is set to true, sets the current status of all the CB_AudioFileCache objects as ABORTED (CB_AudioFileCache.ABORTED value). Internally, calls the CB_AudioFileSprites#destructor method of all the internally-created CB_AudioFileSprites objects. Parameters: Name Type Argument Default Description stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling internally the CB_AudioFileSprites#destructor method of all the internally-created CB_AudioFileSprites objects. preventAbortedStatus boolean &lt;optional&gt; false If set to true (not recommended), it will not assign the status of &quot;ABORTED&quot; (it will not set the CB_AudioFileSpritesPool#_aborted property to true}. Used as the &quot;preventAbortedStatus&quot; parameter when calling internally the CB_AudioFileSprites#destructor method of all the internally-created CB_AudioFileSprites objects. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 325 errorFunction( [message] [, ignorePreviousExecution]) → {boolean} Calls the error function which should be set in the CB_AudioFileSprites#onError property (if any), being &quot;this&quot; the CB_AudioFileSpritesPool object itself. Internal usage only recommended. Parameters: Name Type Argument Default Description message string &lt;optional&gt; The message describing the error that will be sent to the set CB_AudioFileSprites#onError function (if any) as the first and unique parameter. ignorePreviousExecution boolean &lt;optional&gt; false If it is set to false, the function set in the CB_AudioFileSprites#onError property (if any) will only be called if it was not executed previously. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1697 Returns: Returns true if the CB_AudioFileSprites#onError function could be called or false otherwise. Type boolean executeAll() Alias for CB_AudioFileSpritesPool#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 929 See: CB_AudioFileSpritesPool#executeFunctionAll executeAllSprites() Alias for CB_AudioFileSpritesPool#executeFunctionAllSprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 758 See: CB_AudioFileSpritesPool#executeFunctionAllSprites executeAllSubSprites() Alias for CB_AudioFileSpritesPool#executeFunctionAllSubSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1248 See: CB_AudioFileSpritesPool#executeFunctionAllSubSprites executeFunctionAll(functionEach [, delayBetweenEach] [, audioFiles] [, returnArrayOfSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing CB_AudioFile objects or on the desired ones (if provided). Uses the CB_AudioFileSprites#executeFunctionAll method internally. Parameters: Name Type Argument Default Description functionEach CB_Arrays.CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Used as the &quot;functionEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 Used as the &quot;delayBetweenEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. Note that each call to the CB_AudioFileSprites#executeFunctionAll method will be performed sequentially one after the other, without adding a delay. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. returnArrayOfSetTimeoutsArray boolean &lt;optional&gt; false If it is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed. Otherwise, if it is set to true, it will return a numeric array and each value (which will belong to each sprites group) will be another numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile of that sprites group. delayBetweenEachAffectsFirst boolean &lt;optional&gt; false Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAll method internally. Note that each call to the CB_AudioFileSprites#executeFunctionAll method will be performed sequentially one after the other, without adding a delay. functionFinish CB_AudioFileSpritesPool.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array containing all the items which were looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 951 To Do: Think about consider executing only one by one (now it will loop CB_AudioFile objects from different sprites groups simultaneously). Returns: If the &quot;returnArrayOfSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed. Otherwise, if the &quot;returnArrayOfSetTimeoutsArray&quot; is set to true, it will return a numeric array and each value will be another numeric array with a CB_AudioFileCache.executeFunctionAll_OBJECT object for each CB_AudioFile given. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array executeFunctionAllSprites(functionEach [, delayBetweenEach] [, includeWithoutSpriteAssociated] [, avoidCancelled] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer} Executes a desired function for all the CB_AudioFile objects used by all the sound instances currently created of each sprite group. It calls the CB_AudioFileSprites#executeFunctionAllSprites method internally. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Used as the &quot;functionEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAllSprites method internally. delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 Used as the &quot;delayBetweenEach&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAllSprites method internally. Note that each call to the CB_AudioFileSprites#executeFunctionAllSprites method will be performed sequentially one after the other, without adding a delay. includeWithoutSpriteAssociated boolean &lt;optional&gt; false Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAllSprites method internally. avoidCancelled boolean &lt;optional&gt; false Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAllSprites method internally. delayBetweenEachAffectsFirst boolean &lt;optional&gt; false Used as the &quot;delayBetweenEachAffectsFirst&quot; parameter when calling the CB_AudioFileSprites#executeFunctionAllSprites method internally. Internal usage only recommended. Note that each call to the CB_AudioFileSprites#executeFunctionAllSprites method will be performed sequentially one after the other, without adding a delay. functionFinish CB_AudioFileSpritesPool.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array containing all the items which were looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 781 To Do: Think about implementing a &quot;returnSetTimeoutsArray&quot; or similar (as in CB_AudioFileSprites#executeFunctionAllSprites). Think about consider executing only one by one (now it will loop CB_AudioFile objects from different sprites groups simultaneously). Returns: It will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_AudioFile objects used by the sound instances that belong to the sprites of each sprites group). Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer forEach() Alias for CB_AudioFileSpritesPool#executeFunctionAll. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 934 See: CB_AudioFileSpritesPool#executeFunctionAll forEachSprite() Alias for CB_AudioFileSpritesPool#executeFunctionAllSprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 763 See: CB_AudioFileSpritesPool#executeFunctionAllSprites forEachSubSprite() Alias for CB_AudioFileSpritesPool#executeFunctionAllSubSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1253 See: CB_AudioFileSpritesPool#executeFunctionAllSubSprites getAudioFileBySoundInstanceId(soundInstanceId [, avoidCancelled]) → {CB_AudioFile|null} Gets the CB_AudioFile object associated to a given sound instance ID (created by the CB_AudioFileCache#play method), if any, or null otherwise. Uses the CB_AudioFileSprites#getAudioFileBySoundInstanceId method internally. Parameters: Name Type Argument Default Description soundInstanceId integer Used as the &quot;soundInstanceId&quot; parameter when calling the CB_AudioFileSprites#getAudioFileBySoundInstanceId method internally. avoidCancelled boolean &lt;optional&gt; false Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFileBySoundInstanceId method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 917 Returns: Returns the CB_AudioFile object associated to a given sound instance ID, if any, or null otherwise. Type CB_AudioFile | null getAudioFiles( [copy] [, oneDimension]) → {Object|array} Gets an object with arrays or a one-dimension array with all the CB_AudioFile objects. Uses the CB_AudioFileSprites#getAudioFiles method internally. Parameters: Name Type Argument Default Description copy boolean &lt;optional&gt; false Used as the &quot;copy&quot; parameter when calling the CB_AudioFileSprites#getAudioFiles method internally. oneDimension boolean &lt;optional&gt; false If it is set to true, the method will return an array with all the CB_AudioFile objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with all the CB_AudioFile objects that belong to that sprites group. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1482 Returns: If the &quot;oneDimension&quot; parameter is set to true, returns an array with all the CB_AudioFile objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with all the CB_AudioFile objects that belong to that sprites group. Type Object | array getAudioFilesBusy( [oneDimension]) → {Object|array} Gets an object with arrays or a one-dimension array with the busy CB_AudioFile objects (the objects which are not available and ready to use). Uses the CB_AudioFileSprites#getAudioFilesBusy method internally. Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If it is set to true, the method will return an array with the busy CB_AudioFile objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with the busy CB_AudioFile objects that belong to that sprites group. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1558 Returns: If the &quot;oneDimension&quot; parameter is set to true, returns an array with the busy CB_AudioFile objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with the busy CB_AudioFile objects that belong to that sprites group. Type Object | array getAudioFilesFree( [oneDimension]) → {Object|array} Gets an object with arrays or a one-dimension array with the free CB_AudioFile objects (the objects which are available and ready to use). Uses the CB_AudioFileSprites#getAudioFilesFree method internally. Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If it is set to true, the method will return an array with the free CB_AudioFile objects. Otherwise, if it is set to false, the method will return an object whose property names will be the ID of each sprites group and their value will be an array with the free CB_AudioFile objects that belong to that sprites group. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1520 Returns: If the &quot;oneDimension&quot; parameter is set to true, returns an array with the free CB_AudioFile objects. Otherwise, if the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be an array with the free CB_AudioFile objects that belong to that sprites group. Type Object | array getAudioFilesFreeNumber() → {integer} Tells the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Uses the CB_AudioFileSprites#getAudioFilesFreeNumber method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1464 Returns: Returns the current number of free CB_AudioFile objects (the number of objects which are available and ready to use). Type integer getAudioFilesNumber( [real]) → {integer} Tells the number of CB_AudioFile objects created. Uses the CB_AudioFileSprites#getAudioFilesNumber method internally. Parameters: Name Type Argument Default Description real boolean &lt;optional&gt; false Used as the &quot;real&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesNumber method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1596 Returns: Returns the number of CB_AudioFile objects created. Type integer getAudioFilesUsed( [oneDimension] [, includeWithoutSpriteAssociated] [, avoidCancelled]) → {CB_AudioFileSprites.getAudioFilesUsed_OBJECT|array} Returns the CB_AudioFile objects used by all the sounds instances of all the sprites groups. Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the an object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the CB_AudioFile objects used. Otherwise, if set to true, it will return a numeric array with the CB_AudioFile objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the CB_AudioFile objects whose sound instance ID is not associated to any sprite). includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, it will also return the CB_AudioFile objects whose sound instance ID is not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsed method internally. avoidCancelled boolean &lt;optional&gt; false If set to true, it will not return the CB_AudioFile objects whose sound instance has been cancelled. Used as the &quot;avoidCancelled&quot; parameter when calling the CB_AudioFileSprites#getAudioFilesUsed method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 717 Returns: Returns the CB_AudioFile objects used by all the sounds instances of all the sprites groups. If the &quot;oneDimension&quot; parameter is set to false, it will return a CB_AudioFileSpritesPool.getAudioFilesUsed_OBJECT object whose property names will be the ID of each sprites group and their value will be a CB_AudioFileSprites.getAudioFilesUsed_OBJECT object whose property names are the sprite identifiers (including the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated, if the &quot;includeWithoutSpriteAssociated&quot; is set to true) and their value will be a numeric array with the CB_AudioFile objects used. Otherwise, if the &quot;oneDimension&quot; parameter set to true, it will return a numeric array with the CB_AudioFile objects used (if the &quot;includeWithoutSpriteAssociated&quot; parameter is set to true, it will also contain the CB_AudioFile objects whose sound instance ID is not associated to any sprite). Type CB_AudioFileSprites.getAudioFilesUsed_OBJECT | array getProgress( [countLoadedObjects] [, alsoUncheckedAndCheckingObjects]) → {number} Returns a number representing the percentage of the loading progress for the audio sprites pool object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Uses the CB_AudioFileSprites#getProgress method internally. Parameters: Name Type Argument Default Description countLoadedObjects boolean &lt;optional&gt; false Used as the &quot;countLoadedObjects&quot; parameter when calling the CB_AudioFileSprites#getProgress method internally. alsoUncheckedAndCheckingObjects boolean &lt;optional&gt; false Used as the &quot;alsoUncheckedAndCheckingObjects&quot; parameter when calling the CB_AudioFileSprites#getProgress method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1614 Returns: Returns a number representing the percentage of the loading progress for the audio sprites pool object (from 0 to 100, being 100 a complete loading progress). The way to calculate it internally may differ from one audio API to another and it is not totally reliable. Type number getSoundInstancesId( [oneDimension] [, includeWithoutSpriteAssociated]) → {Object|array} Returns the sound instances (their ID) used (stored in the CB_AudioFileSprites#spriteSoundInstances property of each CB_AudioFileSprites object). Parameters: Name Type Argument Default Description oneDimension boolean &lt;optional&gt; false If set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the CB_AudioFileSprites#spriteSoundInstances property of each CB_AudioFileSprites object (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated) which belongs to that sprites group. Otherwise, if it is set to true, it will return a numeric array whose values are the sound instance IDs. includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, it will also return the sound instance identifiers which are not associated to any sprite. Used as the &quot;includeWithoutSpriteAssociated&quot; parameter when calling the CB_AudioFileSprites#getSoundInstancesId method internally. Only used when the &quot;oneDimension&quot; parameter is set to true. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 670 Returns: Returns the sound instances (their ID) used (stored in the CB_AudioFileSprites#spriteSoundInstances property). If the &quot;oneDimension&quot; parameter is set to false, it will return an object whose property names will be the ID of each sprites group and their value will be the CB_AudioFileSprites#spriteSoundInstances property of each CB_AudioFileSprites object (which includes the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property for sound instances without a sprite associated) which belongs to that sprites group. If the &quot;oneDimension&quot; parameter is set to true, it will return a numeric array whose values are the sound instance identifiers (if the &quot;includeWithoutSpriteAssociated&quot; parameter it set to true, it will also include the sound instances which are not associated to any sprite). Type Object | array getSprites( [includeWithoutSpriteAssociated] [, orderBySpritesGroup]) → {CB_AudioFileSprites.SPRITES_OBJECT|Object} Returns an object with the sprites (and includes &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; if we want to). Internally, uses the CB_AudioFileSprites#getSprites method. Parameters: Name Type Argument Default Description includeWithoutSpriteAssociated boolean &lt;optional&gt; false If set to true, the returning object will also contain a property called &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; whose value will be an empty object (unless the &quot;orderBySpritesGroup&quot; parameter is set to true and the property existed before in the object stored in the CB_AudioFileSprites#sprites property and had a value which is not an empty object). If set to false and the &quot;orderBySpritesGroup&quot; parameter is also set to false, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property. If set to false and the &quot;orderBySpritesGroup&quot; parameter is set to true, the returning object will not contain the &quot;_WITHOUT_SPRITE_ASSOCIATED&quot; property unless the property existed before in the object stored in the CB_AudioFileSprites#sprites property. orderBySpritesGroup boolean &lt;optional&gt; false If set to false, it will return a CB_AudioFileSprites.SPRITES_OBJECT object whose properties will be the ID of each sprite (each sprite ID should be unique) and their value will be a CB_AudioFileSprites.SPRITE_OBJECT object. If set to true, it will return an object whose properties will be the ID of each sprites group and the value will be a CB_AudioFileSprites.SPRITES_OBJECT object which will include its sprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 633 Returns: If the &quot;orderBySpritesGroup&quot; is set to false, it will return a CB_AudioFileSprites.SPRITES_OBJECT object whose properties will be the ID of each sprite (each sprite ID should be unique) and their value will be a CB_AudioFileSprites.SPRITE_OBJECT object. If the &quot;orderBySpritesGroup&quot; is set to true, it will return an object whose properties will be the ID of each sprites group and the value will be a CB_AudioFileSprites.SPRITES_OBJECT object which will include its sprites. Type CB_AudioFileSprites.SPRITES_OBJECT | Object getSpritesGroup(spritesGroupId [, withoutChecking]) → {CB_AudioFileSprites|undefined|*|null} Returns a sprites group (the CB_AudioFileSprites object) by its ID. Parameters: Name Type Argument Default Description spritesGroupId string The identifier for the sprites group. withoutChecking boolean &lt;optional&gt; false If set to true and the sprites group cannot be found, the method will return undefined (or whatever is stored by the given ID) instead of null. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 604 Returns: Returns null if the &quot;withoutChecking&quot; parameter is set to true and the sprites group cannot be found. Otherwise, it will return what is stored internally by the given ID which can be a CB_AudioFileSprites object if found or undefined (or whatever is stored by the given ID) if not found. Type CB_AudioFileSprites | undefined | * | null getSpritesGroups() → {Object} Returns an object with the sprites groups (all the internally-created CB_AudioFileSprites objects), being the name of each property their group ID and the value being the CB_AudioFileSprites object itself. Internally, it just returns the CB_AudioFileSpritesPool#audioFileSprites property. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 620 Returns: Returns an object with the sprites groups (all the internally-created CB_AudioFileSprites objects), being the name of each property their group ID and the value being the CB_AudioFileSprites object itself. Internally, it just returns the CB_AudioFileSpritesPool#audioFileSprites property. Type Object getStatus() → {number} Gets the current status of the audio file sprites pool object. Uses the CB_AudioFileSprites#getStatus method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1633 Returns: Returns the current status of the audio file sprites pool object. It is a number, affected by the returning value of the CB_AudioFileSprites#getStatus method of each CB_AudioFileSprites object used internally, which should match the value of the CB_AudioFileCache.UNLOADED (still unloaded), CB_AudioFileCache.LOADING (loading), CB_AudioFileCache.UNCHECKED (not checked by calling the CB_AudioFileCache#checkPlayingAll method yet), CB_AudioFileCache.CHECKING (being checked by the CB_AudioFileCache#checkPlayingAll method), CB_AudioFileCache.LOADED (loaded), CB_AudioFileCache.FAILED (failed loading or failed to play or by any other reason) or CB_AudioFileCache.ABORTED (aborted because it was destroyed with the &quot;destructor&quot; method) property. Type number getStatusString() → {string} Gets the current status of the audio file sprites pool object, as a string. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1681 Returns: Returns the current status of the audio file sprites pool object, as a string. Possible return values are &quot;UNLOADED&quot;, &quot;LOADING&quot;, &quot;UNCHECKED&quot;, &quot;CHECKING&quot;, &quot;LOADED&quot;, &quot;FAILED&quot;, &quot;ABORTED&quot; or &quot;UNKNOWN (UNKNOWN_STATUS)&quot; (where &quot;UNKNOWN_STATUS&quot; will be a returning value from the CB_AudioFileSpritesPool#getStatus method not recognized as any possible status). Type string insertSpritesGroup(spritesGroupId [, dataObject] [, avoidCheckingLoaded]) → {boolean} Inserts the given sprites group to the audio file sprites pool object. Parameters: Name Type Argument Default Description spritesGroupId string The identifier for the sprites group. dataObject CB_AudioFileSprites.DATA_OBJECT &lt;optional&gt; Object with the data of the sprites group. Optional but recommended. avoidCheckingLoaded boolean &lt;optional&gt; false If set to true, it will not check whether all sprites groups has been loaded after inserting the desired one. This is done internally by the CB_AudioFileSpritesPool#_checkSpritesGroupsLoaded method which will fire the CB_AudioFileSpritesPool#onLoad function (if any). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 497 Returns: Returns true if the sprites group has been inserted or false otherwise. Type boolean insertSpritesGroups(sprites) → {integer} Inserts the given sprites groups. Parameters: Name Type Description sprites CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT Object with the desired sprites groups. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 469 Returns: Returns the number of sprites groups inserted. Type integer isAudioFileFree(id) → {boolean} Tells whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property of any CB_AudioFileSprites object) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Uses the CB_AudioFileSprites#isAudioFileFree method internally. Parameters: Name Type Description id string Used as the &quot;id&quot; parameter when calling the CB_AudioFileSprites#isAudioFileFree method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 847 Returns: Returns whether a desired CB_AudioFile object is free (it is in the CB_AudioFileCache#audioFilesFree property of any CB_AudioFileSprites object) or not, by its identifier. A free CB_AudioFile object is an object which is not being used and it is available to be used. Type boolean isPlaying() → {boolean} Tells whether any of the CB_AudioFile objects is playing or not. Uses the CB_AudioFileSprites#isPlaying method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1449 Returns: Returns whether any of the CB_AudioFile objects is playing or not. Type boolean load(dataObject) → {CB_AudioFileSpritesPool|null} Loads the audio file sprites pool with the desired data given. This method is called by the constructor automatically. Recommended to be called through a user-driven event (as onClick, onTouch, etc.), as some clients may need this at least the first time in order to be able to play the audio. Parameters: Name Type Description dataObject CB_AudioFileSpritesPool.DATA_OBJECT Object with the desired data and options for the audio file sprites. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 364 Returns: If a &quot;dataObject&quot; is given, it returns the current CB_AudioFileSpritesPool object. Otherwise, it returns null. Type CB_AudioFileSpritesPool | null muteAll( [onMute] [, audioFiles]) → {integer} Mutes all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileSprites#muteAll method internally. Parameters: Name Type Argument Default Description onMute function &lt;optional&gt; Used as the &quot;onMute&quot; parameter when calling the CB_AudioFileSprites#muteAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#muteAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1238 Returns: Returns the number of calls to the CB_AudioFile#mute method that were performed. Type integer pauseAll( [onPause] [, audioFiles]) → {integer} Tries to pause all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#pause method internally. Uses the CB_AudioFileSprites#pauseAll method internally. Parameters: Name Type Argument Default Description onPause function &lt;optional&gt; Used as the &quot;onPause&quot; parameter when calling the CB_AudioFileSprites#pauseAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#pauseAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1197 Returns: Returns the number of calls to the CB_AudioFile#pause method that were performed. Type integer playAll( [startAt] [, stopAt] [, loop] [, volume] [, avoidDelayedPlay] [, allowedRecursiveDelay] [, onPlayStart] [, onStop] [, includingPlaying]) → {integer} Tries to play all the CB_AudioFile objects by calling their CB_AudioFile#play method internally. If a CB_AudioFile object cannot be played and it is determined necessary, it will try to reload it internally (by calling the CB_AudioFileCache#removeAudioFile method). Uses the CB_AudioFileSprites#playAll method internally. Parameters: Name Type Argument Default Description startAt number &lt;optional&gt; 0 | CB_AudioFile_API.WAAPI#lastStartAt | CB_AudioFile_API.SM2#lastStartAt | CB_AudioFile_API.ACMP#lastStartAt | CB_AudioFile_API.AAPI#lastStartAt | stopAt Used as the &quot;startAt&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. stopAt number &lt;optional&gt; CB_AudioFile_API.WAAPI#getDuration() | CB_AudioFile_API.SM2#getDuration() | CB_AudioFile_API.ACMP#getDuration() | CB_AudioFile_API.AAPI#getDuration() Used as the &quot;stopAt&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT ? CB_Speaker.getVolume() : CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. avoidDelayedPlay boolean &lt;optional&gt; false Used as the &quot;avoidDelayedPlay&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. includingPlaying boolean &lt;optional&gt; false Used as the &quot;includingPlaying&quot; parameter when calling the CB_AudioFileSprites#playAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1144 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer playAndStopAll( [includingPlaying] [, delayBeforeStop]) → {integer} Plays silently and stops all CB_AudioFile objects after a desired time. It can be useful for some clients which need the CB_AudioFile#play method to be called through a user-driven event (as onClick, onTouch, etc.). Internally, it calls CB_AudioFileCache#playAll(0, null, false, 0, true, null, null, null, includingPlaying) and, after a desired delay, calls the CB_AudioFileCache#stopAll method. Uses the CB_AudioFileSprites#playAndStopAll method internally. Parameters: Name Type Argument Default Description includingPlaying boolean &lt;optional&gt; false Used as the &quot;includingPlaying&quot; parameter when calling the CB_AudioFileSprites#playAndStopAll method internally. delayBeforeStop number &lt;optional&gt; 100 Used as the &quot;delayBeforeStop&quot; parameter when calling the CB_AudioFileSprites#playAndStopAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1179 Returns: Returns the number of CB_AudioFile objects whose CB_AudioFile#play method did not return the value of &quot;-1&quot; (this does not mean necessarily that they could be played successfully). Type integer purge(desiredNumber [, setAsMinimumAudioFiles] [, includePlaying] [, stopSounds] [, statuses]) → {integer} Tries to purge the audio file cache of each CB_AudioFileSprites object until it reaches a desired number of CB_AudioFile objects internally (set in the CB_AudioFileCache#audioFiles property), by removing and destroying some of the current CB_AudioFile objects. Note that the desired number is for each CB_AudioFileSprites object and not a global number. For performance purposes. Uses the CB_AudioFileSprites#purge method internally. Parameters: Name Type Argument Default Description desiredNumber integer Used as the &quot;desiredNumber&quot; parameter when calling the CB_AudioFileSprites#purge method internally. Note that the desired number is for each CB_AudioFileSprites object and not a global number. setAsMinimumAudioFiles boolean &lt;optional&gt; false Used as the &quot;setAsMinimumAudioFiles&quot; parameter when calling the CB_AudioFileSprites#purge method internally. includePlaying boolean &lt;optional&gt; false Used as the &quot;includePlaying&quot; parameter when calling the CB_AudioFileSprites#purge method internally. stopSounds boolean &lt;optional&gt; false Used as the &quot;stopSounds&quot; parameter when calling the CB_AudioFileSprites#purge method internally. statuses array &lt;optional&gt; Array(CB_AudioFile.LOADING, CB_AudioFile.UNCHECKED, CB_AudioFile.CHECKING, CB_AudioFile.LOADED) Used as the &quot;statuses&quot; parameter when calling the CB_AudioFileSprites#purge method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 830 Returns: Returns the number of CB_AudioFile objects removed. Type integer removeSpritesGroup(spritesGroupId [, destroy] [, stopSounds] [, preventAbortedStatus]) → {boolean} Removes a sprites group by its ID. Parameters: Name Type Argument Default Description spritesGroupId string The identifier for the sprites group. destroy boolean &lt;optional&gt; false If set to true, it will call the CB_AudioFileSprites#destructor method of the CB_AudioFileSprites object which belongs to the desired sprites group. stopSounds boolean &lt;optional&gt; false If the &quot;destroy&quot; parameter is set to false, this parameter will be ignored. Used as the &quot;stopSound&quot; parameter when calling internally the CB_AudioFileSprites#destructor method of the CB_AudioFileSprites object which belongs to the desired sprites group. preventAbortedStatus boolean &lt;optional&gt; false If the &quot;destroy&quot; parameter is set to false, this parameter will be ignored. Used as the &quot;preventAbortedStatus&quot; parameter when calling internally the CB_AudioFileSprites#destructor method of the CB_AudioFileSprites object which belongs to the desired sprites group. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 572 Returns: Returns true if the sprites group has been deleted or false otherwise. Type boolean removeSpritesGroups() Removes all the sprites groups (CB_AudioFileSprites objects) by clearing the CB_AudioFileSpritesPool#audioFileSprites property. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 457 resumeAll( [loop] [, allowedRecursiveDelay] [, allowedRecursiveDelaySkipping] [, onPlayStart] [, onStop] [, audioFiles] [, spriteId]) → {Object} Resumes all the existing CB_AudioFile objects or the desired ones (if provided), which are paused (and not stopped). Can be focused on just one sprite ID if desired. Uses the CB_AudioFileSprites#resumeAll method internally. Internal usage only recommended. To resume a sprite, better use the CB_AudioFileSprites#resumeSprite method instead. Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; CB_AudioFile#loop Used as the &quot;loop&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. allowedRecursiveDelay boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT Used as the &quot;allowedRecursiveDelay&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. allowedRecursiveDelaySkipping boolean &lt;optional&gt; stopAt-startAt Used as the &quot;allowedRecursiveDelaySkipping&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. onPlayStart function &lt;optional&gt; Used as the &quot;onPlayStart&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. onStop function &lt;optional&gt; Used as the &quot;onStop&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#resumeAll method internally. spriteId string &lt;optional&gt; '_WITHOUT_SPRITE_ASSOCIATED' Used as the &quot;spriteId&quot; when calling the CB_AudioFileSprites#resumeAll method internally. Internal usage only recommended. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1220 Returns: Returns an object whose property names will be the ID of each sprites group and their value will be the returning value of the internal call to the CB_AudioFileSprites#resumeAll method. Type Object setAudioAPIAll(preferredAPIs [, callbackOk] [, callbackError] [, mandatory] [, forceReload] [, audioFiles]) → {integer} Tries to change the audio API for all the existing CB_AudioFile objects or the desired ones (if provided). This method is not allowed to be called if a previous call to it did not finish yet. The function defined in the &quot;callbackError&quot; parameter, if any, will be called immediately if the method was previously called and it is still running currently. Uses the CB_AudioFileSprites#setAudioAPIAll method internally. Parameters: Name Type Argument Default Description preferredAPIs array | string Used as the &quot;preferredAPIs&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. callbackOk CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_OK &lt;optional&gt; Function that will be called when all the process was performed successfully, being &quot;this&quot; the CB_AudioFileSpritesPool object. callbackError CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR &lt;optional&gt; Function that will be called when any error happened, being &quot;this&quot; the CB_AudioFileSpritesPool object. This function will be called immediately if the method was previously called and it is still running currently. mandatory boolean &lt;optional&gt; false Used as the &quot;mandatory&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. forceReload string &lt;optional&gt; false Used as the &quot;forceReload&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#setAudioAPIAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1329 Returns: Returns the number of calls to the CB_AudioFile#setAudioAPI method that were performed. Type integer setVolumeAll( [volume] [, forceSetVolumeProperty] [, onSetVolume] [, audioFiles]) → {integer} Sets the same volume for all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileSprites#setVolumeAll method internally. Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker.getVolume() | CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME Used as the &quot;volume&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. forceSetVolumeProperty boolean &lt;optional&gt; false Used as the &quot;forceSetVolumeProperty&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. onSetVolume function &lt;optional&gt; Used as the &quot;onSetVolume&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#setVolumeAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1276 Returns: Returns the number of calls to the CB_AudioFile#setVolume method that were performed internally. Type integer stopAll( [audioFiles]) → {integer} Tries to stops all the existing CB_AudioFile objects or the desired ones (if provided), which are being played, by calling their CB_AudioFile#stop method internally. Uses the CB_AudioFileSprites#stopAll method internally. Parameters: Name Type Argument Default Description audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#stopAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1161 Returns: Returns the number of calls to the CB_AudioFile#stop method that were performed. Type integer unmuteAll( [onUnmute] [, audioFiles]) → {integer} Unmutes all the existing CB_AudioFile objects or the desired ones (if provided). Uses the CB_AudioFileSprites#unmuteAll method internally. Parameters: Name Type Argument Default Description onUnmute function &lt;optional&gt; Used as the &quot;onUnmute&quot; parameter when calling the CB_AudioFileSprites#unmuteAll method internally. audioFiles array &lt;optional&gt; CB_AudioFileCache#audioFiles Used as the &quot;audioFiles&quot; parameter when calling the CB_AudioFileSprites#unmuteAll method internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1256 Returns: Returns the number of calls to the CB_AudioFile#unmute method that were performed. Type integer Type Definitions checkPlayingAll_CALLBACK_ERROR(errorsObject, performedActions, uncheckedObjects) Callback function used by the CB_AudioFileSpritesPool#checkPlayingAll method that will be called when not all was performed successfully. Parameters: Name Type Description errorsObject Object Object whose property names are the ID of each sprites group or &quot;GENERAL_ERROR&quot; if the error is not related to any sprites group and their value will be a CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR_OBJECT object. performedActions integer The number of CB_AudioFile objects that can be played). uncheckedObjects integer | undefined The number of CB_AudioFile objects that needed to be checked before calling this method (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1011 checkPlayingAll_CALLBACK_ERROR_OBJECT An object with errors, used by the CB_AudioFileSpritesPool.checkPlayingAll_CALLBACK_ERROR callback (used by the CB_AudioFileSpritesPool#checkPlayingAll method). Type: Object Properties: Name Type Description error string A string describing the error (if it was possible to be determined). checked integer The number of CB_AudioFile objects that can be played. needed integer | undefined The number of CB_AudioFile objects that needed to be checked before calling this method (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1020 checkPlayingAll_CALLBACK_OK(performedActions, uncheckedObjects) Callback function used by the CB_AudioFileSpritesPool#checkPlayingAll method that will be called when all the process was performed successfully. Parameters: Name Type Description performedActions integer The number of CB_AudioFile objects that can be played. uncheckedObjects integer The number of CB_AudioFile objects that needed to be checked before calling this method. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1003 DATA_OBJECT Object with the desired data and options for the audio sprites. It is almost identical to the CB_AudioFileSprites.DATA_OBJECT but adding a &quot;spritesGroups&quot; property. Type: Object Properties: Name Type Argument Default Description spritesGroups CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT &lt;optional&gt; Object with the desired sprites groups, containing the CB_AudioFileSprites.DATA_OBJECT objects which will be used to create the CB_AudioFileSprites objects internally. Each group will have a CB_AudioFileSprites object. It will be used as the first parameter to call the CB_AudioFileSpritesPool#insertSpritesGroups method internally. Some of the missing properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) of the CB_AudioFileSprites.DATA_OBJECT objects given will use the value set on the other properties of this object (if any). id string &lt;optional&gt; &quot;&quot; Desired identifier for the object. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#id property. preferredAPIs array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_APIS Array of strings with the preferred audio API or audio APIs, in order of preference. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#preferredAPIs property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;preferredAPIs&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. preferredFormats array &lt;optional&gt; CB_Configuration.CrossBase.CB_AudioFileCache_PREFERRED_AUDIO_FORMATS Array of strings with the preferred audio format or audio formats (they can include just the format as 'audio/ogg' or also the codec as for example 'audio/ogg; codecs=&quot;vorbis&quot;'), in order of preference. It will try to calculate and use the best one for the current client. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#preferredFormats property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;preferredFormats&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. minimumAudioFiles integer &lt;optional&gt; CB_AudioFileCache.minimumAudioFiles_DEFAULT Minimum CB_AudioFile objects to create internally. It must be an integer being 1 the minimum. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#minimumAudioFiles property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;minimumAudioFiles&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. maximumAudioFiles integer &lt;optional&gt; CB_AudioFileCache.maximumAudioFiles_DEFAULT Maximum CB_AudioFile objects that are to be created internally. If it is set to null, there will not be a maximum (it will be unlimited). If an integer is provided, it must be the same number or greater than the value set in the CB_AudioFileCache#minimumAudioFiles property (also provided by the &quot;minimumAudioFiles&quot; of this object), allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#maximumAudioFiles property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;maximumAudioFiles&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. minimumAudioFilesFree integer &lt;optional&gt; parseInt(CB_AudioFileCache#minimumAudioFiles * 0.25 + 0.5) New CB_AudioFile objects will be created internally when the number of free CB_AudioFile objects reaches this limit. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 25% of the CB_AudioFileSpritesPool#minimumAudioFiles by default, rounded to ceil, allowing 0 (zero) minimum. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#minimumAudioFilesFree property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;minimumAudioFilesFree&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. newAudioFilesWhenNeeded integer &lt;optional&gt; Math.min(parseInt(CB_AudioFileCache#minimumAudioFiles * 0.1 + 0.5), 1) Number of new CB_AudioFile objects to create internally when the minimum limit of free CB_AudioFile objects (CB_AudioFileSpritesPool#minimumAudioFilesFree) is reached. If provided, it must be an integer being 0 (zero) the minimum. It will end using a 10% of the CB_AudioFileSpritesPool#minimumAudioFiles by default, rounded to ceil, allowing 1 minimum. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#newAudioFilesWhenNeeded property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;newAudioFilesWhenNeeded&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. retries integer &lt;optional&gt; CB_AudioFileCache.retries_DEFAULT Number of retries to try to load a CB_AudioFile object internally before trying to load the next possible one internally (if any). It must be an integer being 0 the minimum. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#retries property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;retries&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. checkManually boolean &lt;optional&gt; CB_AudioFileCache.checkManually_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) by default. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#checkManually property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManually&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. checkManuallyOnNeededCreated boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnNeededCreated_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when creates a new CB_AudioFile object needed. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#checkManuallyOnNeededCreated property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnNeededCreated&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. checkManuallyOnPlayingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnPlayingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when playing one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#checkManuallyOnPlayingFailed property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnPlayingFailed&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. checkManuallyOnCheckingFailed boolean &lt;optional&gt; CB_AudioFileCache.checkManuallyOnCheckingFailed_DEFAULT Tells whether the CB_AudioFile objects must be checked automatically or not (manually) when checking one has failed and tries to reload it. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#checkManuallyOnCheckingFailed property. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;checkManuallyOnCheckingFailed&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. onLoad function &lt;optional&gt; Desired function to be called once the pool has been loaded. The first and unique parameter will be an integer with the CB_AudioFile objects that still need to be checked, if any, being &quot;this&quot; the current CB_AudioFileSpritesPool object. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#onLoad property. onError function &lt;optional&gt; Desired function to be called when any kind of error happens. The first and unique parameter will be a string with the error description (if it could be determined), being &quot;this&quot; the current CB_AudioFileSpritesPool object. If a valid value is given, this will be added to the CB_AudioFileSpritesPool#onError property. If a function is set, it will always be called through the CB_AudioFileSpritesPool#errorFunction method whenever the &quot;onError&quot; event of an internally-created CB_AudioFileSprites object is fired. disableAutoLoad boolean &lt;optional&gt; false If set to true, it will not create automatically the CB_AudioFile objects by calling the CB_AudioFileCache#createAudioFiles method internally. Internal usage only recommended. If the CB_AudioFileSprites.DATA_OBJECT object (defined in the CB_AudioFileSpritesPool.SPRITES_GROUPS_OBJECT object set in the &quot;spritesGroups&quot;) of a certain sprites group does not contain the &quot;disableAutoLoad&quot; property, it will use the value of this property instead when creating its CB_AudioFileSprites object internally. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 22 executeFunctionAll_ON_FINISH_CALLBACK(array, itemsAffected, delayMaximum) Callback that is used when finishes all iterations after looping through the items. Being &quot;this&quot; an array with all the items. Parameters: Name Type Description array array An array with all the items which were being looped. itemsAffected integer The number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null). delayMaximum integer The maximum &quot;delay&quot; used. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 749 getAudioFilesUsed_OBJECT Object returned by the CB_AudioFileSpritesPool#getAudioFilesUsed method. Each property names will be the the ID of each sprites group and their value will be a CB_AudioFileSprites.getAudioFilesUsed_OBJECT object. Type: Object Properties: Name Type Description spriteId CB_AudioFileSpritesPool.getAudioFilesUsed_OBJECT Each property names will be the the ID of each sprites group and their value will be a CB_AudioFileSprites.getAudioFilesUsed_OBJECT object. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 702 setAudioAPIAll_CALLBACK_ERROR(errorsObject, errorsHappened, objectsChangedAPI, performedActions, actionsNeeded) Callback function used by the CB_AudioFileCache#setAudioAPIAll method that will be called when any error happened. Parameters: Name Type Description errorsObject Object Object whose property names are the ID of each sprites group or &quot;GENERAL_ERROR&quot; if the error is not related to any sprites group and their value will be a CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR_OBJECT object each. errorsHappened integer The number of errors that happened, which could be greater than 1 if more than one internal call to the CB_AudioFile#setAudioAPI method failed. objectsChangedAPI integer The number of CB_AudioFile objects that actually changed its audio API. performedActions integer The number of CB_AudioFile objects that ended with a desired audio API, including those ones which were already using it. actionsNeeded integer | undefined The total number of CB_AudioFile objects that were considered to perform the action (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1296 setAudioAPIAll_CALLBACK_ERROR_OBJECT Object used by the CB_AudioFileSpritesPool.setAudioAPIAll_CALLBACK_ERROR callback. Unless it belongs to a general error, its information will only be regarding a certain sprites group. Type: Object Properties: Name Type Description error string A string describing the error, if it was possible to be determined. errors integer The number of errors that happened, which could be greater than 1 if more than one internal call to the CB_AudioFile#setAudioAPI method failed. changed integer The number of objects that actually changed its audio API. performed integer The number of CB_AudioFile objects that ended with a desired audio API, including those ones which were already using it. needed integer | undefined The total number of CB_AudioFile objects that were considered to perform the action (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1307 setAudioAPIAll_CALLBACK_OK(objectsChangedAPI, performedActions, actionsNeeded) Callback function used by the CB_AudioFileSpritesPool#setAudioAPIAll method that will be called when all the process was performed successfully. Parameters: Name Type Description objectsChangedAPI integer The number of CB_AudioFile objects that actually changed its audio API. performedActions integer The number of CB_AudioFile objects that ended with a desired audio API, including those ones which were already using it. actionsNeeded integer The total number of CB_AudioFile objects that were considered to perform the action (it will be undefined if it could not be determined). Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 1287 SPRITES_GROUPS_OBJECT Object whose property names the identifiers of each sprite (a case-sensitive string) and their value is a CB_AudioFileSprites.DATA_OBJECT object. Type: Object Properties: Name Type Description spritesGroupId CB_AudioFileSprites.DATA_OBJECT Being the name of each property the unique identifier of a sprites group which will use a future internally-created CB_AudioFileSprites object, the value will always be the CB_AudioFileSprites.DATA_OBJECT that the CB_AudioFileSprites object will use to be created (received by its constructor). Some of the missing properties (&quot;preferredAPIs&quot;, &quot;preferredFormats&quot;, &quot;minimumAudioFiles&quot;, &quot;maximumAudioFiles&quot;, &quot;minimumAudioFilesFree&quot;, &quot;newAudioFilesWhenNeeded&quot;, &quot;retries&quot;, &quot;checkManually&quot;, &quot;checkManuallyOnNeededCreated&quot;, &quot;checkManuallyOnPlayingFailed&quot;, &quot;checkManuallyOnCheckingFailed&quot; and &quot;disableAutoLoad&quot;) will use the value set on the properties of the main CB_AudioFileSpritesPool.DATA_OBJECT object (if any) used by the CB_AudioFileSpritesPool object. If a function in the &quot;onError&quot; parameter is given, it will always be wrapped so the main error function set on the CB_AudioFileSpritesPool#onError parameter will always be called (if any) through the CB_AudioFileSpritesPool#errorFunction method. Source: CrossBase/audiovisual/audio/CB_AudioFileSpritesPool.js, line 7 Example { &quot;sprites_group_id_1&quot; : CB_AudioFileSprites.DATA_OBJECT, &quot;sprites_group_id_2&quot; : CB_AudioFileSprites.DATA_OBJECT, &quot;sprites_group_id_3&quot; : CB_AudioFileSprites.DATA_OBJECT, ... } × Search results Close "},"CB_baseSymbols.html":{"id":"CB_baseSymbols.html","title":"Namespace: CB_baseSymbols","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_baseSymbols CB_baseSymbols Object that contains different properties and methods that can be used as the &quot;baseSymbols&quot; parameter for the CB_intToBase and CB_baseToInt functions. Each property is a numeric array of characters. Source: CrossBase/general/CB_data.js, line 1107 Members &lt;static&gt; 10 :array Numeric array of characters with 10 symbols (using 0 to 9), decimal system. These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;] Source: CrossBase/general/CB_data.js, line 1231 &lt;static&gt; 128 :array Numeric array of characters with 128 symbols. These symbols (and also the ones from other bases with higher number) will be encoded by the escape function and also by the encodeURIComponent function and they will need to be encoded in HTML (not recommended for URI components or JavaScript strings or HTML code). Type: array Default Value: An array with each item being the result of calling the String.fromCharCode function from 0 to 127 as its unique parameter. Source: CrossBase/general/CB_data.js, line 1147 &lt;static&gt; 16 :array Numeric array of characters with 16 symbols (using 0 to 9, A to F), hexadecimal system. These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;] Source: CrossBase/general/CB_data.js, line 1219 &lt;static&gt; 2 :array Numeric array of characters with 2 symbols (using 0 and 1), binary system. These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;] Source: CrossBase/general/CB_data.js, line 1255 &lt;static&gt; 64 :array Numeric array of characters with 64 symbols (using 0 to 9, A to Z, a to z, &quot;.&quot; and &quot;*&quot;). These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code in the case that we do not want to use base 66 from the CB_baseSymbols.66 property). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;.&quot;,&quot;*&quot;] Source: CrossBase/general/CB_data.js, line 1207 &lt;static&gt; 66 :array Numeric array of characters with 66 symbols. These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code). Includes Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;.&quot;,&quot;*&quot;,&quot;-&quot;,&quot;_&quot;] Source: CrossBase/general/CB_data.js, line 1195 &lt;static&gt; 71 :array Numeric array of characters with 71 symbols. These symbols will be encoded by the escape function but not by the encodeURIComponent function (not recommended for URI components in old clients, but useful for URI components in new clients with encodeURIComponent function support, for JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;.&quot;,&quot;*&quot;,&quot;-&quot;,&quot;_&quot;,&quot;~&quot;,&quot;!&quot;,&quot;'&quot;,&quot;(&quot;,&quot;)&quot;] Source: CrossBase/general/CB_data.js, line 1183 &lt;static&gt; 8 :array Numeric array of characters with 8 symbols (using 0 to 7), octal system. These symbols will not be encoded neither by the escape function nor by the encodeURIComponent function (recommended for URI components for any client, JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;] Source: CrossBase/general/CB_data.js, line 1243 &lt;static&gt; 87 :array Numeric array of characters with 87 symbols. These symbols will be encoded by the escape function and also by the encodeURIComponent function but they will not need to be encoded neither in JavaScript strings nor in HTML (not recommended for URI components, but useful for JavaScript strings or HTML code). Includes all symbols from lower bases, respecting the same order (which is their value). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;.&quot;,&quot;*&quot;,&quot;-&quot;,&quot;_&quot;,&quot;~&quot;,&quot;!&quot;,&quot;'&quot;,&quot;(&quot;,&quot;)&quot;,&quot;@&quot;,&quot;/&quot;,&quot;|&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;$&quot;,&quot;%&quot;,&quot;=&quot;,&quot;?&quot;,&quot;^&quot;,&quot;:&quot;,&quot;;&quot;,&quot;,&quot;,&quot;+&quot;] Source: CrossBase/general/CB_data.js, line 1171 &lt;static&gt; 88 :array Numeric array of characters with 88 symbols. These symbols will be encoded by the escape function and also by the encodeURIComponent function, but they will not need to be encoded in HTML (not recommended for URI components or JavaScript strings, but useful for HTML code). Type: array Default Value: [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;,&quot;J&quot;,&quot;K&quot;,&quot;L&quot;,&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;P&quot;,&quot;Q&quot;,&quot;R&quot;,&quot;S&quot;,&quot;T&quot;,&quot;U&quot;,&quot;V&quot;,&quot;W&quot;,&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;,&quot;s&quot;,&quot;t&quot;,&quot;u&quot;,&quot;v&quot;,&quot;w&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;.&quot;,&quot;~&quot;,&quot;!&quot;,&quot;'&quot;,&quot;(&quot;,&quot;)&quot;,&quot;*&quot;,&quot;-&quot;,&quot;_&quot;,&quot;@&quot;,&quot;\\\\&quot;,&quot;/&quot;,&quot;|&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;$&quot;,&quot;%&quot;,&quot;=&quot;,&quot;?&quot;,&quot;^&quot;,&quot;:&quot;,&quot;;&quot;,&quot;,&quot;,&quot;+&quot;] Source: CrossBase/general/CB_data.js, line 1159 &lt;static&gt; _8 Alias for CB_baseSymbols.8. Source: CrossBase/general/CB_data.js, line 1233 See: CB_baseSymbols.8 &lt;static&gt; _8 Alias for CB_baseSymbols.2. Source: CrossBase/general/CB_data.js, line 1245 See: CB_baseSymbols.2 &lt;static&gt; _10 Alias for CB_baseSymbols.10. Source: CrossBase/general/CB_data.js, line 1221 See: CB_baseSymbols.10 &lt;static&gt; _16 Alias for CB_baseSymbols.16. Source: CrossBase/general/CB_data.js, line 1209 See: CB_baseSymbols.16 &lt;static&gt; _64 Alias for CB_baseSymbols.64. Source: CrossBase/general/CB_data.js, line 1197 See: CB_baseSymbols.64 &lt;static&gt; _66 Alias for CB_baseSymbols.66. Source: CrossBase/general/CB_data.js, line 1185 See: CB_baseSymbols.66 &lt;static&gt; _71 Alias for CB_baseSymbols.71. Source: CrossBase/general/CB_data.js, line 1173 See: CB_baseSymbols.71 &lt;static&gt; _87 Alias for CB_baseSymbols.87. Source: CrossBase/general/CB_data.js, line 1161 See: CB_baseSymbols.87 &lt;static&gt; _88 Alias for CB_baseSymbols.88. Source: CrossBase/general/CB_data.js, line 1149 See: CB_baseSymbols.88 &lt;static&gt; _128 Alias for CB_baseSymbols.128. Source: CrossBase/general/CB_data.js, line 1136 See: CB_baseSymbols.128 Methods &lt;static&gt; get( [base]) → {array} Function that will return a numeric array of characters containing as many items as the desired base. Uses a cache internally. Parameters: Name Type Argument Default Description base integer &lt;optional&gt; 256 The desired base (number of items, each with a character, that the returning array will contain). Minimum value is 1. The maximum can differ one client to another but it is not recommended to exceed 4096 (or even lower, depending on the client, although some clients could support up to 63988 or even more). All arrays of bases lower than 87 use the symbols included also in base 87. Source: CrossBase/general/CB_data.js, line 1117 Returns: Returns a numeric array of characters containing as many items as the desired base. All arrays of bases lower than 87 use the symbols included also in base 87. When the base is greater than 87 and it is not not created by default (88 and 128), each item of the returning array will be the result of calling the String.fromCharCode function from 0 to one number less than the desired base number. Type array × Search results Close "},"CB_Canvas.html":{"id":"CB_Canvas.html","title":"Class: CB_Canvas","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_Canvas CB_Canvas Class to manage a canvas. For clients which do not support native canvas, it provides Adobe Flash (formerly Macromedia Flash) emulation with FlashCanvas, Microsoft Silverlight emulation with SLCanvas, VML emulation with ExplorerCanvas (reinforced with canvas-text) and DHTML (DOM elements) emulation with CanBox. NOTE: To make the VML emulation work without errors (using ExplorerCanvas), it is recommended to always load FlashCanvas (which already includes ExplorerCanvas) in your HTML code (without using lazy-load, as ExplorerCanvas does not support it). This is recommended even when we are not going to use Adobe Flash (formerly Macromedia Flash) emulation with FlashCanvas. This is an example (should be placed before loading the main &quot;CrossBrowdy&quot; script): &lt;!-- Loads FlashCanvas (Flash emulation) before CrossBrowdy. Needed also to use ExplorerCanvas (VML emulation) without problems: --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;CrossBrowdy/CrossBase/audiovisual/image/canvas/FlashCanvas/pro/bin/flashcanvas.js&quot;&gt;&lt;/script&gt;&lt;!-- FlashCanvas/ExplorerCanvas do not support lazy load. --&gt; new CB_Canvas(canvasId [, contextType] [, canvasWidth] [, canvasHeight] [, onLoad] [, onError] [, canvasParent] [, alternativeCanvasEmulationPreferredOrder] [, forceFirstEmulationMethod] [, addOtherMethods] [, allowFlashCanvasLocally]) → {CB_Canvas} Class to manage a canvas. Parameters: Name Type Argument Default Description canvasId string The desired ID for the canvas. contextType '2d' | 'webgl' | 'experimental-webgl' | 'webgl2' | 'experimental-webgl2' | 'bitmaprenderer' &lt;optional&gt; '2d' The contextType desired by default. More information: HTMLCanvasElement.getContext. Note that most emulation methods will only support &quot;2d&quot;. canvasWidth integer &lt;optional&gt; CB_Canvas.WIDTH_DEFAULT The desired width (horizontal size) in pixels for the canvas. canvasHeight integer &lt;optional&gt; CB_Canvas.HEIGHT_DEFAULT The desired height (vertical size) in pixels for the canvas. onLoad function &lt;optional&gt; Callback function that will be called when the canvas is finally loaded. It will not receive parameters, being &quot;this&quot; the CB_Canvas object itself. onError function &lt;optional&gt; Callback function that will be called when there is an error creating or loading the canvas. Being &quot;this&quot; the CB_Canvas object itself, the unique parameter received will be a string describing the error (if it could be determined). canvasParent Element &lt;optional&gt; document.body The parent element desired to adopt the canvas. alternativeCanvasEmulationPreferredOrder array &lt;optional&gt; CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS Numeric array listing the desired alternative emulation methods for rendering the canvas, in order of preference. Supported emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. forceFirstEmulationMethod boolean &lt;optional&gt; false If set to true, it will force to use the first alternative emulation method desired (even when this alternative emulation method could be not supported and even when native canvas support could be supported). addOtherMethods boolean &lt;optional&gt; true If set to true, it will add other alternative methods (if any is missing) at the end of the desired alternative emulation methods so they will also be checked and used if the previous ones are not finally used. The order they will be added will be the one used in the CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS constant. allowFlashCanvasLocally boolean &lt;optional&gt; CB_Configuration.CrossBase.FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT If set to true, it will allow to use Adobe Flash (formerly Macromedia Flash) emulation (if needed) even when it is running locally. Uses the CB_Client.isRunningLocally function internally. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 29 Returns: Returns a new CB_Canvas object. Type CB_Canvas Members &lt;static, constant&gt; HEIGHT_DEFAULT :integer Default canvas height in pixels. Type: integer Default Value: 240 Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 80 &lt;static, constant&gt; WIDTH_DEFAULT :integer Default canvas width in pixels. Type: integer Default Value: 320 Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 73 Methods &lt;static&gt; bestEmulation( [preferredOrder] [, forceFirstEmulationMethod] [, addOtherMethods] [, allowFlashCanvasLocally]) → {'NONE'|'FLASH'|'SILVERLIGHT'|'VML'|'DHTML'} Calculates and returns the best alternative canvas emulation. Parameters: Name Type Argument Default Description preferredOrder array | string &lt;optional&gt; CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS Numeric array listing the desired alternative emulation methods for rendering the canvas, in order of preference. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. It can also be a string with the unique desired canvas emulation method or with &quot;NO&quot; or &quot;NONE&quot; value (meaning no emulation method is desired and then the returning value will always be &quot;NONE&quot;). forceFirstEmulationMethod boolean &lt;optional&gt; false If set to true, it will force to return the first alternative emulation method desired which is detected as supported without being too strict (even when this alternative emulation method could be not really supported and even when native canvas support could be supported). addOtherMethods boolean &lt;optional&gt; true If set to true, it will add other alternative methods (if any is missing) at the end of the desired alternative emulation methods so they will also be checked and used if the previous ones are not finally used. The order they will be added will be the one used in the CB_Configuration.CrossBase.CB_Canvas_PREFERRED_EMULATION_METHODS constant. allowFlashCanvasLocally boolean &lt;optional&gt; CB_Configuration.CrossBase.FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT If set to true, it will allow to use Adobe Flash (formerly Macromedia Flash) emulation (if needed) even when it is running locally. Uses the CB_Client.isRunningLocally function internally. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 141 Returns: Returns &quot;NONE&quot; if no canvas emulation is needed/supported (and no emulation method is forced). Otherwise, it returns the best emulation method calculated (&quot;FLASH&quot;, &quot;SILVERLIGHT&quot;, &quot;VML&quot; or &quot;DHTML&quot;). Type 'NONE' | 'FLASH' | 'SILVERLIGHT' | 'VML' | 'DHTML' &lt;static&gt; needsEmulation() → {boolean} Tells whether the current client needs canvas emulation or not. Uses CB_Client.supportsCanvas internally. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 126 Returns: Returns whether the current client needs canvas emulation or not. Type boolean &lt;static&gt; supportsEmulationMethod(emulationMethod [, strictMode]) → {boolean} Tells whether the current client is compatible with a given canvas emulation method or not. Parameters: Name Type Argument Default Description emulationMethod string Emulation method we want to check. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. strictMode boolean &lt;optional&gt; true If set to true, the compatibility will be checked more carefully. If set to false (not recommended), the method could return true even when sometimes the canvas emulation method is not totally supported by the current client. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 215 Returns: Returns whether the current client is compatible with the given canvas emulation method or not. Type boolean clear( [keepTransform] [, backgroundFillStyle]) → {boolean} Clear the canvas entirely. Parameters: Name Type Argument Default Description keepTransform boolean &lt;optional&gt; false If set to true, it will save and restore the current transformation. backgroundFillStyle string &lt;optional&gt; The style used (color, gradient, pattern...) to fill the canvas background. If defined, it will be used as the value for the fillStyle property of the context object, internally. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 839 Returns: Returns true if the action could be performed or false otherwise. Type boolean clearCanvas() Alias for CB_Canvas#clear. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 827 See: CB_Canvas#clear disableAntiAliasing( [performTranslate]) → {boolean} Disables anti-aliasing. Useful to work with image sprites (to avoid problems showing adjacent ones), for example. Parameters: Name Type Argument Default Description performTranslate boolean &lt;optional&gt; false If set to true, it will also call the transform method. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 888 Returns: Returns true if the action could be performed or false otherwise. Type boolean get() → {Element|null} Returns the canvas element (if any). Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 601 Returns: Returns the canvas element (if any). If not found, null will be returned. Type Element | null getContext( [contextType]) → {RenderingContext|Object} Defines and returns the canvas context. It could call the CB_Canvas#prepareContext method internally. Parameters: Name Type Argument Default Description contextType '2d' | 'webgl' | 'experimental-webgl' | 'webgl2' | 'experimental-webgl2' | 'bitmaprenderer' &lt;optional&gt; CB_Canvas#._contextType|'2d' The context type desired. More information: HTMLCanvasElement.getContext. Note that most emulation methods will only support &quot;2d&quot;. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 613 Returns: Returns the canvas context (different type if a canvas emulation method is being used). Type RenderingContext | Object getContextType() → {string} Tells the current canvas context type used. Internally, it returns the value of the CB_Canvas#._contextType property. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 667 Returns: Tells the current canvas context type used. More information: HTMLCanvasElement.getContext. Type string getHeight() → {number} Tells the canvas height (vertical size) being used in pixels. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 788 Returns: Returns the canvas height (vertical size) being used in pixels. It could return zero (0) if cannot be calculated. Type number getId() → {string} Returns the identifier (ID) of the canvas element. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 318 Returns: Returns the identifier (ID) of the canvas element. Type string getMode() → {'NONE'|'NORMAL'|'FLASH'|'SILVERLIGHT'|'VML'|'DHTML'} Tells the mode used to create the canvas. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 799 Returns: Returns the mode used to create the canvas. Returns &quot;NONE&quot; if no method is used yet (possible when no method is supported at all or when it is still loading). Returns &quot;NORMAL&quot; if native canvas is used (no canvas emulation method). Type 'NONE' | 'NORMAL' | 'FLASH' | 'SILVERLIGHT' | 'VML' | 'DHTML' getWidth() → {number} Tells the canvas width (horizontal size) being used in pixels. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 738 Returns: Returns the canvas width (horizontal size) being used in pixels. It could return zero (0) if cannot be calculated. Type number isLoading() → {boolean} Tells whether the canvas is loading or not. Some canvas emulation methods can take some time until they finish loading. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 821 Returns: Returns whether the canvas is loading or not. Type boolean isReady() → {boolean} Tells whether the canvas is ready to be used or not. Some canvas emulation methods can take some time until they are ready to be used. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 810 Returns: Returns whether the canvas is ready to be used or not. Type boolean isSupported() → {boolean} Tells whether the canvas works or not. The internal test used could be not totally reliable. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 678 Returns: Returns whether the canvas works or not. The internal test used could be not totally reliable. Type boolean normalizeContext() Alias for CB_Canvas#prepareContext. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 536 See: CB_Canvas#prepareContext prepareContext( ) → {RenderingContext|Object} Provides the canvas context with some methods and properties, in case it needs it (as some canvas emulation methods lack of some methods and properties). Since this method is called by the CB_Canvas#set method already (and this one is called by the constructor automatically), it is not needed to be called again normally. Parameters: Name Type Argument Default Description context RenderingContext | Object &lt;optional&gt; CB_Canvas#getContext() The context object that we want to prepare (different type if a canvas emulation method is being used). If not defined, calls the CB_Canvas#getContext method internally. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 548 To Do: Add more methods and properties needed by some emulation methods. Returns: Returns the canvas context (different type if a canvas emulation method is being used). Type RenderingContext | Object set(canvasId [, canvasWidth] [, canvasHeight] [, onLoad] [, onError] [, alternativeCanvasEmulation] [, forceEmulation]) Defines the canvas element. Since this method is called by the constructor already, it is not needed to be called unless the canvas element wants to be defined again. Parameters: Name Type Argument Default Description canvasId string The desired ID for the canvas. canvasWidth integer &lt;optional&gt; CB_Canvas.WIDTH_DEFAULT The desired width (horizontal size) in pixels for the canvas. canvasHeight integer &lt;optional&gt; CB_Canvas.HEIGHT_DEFAULT The desired height (vertical size) in pixels for the canvas. onLoad function &lt;optional&gt; Callback function that will be called when the canvas is finally loaded. It will not receive parameters, being &quot;this&quot; the CB_Canvas object itself. onError function &lt;optional&gt; Callback function that will be called when there is an error creating or loading the canvas. Being &quot;this&quot; the CB_Canvas object itself, the unique parameter received will be a string describing the error (if it could be determined). alternativeCanvasEmulation string &lt;optional&gt; CB_Canvas.bestEmulation() Emulation method we want to use in the case that the native canvas is not supported or if the &quot;forceEmulation&quot; parameter is set to true. Possible emulation methods: &quot;FLASH&quot;, &quot;VML&quot;, &quot;DHTML&quot; and &quot;SILVERLIGHT&quot;. forceEmulation boolean &lt;optional&gt; false If set to true, it will force to use the emulation method defined in the &quot;alternativeCanvasEmulation&quot; parameter (even when this alternative emulation method could be not supported and even when native canvas support could be supported). Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 335 setContextType( [contextType]) → {string} Defines the desired canvas context type. Internally, it only defines the CB_Canvas#._contextType property. Parameters: Name Type Argument Default Description contextType '2d' | 'webgl' | 'experimental-webgl' | 'webgl2' | 'experimental-webgl2' | 'bitmaprenderer' &lt;optional&gt; '2d' The [context]context type desired. More information: HTMLCanvasElement.getContext. Note that most emulation methods will only support &quot;2d&quot;. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 649 Returns: Returns the context type just applied. Type string setHeight( [canvasHeight]) → {number} Defines the desired canvas height. Parameters: Name Type Argument Default Description canvasHeight integer &lt;optional&gt; CB_Canvas.HEIGHT_DEFAULT The desired height (vertical size) in pixels for the canvas. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 750 Returns: Returns the canvas height (vertical size) being used in pixels. It could return zero (0) if cannot be calculated. Type number setId(canvasId) Sets the desired identifier (ID) of the canvas element. Since this method is called by the constructor already, it is not needed to be called unless the canvas element wants to be defined again through the CB_Canvas#set method. Note that changing the ID after the canvas has been set could lead to some problems when using certain emulation methods so it is not recommended. Parameters: Name Type Description canvasId string Identifier (ID) for the canvas element. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 303 setWidth( [canvasWidth]) → {number} Defines the desired canvas width. Parameters: Name Type Argument Default Description canvasWidth integer &lt;optional&gt; CB_Canvas.WIDTH_DEFAULT The desired width (horizontal size) in pixels for the canvas. Source: CrossBase/audiovisual/image/canvas/CB_Canvas.js, line 700 Returns: Returns the canvas width (horizontal size) being used in pixels. It could return zero (0) if cannot be calculated. Type number × Search results Close "},"CB_Client.html":{"id":"CB_Client.html","title":"Namespace: CB_Client","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Client CB_Client Static class to manage the current client. It will return itself if it is tried to be instantiated. It can use BrowserDetect (source code rescued). Source: CrossBase/general/CB_Client.js, line 13 To Do: Think about implementing a getDocumentParents function (similar to CB_Client.getWindowParents). Think about implementing &quot;onClose&quot; event (to fire when app/web is going to be closed). Methods &lt;static&gt; exit( [allowWindowCloseFallback] [, allowRedirectionFallback] [, redirectionAddress]) Exits and finishes the script. In a browser, it will try to close the window or at least abandon it redirecting to an empty one (or to a desired URL). In an app (NW.js (formerly node-webkit)/Electron (Electron.js)/Apache Cordova/Adobe PhoneGap/Appcelerator Titanium SDK/Appcelerator TideSDK (Titanium Desktop)/Weixin (WeChat)/etc.), it will try to close the app. Parameters: Name Type Argument Default Description allowWindowCloseFallback boolean &lt;optional&gt; true Defines whether to allow using the window.close method as a fallback. allowRedirectionFallback boolean &lt;optional&gt; true Defines whether to redirect the current client as a fallback (to the URL defined in the &quot;redirectionAddress&quot; parameter). redirectionAddress boolean &lt;optional&gt; 'about:blank' Defines the URL where the current client will be redirected to in the case that the window cannot be closed. Only used if the &quot;allowRedirectionFallback&quot; parameter is set to true. Source: CrossBase/general/CB_Client.js, line 555 To Do: Have in mind iframes (think about it). &lt;static&gt; get() → {string} Returns the current web client (if possible) as a string. It uses BrowserDetect (source code rescued) internally. Source: CrossBase/general/CB_Client.js, line 106 Returns: Type string &lt;static&gt; getAddressWithoutFile(address [, fallbackURL] [, allowsLocal]) → {string} Returns the given address without the file (for example, if &quot;http://whatever.com/index.html&quot; is given, it will return &quot;http://whatever.com/&quot;). Parameters: Name Type Argument Default Description address string The address that we want to filter. fallbackURL string &lt;optional&gt; The address that we want it to return in the case that the given one is not allowed (used when &quot;allowsLocal&quot; does not allow a local address). If it contains a file, it will not be stripped out. allowsLocal boolean &lt;optional&gt; true Defines whether to allow returning a local address or not. If it is set to false and the address is local, it will return the &quot;fallbackURL&quot; instead (without stripping out the file, if any). Source: CrossBase/general/CB_Client.js, line 760 Returns: Type string &lt;static&gt; getBoundingClientRectMargin( [leftOrTop]) → {integer} Gets the starting pixel of top or left coordinates for getBoundingClientRect (it's not 0 in some Internet Explorer versions). Parameters: Name Type Argument Default Description leftOrTop 'left' | 'top' &lt;optional&gt; 'left' String that defines whether we want it to return the values for &quot;left&quot; or for &quot;top&quot;. Source: CrossBase/general/CB_Client.js, line 796 Returns: Type integer &lt;static&gt; getBrowser() Alias for CB_Client.get. Source: CrossBase/general/CB_Client.js, line 96 See: CB_Client.get &lt;static&gt; getBrowserVersion() Alias for CB_Client.getVersion. Source: CrossBase/general/CB_Client.js, line 112 See: CB_Client.getVersion &lt;static&gt; getBrowserVersionMain() Alias for CB_Client.getVersionMain. Source: CrossBase/general/CB_Client.js, line 128 See: CB_Client.getVersionMain &lt;static&gt; getButtonsDown() Alias for CB_Client.getButtons. Source: CrossBase/input/CB_Mouse.js, line 290 See: CB_Client.getButtons &lt;static&gt; getDocument( [mindIframes]) → {Object} Returns the document object (having in mind whether the script is running in one iframe or more, if we want). Parameters: Name Type Argument Default Description mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to get and return the topmost document object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 263 Returns: Type Object &lt;static&gt; getDocumentBase() → {Object} Returns the document object of the first parent (the topmost one). Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 245 Returns: Type Object &lt;static&gt; getFlashVersion( [asString]) → {array|string} Returns the available version of Adobe Flash (formerly Macromedia Flash) plugin, if any, as either an array of strings or as a string. Parameters: Name Type Argument Default Description asString boolean &lt;optional&gt; false If set to true, returns the version as a string. Source: CrossBase/general/CB_Client.js, line 439 Returns: Type array | string &lt;static&gt; getLanguage( [allowNavigatorLanguages] [, PHPAcceptedLanguagesFirst]) → {string} Returns the most preferred language as a string. Parameters: Name Type Argument Default Description allowNavigatorLanguages boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Client_allowNavigatorLanguages_DEFAULT Defines whether to allow using the window.navigator.languages property (if not available, it will proceed normally). PHPAcceptedLanguagesFirst boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Client_PHPAcceptedLanguagesFirst_DEFAULT If it is set to true, it will try to return the accepted languages found out by PHP (if PHP is available) in $_SERVER['HTTP_ACCEPT_LANGUAGE'] or it will proceed normally otherwise. Source: CrossBase/general/CB_Client.js, line 46 To Do: Use other back-end ways to calculate the language (using Node.js, for example). Returns: Type string &lt;static&gt; getLanguages( [allowNavigatorLanguages] [, PHPAcceptedLanguagesFirst]) → {array} Returns the most preferred languages as an array of strings. Parameters: Name Type Argument Default Description allowNavigatorLanguages boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Client_allowNavigatorLanguages_DEFAULT Defines whether to allow using the window.navigator.languages property (if not available, it will proceed normally). PHPAcceptedLanguagesFirst boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Client_PHPAcceptedLanguagesFirst_DEFAULT If it is set to true, it will try to return the accepted languages found out by PHP (if PHP is available) in $_SERVER['HTTP_ACCEPT_LANGUAGE'] or it will proceed normally otherwise. Source: CrossBase/general/CB_Client.js, line 77 To Do: Use other back-end ways to calculate languages (using Node.js, for example). Returns: Type array &lt;static&gt; getLocation( [mindIframes]) → {string} Returns the current URL, if possible (having in mind whether the script is running in one iframe or more, if we want). Parameters: Name Type Argument Default Description mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to get the location of the topmost window object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 740 Returns: Type string &lt;static&gt; getLocationWithoutFile( [fallbackURL] [, allowsLocal] [, mindIframes]) → {string} Returns the current URL without the file (for example, if &quot;http://whatever.com/index.html&quot; is the current URL, it will return &quot;http://whatever.com/&quot;), if possible (having in mind whether the script is running in one iframe or more, if we want). Parameters: Name Type Argument Default Description fallbackURL string &lt;optional&gt; The address that we want it to return in the case that the current one is not allowed (used when &quot;allowsLocal&quot; does not allow a local address). If it contains a file, it will not be stripped out. allowsLocal boolean &lt;optional&gt; true Defines whether to allow returning a local address or not. If it is set to false and the current address is local, it will return the &quot;fallbackURL&quot; instead (without stripping out the file, if any). mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to get the location of the topmost window object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 783 Returns: Type string &lt;static&gt; getNodeJSVersion( [asString]) → {array|string} Returns the available version of Node.js (if any), as either an array of strings or as a string. Parameters: Name Type Argument Default Description asString boolean &lt;optional&gt; false If set to true, returns the version as a string. Source: CrossBase/general/CB_Client.js, line 344 Returns: Type array | string &lt;static&gt; getPHPVersion( [asString]) → {array|string} Returns the available version of PHP (if any), as either an array of strings or as a string. Parameters: Name Type Argument Default Description asString boolean &lt;optional&gt; false If set to true, returns the version as a string. Source: CrossBase/general/CB_Client.js, line 320 Returns: Type array | string &lt;static&gt; getSilverlightVersion( [asString]) → {array|string} Returns the available version of Microsoft Silverlight plugin (if any), as either an array of strings or as a string. Parameters: Name Type Argument Default Description asString boolean &lt;optional&gt; false If set to true, returns the version as a string. Source: CrossBase/general/CB_Client.js, line 385 Returns: Type array | string &lt;static&gt; getTitle() → {string} Returns the current document title. Source: CrossBase/general/CB_Client.js, line 866 Returns: Type string &lt;static&gt; getVersion() → {string} Returns the current web client version (if possible) as a string. It uses BrowserDetect (source code rescued) internally. Source: CrossBase/general/CB_Client.js, line 122 Returns: Type string &lt;static&gt; getVersionMain() → {integer} Returns the current web client main version (first number), if possible, as an integer. It uses BrowserDetect (source code rescued) internally. Source: CrossBase/general/CB_Client.js, line 138 Returns: Type integer &lt;static&gt; getWindow( [mindIframes]) → {Object} Returns the window object (having in mind whether the script is running in one iframe or more, if we want). Parameters: Name Type Argument Default Description mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to get and return the topmost window object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 222 Returns: Type Object &lt;static&gt; getWindowBase() → {Object} Returns the window object of the first parent (the topmost one). Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 185 Returns: Type Object &lt;static&gt; getWindowParents() → {array} Returns all the window objects, parents and last son (main one) in an array (with the topmost parent in the highest index). Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 150 Returns: Type array &lt;static&gt; isRunningLocally( [mindIframes]) → {boolean} Tells whether the script is running locally (using &quot;file:&quot; protocol) or not. Parameters: Name Type Argument Default Description mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to check the protocol of the topmost window object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 479 Returns: Type boolean &lt;static&gt; isRunningOnElectron() → {boolean} Tells whether the script is running on Electron (Electron.js) or not. Source: CrossBase/general/CB_Client.js, line 535 Returns: Type boolean &lt;static&gt; isRunningOnNWjs() → {boolean} Tells whether the script is running on NW.js (formerly node-webkit) or not. Source: CrossBase/general/CB_Client.js, line 516 Returns: Type boolean &lt;static&gt; onLanguageChanges(eventFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the languagechange event is fired (only for some web clients) or removes it. Parameters: Name Type Argument Default Description eventFunction function | null Function that represents the event listener that will be called when the event is fired. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether to also keep the previous listeners or remove them otherwise. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/general/CB_Client.js, line 90 &lt;static&gt; redirectTo(address [, getData] [, mindIframes]) Redirects the current client to the desired location (having in mind whether the script is running in one iframe or more, if we want). Parameters: Name Type Argument Default Description address string The address where we want to go. getData string &lt;optional&gt; Any URL (GET) variables we want to send (as for example &quot;data1=value1&amp;data2=value2&quot;). mindIframes boolean &lt;optional&gt; CB_Configuration.CrossBase.MIND_IFRAMES If set to true, it will try to redirect the topmost window object. Useful in case the script is running in an iframe or more. Source: CrossBase/general/CB_Client.js, line 719 &lt;static&gt; setTitle(newTitle) → {string} Tries to change the document title and returns it. Parameters: Name Type Description newTitle newTitle The desired new title. Source: CrossBase/general/CB_Client.js, line 846 Returns: Type string &lt;static&gt; supportsCanvas() → {boolean} Tells whether the canvas element is supported natively or not. Source: CrossBase/general/CB_Client.js, line 279 Returns: Type boolean &lt;static&gt; supportsCSS3Transform() → {boolean} Tells whether CSS3 transform is supported natively or not. Source: CrossBase/general/CB_Client.js, line 291 Returns: Type boolean &lt;static&gt; supportsFlash() → {boolean} Function that tells whether Adobe Flash (formerly Macromedia Flash) plugin is available or not. Source: CrossBase/general/CB_Client.js, line 401 Returns: Type boolean &lt;static&gt; supportsNodeJS() → {boolean} Function that tells whether Node.js is available (checks the availability of process.versions.node) or not. Source: CrossBase/general/CB_Client.js, line 332 Returns: Type boolean &lt;static&gt; supportsPHP() → {boolean} Function that tells whether PHP is available or not. Source: CrossBase/general/CB_Client.js, line 308 Returns: Type boolean &lt;static&gt; supportsSilverlight() → {boolean} Function that tells whether Microsoft Silverlight plugin is available or not. Source: CrossBase/general/CB_Client.js, line 359 Returns: Type boolean × Search results Close "},"CB_Collisions.html":{"id":"CB_Collisions.html","title":"Namespace: CB_Collisions","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Collisions CB_Collisions Static class to manage collisions. It will return itself if it is tried to be instantiated. Source: CrossBase/general/CB_Collisions.js, line 17 To Do: Finish many functions for many more kinds of collisions. Add triangles, polygons, arcs, etc. Add support to more dimensions (at least to 3D). Add lacking &quot;touching&quot; functions, equivalent to the &quot;over&quot; ones. Add a boolean parameter and a border parameter to detect collision just when it hits the border (not when it is inside of the object without touching the border), for &quot;hollow&quot; shapes. Think about adding function aliases with reversed names (for example, &quot;isElementOverPoint&quot; that points to &quot;isPointOverElement&quot;, etc.). Think about whether the aliases should or not have some parameters in reversed order. Methods &lt;static&gt; getDistancePoints(x, y, x2, y2) → {number|null} Tells the distance between two points. Parameters: Name Type Description x number The &quot;X&quot; coordinate of the first point. y number The &quot;Y&quot; coordinate of the first point. x2 number The &quot;X&quot; coordinate of the second point. y2 number The &quot;Y&quot; coordinate of the second point. Source: CrossBase/general/CB_Collisions.js, line 48 Returns: Returns the distance between the two points. In the case that it could not be calculated, returns null. Type number | null &lt;static&gt; isCircleOverCircle(centreX, centreY, radius, centreX2, centreY2, radius2) → {boolean} Tells whether a circle is over another circle. Parameters: Name Type Description centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. centreX2 number The &quot;X&quot; coordinate of the center of the second circle. centreY2 number The &quot;Y&quot; coordinate of the center of the second circle. radius2 number The radius of the second circle. Source: CrossBase/general/CB_Collisions.js, line 433 Returns: Returns whether the circle is over the other circle. Type boolean &lt;static&gt; isCircleTouchingCircle(centreX, centreY, radius, centreX2, centreY2, radius2) → {boolean} Tells whether a circle is touching (maybe over) another circle. This will also return true if they are adjacent (next to each other). Parameters: Name Type Description centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. centreX2 number The &quot;X&quot; coordinate of the center of the second circle. centreY2 number The &quot;Y&quot; coordinate of the center of the second circle. radius2 number The radius of the second circle. Source: CrossBase/general/CB_Collisions.js, line 451 Returns: Returns whether the circle is touching (maybe over) the other circle. This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isElementOverElement(element, element2) → {boolean} Tells whether two given DOM elements are over each other (they will be considered a rectangle). Parameters: Name Type Description element Element The first DOM element that we want to check (it will be considered a rectangle). element2 Element The second DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 401 Returns: Returns whether the two given DOM elements are over each other (they will be considered a rectangle). Type boolean &lt;static&gt; isElementTouchingElement(element, element2) → {boolean} Tells whether two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other). Parameters: Name Type Description element Element The first DOM element that we want to check (it will be considered a rectangle). element2 Element The second DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 415 Returns: Returns whether the two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isLineOverCircle(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius) → {boolean} Tells whether a line (infinite) is over a given circle. Parameters: Name Type Description lineX1 number The &quot;X&quot; coordinate of a first point of the line. lineY1 number The &quot;Y&quot; coordinate of a first point of the line. lineX2 number The &quot;X&quot; coordinate of a second point of the line. lineY2 number The &quot;Y&quot; coordinate of a second point of the line. centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. Source: CrossBase/general/CB_Collisions.js, line 535 Returns: Returns whether the line (infinite) is over the circle. Type boolean &lt;static&gt; isLineTouchingCircle(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius) → {boolean} Tells whether a line (infinite) is touching (maybe over) a given circle. Parameters: Name Type Description lineX1 number The &quot;X&quot; coordinate of a first point of the line. lineY1 number The &quot;Y&quot; coordinate of a first point of the line. lineX2 number The &quot;X&quot; coordinate of a second point of the line. lineY2 number The &quot;Y&quot; coordinate of a second point of the line. centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. Source: CrossBase/general/CB_Collisions.js, line 576 Returns: Returns whether the line (infinite) is touching (maybe over) the circle. Type boolean &lt;static&gt; isPointOverCircle(x, y, centreX, centreY, radius) → {boolean} Tells whether a point is over a circle. Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. centreX number The &quot;X&quot; coordinate of the center of the circle. centreY number The &quot;Y&quot; coordinate of the center of the circle. radius number The radius of the circle. Source: CrossBase/general/CB_Collisions.js, line 236 Returns: Returns whether the point is over the circle. Type boolean &lt;static&gt; isPointOverElement(x, y, element) → {boolean} Tells whether a given point is over a given DOM element (it will be considered a rectangle). Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. element Element The DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 63 Returns: Returns whether the point is over the given DOM element (it will be considered a rectangle). Type boolean &lt;static&gt; isPointOverEllipse(x, y, centreX, centreY, radiusX, radiusY [, rotation] [, rotationUseDegrees]) → {boolean} Tells whether a point is over an ellipse. Parameters: Name Type Argument Default Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. centreX number The &quot;X&quot; coordinate of the center of the ellipse. centreY number The &quot;Y&quot; coordinate of the center of the ellipse. radiusX number The X (horizontal) radius of the ellipse. radiusY number The Y (vertical) radius of the ellipse. rotation number &lt;optional&gt; 0 The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! rotationUseDegrees boolean &lt;optional&gt; false Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! Source: CrossBase/general/CB_Collisions.js, line 276 To Do: Make the &quot;rotation&quot; parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate). Returns: Returns whether the point is over the ellipse. Type boolean &lt;static&gt; isPointOverLine(x, y, lineX1, lineY1, lineX2, lineY2 [, tolerance]) → {boolean} Tells whether a point is over a line (infinite). Parameters: Name Type Argument Default Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. lineX1 number The &quot;X&quot; coordinate of a first point of the line. lineY1 number The &quot;Y&quot; coordinate of a first point of the line. lineX2 number The &quot;X&quot; coordinate of a second point of the line. lineY2 number The &quot;Y&quot; coordinate of a second point of the line. tolerance number &lt;optional&gt; 0.001 The amount of loss of precision we can tolerate to consider a collision. Source: CrossBase/general/CB_Collisions.js, line 99 To Do: Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). Create a CB_Collisions.isPointTouchingLine function. Returns: Returns whether the point is over the line (infinite). Type boolean &lt;static&gt; isPointOverRectangle(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight) → {boolean} Tells whether a point is over a rectangle. Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. rectangleX number The &quot;X&quot; coordinate of the upper left corner of the rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the rectangle. rectangleWidth number The width of the rectangle. rectangleHeight number The height of the rectangle. Source: CrossBase/general/CB_Collisions.js, line 192 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. Returns: Returns whether the point is over the rectangle. Type boolean &lt;static&gt; isPointOverSegment(x, y, segmentX1, segmentY1, segmentX2, segmentY2 [, tolerance]) → {boolean} Tells whether a point is over a line segment. Parameters: Name Type Argument Default Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. segmentX1 number The &quot;X&quot; coordinate of the beginning point of the line. segmentY1 number The &quot;Y&quot; coordinate of the beginning point of the line. segmentX2 number The &quot;X&quot; coordinate of the end point of the line. segmentY2 number The &quot;Y&quot; coordinate of the end point of the line. tolerance number &lt;optional&gt; 0.001 The amount of loss of precision we can tolerate to consider a collision. Source: CrossBase/general/CB_Collisions.js, line 153 To Do: Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). Create a CB_Collisions.isPointTouchingSegment function. Returns: Returns whether the point is over the line segment. Type boolean &lt;static&gt; isPointTouchingCircle(x, y, centreX, centreY, radius) → {boolean} Tells whether a point is touching (maybe over) a circle. This will also return true if they are adjacent (next to each other). Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. centreX number The &quot;X&quot; coordinate of the center of the circle. centreY number The &quot;Y&quot; coordinate of the center of the circle. radius number The radius of the circle. Source: CrossBase/general/CB_Collisions.js, line 254 Returns: Returns whether the point is touching (maybe over) the circle. This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isPointTouchingElement(x, y, element) → {boolean} Tells whether a given point is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. element Element The DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 78 Returns: Returns whether the point is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isPointTouchingEllipse(x, y, centreX, centreY, radiusX, radiusY [, rotation] [, rotationUseDegrees]) → {boolean} Tells whether a point is touching (maybe over) a ellipse. This will also return true if they are adjacent (next to each other). Parameters: Name Type Argument Default Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. centreX number The &quot;X&quot; coordinate of the center of the ellipse. centreY number The &quot;Y&quot; coordinate of the center of the ellipse. radiusX number The X (horizontal) radius of the ellipse. radiusY number The Y (vertical) radius of the ellipse. rotation number &lt;optional&gt; 0 The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! rotationUseDegrees boolean &lt;optional&gt; false Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! Source: CrossBase/general/CB_Collisions.js, line 301 To Do: Make the &quot;rotation&quot; parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate). Returns: Returns whether the point is touching (maybe over) the ellipse. This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isPointTouchingRectangle(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight) → {boolean} Tells whether a point is touching (maybe over) a rectangle. This will also return true if they are adjacent (next to each other). Parameters: Name Type Description x number The &quot;X&quot; coordinate of the point. y number The &quot;Y&quot; coordinate of the point. rectangleX number The &quot;X&quot; coordinate of the upper left corner of the rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the rectangle. rectangleWidth number The width of the rectangle. rectangleHeight number The height of the rectangle. Source: CrossBase/general/CB_Collisions.js, line 210 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. Returns: Returns whether the point is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isRectangleOverCircle(centreX, centreY, radius, rectangleX, rectangleY, rectangleWidth, rectangleHeight) → {boolean} Tells whether a circle is over a given rectangle. Parameters: Name Type Description centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. Source: CrossBase/general/CB_Collisions.js, line 472 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. Returns: Returns whether the circle is over the rectangle. Type boolean &lt;static&gt; isRectangleOverElement(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element) → {boolean} Tells whether a rectangle is over a given DOM element (it will be considered a rectangle). Parameters: Name Type Description rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. element Element The DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 369 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. Returns: Returns whether the rectangle is over the given DOM element (it will be considered a rectangle). Type boolean &lt;static&gt; isRectangleOverRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) → {boolean} Tells whether a rectangle is over another rectangle. Parameters: Name Type Description rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. rectangleX2 number The &quot;X&quot; coordinate of the upper left corner of the second rectangle. rectangleY2 number The &quot;Y&quot; coordinate of the upper left corner of the second rectangle. rectangleWidth2 number The width of the second rectangle. rectangleHeight2 number The height of the second rectangle. Source: CrossBase/general/CB_Collisions.js, line 326 To Do: Think about using &quot;rotation&quot; and &quot;rotation2&quot; parameters to accept rotated rectangles. Returns: Returns whether the rectangle is over the other rectangle. Type boolean &lt;static&gt; isRectangleTouchingCircle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, centreX, centreY, radius) → {boolean} Tells whether a circle is touching (maybe over) a given rectangle. Parameters: Name Type Description rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. centreX number The &quot;X&quot; coordinate of the center of the first circle. centreY number The &quot;Y&quot; coordinate of the center of the first circle. radius number The radius of the first circle. Source: CrossBase/general/CB_Collisions.js, line 504 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. //* Source (modified): markE at https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle Returns: Returns whether the circle is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isRectangleTouchingElement(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element) → {boolean} Tells whether a rectangle is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). Parameters: Name Type Description rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. element Element The DOM element that we want to check (it will be considered a rectangle). Source: CrossBase/general/CB_Collisions.js, line 387 To Do: Think about using a &quot;rotation&quot; parameter to accept rotated rectangles. Returns: Returns whether the rectangle is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other). Type boolean &lt;static&gt; isRectangleTouchingRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2) → {boolean} Tells whether a rectangle is touching (maybe over) another rectangle. This will also return true if they are adjacent (next to each other). Parameters: Name Type Description rectangleX number The &quot;X&quot; coordinate of the upper left corner of the first rectangle. rectangleY number The &quot;Y&quot; coordinate of the upper left corner of the first rectangle. rectangleWidth number The width of the first rectangle. rectangleHeight number The height of the first rectangle. rectangleX2 number The &quot;X&quot; coordinate of the upper left corner of the second rectangle. rectangleY2 number The &quot;Y&quot; coordinate of the upper left corner of the second rectangle. rectangleWidth2 number The width of the second rectangle. rectangleHeight2 number The height of the second rectangle. Source: CrossBase/general/CB_Collisions.js, line 349 To Do: Think about using &quot;rotation&quot; and &quot;rotation2&quot; parameters to accept rotated rectangles. Returns: Returns whether the rectangle is touching (maybe over) the other rectangle. This will also return true if they are adjacent (next to each other). Type boolean × Search results Close "},"CB_Configuration.html":{"id":"CB_Configuration.html","title":"Namespace: CB_Configuration","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Configuration CB_Configuration Static class to manage the configuration. It will be overwritten with the values defined in CB_OPTIONS (if any). First-level indexes should belong to the module name and second-level indexes should belong to the option name. Follows the same format as CB_OPTIONS. Source: CrossBrowdy.js, line 65 Namespaces CrossBase CrossBrowdy × Search results Close "},"CB_Configuration.CrossBase.html":{"id":"CB_Configuration.CrossBase.html","title":"Namespace: CrossBase","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CrossBase CB_Configuration. CrossBase Property that contains an object with the options for the main script. Source: CrossBase/CrossBase.js, line 52 Members &lt;static, constant&gt; BANDJS_LOAD :boolean Defines whether to load or not Band.js. Type: boolean Default Value: typeof(window.AudioContext) !== &quot;undefined&quot; || typeof(window.webkitAudioContext) !== &quot;undefined&quot; Source: CrossBase/CrossBase.js, line 1161 &lt;static, constant&gt; BANDJS_PATH :string Directory that contains the Band.js files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/audio/band.js/&quot; Source: CrossBase/CrossBase.js, line 1171 &lt;static, constant&gt; BANDJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.BANDJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1191 &lt;static, constant&gt; BANDJS_PATH_SCRIPT_FILE :string The script file path for Band.js. Type: string Default Value: CB_Configuration.CrossBase.BANDJS_PATH + &quot;band.min.js&quot; Source: CrossBase/CrossBase.js, line 1181 &lt;static, constant&gt; CANBOX_LOAD :boolean Defines whether to load or not Canbox. Type: boolean Default Value: CB_Configuration.CrossBase.needsCanbox() Source: CrossBase/CrossBase.js, line 1554 &lt;static, constant&gt; CANBOX_PATH :string Directory that contains the Canbox files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/canvas/canbox/&quot; Source: CrossBase/CrossBase.js, line 1564 &lt;static, constant&gt; CANBOX_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.CANBOX_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1584 &lt;static, constant&gt; CANBOX_PATH_SCRIPT_FILE :string The script file path for Canbox. Type: string Default Value: CB_Configuration.CrossBase.CANBOX_PATH + &quot;canbox.0.2.1.js&quot; Source: CrossBase/CrossBase.js, line 1574 &lt;static, constant&gt; CANVAS_TEXT_LOAD :boolean Defines whether to load or not canvas-text. Type: boolean Default Value: CB_Configuration.CrossBase.needsCanvasText() Source: CrossBase/CrossBase.js, line 1772 &lt;static, constant&gt; CANVAS_TEXT_PATH :string Directory that contains the canvas-text files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot; Source: CrossBase/CrossBase.js, line 1782 &lt;static, constant&gt; CANVAS_TEXT_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.CANVAS_TEXT_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1802 &lt;static, constant&gt; CANVAS_TEXT_PATH_SCRIPT_FILE :string The script file path for canvas-text. Type: string Default Value: CB_Configuration.CrossBase.CANVAS_TEXT_PATH + &quot;canvas.text.js&quot; Source: CrossBase/CrossBase.js, line 1792 &lt;static, constant&gt; CB_AudioDetector_allowEmulation_DEFAULT :boolean Value by default when the &quot;allowEmulation&quot; parameter is not provided in the CB_AudioDetector.getPreferredAPI, the CB_AudioDetector.getSupportedAPIs or the CB_AudioDetector.isAPISupported function. Type: boolean Source: CrossBase/CrossBase.js, line 363 &lt;static, constant&gt; CB_AudioFile_AAPI_USE_TIMEOUT_TO_DETECT_STOPAT :boolean Tells whether CB_AudioFile[&quot;AAPI&quot;] uses setTimeout (instead of timeupdate event) to detect when the given &quot;stopAt&quot; is reached. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 295 &lt;static, constant&gt; CB_AudioFile_AudioFileCache_ALLOWED_RECURSIVE_DELAY_DEFAULT :integer Default value for maximum delay (in milliseconds) to wait for a sound to start playing or start next loop (if the time expires, the sound will never be played). Used by CB_AudioFile_API.WAAPI, CB_AudioFile_API.AAPI, CB_AudioFile_API.SM2, CB_AudioFile_API.ACMP and CB_AudioFileCache. Type: integer Default Value: 150 Source: CrossBase/CrossBase.js, line 306 &lt;static, constant&gt; CB_AudioFile_AudioFileCache_MUTE_ON_LOAD_AND_CHECKING :boolean Tells whether to mute or not the audio files when they load or are checking. Note: Audio cache does not work properly on BlackBerry PlayBook's default browser if the sounds are muted when load or are checking. Used by CB_AudioFile, CB_AudioFile_API.WAAPI, CB_AudioFile_API.AAPI, CB_AudioFile_API.SM2, CB_AudioFile_API.ACMP and CB_AudioFileCache. Type: boolean Default Value: !(navigator.userAgent.indexOf(&quot;PlayBook&quot;) !== -1 &amp;&amp; navigator.userAgent.indexOf(&quot;Tablet OS&quot;) !== -1) Source: CrossBase/CrossBase.js, line 317 &lt;static, constant&gt; CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_DEFAULT :boolean Defines whether to use CB_Speaker._volume as default volume. Used by CB_AudioFile, CB_AudioFile_API.WAAPI, CB_AudioFile_API.AAPI, CB_AudioFile_API.SM2, CB_AudioFile_API.ACMP and CB_AudioFileCache. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 327 &lt;static, constant&gt; CB_AudioFile_AudioFileCache_USE_SPEAKER_VOLUME_AS_MAXIMUM :boolean Defines whether to use CB_Speaker._volume as maximum volume. Used by CB_AudioFile, CB_AudioFile_API.WAAPI, CB_AudioFile_API.AAPI, CB_AudioFile_API.SM2 and CB_AudioFile_API.ACMP. Type: boolean Source: CrossBase/CrossBase.js, line 337 &lt;static, constant&gt; CB_AudioFile_AUTOPLAY_SILENTLY_ON_LOAD_MS :integer Milliseconds that a file is played (with volume set to 0) automatically when an audio file is loaded. Needed for some web clients which cannot find out the duration otherwise. Used by CB_AudioFile. Type: integer Default Value: 500 Source: CrossBase/CrossBase.js, line 275 &lt;static, constant&gt; CB_AudioFile_ONLOAD_TIMEOUT_MS :integer Milliseconds to wait before declaring a sound as failed if it cannot be loaded before. Used by CB_AudioFile_API.SM2. Type: integer Default Value: 15000 Source: CrossBase/CrossBase.js, line 285 &lt;static, constant&gt; CB_AudioFileCache_PREFERRED_AUDIO_APIS :array Array with the default preferred audio APIs by order of preference. Used by CB_AudioFileCache and CB_AudioDetector. Possible audio APIs are &quot;WAAPI&quot; (HTML5 Web Audio API), &quot;SM2&quot; (SoundManager 2), &quot;ACMP&quot; (Apache Cordova Media Plugin) or &quot;AAPI&quot; (HTML5 Audio API). Note: since Internet Explorer 9 works better with SM2 than with AAPI, if it is detected then the default value will be: [ &quot;WAAPI&quot;, &quot;SM2&quot;, &quot;ACMP&quot;, &quot;AAPI&quot; ] Type: array Default Value: [&quot;WAAPI&quot;, &quot;AAPI&quot;, &quot;ACMP&quot;, &quot;SM2&quot;] Source: CrossBase/CrossBase.js, line 375 &lt;static, constant&gt; CB_AudioFileCache_PREFERRED_AUDIO_FORMATS :array Array with the default preferred audio formats by order of preference. Used by CB_AudioFileCache and CB_AudioDetector. NOTE: some web clients do not support to specify codecs so it is better to also provide strings without codecs. Type: array Default Value: [&quot;audio/ogg; codecs=\\&quot;vorbis\\&quot;&quot;,&quot;audio/ogg; codecs=\\&quot;speex\\&quot;&quot;,&quot;audio/ogg; codecs=\\&quot;flac\\&quot;&quot;,&quot;audio/ogg&quot;,&quot;audio/mpeg; codecs=\\&quot;mp3\\&quot;&quot;,&quot;audio/mpeg&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.40.5\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.40.2\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.40.05\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.40.02\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.69\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.6B\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.67\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.a6\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;mp4a.a5\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;aac51\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;ac-3\\&quot;&quot;,&quot;audio/mp4; codecs=\\&quot;ec-3\\&quot;&quot;,&quot;audio/mp4&quot;,&quot;audio/aac; codecs=\\&quot;aac\\&quot;&quot;,&quot;audio/aac; codecs=\\&quot;mp4a.40.5\\&quot;&quot;,&quot;audio/aac; codecs=\\&quot;vorbis\\&quot;&quot;,&quot;audio/aac&quot;,&quot;audio/x-aac; codecs=\\&quot;aac\\&quot;&quot;,&quot;audio/x-aac&quot;,&quot;audio/x-m4b; codecs=\\&quot;aac\\&quot;&quot;,&quot;audio/x-m4b&quot;,&quot;audio/x-m4p; codecs=\\&quot;aac\\&quot;&quot;,&quot;audio/x-m4p&quot;,&quot;audio/webm; codecs=\\&quot;vorbis\\&quot;&quot;,&quot;audio/webm&quot;,&quot;audio/3gpp; codecs=\\&quot;samr\\&quot;&quot;,&quot;audio/3gpp&quot;,&quot;audio/wav; codecs=\\&quot;1\\&quot;&quot;,&quot;audio/wav&quot;,&quot;audio/x-wav; codecs=\\&quot;1\\&quot;&quot;,&quot;audio/x-wav&quot;,&quot;audio/x-pn-wav; codecs=\\&quot;1\\&quot;&quot;,&quot;audio/x-pn-wav&quot;,&quot;audio/wave; codecs=\\&quot;1\\&quot;&quot;,&quot;audio/wave&quot;,&quot;audio/x-wave; codecs=\\&quot;1\\&quot;&quot;,&quot;audio/x-wave&quot;] Source: CrossBase/CrossBase.js, line 395 &lt;static, constant&gt; CB_Canvas_PREFERRED_EMULATION_METHODS :array Array with the default desired canvas emulation methods by order of preference. Used by CB_Canvas. Type: array Default Value: [&quot;FLASH&quot;,&quot;VML&quot;,&quot;DHTML&quot;,&quot;SILVERLIGHT&quot;] Source: CrossBase/CrossBase.js, line 347 &lt;static, constant&gt; CB_Client_allowNavigatorLanguages_DEFAULT :boolean Default value for the &quot;allowNavigatorLanguages&quot; parameter for CB_Client.getLanguage and CB_Client.getLanguages functions. Type: boolean Source: CrossBase/CrossBase.js, line 145 &lt;static, constant&gt; CB_Client_language_DEFAULT :string Default language to use for CB_Client when no language can be detected (very strange case!). Type: string Default Value: en Source: CrossBase/CrossBase.js, line 135 &lt;static, constant&gt; CB_Client_PHPAcceptedLanguagesFirst_DEFAULT :boolean Tells whether the CB_Client.getLanguage and CB_Client.getLanguages functions will use the accepted languages detected by PHP (if any) as the first option by default or not. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 155 &lt;static, constant&gt; CB_Controllers_avoidProprietary_DEFAULT :boolean Default value for the &quot;avoidProprietary&quot; proprietary when calling different functions of the CB_Controllers static class, as the CB_Controllers.getButtonsDown, the CB_Controllers.isButtonDown and the CB_Controllers.getGamePads functions, etc. Type: boolean Source: CrossBase/CrossBase.js, line 225 &lt;static, constant&gt; CB_Device_getTime_HIGH_PRECISION :string Defines whether to use high precision in the CB_Device.getTime (returning 'window.performance.timing.navigationStart + window.performance.now()', where 'window.performance.now' could be polyfilled) or not (returning 'Date.now()', where 'Date.now' could be polyfilled). Type: string Default Value: true Source: CrossBase/CrossBase.js, line 95 &lt;static, constant&gt; CB_Elements_classes_USE_CACHE :boolean Defines whether to use cache for the function CB_Elements.classes by default. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 125 &lt;static, constant&gt; CB_Elements_id_USE_CACHE :boolean Defines whether to use cache for the function CB_Elements.id by default. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 105 &lt;static, constant&gt; CB_Elements_tag_USE_CACHE :boolean Defines whether to use cache for the CB_Elements.tag function by default. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 115 &lt;static, constant&gt; CB_Keyboard_extended_PS4_allowDuplicateKeyAliases :boolean Defines whether to allow Sony Playstation 4 codes set in the CB_Keyboard.extended.PS4CB_Keyboard.extended.PS4 object to be defined in the key aliases even if they use codes which belong to other keys. Used by CB_Keyboard. Type: boolean Source: CrossBase/CrossBase.js, line 195 &lt;static, constant&gt; CB_Keyboard_extended_SAMSUNG_TV_allowDuplicateKeyAliases :boolean Defines whether to allow Samsung TV key codes (from the remote control) set in the CB_Keyboard.extended.SAMSUNG_TV object to be defined in the key aliases even if they use codes which belong to other keys. Used by CB_Keyboard. Type: boolean Source: CrossBase/CrossBase.js, line 215 &lt;static, constant&gt; CB_Keyboard_extended_VK_allowDuplicateKeyAliases :boolean Defines whether to allow Smart TV codes (from the remote control) and virtual key codes set in the CB_Keyboard.extended.VK object to be defined in the key aliases even if they use codes which belong to other keys. Used by CB_Keyboard. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 205 &lt;static, constant&gt; CB_Keyboard_extended_WII_allowDuplicateKeyAliases :boolean Defines whether to allow Nintendo Wii codes (from the Wiimote) set in the CB_Keyboard.extended.WII object to be defined in the key aliases even if they use codes which belong to other keys. Used by CB_Keyboard. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 185 &lt;static, constant&gt; CB_Net_Sockets_PREVENT_FIREFOX_ESC_BUG :boolean Defines whether we want to prevent the Firefox bug that affects SockJS library (see https://github.com/sockjs/sockjs-client/issues/18) or not. Used by CB_Keyboard. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 175 &lt;static, constant&gt; CB_Net_XHR_PROXY_URL :string URL for the proxy to prevent cross-domain issues through AJAX, used by CB_Net.XHR.callProxy function. Can be relative to the main script folder or not, depending on CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL_RELATIVE. NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy. Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;net/proxy/CB_proxy.php&quot; Source: CrossBase/CrossBase.js, line 457 &lt;static, constant&gt; CB_Net_XHR_PROXY_URL_RELATIVE :boolean Defines whether the URL for the proxy (defined in CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL) is relative to the main script folder or not. If it is relative, the &quot;onCall&quot; event of the CrossBase module will append the value of the &quot;scriptPathGiven&quot; parameter at the beginning. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 165 &lt;static, constant&gt; CB_Screen_isFullScreen_ALLOWED_HEIGHT_MARGIN_PERCENTAGE :float Allowed height margin of the total screen available to consider whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. Used by the CB_Screen.isFullScreen function. Type: float Default Value: 3.5 Source: CrossBase/CrossBase.js, line 245 &lt;static, constant&gt; CB_Screen_isFullScreen_ALLOWED_WIDTH_MARGIN_PERCENTAGE :float Allowed width margin of the total screen available to consider whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. Used by the CB_Screen.isFullScreen function. Type: float Default Value: 3.9 Source: CrossBase/CrossBase.js, line 235 &lt;static, constant&gt; CB_Speaker_DEFAULT_VOLUME :integer Default volume for CB_Speaker (from 0 to 100). Type: integer Default Value: 100 Source: CrossBase/CrossBase.js, line 265 &lt;static, constant&gt; CORDOVAJS_LOAD :boolean Defines whether to try to load or not cordova.js (used by Apache Cordova). It should not be loaded together with phonegap.js, normally. If set to true, the checker defined at CB_Configuration.CrossBase.CORDOVAJS_LOAD_CHECKER will finally decide whether to load it or not. Type: boolean Default Value: !CB_Configuration.CrossBase.PHONEGAPJS_LOAD Source: CrossBase/CrossBase.js, line 930 &lt;static, constant&gt; CORDOVAJS_LOAD_CHECKER :CB_Modules.neededFile_LOAD_CHECKER Callback checker to determine whether cordova.js (used by Apache Cordova) is needed or not. Requires CB_Configuration.CrossBase.CORDOVAJS_LOAD set to true. Type: CB_Modules.neededFile_LOAD_CHECKER Default Value: function(currentPath, info) { return (typeof(window.cordova) === &quot;undefined&quot;); } Source: CrossBase/CrossBase.js, line 941 &lt;static, constant&gt; CORDOVAJS_PATH :string Directory that contains the &quot;cordova.js&quot; file (used by Apache Cordova). Type: string Source: CrossBase/CrossBase.js, line 951 &lt;static, constant&gt; CORDOVAJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.CORDOVAJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 971 &lt;static, constant&gt; CORDOVAJS_PATH_SCRIPT_FILE :string The script file path for the cordova.js file (used by Apache Cordova). Type: string Default Value: CB_Configuration.CrossBase.CORDOVAJS_PATH + &quot;cordova.js&quot; Source: CrossBase/CrossBase.js, line 961 &lt;static, constant&gt; EXCANVAS_LOAD :boolean Defines whether to load or not ExplorerCanvas. Type: boolean Default Value: CB_Configuration.CrossBase.needsExplorerCanvas() Source: CrossBase/CrossBase.js, line 1730 &lt;static, constant&gt; EXCANVAS_PATH :string Directory that contains the ExplorerCanvas files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/canvas/excanvas_with_canvas_text/&quot; Source: CrossBase/CrossBase.js, line 1740 &lt;static, constant&gt; EXCANVAS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.EXCANVAS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1760 &lt;static, constant&gt; EXCANVAS_PATH_SCRIPT_FILE :string The script file path for ExplorerCanvas. Type: string Default Value: CB_Configuration.CrossBase.EXCANVAS_PATH + &quot;excanvas.js&quot; Source: CrossBase/CrossBase.js, line 1750 &lt;static, constant&gt; EXTEND_DOM :boolean Defines whether to allow to extend the DOM if needed or not. If set to true and some methods (as for example Array.indexOf, Array.lastIndexOf, Array.isArray, Array.forEach, NodeList.forEach, HTMLCollection.forEach, etc.) are not supported natively, they will be added. Type: boolean Source: CrossBase/CrossBase.js, line 85 &lt;static, constant&gt; FLASHCANVAS_ALLOW_RUN_LOCALLY_DEFAULT :boolean Defines whether to allow to run FlashCanvas locally or not (because the &quot;.swf&quot; file folder needs to be added to 'trusted files' in Flash global configuration to work locally in some operating systems). Type: boolean Source: CrossBase/CrossBase.js, line 1606 &lt;static, constant&gt; FLASHCANVAS_DISABLE_CONTEXT_MENU :boolean Disables the context menu when the right mouse button is clicked on any canvas using FlashCanvas' SWF. Belongs to the &quot;disableContextMenu&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config Type: boolean Source: CrossBase/CrossBase.js, line 1656 &lt;static, constant&gt; FLASHCANVAS_IMAGE_CACHE_SIZE :integer Maximum size for the image cache used by FlashCanvas. Belongs to the &quot;imageCacheSize&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config Type: integer Source: CrossBase/CrossBase.js, line 1676 &lt;static, constant&gt; FLASHCANVAS_LOAD :boolean Defines whether to load or not FlashCanvas. Type: boolean Default Value: CB_Configuration.CrossBase.needsFlashCanvas() Source: CrossBase/CrossBase.js, line 1596 &lt;static, constant&gt; FLASHCANVAS_PATH :string Directory that contains the FlashCanvas files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/canvas/FlashCanvas/pro/&quot; Source: CrossBase/CrossBase.js, line 1616 &lt;static, constant&gt; FLASHCANVAS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.FLASHCANVAS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1646 &lt;static, constant&gt; FLASHCANVAS_PATH_SCRIPT_FILE :string The script file path for FlashCanvas. Type: string Default Value: CB_Configuration.CrossBase.FLASHCANVAS_PATH + &quot;bin/flashcanvas.js&quot; Source: CrossBase/CrossBase.js, line 1626 &lt;static, constant&gt; FLASHCANVAS_PATH_SWF :string Directory that contains the SWF's for FlashCanvas. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;swfPath&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config Type: string Default Value: CB_Configuration.CrossBase.FLASHCANVAS_PATH + &quot;bin/&quot; Source: CrossBase/CrossBase.js, line 1636 &lt;static, constant&gt; FLASHCANVAS_TURBO_MODE :boolean Uses turbo mode to speed up FlashCanvas. Belongs to the &quot;turbo&quot; parameter of the library set on the &quot;window.FlashCanvasOptions&quot; object. More information: https://web.archive.org/web/20180604011002/http://flashcanvas.net/docs/config Type: boolean Source: CrossBase/CrossBase.js, line 1666 &lt;static, constant&gt; GAMEPAD_PLUS_LOAD :boolean Defines whether to load or not gamepad-plus. Type: boolean Default Value: CB_Configuration.CrossBase.needsGamepadPlus() Source: CrossBase/CrossBase.js, line 1512 &lt;static, constant&gt; GAMEPAD_PLUS_PATH :string Directory that contains the gamepad-plus files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;input/controllers/gamepad-plus/&quot; Source: CrossBase/CrossBase.js, line 1522 &lt;static, constant&gt; GAMEPAD_PLUS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.GAMEPAD_PLUS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1542 &lt;static, constant&gt; GAMEPAD_PLUS_PATH_SCRIPT_FILE :string The script file path for gamepad-plus. Type: string Default Value: CB_Configuration.CrossBase.GAMEPAD_PLUS_PATH + &quot;gamepads.js&quot; Source: CrossBase/CrossBase.js, line 1532 &lt;static, constant&gt; HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE :string The script file path for Hammer Time. Type: string Default Value: CB_Configuration.CrossBase.HAMMERJS_PATH + &quot;hammer-time/hammer-time.min.js&quot; Source: CrossBase/CrossBase.js, line 1448 &lt;static, constant&gt; HAMMERJS_LOAD :boolean Defines whether to load or not Hammer.js and Hammer Time. Type: boolean Default Value: CB_Configuration.CrossBase.needsHammerJS() Source: CrossBase/CrossBase.js, line 1418 &lt;static, constant&gt; HAMMERJS_PATH :string Directory that contains the Hammer.js and Hammer Time files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;input/hammer.js/&quot; Source: CrossBase/CrossBase.js, line 1428 &lt;static, constant&gt; HAMMERJS_PATH_ABSOLUTE :boolean Defines whether the paths defined in CB_Configuration.CrossBase.HAMMERJS_PATH_SCRIPT_FILE and CB_Configuration.CrossBase.HAMMERJS_HAMMER_TIME_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1458 &lt;static, constant&gt; HAMMERJS_PATH_SCRIPT_FILE :string The script file path for Hammer.js. Type: string Default Value: CB_Configuration.CrossBase.HAMMERJS_PATH + &quot;hammer.min.js&quot; Source: CrossBase/CrossBase.js, line 1438 &lt;static, constant&gt; INTELXDK_INITDEVJS_LOAD :boolean Defines whether to try to load or not init-dev.js (used by Intel XDK). If set to true, the checker defined at CB_Configuration.CrossBase.INTELXDK_INITDEVJS_LOAD_CHECKER will finally decide whether to load it or not. Type: boolean Source: CrossBase/CrossBase.js, line 835 &lt;static, constant&gt; INTELXDK_INITDEVJS_LOAD_CHECKER :CB_Modules.neededFile_LOAD_CHECKER Callback checker to determine whether init-dev.js (used by Intel XDK) is needed or not. Requires CB_Configuration.CrossBase.INTELXDK_INITDEVJS_LOAD set to true. Type: CB_Modules.neededFile_LOAD_CHECKER Default Value: false Source: CrossBase/CrossBase.js, line 846 &lt;static, constant&gt; INTELXDK_INITDEVJS_PATH :string Directory that contains the &quot;init-dev.js&quot; (used by Intel XDK). Type: string Source: CrossBase/CrossBase.js, line 856 &lt;static, constant&gt; INTELXDK_INITDEVJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.INTELXDK_INITDEVJS_PATH is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 876 &lt;static, constant&gt; INTELXDK_INITDEVJS_PATH_SCRIPT_FILE :string The script file path for init-dev.js file (used by Intel XDK). Type: string Default Value: CB_Configuration.CrossBase.INTELXDK_INITDEVJS_PATH + &quot;init-dev.js&quot; Source: CrossBase/CrossBase.js, line 866 &lt;static, constant&gt; INTELXDKJS_LOAD :boolean Defines whether to load or not intelxdk.js (used by Intel XDK). Type: boolean Source: CrossBase/CrossBase.js, line 795 &lt;static, constant&gt; INTELXDKJS_PATH :string Directory that contains the &quot;intelxdk.js&quot; file (used by Intel XDK). Type: string Source: CrossBase/CrossBase.js, line 805 &lt;static, constant&gt; INTELXDKJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.INTELXDKJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 825 &lt;static, constant&gt; INTELXDKJS_PATH_SCRIPT_FILE :string The script file path for intelxdk.js (used by Intel XDK). Type: string Default Value: CB_Configuration.CrossBase.INTELXDKJS_PATH + &quot;intelxdk.js&quot; Source: CrossBase/CrossBase.js, line 815 &lt;static, constant&gt; JSFX_LOAD :boolean Defines whether to load or not jsfx. Type: boolean Default Value: CB_Configuration.CrossBase.needsJsfx() Source: CrossBase/CrossBase.js, line 1292 &lt;static, constant&gt; JSFX_PATH :string Directory that contains the jsfx files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/audio/jsfx/&quot; Source: CrossBase/CrossBase.js, line 1302 &lt;static, constant&gt; JSFX_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.JSFX_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1322 &lt;static, constant&gt; JSFX_PATH_SCRIPT_FILE :string The script file path for jsfx. Type: string Default Value: CB_Configuration.CrossBase.JSFX_PATH + &quot;jsfx.js&quot; Source: CrossBase/CrossBase.js, line 1312 &lt;static, constant&gt; LOCALSTORAGE_POLYFILL_LOAD :boolean Defines whether to load or not localStorage polyfill. Type: boolean Source: CrossBase/CrossBase.js, line 983 &lt;static, constant&gt; LOCALSTORAGE_POLYFILL_PATH :string Directory that contains the localStorage polyfill files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;general/localStorage/&quot; Source: CrossBase/CrossBase.js, line 993 &lt;static, constant&gt; LOCALSTORAGE_POLYFILL_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1024 &lt;static, constant&gt; LOCALSTORAGE_POLYFILL_PATH_SCRIPT_FILE :string The script file path for localStorage polyfill. Type: string Default Value: CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH + &quot;localStorage.min.js?swfURL=&quot; + CB_Configuration[CB_BASE_NAME].LOCALSTORAGE_POLYFILL_PATH_SWF_FILE Source: CrossBase/CrossBase.js, line 1014 &lt;static, constant&gt; LOCALSTORAGE_POLYFILL_PATH_SWF :string Directory that contains the SWF for localStorage polyfill. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;swfURL&quot; parameter (URL &quot;GET&quot; parameter) of the library when the localStorage script file is attached. Type: string Default Value: CB_Configuration.CrossBase.LOCALSTORAGE_POLYFILL_PATH + &quot;localStorage.swf&quot; Source: CrossBase/CrossBase.js, line 1003 &lt;static, constant&gt; MIND_IFRAMES :boolean Defines whether to have in mind possible iframes that could contain the script or not. Used by some functions of CB_Client, CB_Events, etc. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 75 &lt;static, constant&gt; NOSLEEP_LOAD :boolean Defines whether to load or not NoSleep.js. Type: boolean Default Value: CB_Configuration.CrossBase.needsSleepJS() Source: CrossBase/CrossBase.js, line 1334 &lt;static, constant&gt; NOSLEEP_PATH :string Directory that contains the NoSleep.js files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/NoSleep/&quot; Source: CrossBase/CrossBase.js, line 1344 &lt;static, constant&gt; NOSLEEP_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.NOSLEEP_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1364 &lt;static, constant&gt; NOSLEEP_PATH_SCRIPT_FILE :string The script file path for NoSleep.js. Type: string Default Value: CB_Configuration.CrossBase.NOSLEEP_PATH + &quot;NoSleep.min.js&quot; Source: CrossBase/CrossBase.js, line 1354 &lt;static, constant&gt; PHONEGAPJS_LOAD :boolean Defines whether to load or not phonegap.js (used by Adobe PhoneGap). Type: boolean Source: CrossBase/CrossBase.js, line 888 &lt;static, constant&gt; PHONEGAPJS_PATH :string Directory that contains the &quot;phonegap.js&quot; (used by Adobe PhoneGap) file. Type: string Source: CrossBase/CrossBase.js, line 898 &lt;static, constant&gt; PHONEGAPJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.PHONEGAPJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 918 &lt;static, constant&gt; PHONEGAPJS_PATH_SCRIPT_FILE :string The script file path for phonegap.js (used by Adobe PhoneGap). Type: string Default Value: CB_Configuration.CrossBase.PHONEGAPJS_PATH + &quot;phonegap.js&quot; Source: CrossBase/CrossBase.js, line 908 &lt;static, constant&gt; PRESSUREJS_LOAD :boolean Defines whether to load or not Pressure.js. Type: boolean Default Value: CB_Configuration.CrossBase.needsPressureJS() Source: CrossBase/CrossBase.js, line 1376 &lt;static, constant&gt; PRESSUREJS_PATH :string Directory that contains the Pressure.js files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;input/pressure.js/&quot; Source: CrossBase/CrossBase.js, line 1386 &lt;static, constant&gt; PRESSUREJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.PRESSUREJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1406 &lt;static, constant&gt; PRESSUREJS_PATH_SCRIPT_FILE :string The script file path for Pressure.js. Type: string Default Value: CB_Configuration.CrossBase.PRESSUREJS_PATH + &quot;pressure.min.js&quot; Source: CrossBase/CrossBase.js, line 1396 &lt;static, constant&gt; SCRIPT_PATH :string Path to the CrossBase module, relative to the CrossBrowdy folder. Type: string Default Value: CB_BASE_NAME + &quot;/&quot; Source: CrossBase/CrossBase.js, line 65 &lt;static, constant&gt; SLCANVAS_LOAD :boolean Defines whether to load or not SLCanvas. Type: boolean Default Value: CB_Configuration.CrossBase.needsSLCanvas() Source: CrossBase/CrossBase.js, line 1688 &lt;static, constant&gt; SLCANVAS_PATH :string Directory that contains the SLCanvas files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/image/canvas/slcanvas/&quot; Source: CrossBase/CrossBase.js, line 1698 &lt;static, constant&gt; SLCANVAS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.SLCANVAS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1718 &lt;static, constant&gt; SLCANVAS_PATH_SCRIPT_FILE :string The script file path for SLCanvas. Type: string Default Value: CB_Configuration.CrossBase.SLCANVAS_PATH + &quot;slcanvas.js&quot; Source: CrossBase/CrossBase.js, line 1708 &lt;static, constant&gt; SM2_AUDIO_FORMATS_REQUIRED :Object Object with the required formats for SoundManager 2. If the format is required and the web client doesn't support it, SoundManager 2 will use Flash. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-audioformats Type: Object Properties: Name Type Default Description mp3 boolean false Defines MP3 format as required. mp4 boolean false Defines MP4 format as required. ogg boolean false Defines OGG format as required. opus boolean false Defines OPUS format as required. wav boolean false Defines WAV format as required. Source: CrossBase/CrossBase.js, line 1253 &lt;static, constant&gt; SM2_LOAD :boolean Defines whether to load or not SoundManager 2. Type: boolean Source: CrossBase/CrossBase.js, line 1203 &lt;static, constant&gt; SM2_PATH :string Directory that contains the SoundManager 2 files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/audio/soundmanager2/&quot; Source: CrossBase/CrossBase.js, line 1213 &lt;static, constant&gt; SM2_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.SM2_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1243 &lt;static, constant&gt; SM2_PATH_SCRIPT_FILE :string The script file path for SoundManager 2. Type: string Default Value: CB_Configuration.CrossBase.SM2_PATH + &quot;script/soundmanager2-nodebug-jsmin.js&quot; Source: CrossBase/CrossBase.js, line 1223 &lt;static, constant&gt; SM2_PATH_SWF :string Directory that contains the SWF's for SoundManager 2. The value of the &quot;scriptPathGiven&quot; parameter will be attached at the beginning automatically. Belongs to the &quot;url&quot; parameter of the library when soundManager.setup&quot;&gt;www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-url Type: string Default Value: CB_Configuration.CrossBase.SM2_PATH + &quot;swf/&quot; Source: CrossBase/CrossBase.js, line 1233 &lt;static, constant&gt; SM2_TIMEOUT_MS :integer Milliseconds to wait after loading SoundManager 2 to define it as not supported if there is no response. Belongs to the &quot;flashLoadTimeout&quot; parameter of the library when soundManager.setup&quot;&gt;www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-flashloadtimeout Type: integer Source: CrossBase/CrossBase.js, line 1278 &lt;static, constant&gt; SM2_USE_HIGH_PERFORMANCE :boolean Defines whether to use or not high performance mode in SoundManager 2 (may cause a flash object to be visible). Belongs to the &quot;useHighPerformance&quot; parameter of the library when soundManager.setup&quot;&gt;www.schillmania.com/projects/soundmanager2/doc/#soundmanager-setup} function is called. More information: http://www.schillmania.com/projects/soundmanager2/doc/#soundmanager-highperformance Type: boolean Source: CrossBase/CrossBase.js, line 1268 &lt;static, constant&gt; SOCKJS_PATH :string Directory that contains the SockJS library files. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;net/sockets/SockJS/&quot; Source: CrossBase/CrossBase.js, line 769 &lt;static, constant&gt; SOCKJS_PATH_SCRIPT_FILE :string The script file path for the SockJS library. As the newer SockJS library versions do not work in old Internet Explorer versions (6, 7 or 8), if they are detected it will use the SockJS library 0.3.4 version instead. Type: string Default Value: CB_Configuration[CB_BASE_NAME].SOCKJS_PATH + SOCKJS_SCRIPT_FILE, where &quot;SOCKJS_SCRIPT_FILE&quot; is sockjs-0.3.4.min.js (SockJS 0.3.4), sockjs-1.1.1.min.js (SockJS 1.1.1) or sockjs.min.js (last version) depending on the client detected. Source: CrossBase/CrossBase.js, line 780 &lt;static, constant&gt; SUBCOLLIDERJS_LOAD :boolean Defines whether to load or not subcollider.js. Type: boolean Default Value: CB_Configuration.CrossBase.TIMBREJS_LOAD Source: CrossBase/CrossBase.js, line 1119 &lt;static, constant&gt; SUBCOLLIDERJS_PATH :string Directory that contains the subcollider.js script. Type: string Default Value: CB_Configuration.CrossBase.TIMBREJS_PATH + &quot;subcollider/&quot; Source: CrossBase/CrossBase.js, line 1129 &lt;static, constant&gt; SUBCOLLIDERJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.SUBCOLLIDERJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1149 &lt;static, constant&gt; SUBCOLLIDERJS_PATH_SCRIPT_FILE :string The script file path for subcollider.js. Type: string Default Value: CB_Configuration.CrossBase.SUBCOLLIDERJS_PATH + &quot;subcollider.js&quot; Source: CrossBase/CrossBase.js, line 1139 &lt;static, constant&gt; TIMBREJS_LOAD :boolean Defines whether to load or not timbre.js. Type: boolean Default Value: CB_Configuration.CrossBase.needsTimbreJS() Source: CrossBase/CrossBase.js, line 1079 &lt;static, constant&gt; TIMBREJS_PATH :string Directory that contains the timbre.js files (script and SWF). Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/audio/timbre.js/&quot; Source: CrossBase/CrossBase.js, line 1089 &lt;static, constant&gt; TIMBREJS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.TIMBREJS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1109 &lt;static, constant&gt; TIMBREJS_PATH_SCRIPT_FILE :string The script file path for timbre.js. Type: string Default Value: CB_Configuration.CrossBase.TIMBREJS_PATH + &quot;timbre.js&quot; Source: CrossBase/CrossBase.js, line 1099 &lt;static, constant&gt; WAAPI_EMULATION_ALLOWED :boolean Defines whether to allow using &quot;WAAPI&quot; (HTML5 Web Audio API) emulation (it will use WAAPISim if needed) or not. Type: boolean Default Value: true Source: CrossBase/CrossBase.js, line 255 &lt;static, constant&gt; WAAPISIM_LOAD :boolean Defines whether to load or not WAAPISim. Type: boolean Default Value: CB_Configuration.CrossBase.WAAPI_EMULATION_ALLOWED &amp;&amp; CB_Configuration.CrossBase.needsWAAPISim() Source: CrossBase/CrossBase.js, line 1036 &lt;static, constant&gt; WAAPISIM_PATH :string Directory that contains the WAAPISim files (script and SWF). Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;audiovisual/audio/WAAPISim/&quot; Source: CrossBase/CrossBase.js, line 1047 &lt;static, constant&gt; WAAPISIM_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.WAAPISIM_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1067 &lt;static, constant&gt; WAAPISIM_PATH_SCRIPT_FILE :string The script file path for the WAAPISim script file. Type: string Default Value: CB_Configuration.CrossBase.WAAPISIM_PATH + &quot;waapisim.min.js&quot; Source: CrossBase/CrossBase.js, line 1057 &lt;static, constant&gt; WII_JS_LOAD :boolean Defines whether to load or not wii-js. Type: boolean Source: CrossBase/CrossBase.js, line 1470 &lt;static, constant&gt; WII_JS_PATH :string Directory that contains the wii-js script. Type: string Default Value: CB_Configuration.CrossBase.SCRIPT_PATH + &quot;input/controllers/wii-js/&quot; Source: CrossBase/CrossBase.js, line 1480 &lt;static, constant&gt; WII_JS_PATH_ABSOLUTE :boolean Defines whether the path defined in CB_Configuration.CrossBase.WII_JS_PATH_SCRIPT_FILE is either absolute or relative to the CrossBrowdy script path. Type: boolean Source: CrossBase/CrossBase.js, line 1500 &lt;static, constant&gt; WII_JS_PATH_SCRIPT_FILE :string The script file path for wii-js. Type: string Default Value: CB_Configuration.CrossBase.WII_JS_PATH + &quot;wii.min.js&quot; Source: CrossBase/CrossBase.js, line 1490 Methods &lt;static&gt; needsCanbox() → {boolean} Detects whether the web client needs Canbox or not. Source: CrossBase/CrossBase.js, line 547 Returns: Type boolean &lt;static&gt; needsCanvasText() → {boolean} Detects whether the web client needs canvas-text or not. Source: CrossBase/CrossBase.js, line 641 Returns: Type boolean &lt;static&gt; needsExplorerCanvas() → {boolean} Detects whether the web client needs ExplorerCanvas or not. Source: CrossBase/CrossBase.js, line 570 Returns: Type boolean &lt;static&gt; needsFlashCanvas() → {boolean} Detects whether the web client needs FlashCanvas or not. Source: CrossBase/CrossBase.js, line 619 Returns: Type boolean &lt;static&gt; needsGamepadPlus() → {boolean} Detects whether the web client needs gamepad-plus or not. Source: CrossBase/CrossBase.js, line 739 To Do: Find a better way for this as old Firefox versions can only detect GamePad API support when the events are fired, so we cannot relay on navigator.getGamepads/navigator.webkitGetGamepads/navigator.webkitGamepads. Returns: Type boolean &lt;static&gt; needsHammerJS() → {boolean} Detects whether the web client needs Hammer.js or not. Source: CrossBase/CrossBase.js, line 725 Returns: Type boolean &lt;static&gt; needsJsfx() → {boolean} Detects whether the web client needs jsfx or not. Source: CrossBase/CrossBase.js, line 697 Returns: Type boolean &lt;static&gt; needsPressureJS() → {boolean} Detects whether the web client needs Pressure.js or not. Source: CrossBase/CrossBase.js, line 711 Returns: Type boolean &lt;static&gt; needsSLCanvas() → {boolean} Detects whether the web client needs SLCanvas or not. Source: CrossBase/CrossBase.js, line 593 Returns: Type boolean &lt;static&gt; needsSleepJS() → {boolean} Detects whether the web client needs NoSleep.js or not. Source: CrossBase/CrossBase.js, line 754 Returns: Type boolean &lt;static&gt; needsTimbreJS() → {boolean} Detects whether the web client needs timbre.js (including subcollider.js) or not. Source: CrossBase/CrossBase.js, line 683 Returns: Type boolean &lt;static&gt; needsWAAPISim() → {boolean} Detects whether the web client needs WAAPISim or not. Source: CrossBase/CrossBase.js, line 473 Returns: Type boolean × Search results Close "},"CB_Configuration.CrossBrowdy.html":{"id":"CB_Configuration.CrossBrowdy.html","title":"Namespace: CrossBrowdy","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CrossBrowdy CB_Configuration. CrossBrowdy Property that contains an object with the options for the main script. Source: CrossBrowdy.js, line 67 Members &lt;static, constant&gt; CB_console_ALLOW_ALERTS :boolean Defines whether to allow the use of alert()'s as a fallback when using CB_console and neither the console object nor a DOM element with &quot;CB_console&quot; ID are found. Type: boolean Default Value: true Source: CrossBrowdy.js, line 122 &lt;static, constant&gt; CB_includeJSFile_TIMEOUT_MS_DEFAULT :int Default milliseconds before firing the timeout callback for the CB_includeJSFile function. Type: int Default Value: 90000 Source: CrossBrowdy.js, line 132 &lt;static, constant&gt; SCRIPT_PATH_DEFAULT :string Default path of the script (path can be changed when CB_init is called) Type: string Default Value: CB_NAME + &quot;/&quot; Source: CrossBrowdy.js, line 80 &lt;static, constant&gt; SHOW_SPLASH_SCREEN_DEFAULT :boolean Defines whether to show the splash screen in the beginning by default or not. Type: boolean Default Value: true Source: CrossBrowdy.js, line 90 &lt;static, constant&gt; STATS :boolean Defines whether to register statistics or not. If it is enabled, the URL defined in CB_Configuration.CrossBrowdy.STATS_URL will be called (by including it as a JavaScript file) as soon as CrossBrowdy gets called (might not be ready yet).This parameter do not do anything else, just includes your desired URL (defined in CB_Configuration.CrossBrowdy.STATS_URL) as a JavaScript file when CrossBrowdy is called. Type: boolean Source: CrossBrowdy.js, line 101 &lt;static, constant&gt; STATS_URL :string URL to register the statistics if CB_Configuration.CrossBrowdy.STATS is enabled. When CB_Configuration.CrossBrowdy.STATS is enabled, this URL will be included as a JavaScript file as soon as CrossBrowdy gets called (might not be ready yet).The URL will be called (included in the document as a JavaScript file) adding three parameters: &quot;cb&quot; parameter with the CrossBrowdy version as the value, &quot;time&quot; with a timestamp which belongs to the current time of the client and &quot;url&quot; parameter with the current URL visited by the user as the value. Type: string Default Value: https://crossbrowdy.com/_stats/CB_stats.php Source: CrossBrowdy.js, line 112 × Search results Close "},"CB_Controllers.html":{"id":"CB_Controllers.html","title":"Namespace: CB_Controllers","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Controllers CB_Controllers Static class to manage different controllers (gamepads, joysticks, remotes, etc.). It will return itself if it is tried to be instantiated. It uses gamepad-plus. Source: CrossBase/input/controllers/CB_Controllers.js, line 7 To Do: Find a way to do button mapping (so we could use names as LEFT, RIGHT, etc.) and normalization for most web clients and gamepads (without forgetting proprietary ones as WII U, etc.). Consider using always a numeric index instead of the ID of the gamepad (array instead of object), which could be a string, for CB_Controllers._gamepads (for optimization purposes). Consider modifying CB_Controllers.isButtonDown function or add a new one to check whether any button (or axes) is down or not. Methods &lt;static&gt; getAxes( [gamepadId] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {array} Gets an array with information about the status of the axes of a given gamepad (or from all if none is given). Parameters: Name Type Argument Default Description gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). When more than one gamepad is checked, the first axes values found which are not zero (0) will have priority. gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 320 Returns: Returns an array with information about the status of the axes of a given gamepad (or from all if none is given). Type array &lt;static&gt; getAxesDown( [gamepadId] [, minimumValue] [, maximumValue] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {Object} Gets an array with the axes pressed of a given gamepad (or from all if none is given). If more than one gamepad is pressing the same axis, it will return the value of the first one found. Parameters: Name Type Argument Default Description gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). minimumValue float &lt;optional&gt; 0.5 The minimum value (included) that the checked axis or axes must have to consider them to be pressed. maximumValue float &lt;optional&gt; 1|-0.5 The maximum value (included) that the checked axis or axes must have to consider them to be pressed. The default value will be -0.5 if the given &quot;minimumValue&quot; is negative or zero (0) or it will be 1 otherwise. gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 378 Returns: Returns an array with the axes pressed of a given gamepad (or from all if none is given). If more than one gamepad is pressing the same axis, it will return the value of the first one found. Type Object &lt;static&gt; getButtons( [gamepadId] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {Object} Gets an object with all the buttons of a given gamepad (or from all if none is given). Parameters: Name Type Argument Default Description gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 475 Returns: Returns an object with all the buttons of a given gamepad (or from all if none is given). The indexes will be the button code and the values will be an object with information about the button (with properties such as &quot;pressed&quot;, &quot;value&quot;, etc.). Type Object &lt;static&gt; getButtonsDown( [gamepadId] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {Object} Gets an object with the buttons pressed of a given gamepad (or from all if none is given). Parameters: Name Type Argument Default Description gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 521 Returns: Returns an object with the buttons pressed of a given gamepad (or from all if none is given). Type Object &lt;static&gt; getGamePads( [avoidProprietary]) → {Object} Returns an object with the current gamepad objects, if any (using the GamePad API for non-proprietary gamepads). Parameters: Name Type Argument Default Description avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads which do not use the GamePad API (as WII, WI U gamepads, etc.) will not be included in the returning object and it will only include the ones detected by the GamePad API. Otherwise, if set to true, the returning object will contain one property called &quot;standard&quot; which will contain an object with the &quot;gamepads&quot; property with the gamepad objects that use the GamePad API and possibly different properties (one per each proprietary system) and inside of them an object with the &quot;gamepads&quot; property and maybe also other properties for other kind of devices which will include the status objects of those devices for each proprietary system. For gamepads that support the GamePad API, the indexes will be the identifier for each gamepad and the value its gamepad object. For proprietary gamepads, it will contain the returning value of the &quot;getGamePads&quot; function of each proprietary API. Source: CrossBase/input/controllers/CB_Controllers.js, line 581 To Do: The proprietary ones should return better-normalized values to simulate the GamePad API. Returns: Returns an object with the current gamepad objects, if any (using the GamePad API for non-proprietary gamepads). Type Object &lt;static&gt; isAxisDown(axesNumbers [, gamepadId] [, minimumValue] [, maximumValue] [, allPressed] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {boolean} Returns whether a given axis or axes are being pressed or not (accepts one index or more than one with an array). Parameters: Name Type Argument Default Description axesNumbers integer | array Number with the index of the axis or array of numbers with the indexes of the axes that we want to check. gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). minimumValue float &lt;optional&gt; 0.5 The minimum value (included) that the checked axis or axes must have to consider them to be pressed. maximumValue float &lt;optional&gt; 1|-0.5 The maximum value (included) that the checked axis or axes must have to consider them to be pressed. The default value will be -0.5 if the given &quot;minimumValue&quot; is negative or zero (0) or it will be 1 otherwise. allPressed boolean &lt;optional&gt; false If set to true, the function will return true only in the case that all given axes are being pressed. In the case that this parameter is set to true and the &quot;gamepadId&quot; parameter is set to an empty string, it will not have in mind whether the axes are pressed by a unique gamepad or by different ones as long as all axes are pressed. gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 398 To Do: Make it compatible with proprietary gamepads (if possible). Returns: If the &quot;allPressed&quot; parameter is false, returns true if the given code or any of the given codes is pressed. If the &quot;allPressed&quot; parameter is set to true, it will return true only in the case that all given axes are being pressed. In the case that the &quot;allPressed&quot; parameter is set to true and the gamepadId parameter is set to an empty string, it will not have in mind whether the axes are pressed by a unique gamepad or by different ones as long as all axes are pressed. Type boolean &lt;static&gt; isButtonDown(buttonCodes [, gamepadId] [, allPressed] [, gamepadIdNumeric] [, caseSensitive] [, avoidProprietary]) → {boolean} Returns whether a given button or buttons are being pressed or not (accepts one key code or more than one with an array). Parameters: Name Type Argument Default Description buttonCodes integer | array Number with the button code or array of numbers with the button codes that we want to check. gamepadId integer | string &lt;optional&gt; &quot;&quot; If an empty string is given, all gamepads available will be checked. Otherwise, it will only check the gamepad with the given ID or index (if any). allPressed boolean &lt;optional&gt; false If set to true, the function will return true only in the case that all given buttons are being pressed. In the case that this parameter is set to true and the &quot;gamepadId&quot; parameter is set to an empty string, it will not have in mind whether the buttons are pressed by a unique gamepad or by different ones as long as all buttons are pressed. gamepadIdNumeric boolean &lt;optional&gt; false|true If the &quot;gamepadId&quot; parameter is an empty string, this parameter will be ignored. Otherwise, if the &quot;gamepadId&quot; parameter is not empty and this parameter is set to true, the gamepadId parameter will be converted to integer using &quot;parseInt&quot; internally. By default, this parameter is false unless the given &quot;gamepadId&quot; is numeric. caseSensitive boolean &lt;optional&gt; false Defines whether the &quot;gamepadId&quot; given should match the ID of the gamepad being case sensitive or not. This parameter will only be considered when the &quot;gamepadIdNumeric&quot; parameter is set to false. avoidProprietary boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Controllers_avoidProprietary_DEFAULT If set to true, proprietary gamepads will not be checked (performance will be faster). Source: CrossBase/input/controllers/CB_Controllers.js, line 539 To Do: Make it compatible with proprietary gamepads (if possible). Returns: If the &quot;allPressed&quot; parameter is false, returns true if the given code or any of the given codes is pressed. If the &quot;allPressed&quot; parameter is set to true, it will return true only in the case that all given buttons are being pressed. In the case that the &quot;allPressed&quot; parameter is set to true and the gamepadId parameter is set to an empty string, it will not have in mind whether the buttons are pressed by a unique gamepad or by different ones as long as all buttons are pressed. Type boolean &lt;static&gt; onConnect(callbackFunction [, keepOldFunction]) Sets a function to execute when a gamepad is connected (&quot;onGamepadConnected&quot; event is fired) or removes it. More information: Gamepad API. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the gamepad object affected and the second parameter will be an object containing all current gamepads objects (properties will be the index of each gamepad). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/input/controllers/CB_Controllers.js, line 175 To Do: Make it compatible with proprietary ones (if possible). &lt;static&gt; onDisconnect(callbackFunction [, keepOldFunction]) Sets a function to execute when a gamepad is disconnected (&quot;onGamepadDisconnected&quot; event is fired) or removes it. More information: Gamepad API. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the gamepad object affected and the second parameter will be an object containing all current gamepads objects (properties will be the index of each gamepad). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/input/controllers/CB_Controllers.js, line 188 To Do: Make it compatible with proprietary ones (if possible). × Search results Close "},"CB_Controllers_Proprietary.html":{"id":"CB_Controllers_Proprietary.html","title":"Namespace: CB_Controllers_Proprietary","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Controllers_Proprietary CB_Controllers_Proprietary Static class to manage proprietary controller APIs. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js, line 6 Namespaces WII WII_U × Search results Close "},"CB_Controllers_Proprietary.WII.html":{"id":"CB_Controllers_Proprietary.WII.html","title":"Namespace: WII","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: WII CB_Controllers_Proprietary. WII Static class to manage the Nintendo Wii remotes (Wiimotes). It will return itself if it is tried to be instantiated. It uses wii-js. NOTE: This class is still under development. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js, line 11 To Do: Find a way to know how to check when a button is released. Update values of CB_Controllers_Proprietary.WII._wiimotes[x].UP, etc. Do not forget x and y properties (?). Methods &lt;static&gt; getGamePads() → {Object} Returns an object with all gamepads simulating the GamePad API. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII.js, line 142 Returns: Returns an object with the &quot;remotes&quot; property which contains another object whose properties are the index of each device and the value an object with the status of that device. The number of remotes is 4 (index from &quot;0&quot; to &quot;3&quot;). Simulating the GamePad API. Those status objects which are not using the real API will have a property called &quot;usingPrototype&quot; set to true. Type Object × Search results Close "},"CB_Controllers_Proprietary.WII_U.html":{"id":"CB_Controllers_Proprietary.WII_U.html","title":"Namespace: WII_U","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: WII_U CB_Controllers_Proprietary. WII_U Static class to manage the Nintendo Wii U gamepad and remotes. It will return itself if it is tried to be instantiated. NOTE: This class is still under development. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 6 To Do: Function or option that returns an array with the pressed buttons (LEFT: true, L: true, R: false, etc.). Use the bitmasks of CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS and CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS. Members &lt;static, constant&gt; GAMEPAD_BUTTONS :Object Object which keeps the values for the Nintendo Wii U gamepad's buttons (bitmasks). Type: Object Properties: Name Type Description LEFT_STICK_LEFT number LEFT on the LEFT STICK. Default action: Scroll/Pan. LEFT_STICK_RIGHT number RIGHT on the LEFT STICK. Default action: Scroll/Pan. LEFT_STICK_UP number UP on the LEFT STICK. Default action: Scroll/Pan. LEFT_STICK_DOWN number DOWN on the LEFT STICK. Default action: Scroll/Pan. LEFT_STICK_CLICK number CLICK on the LEFT STICK. Default action: Hide/show bottom toolbar. RIGHT_STICK_LEFT number LEFT on the RIGHT STICK. Default action: Zoom. RIGHT_STICK_RIGHT number RIGHT on the RIGHT STICK. Default action: Zoom. RIGHT_STICK_UP number UP on the RIGHT STICK. Default action: Zoom. RIGHT_STICK_DOWN number DOWN on the RIGHT STICK. Default action: Zoom. RIGHT_STICK_CLICK number CLICK on the RIGHT STICK. Default actionn: Toggle zoom in/out on center of screen. TV number &quot;TV&quot; button. A number &quot;A&quot; button. Send the &quot;Enter&quot; key (keyCode 13). B number &quot;B&quot; button. Default action: Back to previous page (hold B: Close current tab). X number &quot;X&quot; button. Default action: Toggle curtain mode. Y number &quot;Y&quot; button. Default action: View bookmarks. LEFT number LEFT button on the control pad. Default action: Select links / form fields. RIGHT number RIGHT button on the control pad. Default action: Select links / form fields. UP number UP button on the control pad. Default action: Select links / form fields. DOWN number DOWN button on the control pad. Default action: Select links / form fields. ZL number &quot;ZL&quot; button. Default action: Switch to previous tab (hold ZL+ZR: Tilt scrolling). ZR number &quot;ZR&quot; button. Default action: Switch to next tab (hold ZL+ZR: Tilt scrolling). L number &quot;L&quot; button. Default action: Back to previous page. R number &quot;R&quot; button. Default action: Forward to next page. START number &quot;START&quot; button. PLUS number Alias for CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.START. SELECT number &quot;SELECT&quot; button. MINUS number Alias for CB_Controllers_Proprietary.WII_U.GAMEPAD_BUTTONS.SELECT. HOME number HOME button. Default action: Quit browser. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 45 &lt;static, readonly&gt; gamepadLastStatus :Object Keeps the last return value of the CB_Controllers_Proprietary.WII_U.getGamePadStatus function (if any). The value should be the last status object returned. Type: Object Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 33 &lt;static, constant&gt; REMOTE_BUTTONS :Object Object which keeps the values for the Nintendo Wii U remote's buttons (bitmasks). Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. A number &quot;A&quot; button. B number &quot;B&quot; button. ONE number &quot;1&quot; button. _1 number Alias for CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.ONE. 1 number Alias for CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.ONE. TWO number &quot;2&quot; button. _2 number Alias for CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.TWO. 2 number Alias for CB_Controllers_Proprietary.WII_U.REMOTE_BUTTONS.TWO. PLUS number PLUS (&quot;+&quot;) button. MINUS number MINUS (&quot;-&quot;) button. HOME number HOME button. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 110 &lt;static, readonly&gt; remoteLastStatus :array Keeps an array with numeric indexes (should be from 0 to 7 maximum) that belong to each remote number and whose values contain the last return value of the CB_Controllers_Proprietary.WII_U.getRemoteStatus function (if any). Each value should be the last status object returned. Type: array Default Value: [] Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 43 &lt;static, readonly&gt; wiiuObject :Object Keeps the &quot;wiiu&quot; object (if any). Type: Object Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 24 Methods &lt;static&gt; getGamePads() → {Object} Returns an object with the gamepad and all remotes simulating the GamePad API. Uses the CB_Controllers_Proprietary.WII_U.getRemoteStatus and CB_Controllers_Proprietary.WII_U.getRemoteStatus internally so the objects will be normalized already. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 444 To Do: Check the documentation to find out the maximum number of remotes allowed and find out whether the first index should be 0 or 1 and last one 7 or 8. Returns: Returns an object with two properties: &quot;gamepads&quot; and &quot;remotes&quot;. Each of those two properties will have an object as value whose names will be the index of the device and the value an object with the status of that device. In the case of the gamepad (which is unique), there will only be one index (&quot;0&quot;, zero). In the case of the remotes, it will contain the status objects of all the remotes. The number of remotes is 8 (index from &quot;0&quot; to &quot;7&quot;). Simulating the GamePad API. Those status objects which are not using the real API will have a property called &quot;usingPrototype&quot; set to true. Type Object &lt;static&gt; getGamePadStatus() → {Object} Returns an object with the current status of each button of the gamepad. Already calls CB_Controllers_Proprietary.WII_U.normalizeGamepad automatically. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 417 Returns: Returns an object with the current status of each button of the gamepad. Type Object &lt;static&gt; getRemoteStatus( [n]) → {Object} Returns an object with the current status of each button of the desired remote. Already calls CB_Controllers_Proprietary.WII_U.normalizeRemote automatically. Parameters: Name Type Argument Default Description n integer &lt;optional&gt; 0 Number of the remote whose status we want to get, from 0 to 7 (both numbers included, 8 in total). Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 430 To Do: Check documentation to see whether the first index should be 0 or 1 and maximum 7 or 8. Returns: Returns an object with the current status of each button of the desired remote. Type Object &lt;static&gt; normalizeGamepad(gamepadStatusObject) → {Object} Normalizes the given gamepad status object, adding missing properties. Parameters: Name Type Description gamepadStatusObject object The gamepad status object that we want to normalize. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 293 Returns: Returns the given gamepad status object but normalized, adding missing properties. Type Object &lt;static&gt; normalizeRemote(gamepadStatusObject [, n]) → {Object} Normalizes the given remote status object, adding missing properties. Parameters: Name Type Argument Default Description gamepadStatusObject object The remote status object that we want to normalize. n integer &lt;optional&gt; 0 Number of the remote whose status we want to get, from 0 to 7 (both numbers included, 8 in total). It will be used as its identifier. Source: CrossBase/input/controllers/CB_Controllers_Proprietary_WII_U.js, line 370 Returns: Returns the given remote status object but normalized, adding missing properties. Type Object × Search results Close "},"CB_Device.html":{"id":"CB_Device.html","title":"Namespace: CB_Device","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Device CB_Device Static class to manage the device. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 12 To Do: Think about defining a parameter on many of the events to disable automatic normalization of the event object. Namespaces AmbientLight Battery Location Motion Orientation Proximity Vibration Methods &lt;static&gt; getTime() → {integer} Gets a timestamp in milliseconds (elapsed since 1st of January 1970 00:00:00 UTC) representing the current time. Using high precision if the CB_Configuration.CrossBase.CB_Device_getTime_HIGH_PRECISION option is true (it would return 'window.performance.timing.navigationStart + window.performance.now()', where 'window.performance.now' could be polyfilled) or normal precision otherwise (it would return 'Date.now()', where 'Date.now' could be polyfilled). Source: CrossBase/device/CB_Device.js, line 46 Returns: Returns a timestamp in milliseconds (elapsed since 1st of January 1970 00:00:00 UTC) representing the current time or zero (0) if it was not possible. Type integer &lt;static&gt; getTiming() → {number} Gets the time elapsed since the time origin. If possible, it uses window.performance.now, which could be polyfilled (if it is polyfilled it will not have high precision timing but, if it is not, time precision/resolution will depend on the client). Source: CrossBase/device/CB_Device.js, line 57 Returns: Returns the time elapsed since the time origin. If possible, it uses window.performance.now, which could be polyfilled (if it is polyfilled it will not have high precision timing but, if it is not, time precision/resolution will depend on the client). Type number × Search results Close "},"CB_Device.AmbientLight.html":{"id":"CB_Device.AmbientLight.html","title":"Namespace: AmbientLight","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: AmbientLight CB_Device. AmbientLight Static class to manage the device's ambient light sensor. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 1062 To Do: Normalize more differences between web clients. Methods &lt;static&gt; get(eventFunction [, keepOldFunction] [, useCapture] [, callbackError]) → {undefined|false} Sets the event to get the ambient light or removes it. Uses the Ambient Light Sensor API or the Ambient Light Sensor Events (&quot;ondevicelight&quot;) or &quot;onlightlevel&quot; event. The given &quot;eventFunction&quot; will receive the event object as the first parameter but this event object will vary depending on the way to get the ambient light which is supported by the client (if any): First choice, if available, uses the Ambient Light Sensor API and &quot;event.value&quot; will contain the units in lux. Second choice, if available, uses the Ambient Light Sensor Events (&quot;ondevicelight&quot;) and &quot;event.value&quot; will contain the units in lux. Third choice, if available, uses the &quot;onlightlevel&quot; event and &quot;event.value&quot; will be &quot;&quot; (an empty string), &quot;dim&quot;, &quot;normal&quot; or &quot;bright&quot; instead of a number. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. The event object received will already be normalized by the CB_Device.AmbientLight.normalizeEvent function automatically. Despite of this, due to the big differences between different clients, the event object received as the first parameter will vary depending on the way to get the ambient light which is supported by the client (if any). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the ambient light. Only used by the Ambient Light Sensor API (if available). Source: CrossBase/device/CB_Device.js, line 1092 Returns: Returns false in the case that no way to get the ambient light is available or undefined otherwise. Type undefined | false &lt;static&gt; isSupported() → {boolean} Tells whether the Ambient Light Sensor API or the Ambient Light Sensor Events (&quot;ondevicelight&quot;) or &quot;onlightlevel&quot; event are supported or not. Source: CrossBase/device/CB_Device.js, line 1069 Returns: Type boolean &lt;static&gt; normalizeEvent(e, eventName [, sensor]) → {Event} Normalizes the data gotten from the the Ambient Light Sensor API or the Ambient Light Sensor Events (&quot;ondevicelight&quot;) or &quot;onlightlevel&quot; event to try to match the Ambient Light Sensor API and follow always the same rules as much as possible. Parameters: Name Type Argument Description e Event The event object that we want to normalize. eventName 'change' | 'reading' | 'devicelight' | 'lightlevel' The name of the event that we want to normalize. Case sensitive. sensor AmbientLightSensor &lt;optional&gt; AmbientLightSensor object used by the Ambient Light Sensor API. Source: CrossBase/device/CB_Device.js, line 1143 To Do: Normalize more differences between web clients. Returns: Returns the given event object again but normalized (if possible). Type Event × Search results Close "},"CB_Device.Battery.html":{"id":"CB_Device.Battery.html","title":"Namespace: Battery","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Battery CB_Device. Battery Static class to manage the device's battery. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 745 To Do: Normalize more differences between web clients. Methods &lt;static&gt; cordova_onChange(eventFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the &quot;batterystatus&quot; event of the battery is fired or removes it. Using the Apache Cordova's Battery Status plugin. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://github.com/apache/cordova-plugin-battery-status. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 975 &lt;static&gt; cordova_onCritical(eventFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the &quot;batterycritical&quot; event of the battery is fired or removes it. Using the Apache Cordova's Battery Status plugin. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://github.com/apache/cordova-plugin-battery-status. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 1001 &lt;static&gt; cordova_onLow(eventFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the &quot;batterylow&quot; event of the battery is fired or removes it. Using the Apache Cordova's Battery Status plugin. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://github.com/apache/cordova-plugin-battery-status. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 988 &lt;static&gt; get( [callbackOk] [, chargingOnFail] [, levelOnFail] [, chargingTimeOnFail] [, dischargingTimeOnFail]) → {Object|Promise} Gets the battery object (BatteryManager) using the Battery Status API (or compatible one) if available or falling back to Apache Cordova's Battery Status plugin emulating the object if possible or a fake object otherwise. It could be synchronous or asynchronous depending on the client. When the Battery Status API (or compatible one) is not available, the generated object will always contain null values for the &quot;onchargingchange&quot;, &quot;onchargingtimechage&quot;, &quot;ondischargingtimechange&quot; and &quot;onlevelchange&quot; properties. The &quot;charging&quot; and &quot;level&quot; properties will be tried to be calculated by using Apache Cordova's Battery Status plugin if possible. The return will be synchronous only when getBattery function is not available. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final battery object (real or fake). Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; The callback function that will be called once the final battery object (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final battery object (due the fact that some clients will execute the function asynchronously). chargingOnFail boolean &lt;optional&gt; Desired value for the &quot;charging&quot; property of the fake battery object when neither the Battery Status API (or compatible one) nor Apache Cordova's Battery Status plugin are available. It should follow the same rules as the real property of the BatteryManager object. levelOnFail float &lt;optional&gt; Desired value for the &quot;level&quot; property of the fake battery object when neither the Battery Status API (or compatible one) nor Apache Cordova's Battery Status plugin are available. It should follow the same rules as the real property of the BatteryManager object. chargingTimeOnFail integer &lt;optional&gt; Desired value for the &quot;chargingTime&quot; property of the fake battery object when the Battery Status API (or compatible one) is not available. It should follow the same rules as the real property of the BatteryManager object. dischargingTimeOnFail integer &lt;optional&gt; Desired value for the &quot;dischargingTime&quot; property of the fake battery object when the Battery Status API (or compatible one) is not available. It should follow the same rules as the real property of the BatteryManager object. Source: CrossBase/device/CB_Device.js, line 784 Returns: Returns the battery object (fake or real) synchronously only when the native getBattery function is not available. Otherwise it returns a Promise (the result of calling navigator.getBattery().then(callbackOk)). It is highly recommended to ignore this returned value. Type Object | Promise &lt;static&gt; getChargingTime( [callbackOk] [, valueOnFail]) → {integer|Promise} Returns the time (in seconds) that the battery needs to be completely charged. Using the CB_Device.Battery.get function internally. It could be synchronous or asynchronous depending on the client. The return will be synchronous only sometimes (when it is asynchronous it will just return a Promise), following the same rules as the CB_Device.Battery.get function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). valueOnFail integer &lt;optional&gt; Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;chargingTime&quot; property of the BatteryManager object. Source: CrossBase/device/CB_Device.js, line 857 Returns: Returns the desired value only when the function is executed synchronously (following the same rules as the CB_Device.Battery.get function which is called internally). It is highly recommended to ignore this returned value. Type integer | Promise &lt;static&gt; getDischargingTime( [callbackOk] [, valueOnFail]) → {integer|Promise} Returns the time (in seconds) that the battery needs to be completely discharged (or when the device will shutdown, depending on the client). Using the CB_Device.Battery.get function internally. It could be synchronous or asynchronous depending on the client. The return will be synchronous only sometimes (when it is asynchronous it will just return a Promise), following the same rules as the CB_Device.Battery.get function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). valueOnFail integer &lt;optional&gt; Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;dischargingTime&quot; property of the BatteryManager object. Source: CrossBase/device/CB_Device.js, line 874 Returns: Returns the desired value only when the function is executed synchronously (following the same rules as the CB_Device.Battery.get function which is called internally). It is highly recommended to ignore this returned value. Type integer | Promise &lt;static&gt; getLevel( [callbackOk] [, valueOnFail]) → {float|Promise} Returns tha current charging level of the battery. Using the CB_Device.Battery.get function internally. It could be synchronous or asynchronous depending on the client. The return will be synchronous only sometimes (when it is asynchronous it will just return a Promise), following the same rules as the CB_Device.Battery.get function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). valueOnFail float &lt;optional&gt; Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;level&quot; property of the BatteryManager object. Source: CrossBase/device/CB_Device.js, line 840 Returns: Returns the desired value only when the function is executed synchronously (following the same rules as the CB_Device.Battery.get function which is called internally). It is highly recommended to ignore this returned value. Type float | Promise &lt;static&gt; isCharging( [callbackOk] [, valueOnFail]) → {boolean|Promise} Returns whether the battery is charging or not. Using the CB_Device.Battery.get function internally. It could be synchronous or asynchronous depending on the client. The return will be synchronous only sometimes (when it is asynchronous it will just return a Promise), following the same rules as the CB_Device.Battery.get function which is called internally. The best practice is to ignore the immediate return value and just trust the first parameter passed to the &quot;callbackOk&quot; function once it is called, since this one will be the final value that we want to get (real or fake). Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; The callback function that will be called once the final value (real or fake one) is gotten (passed as the first and unique parameter). Highly recommended since it is the unique way to always get the final value (due the fact that some clients will execute the function asynchronously). valueOnFail boolean &lt;optional&gt; Desired value to use when it fails getting the real one. It should follow the same rules as the real &quot;charging&quot; property of the BatteryManager object. Source: CrossBase/device/CB_Device.js, line 823 Returns: Returns the desired value only when the function is executed synchronously (following the same rules as the CB_Device.Battery.get function which is called internally). It is highly recommended to ignore this returned value. Type boolean | Promise &lt;static&gt; isSupported() → {boolean} Tells whether the Battery Status API (or compatible one) is available or not. Source: CrossBase/device/CB_Device.js, line 764 Returns: Type boolean &lt;static&gt; onChargingChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false|Promise} Sets a function to execute when the &quot;onchargingchange&quot; event of the battery is fired or removes it. This should happen whenever the charging status changes (is charging now but before it was not or vice versa). Using the Battery Status API (or compatible one). Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://developer.mozilla.org/docs/Web/Events/chargingchange. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 890 Returns: Returns false when the Battery Status API (or compatible one) is not available. Returns a Promise when the native getBattery function is available. Otherwise, it returns undefined. Type undefined | false | Promise &lt;static&gt; onChargingTimeChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false|Promise} Sets a function to execute when the &quot;onchargingtimechage&quot; event of the battery is fired or removes it. This should happen whenever the charging time changes. Using the Battery Status API (or compatible one). Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://developer.mozilla.org/docs/Web/Events/chargingtimechange. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 904 Returns: Returns false when the Battery Status API (or compatible one) is not available. Returns a Promise when the native getBattery function is available. Otherwise, it returns undefined. Type undefined | false | Promise &lt;static&gt; onDischargingTimeChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false|Promise} Sets a function to execute when the &quot;ondischargingtimechange&quot; event of the battery is fired or removes it. This should happen whenever the discharging time changes. Using the Battery Status API (or compatible one). Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://developer.mozilla.org/docs/Web/Events/dischargingtimechange. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 918 Returns: Returns false when the Battery Status API (or compatible one) is not available. Returns a Promise when the native getBattery function is available. Otherwise, it returns undefined. Type undefined | false | Promise &lt;static&gt; onLevelChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false|Promise} Sets a function to execute when the &quot;onlevelchange&quot; event of the battery is fired or removes it. This should happen when the battery level changes. Using the Battery Status API (or compatible one). Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://developer.mozilla.org/docs/Web/Events/levelchange. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 932 Returns: Returns false when the Battery Status API (or compatible one) is not available. Returns a Promise when the native getBattery function is available. Otherwise, it returns undefined. Type undefined | false | Promise × Search results Close "},"CB_Device.Location.html":{"id":"CB_Device.Location.html","title":"Namespace: Location","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Location CB_Device. Location Static class to manage the device's location. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 95 To Do: Normalize more differences between web clients. Members &lt;static, readonly&gt; get_callbackError :function|null Keeps the callback function used when there is an error getting the location for the CB_Device.Location.get function. Type: function | null Source: CrossBase/device/CB_Device.js, line 134 &lt;static, readonly&gt; get_callbackOk :function|null Keeps the callback function used when location can be gotten successfully for the CB_Device.Location.get function. Type: function | null Source: CrossBase/device/CB_Device.js, line 124 &lt;static, readonly&gt; get_options :Object|undefined Keeps the last options used by the CB_Device.Location.get function. Type: Object | undefined Source: CrossBase/device/CB_Device.js, line 144 &lt;static, readonly&gt; getConstantly_callbackError :function|null Keeps the callback function used when there is an error getting the location for the CB_Device.Location.getConstantly function. Type: function | null Source: CrossBase/device/CB_Device.js, line 164 &lt;static, readonly&gt; getConstantly_callbackOk :function|null Keeps the callback function used when location can be gotten successfully for the CB_Device.Location.getConstantly function. Type: function | null Source: CrossBase/device/CB_Device.js, line 154 &lt;static, readonly&gt; getConstantly_lastId :integer|null Keeps the last watch ID that gets the location constantly. Used by the CB_Device.Location.getConstantly function. Type: integer | null Source: CrossBase/device/CB_Device.js, line 104 &lt;static, readonly&gt; getConstantly_options :Object|undefined Keeps the last options used by the CB_Device.Location.getConstantly function. Type: Object | undefined Source: CrossBase/device/CB_Device.js, line 174 &lt;static, readonly&gt; keepAwake_locationLockGPS :Object|null Keeps the &quot;WakeLock&quot; (MozWakeLock) object to be able to release the lock related with the GPS (so far, only works in Firefox/Firefox OS). Used by the CB_Device.Location.keepAwake function. Type: Object | null Source: CrossBase/device/CB_Device.js, line 114 Methods &lt;static&gt; get( [callbackOk] [, callbackError] [, options] [, keepOldCallbackOk] [, keepOldCallbackError] [, keepOldOptions]) → {undefined|false} Gets the current position. Uses the Geolocation API (or compatible one as Apache Cordova's Geolocation plugin). Parameters: Name Type Argument Default Description callbackOk function &lt;optional&gt; Callback that will be called if it gets the location successfully. Following the same rules as the first parameter of the native getCurrentPosition function. callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the location. Following the same rules as the second parameter of the native getCurrentPosition function. options Object &lt;optional&gt; Object that represents the desired options. This parameter will be ignored if &quot;keepOldOptions&quot; is set to true. Following the same rules as the third parameter of the native getCurrentPosition function. keepOldCallbackOk boolean &lt;optional&gt; true If it is set to false, it will not keep the old previous &quot;callbackOk&quot; (if any) which was/were set in previous calls to this function. keepOldCallbackError boolean &lt;optional&gt; true If it is set to false, it will not keep the old previous &quot;callbackError&quot; (if any) which was/were set in previous calls to this function. keepOldOptions boolean &lt;optional&gt; false If it is set to true, it will ignore the given options and it will try to use the old previous options (if any) which were set in previous calls to this function. Source: CrossBase/device/CB_Device.js, line 200 Returns: Returns false in the case that Geolocation API (or compatible one as Apache Cordova's Geolocation plugin) is not supported or undefined otherwise. Type undefined | false &lt;static&gt; getConstantly( [callbackOkOrId] [, callbackError] [, options] [, keepOldCallbackOk] [, keepOldCallbackError] [, keepOldOptions]) → {integer|undefined|false} Starts or stops getting the current position constantly (real-time) every time it changes. Uses the Geolocation API (or compatible one as Apache Cordova's Geolocation plugin). Parameters: Name Type Argument Default Description callbackOkOrId function | integer &lt;optional&gt; CB_Device.Location.getConstantly_lastId In the case that we want to start getting the position, use a function callback that will be called every time it gets the location successfully (using the native watchPosition function). To stop getting the position, use the watch ID that we want to stop (using the native clearWatch function). Following the same rules as the first parameter of the native watchPosition function (when we want to start watching) or the first parameter of clearWatch function (when we want to stop watching). callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the location. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the native watchPosition function. options Object &lt;optional&gt; Object that represents the desired options. This parameter will be ignored if &quot;keepOldOptions&quot; is set to true. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the native watchPosition function. keepOldCallbackOk boolean &lt;optional&gt; true If it is set to false, it will not keep the old previous &quot;callbackOk&quot; (if any) which was/were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). keepOldCallbackError boolean &lt;optional&gt; true If it is set to false, it will not keep the old previous &quot;callbackError&quot; (if any) which was/were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). keepOldOptions boolean &lt;optional&gt; false If it is set to true, it will ignore the given options and it will try to use the old previous options (if any) which were set in previous calls to this function. Only used when we want to start getting the current position (&quot;callbackOkOrId&quot; is a function). Source: CrossBase/device/CB_Device.js, line 264 Returns: Returns false in the case that Geolocation API (or compatible one as Apache Cordova's Geolocation plugin) is not supported. In the case that we want to start getting the current position (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the position (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. Type integer | undefined | false &lt;static&gt; getConstantlyDisable( [id] [, keepOldCallbackOk] [, keepOldCallbackError] [, keepOldOptions]) → {undefined|false} Stops getting the current position constantly (real-time) every time it changes. Uses the Geolocation API (or compatible one as Apache Cordova's Geolocation plugin). Parameters: Name Type Argument Default Description id integer &lt;optional&gt; CB_Device.Location.getConstantly_lastId The watch ID that we want to stop. Following the same rules as the first parameter of the native clearWatch function. keepOldCallbackOk boolean &lt;optional&gt; false If it is set to false, it will not remove the current &quot;callbackOk&quot; (if any) which was/were set previously. keepOldCallbackError boolean &lt;optional&gt; false If it is set to false, it will remove the current &quot;callbackError&quot; (if any) which was/were set previously. keepOldOptions boolean &lt;optional&gt; false If it is set to false, it will remove the current &quot;options&quot; (if any) which were set previously. Source: CrossBase/device/CB_Device.js, line 341 Returns: Returns false in the case that Geolocation API (or compatible one as Apache Cordova's Geolocation plugin) is not supported or undefined otherwise. Type undefined | false &lt;static&gt; isSupported() → {boolean} Tells whether the Geolocation API (or compatible one as Apache Cordova's Geolocation plugin) is supported or not. Source: CrossBase/device/CB_Device.js, line 182 Returns: Type boolean &lt;static&gt; keepAwake( [keepAwake] [, lock]) → {undefined|Object|false} Keeps or stops keeping the application getting the position, even when the application is invisible or screen is locked, by using requestWakeLock (so far, only works in Firefox/Firefox OS). Parameters: Name Type Argument Default Description keepAwake boolean &lt;optional&gt; true Defines whether we want to keep it awake or stop doing it. lock Object &lt;optional&gt; CB_Device.Location.keepAwake_locationLockGPS The &quot;WakeLock&quot; (MozWakeLock) object that we want to unlock. It will be used only when &quot;keepAwake&quot; is set to false. Source: CrossBase/device/CB_Device.js, line 359 Returns: Returns false in the case that &quot;WakeLock&quot; (MozWakeLock) is not supported or something went wrong. Returns the &quot;WakeLock&quot; (MozWakeLock) object in the case that we wanted to keep it awake (&quot;keepAwake&quot; is set to true). Returns undefined in the case that we do not want it to keep it awake (&quot;keepAwake&quot; is set to false and the lock is a valid &quot;WakeLock&quot; object). Type undefined | Object | false × Search results Close "},"CB_Device.Motion.html":{"id":"CB_Device.Motion.html","title":"Namespace: Motion","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Motion CB_Device. Motion Static class to manage the device's motion. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 604 To Do: Normalize more differences between web clients. Members &lt;static, readonly&gt; cordova_getAccelerationConstantly_lastId :integer|null Keeps the last watch ID that gets the acceleration constantly using the Apache Cordova's Device Motion plugin. Used by the CB_Device.Motion.cordova_getAccelerationConstantly function. Type: integer | null Source: CrossBase/device/CB_Device.js, line 613 Methods &lt;static&gt; cordova_getAcceleration(callbackOk, callbackError) → {undefined|false} Gets the acceleration using the Apache Cordova's Device Motion plugin. Uses &quot;navigator.accelerometer.getCurrentAcceleration&quot; internally. Parameters: Name Type Description callbackOk function The function that will be called when it succeeds getting the acceleration. The event object received will already be normalized by the CB_Device.Motion.cordova_getAccelerationNormalized function automatically. Following the same rules as in https://github.com/apache/cordova-plugin-device-motion (&quot;navigator.accelerometer.getCurrentAcceleration&quot; function). callbackError function The function that will be called if there is any error getting the acceleration. Following the same rules as in https://github.com/apache/cordova-plugin-device-motion (&quot;navigator.accelerometer.getCurrentAcceleration&quot; function). Source: CrossBase/device/CB_Device.js, line 660 Returns: Returns false in the case that the Apache Cordova's Device Motion plugin is not supported or undefined otherwise. Type undefined | false &lt;static&gt; cordova_getAccelerationConstantly( [callbackOkOrId] [, callbackError] [, options]) → {integer|undefined|false} Starts or stops getting the acceleration constantly at a regular interval. Uses the Apache Cordova's Device Motion plugin (&quot;navigator.accelerometer.watchAcceleration&quot; and &quot;navigator.accelerometer.clearWatch&quot; functions). Parameters: Name Type Argument Default Description callbackOkOrId function | integer &lt;optional&gt; CB_Device.Motion.cordova_getAccelerationConstantly_lastId In the case that we want to start getting the acceleration, use a function callback that will be called regularly when the acceleration is gotten successfully (using the &quot;navigator.accelerometer.watchAcceleration&quot; function) and the event object received will already be normalized by the CB_Device.Motion.cordova_getAccelerationNormalized function automatically. To stop getting the acceleration, use the watch ID that we want to stop (using the &quot;navigator.accelerometer.clearWatch&quot; function). Following the same rules as the first parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function (when we want to start watching) or the first parameter of &quot;navigator.accelerometer.clearWatch&quot; function (when we want to stop watching) described in https://github.com/apache/cordova-plugin-device-motion. callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the acceleration. Only used when we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function described in https://github.com/apache/cordova-plugin-device-motion. options Object &lt;optional&gt; Object that represents the desired options. Only used when we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the &quot;navigator.accelerometer.watchAcceleration&quot; function described in https://github.com/apache/cordova-plugin-device-motion. Source: CrossBase/device/CB_Device.js, line 677 To Do: Add parameters to keep old callbacks and options. Returns: Returns false in the case that Apache Cordova's Device Motion plugin is not supported. In the case that we want to start getting the acceleration (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the acceleration (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. Type integer | undefined | false &lt;static&gt; cordova_getAccelerationConstantlyDisable( [id]) → {undefined|false} Stops getting the acceleration constantly at a regular interval. Uses the Apache Cordova's Device Motion plugin (&quot;navigator.accelerometer.clearWatch&quot; function). Parameters: Name Type Argument Default Description id integer &lt;optional&gt; CB_Device.Motion.cordova_getAccelerationConstantly_lastId The watch ID that we want to stop. Following the same rules as the first parameter of the &quot;navigator.accelerometer.clearWatch&quot; function described in https://github.com/apache/cordova-plugin-device-motion. Source: CrossBase/device/CB_Device.js, line 707 To Do: Add parameters to keep old callbacks and options. Returns: Returns false in the case that Apache Cordova's Device Motion plugin is not supported or undefined otherwise. Type undefined | false &lt;static&gt; cordova_getAccelerationNormalized(accelerometerData) → {Event} Normalizes the data gotten from the Apache Cordova's Device Motion plugin to try to match the Device Motion Event and follow always the same rules as much as possible. Parameters: Name Type Description accelerometerData Object The acceleration object that we want to normalize. Source: CrossBase/device/CB_Device.js, line 721 To Do: Normalize the values without gravity too (accelerometerData.acceleration.x, accelerometerData.acceleration.y, accelerometerData.acceleration.z) if possible (needs gyroscope probably) and maybe more properties. Returns: Returns the given acceleration object again but normalized (if possible). Type Event &lt;static&gt; cordova_isAccelerationSupported() → {boolean} Tells whether the Apache Cordova's Device Motion plugin is available or not. Source: CrossBase/device/CB_Device.js, line 647 Returns: Type boolean &lt;static&gt; isSupported() → {boolean} Tells whether the Device Motion Event (used by the Device Orientation API or compatible one) is supported or not. Source: CrossBase/device/CB_Device.js, line 621 Returns: Type boolean &lt;static&gt; onChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false} Sets a function to execute for the Device Motion Event (used by the Device Orientation API or compatible one) or removes it. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://developer.mozilla.org/docs/Web/API/DeviceMotionEvent. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 635 Returns: Returns false in the case that the Device Motion Event is not supported or undefined otherwise. Type undefined | false × Search results Close "},"CB_Device.Orientation.html":{"id":"CB_Device.Orientation.html","title":"Namespace: Orientation","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Orientation CB_Device. Orientation Static class to manage the device's orientation. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 393 To Do: Normalize more differences between web clients. Members &lt;static, readonly&gt; cordova_getCompassConstantly_lastId :integer|null Keeps the last watch ID that gets the compass heading constantly using the Apache Cordova's Device Orientation plugin. Used by the CB_Device.Orientation.cordova_getCompassConstantly function. Type: integer | null Source: CrossBase/device/CB_Device.js, line 402 Methods &lt;static&gt; cordova_getCompass(callbackOk, callbackError) → {undefined|false} Gets the compass heading using the Apache Cordova's Device Orientation plugin. Uses &quot;navigator.compass.getCurrentHeading&quot; internally. Parameters: Name Type Description callbackOk function The function that will be called when it succeeds getting the compass heading. Following the same rules as in https://github.com/apache/cordova-plugin-device-orientation (&quot;navigator.compass.getCurrentHeading&quot; function). callbackError function The function that will be called if there is any error getting the compass heading. Following the same rules as in https://github.com/apache/cordova-plugin-device-orientation (&quot;navigator.compass.getCurrentHeading&quot; function). Source: CrossBase/device/CB_Device.js, line 544 To Do: Add a function to normalize the event and call it automatically. Returns: Returns false in the case that the Apache Cordova's Device Orientation plugin is not supported or undefined otherwise. Type undefined | false &lt;static&gt; cordova_getCompassConstantly( [callbackOkOrId] [, callbackError] [, options]) → {integer|undefined|false} Starts or stops getting the compass heading constantly at a regular interval. Uses the Apache Cordova's Device Orientation plugin (&quot;navigator.compass.watchHeading&quot; and &quot;navigator.compass.clearWatch&quot; functions). Parameters: Name Type Argument Default Description callbackOkOrId function | integer &lt;optional&gt; CB_Device.Orientation.cordova_getCompassConstantly_lastId In the case that we want to start getting the compass heading, use a function callback that will be called regularly when the compass heading is gotten successfully (using the &quot;navigator.compass.watchHeading&quot; function). To stop getting the compass heading, use the watch ID that we want to stop (using the &quot;navigator.compass.clearWatch&quot; function). Following the same rules as the first parameter of the &quot;navigator.compass.watchHeading&quot; function (when we want to start watching) or the first parameter of &quot;navigator.compass.clearWatch&quot; function (when we want to stop watching) described in https://github.com/apache/cordova-plugin-device-orientation. callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the compass heading. Only used when we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function). Following the same rules as the second parameter of the &quot;navigator.compass.watchHeading&quot; function described in https://github.com/apache/cordova-plugin-device-orientation. options Object &lt;optional&gt; Object that represents the desired options. Only used when we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function). Following the same rules as the third parameter of the &quot;navigator.compass.watchHeading&quot; function described in https://github.com/apache/cordova-plugin-device-orientation. Source: CrossBase/device/CB_Device.js, line 561 To Do: Add a function to normalize the event and call it automatically. Add parameters to keep old callbacks and options. Returns: Returns false in the case that Apache Cordova's Device Orientation plugin is not supported. In the case that we want to start getting the compass heading (&quot;callbackOkOrId&quot; is a function), it will return the watch ID that has been created. In the case that we want to stop getting the compass heading (&quot;callbackOkOrId&quot; is a watch ID), it will return undefined. Type integer | undefined | false &lt;static&gt; cordova_getCompassConstantlyDisable( [id]) → {undefined|false} Stops getting the compass heading constantly at a regular interval. Uses the Apache Cordova's Device Orientation plugin (&quot;navigator.compass.clearWatch&quot; function). Parameters: Name Type Argument Default Description id integer &lt;optional&gt; CB_Device.Orientation.cordova_getCompassConstantly_lastId The watch ID that we want to stop. Following the same rules as the first parameter of the &quot;navigator.compass.clearWatch&quot; function described in https://github.com/apache/cordova-plugin-device-orientation. Source: CrossBase/device/CB_Device.js, line 590 To Do: Add parameters to keep old callbacks and options. Returns: Returns false in the case that Apache Cordova's Device Orientation plugin is not supported or undefined otherwise. Type undefined | false &lt;static&gt; cordova_isCompassSupported() → {boolean} Tells whether the Apache Cordova's Device Orientation plugin is available or not. Source: CrossBase/device/CB_Device.js, line 530 Returns: Type boolean &lt;static&gt; isCompassNeedsCalibrationSupported() → {boolean} Tells whether the Compass Needs Calibration Event (used by the Device Orientation API or compatible one) is supported or not. Source: CrossBase/device/CB_Device.js, line 504 Returns: Type boolean &lt;static&gt; isMozOrientationSupported() → {boolean} Tells whether the MozOrientation API is supported or not. Source: CrossBase/device/CB_Device.js, line 422 Returns: Type boolean &lt;static&gt; isSupported() → {boolean} Tells whether the Device Orientation Event (used by the Device Orientation API or compatible one) is supported or not. Source: CrossBase/device/CB_Device.js, line 411 To Do: Think about using the &quot;ondeviceorientationabsolute&quot; event. Returns: Type boolean &lt;static&gt; normalizeEvent(e, eventName) → {Event} Normalizes the data gotten from the Device Orientation Event produced by different clients to try to match the Device Orientation API and follow always the same rules as much as possible. Parameters: Name Type Description e Event The event object that we want to normalize. eventName 'deviceorientation' | 'MozOrientation' The name of the event that we want to normalize. Case sensitive. Source: CrossBase/device/CB_Device.js, line 476 To Do: Think about using the &quot;deviceorientationabsolute&quot; event. Normalize more differences between web clients. Returns: Returns the given event object again but normalized (if possible). Type Event &lt;static&gt; onChange(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false} Sets a function to execute for the Device Orientation Event (used by the Device Orientation API or compatible one) or removes it. Falls back to the MozOrientation API if possible. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. The event object received will already be normalized by the CB_Device.Orientation.normalizeEvent function automatically. Following the same rules as in https://developer.mozilla.org/docs/Web/API/DeviceOrientationEvent. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 437 To Do: Think about using the &quot;deviceorientationabsolute&quot; event. Returns: Returns false in the case that neither the Device Orientation API (or compatible one) nor the MozOrientation API are supported or undefined otherwise. Type undefined | false &lt;static&gt; onCompassNeedsCalibration(eventFunction [, keepOldFunction] [, useCapture]) → {undefined|false} Sets a function to execute for the Compass Needs Calibration Event (used by the Device Orientation API or compatible one) or removes it. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. Following the same rules as in https://w3c.github.io/deviceorientation/spec-source-orientation.html#compassneedscalibration. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/device/CB_Device.js, line 518 Returns: Returns false in the case that the Compass Needs Calibration Event is not supported or undefined otherwise. Type undefined | false × Search results Close "},"CB_Device.Proximity.html":{"id":"CB_Device.Proximity.html","title":"Namespace: Proximity","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Proximity CB_Device. Proximity Static class to manage the device's proximity sensor. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 1180 To Do: Normalize more differences between web clients. Methods &lt;static&gt; get(eventFunction [, detectNear] [, keepOldFunction] [, useCapture] [, callbackError]) → {undefined|false} Sets the event to get the proximity or removes it. Uses the Proximity Sensor API or the Proximity Sensor Events as &quot;ondeviceproximity&quot; or &quot;onuserproximity&quot;. The given &quot;eventFunction&quot; will receive the event object as the first parameter but this event object will vary depending on the way to get the proximity which is supported by the client (if any) and the &quot;detectNear&quot; parameter. It will use the following logic order: If &quot;detectNear&quot; is not set to true, Proximity Sensor API is used as the first option (if available) and &quot;event.value&quot; will contain the units in centimeters (depending on the implementation, &quot;event.near&quot; will also be present, containing a boolean depending on whether an object is near or not). If &quot;detectNear&quot; is not set to true, Proximity Sensor Events (&quot;ondeviceproximity&quot;) is used as the second option (if available) and &quot;event.value&quot; will contain the units in centimeters. If &quot;detectNear&quot; is set to true, &quot;onuserproximity&quot; event is the unique option used (if available) and &quot;event.near&quot; will be a boolean which tell us whether something is near or not. Parameters: Name Type Argument Default Description eventFunction function | null The function that will be called when the event is fired. The event object received will already be normalized by the CB_Device.Proximity.normalizeEvent function automatically. Despite of this, due to the big differences between different clients, the event object received as the first parameter will vary depending on the way to get the proximity which is supported by the client (if any). If a null value is used, the event will be removed. detectNear boolean &lt;optional&gt; false Defines whether we want to detect when a physical object is nearby. If it is set to true, it will use the &quot;onuserproximity&quot; event. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener or not. useCapture float &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. callbackError function &lt;optional&gt; Callback that will be called if there is any error getting the proximity. Only used by the Proximity Sensor API (if available). Source: CrossBase/device/CB_Device.js, line 1211 Returns: Returns false in the case that no way to get the proximity is available or undefined otherwise. Type undefined | false &lt;static&gt; isSupported() → {boolean} Tells whether the Proximity Sensor API or the Proximity Sensor Events as &quot;ondeviceproximity&quot; or &quot;onuserproximity&quot; are supported or not. Source: CrossBase/device/CB_Device.js, line 1187 Returns: Type boolean &lt;static&gt; normalizeEvent(e, eventName [, sensor]) → {Event} Normalizes the data gotten from the the Proximity Sensor API or the Proximity Sensor Events as &quot;ondeviceproximity&quot; or &quot;onuserproximity&quot; to try to match the Proximity Sensor API and follow always the same rules as much as possible. Parameters: Name Type Argument Description e Event The event object that we want to normalize. eventName 'change' | 'reading' | 'deviceproximity' | 'userproximity' The name of the event that we want to normalize. Case sensitive. sensor ProximitySensor &lt;optional&gt; ProximitySensor object used by the Proximity Sensor API. Source: CrossBase/device/CB_Device.js, line 1268 To Do: Normalize more differences between web clients. Returns: Returns the given event object again but normalized (if possible). Type Event × Search results Close "},"CB_Device.Vibration.html":{"id":"CB_Device.Vibration.html","title":"Namespace: Vibration","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Vibration CB_Device. Vibration Static class to manage the device's vibration. It will return itself if it is tried to be instantiated. Source: CrossBase/device/CB_Device.js, line 1013 Methods &lt;static&gt; isSupported() → {boolean} Tells whether the Vibration API (or compatible one as Apache Cordova's Vibration plugin) is available or not. Source: CrossBase/device/CB_Device.js, line 1020 Returns: Type boolean &lt;static&gt; start( [vibration]) → {undefined|false} Makes the device vibrate using the Vibration API (or compatible one as Apache Cordova's Vibration plugin). Parameters: Name Type Argument Description vibration integer | array &lt;optional&gt; The vibration pattern which can be either a single integer value or an array of integers. Following the same rules as the first parameter of the native vibrate function. Source: CrossBase/device/CB_Device.js, line 1032 Returns: Returns false in the case that Vibration API (or compatible one as Apache Cordova's Vibration plugin) cannot be used or undefined otherwise. Type undefined | false &lt;static&gt; stop() → {undefined|false} Makes the device stop vibrating using the Vibration API (or compatible one as Apache Cordova's Vibration plugin). Source: CrossBase/device/CB_Device.js, line 1048 Returns: Returns false in the case that Vibration API (or compatible one as Apache Cordova's Vibration plugin) cannot be used or undefined otherwise. Type undefined | false × Search results Close "},"CB_Elements.html":{"id":"CB_Elements.html","title":"Namespace: CB_Elements","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Elements CB_Elements Static class to manage DOM elements. It will return itself if it is tried to be instantiated. Source: CrossBase/general/CB_Elements.js, line 13 To Do: Think about creating a function called &quot;add&quot; or &quot;create&quot; to create a new element (it could accept &quot;tagName&quot;, &quot;id&quot; and &quot;content&quot; parameters). Think about creating &quot;setStyle&quot; and &quot;setStyleById&quot; methods to add a given style attribute and also supporting a boolean parameter to also add the style attribute with vendor prefixes (webkit, moz, ms, o, khtml) if we want to. Methods &lt;static&gt; addClass(element, className [, checkValues] [, onAddClass]) → {Node} Adds a desired class to a given element. The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description element Node The element that will get the new given class. className string The class that will be added. checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to add the given class if it is not being used already. It is recommended to use true to prevent some old clients from adding the same class multiple times. onAddClass function &lt;optional&gt; Callback function that will be called if the class of the element has been added, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1321 To Do: Think about allowing to use more than once class (and think how many times the &quot;onAddClass&quot; function should be called). Returns: Returns the given element again. Type Node &lt;static&gt; addClassById(elementId, className [, checkValues] [, onAddClass]) → {Node|null} Adds a desired class to a given element (by its identifier). The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description elementId string The identifier of the element that will get the new given class. className string The class that will be added. checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to add the given class if it is not being used already. It is recommended to use true to prevent some old clients from adding the same class multiple times. onAddClass function &lt;optional&gt; Callback function that will be called if the class of the element has been added, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1348 To Do: Think about allowing to use more than once class (and think how many times the &quot;onAddClass&quot; function should be called). Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; appendContent(container, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow] [, appendAtBeginning]) → {Node} Appends the desired content inside a given element, keeping the existing one (using innerHTML). Calls the CB_Elements.insertContent internally. Parameters: Name Type Argument Default Description container Node The element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. appendAtBeginning boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. Source: CrossBase/general/CB_Elements.js, line 832 Returns: Returns the given container again. Type Node &lt;static&gt; appendContentBeginning(container, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow]) → {Node} Appends the desired content inside a given element at the beginning, keeping the existing one (using innerHTML). Calls the CB_Elements.insertContent internally. Parameters: Name Type Argument Default Description container Node The element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. Source: CrossBase/general/CB_Elements.js, line 850 Returns: Returns the given container again. Type Node &lt;static&gt; appendContentById(containerId, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow] [, append] [, appendAtBeginning]) → {Node|null} Appends the desired content inside a given element, keeping the existing one (using innerHTML), by its identifier. Calls the CB_Elements.insertContent internally. Parameters: Name Type Argument Default Description containerId string The identifier of the element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. append boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. appendAtBeginning boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. Source: CrossBase/general/CB_Elements.js, line 890 Returns: Returns the affected container (if any) or null otherwise. Type Node | null &lt;static&gt; appendContentByIdBeginning(containerId, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow] [, append]) → {Node|null} Appends the desired content inside a given element at the beginning, keeping the existing one (using innerHTML), by its identifier. Calls the CB_Elements.insertContent internally. Parameters: Name Type Argument Default Description containerId string The identifier of the element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. append boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. Source: CrossBase/general/CB_Elements.js, line 909 Returns: Returns the affected container (if any) or null otherwise. Type Node | null &lt;static&gt; byId() Alias for CB_Elements.id. Source: CrossBase/general/CB_Elements.js, line 520 See: CB_Elements.id &lt;static&gt; classes(classNames [, baseElement] [, useCache]) → {NodeList|array} Returns elements by their class or classes name. Parameters: Name Type Argument Default Description classNames string The name of the class or classes (separated by a blank space) whose elements we want to find. The order of the classes is just important for the internal cache. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_classes_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 273 Returns: Returns the elements (NodeList or array, depending on the web client). Type NodeList | array &lt;static&gt; classesCacheClear( [classNames] [, baseElement]) → {Object} Clears the internal cache used by CB_Elements.classes and others. If no parameter is given, whole internal cache will be cleared. Parameters: Name Type Argument Description classNames string &lt;optional&gt; The name of the class or classes (separated by a blank space) whose internal cache we want to clear. The order of the classes is important for the internal cache. If not provided, it will clear the whole internal cache or the internal cache that belongs to the &quot;baseElement&quot; given (if provided). baseElement Node &lt;optional&gt; The node element parent whose internal cache we want to clear. If not provided but &quot;classNames&quot; is provided, it will clear the internal cache which matches the given &quot;classNames&quot; for any nodes. If it is provided but &quot;classNames&quot; is not, it will clear all the internal cache that belongs to this node element. Source: CrossBase/general/CB_Elements.js, line 439 Returns: Returns the current internal cache after cleaning it (if it is has been possible), which is an associative array of two dimensions (JavaScript object) whose first index belongs to the nodes, the second and last index belongs to the class name or class names and the value belongs to the returning value of the CB_Elements.classes function when it was called for those parameters. Type Object &lt;static&gt; classesCacheUpdate(classNames [, baseElement]) → {NodeList|array} Returns elements by their class or classes name, updating (or creating) the internal cache. Calls the CB_Elements.classes function internally, with the &quot;useCache&quot; parameter set to false. Parameters: Name Type Argument Default Description classNames string The name of the class or classes (separated by a blank space) whose elements we want to find. The order of the classes is just important for the internal cache. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. Source: CrossBase/general/CB_Elements.js, line 426 Returns: Returns the elements (NodeList or array, depending on the web client). Type NodeList | array &lt;static&gt; classesRemove(classNames [, baseElement] [, useCache]) Removes elements by their class or classes name. Parameters: Name Type Argument Default Description classNames string The name of the class or classes (separated by a blank space) whose elements we want to delete. The order of the classes is just important for the internal cache. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_classes_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 495 &lt;static&gt; contextMenuDisable( [element] [, disableContextMenu]) → {Node} Disables or enables the contextual menu for a given element or in the whole document. Parameters: Name Type Argument Default Description element Node &lt;optional&gt; document The element whose contextual menu we want to disable or enable. If not given, it will affect the whole document. disableContextMenu boolean &lt;optional&gt; true If set to false, it will allow showing the contextual menu. Otherwise, it will prevent it to show. Source: CrossBase/general/CB_Elements.js, line 1838 Returns: Returns the affected element. Type Node &lt;static&gt; contextMenuDisableById(elementId [, disableContextMenu]) → {Node|null} Disables or enables the contextual menu for a given element (by its identifier). Parameters: Name Type Argument Default Description elementId string The identifier of the element whose contextual menu we want to disable or enable. disableContextMenu boolean &lt;optional&gt; true If set to false, it will allow showing the contextual menu. Otherwise, it will prevent it to show. Source: CrossBase/general/CB_Elements.js, line 1861 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; get() Alias for CB_Elements.id. Source: CrossBase/general/CB_Elements.js, line 525 See: CB_Elements.id &lt;static&gt; getById() Alias for CB_Elements.id. Source: CrossBase/general/CB_Elements.js, line 530 See: CB_Elements.id &lt;static&gt; getFrameBodyContent(frameElement) → {string|null} Tries to get the body content of an iframe. Depending on the client and the safety measures, this might fail. Parameters: Name Type Description frameElement HTMLIFrameElement The iframe element whose body content we want to get. Source: CrossBase/general/CB_Elements.js, line 1879 Returns: Returns null if something goes wrong. Type string | null &lt;static&gt; getFrameBodyContentById(frameElementId) → {string|null} Tries to get the body content of an iframe (by its identifier). Depending on the client and the safety measures, this might fail. Parameters: Name Type Description frameElementId string The identifier of the iframe element whose body content we want to get. Source: CrossBase/general/CB_Elements.js, line 1923 Returns: Returns null if something goes wrong. Type string | null &lt;static&gt; getHeight(element [, returnNullOnFail] [, computed]) → {*} Returns the height of an element (having in mind its border). Parameters: Name Type Argument Default Description element Node The element whose data we are interested in. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1715 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getHeightById(elementId [, returnNullOnFail] [, computed]) → {*} Returns the height of an element (having in mind its border), by its identifier. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose data we are interested in. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1765 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getLeft(element [, ignoreScroll] [, returnNullOnFail] [, computed]) → {*} Returns the left position of an element (having in mind getBoundingClientRect if available, its parents, etc.). Parameters: Name Type Argument Default Description element Node The element whose data we are interested in. ignoreScroll boolean &lt;optional&gt; true If it is set to false, it will have in mind the current scroll position to calculate the result. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyleProperty and CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1401 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getLeftById(elementId [, ignoreScroll] [, returnNullOnFail] [, computed]) → {*} Returns the left position of an element (having in mind getBoundingClientRect if available, its parents, etc.), by its identifier. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose data we are interested in. ignoreScroll boolean &lt;optional&gt; true If it is set to false, it will have in mind the current scroll position to calculate the result. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyleProperty and CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1510 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getParent(element) → {Node|null} Returns the first parent of a given element: Parameters: Name Type Description element Node The element whose parent we want to get. Source: CrossBase/general/CB_Elements.js, line 720 Returns: Returns null if the parent cannot be found. Type Node | null &lt;static&gt; getParentById(elementId) → {Node|null} Returns the first parent of a given element (by its identifier): Parameters: Name Type Description elementId string The identifier of the element whose parent we want to get. Source: CrossBase/general/CB_Elements.js, line 742 Returns: Returns null if the parent cannot be found. Type Node | null &lt;static&gt; getParents(element) → {array} Returns an array with the parents of a given element, with the topmost parent in the highest index: Parameters: Name Type Description element Node The element whose parents we want to get. Source: CrossBase/general/CB_Elements.js, line 688 Returns: Type array &lt;static&gt; getParentsById(elementId) → {array} Returns an array with the parents of a given element (by its identifier), with the topmost parent in the highest index: Parameters: Name Type Description elementId string The identifier of the element whose parents we want to get. Source: CrossBase/general/CB_Elements.js, line 708 Returns: Type array &lt;static&gt; getScrollLeftById( [elementId] [, onScrollLeftChanges] [, fireFirstTime] [, fireAlways] [, timeoutMs] [, returnNullOnFail]) → {number|null} Returns the horizontal scroll of a given element (by its identifier) and allows running a callback function (becoming recursive if desired). Any previous interval started by a previous call to this function, for the same &quot;elementId&quot;, will be stopped. Parameters: Name Type Argument Default Description elementId string | window &lt;optional&gt; window The identifier of the element whose horizontal scroll position we want to get. If a string with the identifier is not given, the unique value allowed is the window object (which is the default value when a non-valid value or no value is given). onScrollLeftChanges CB_Elements.getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES &lt;optional&gt; The desired callback function. It will be called as an interval if &quot;timeoutMs&quot; is a valid integer value. fireFirstTime boolean &lt;optional&gt; false If it is set to true, it will call the callback function (if any) as soon as this function is called. fireAlways boolean &lt;optional&gt; false If it is set to true, it will call the callback function (if any) every interval even if the horizontal scroll value has not changed from the last call. timeoutMs integer &lt;optional&gt; The number of milliseconds between one call to the callback function (if any) and the next one. If not given, it will not perform any interval. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. Source: CrossBase/general/CB_Elements.js, line 1955 Returns: Returns the horizontal scroll of the given element (by its identifier). It could return zero (0) if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type number | null &lt;static&gt; getScrollTopById( [elementId] [, onScrollTopChanges] [, fireFirstTime] [, fireAlways] [, timeoutMs] [, returnNullOnFail]) → {number|null} Returns the vertical scroll of a given element (by its identifier) and allows running a callback function (becoming recursive if desired). Any previous interval started by a previous call to this function, for the same &quot;elementId&quot;, will be stopped. Parameters: Name Type Argument Default Description elementId string | window &lt;optional&gt; window The identifier of the element whose vertical scroll position we want to get. If a string with the identifier is not given, the unique value allowed is the window object (which is the default value when a non-valid value or no value is given). onScrollTopChanges CB_Elements.getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES &lt;optional&gt; The desired callback function. It will be called as an interval if &quot;timeoutMs&quot; is a valid integer value. fireFirstTime boolean &lt;optional&gt; false If it is set to true, it will call the callback function (if any) as soon as this function is called. fireAlways boolean &lt;optional&gt; false If it is set to true, it will call the callback function (if any) every interval even if the vertical scroll value has not changed from the last call. timeoutMs integer &lt;optional&gt; The number of milliseconds between one call to the callback function (if any) and the next one. If not given, it will not perform any interval. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. Source: CrossBase/general/CB_Elements.js, line 2066 Returns: Returns the vertical scroll of the given element (by its identifier). It could return zero (0) if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type number | null &lt;static&gt; getStyle(element [, computed]) → {Object|null} Returns the style of an element, computed or static: Parameters: Name Type Argument Default Description element Node The element whose style property we want to get. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 922 Returns: Returns an associative array (JavaScript object) with all the styles retrieved or null if nothing can be retrieved. Type Object | null &lt;static&gt; getStyleById(elementId [, computed]) → {Object|null} Returns the style of an element, computed or static (by its identifier): Parameters: Name Type Argument Default Description elementId string The identifier of the element whose style property we want to get. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 954 Returns: Returns an associative array (JavaScript object) with all the styles retrieved or null if nothing can be retrieved. Type Object | null &lt;static&gt; getStyleProperty(element, attribute [, computed]) → {*} Returns the desired attribute value from the style of an element, computed or static: Parameters: Name Type Argument Default Description element Node The element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 969 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns null if nothing can be retrieved. Type * &lt;static&gt; getStylePropertyById(elementId, attribute [, computed]) → {*} Returns the desired attribute value from the style of an element, computed or static (by its identifier): Parameters: Name Type Argument Default Description elementId string The identifier of the element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 990 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns null if nothing can be retrieved. Type * &lt;static&gt; getStylePropertyInteger(element, attribute [, computed]) → {array} Returns the integer value or values (base decimal) of a desired attribute from the style of an element, computed or static: Parameters: Name Type Argument Default Description element Node The element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 1005 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). Type array &lt;static&gt; getStylePropertyIntegerById(elementId, attribute [, computed]) → {array} Returns the integer value or values (base decimal) of a desired attribute from the style of an element, computed or static (by its identifier): Parameters: Name Type Argument Default Description elementId string The identifier of the element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). Source: CrossBase/general/CB_Elements.js, line 1020 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). Type array &lt;static&gt; getStylePropertyNumeric(element, attribute [, computed] [, parseToInteger]) → {array} Returns the numeric value or values (base decimal) of a desired attribute from the style of an element, computed or static: Parameters: Name Type Argument Default Description element Node The element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). parseToInteger boolean &lt;optional&gt; false If it is set to true, the value or values will be parsed to integer. Source: CrossBase/general/CB_Elements.js, line 1036 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). Type array &lt;static&gt; getStylePropertyNumericById(elementId, attribute [, computed] [, parseToInteger]) → {array} Returns the numeric value or values (base decimal) of a desired attribute from the style of an element, computed or static (by its identifier): Parameters: Name Type Argument Default Description elementId string The identifier of the element whose attribute value from its style we want to get. attribute string The name of the attribute whose value we want to get from the style. computed boolean &lt;optional&gt; false If it is set to true, it will try to use the native function window.getComputedStyle (if available). parseToInteger boolean &lt;optional&gt; false If it is set to true, the value or values will be parsed to integer. Source: CrossBase/general/CB_Elements.js, line 1081 To Do: Think about supporting a boolean parameter to try to find the attribute having into account vendor prefixes (webkit, moz, ms, o, khtml). Returns: Returns a numeric array with the values retrieved. If nothing could be retrieved, the first and unique index of the array will contain the value of zero (0). Type array &lt;static&gt; getTop(element [, ignoreScroll] [, returnNullOnFail] [, computed]) → {*} Returns the top position of an element (having in mind getBoundingClientRect if available, its parents, etc.). Parameters: Name Type Argument Default Description element Node The element whose data we are interested in. ignoreScroll boolean &lt;optional&gt; true If it is set to false, it will have in mind the current scroll position to calculate the result. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyleProperty and CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1525 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getTopById(elementId [, ignoreScroll] [, returnNullOnFail] [, computed]) → {*} Returns the top position of an element (having in mind getBoundingClientRect if available, its parents, etc.), by its identifier. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose data we are interested in. ignoreScroll boolean &lt;optional&gt; true If it is set to false, it will have in mind the current scroll position to calculate the result. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyleProperty and CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1637 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getWidth(element [, returnNullOnFail] [, computed]) → {*} Returns the width of an element (having in mind its border). Parameters: Name Type Argument Default Description element Node The element whose data we are interested in. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1651 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; getWidthById(elementId [, returnNullOnFail] [, computed]) → {*} Returns the width of an element (having in mind its border), by its identifier. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose data we are interested in. returnNullOnFail function &lt;optional&gt; false If it is set to true, it will return null instead of zero (0) in the case that something goes wrong. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStylePropertyInteger internally. Source: CrossBase/general/CB_Elements.js, line 1701 Returns: It could return zero (0) or even a non-numeric value if something fails (use &quot;returnNullOnFail&quot; set to true to return null when it fails). Type * &lt;static&gt; hide(element [, checkValues] [, computed] [, onHide]) → {Node} Hides a given element by changing its display property to &quot;none&quot; and its visibility to &quot;hidden&quot;. Parameters: Name Type Argument Default Description element Node The element that we want to hide. checkValues boolean &lt;optional&gt; false If it is set to true, it will only perform the change if either the current visibility property is not &quot;hidden&quot; or the current display property is not &quot;none&quot;. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyle internally. onHide function &lt;optional&gt; Callback function that will be called if the element has been hidden, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the display property (not computed) which should be &quot;none&quot;. Source: CrossBase/general/CB_Elements.js, line 1184 Returns: Returns the given element again. Type Node &lt;static&gt; hideById(elementId [, checkValues] [, computed] [, onHide]) → {Node|null} Hides a given element by changing its display property to &quot;none&quot; and its visibility to &quot;hidden&quot; (by its identifier). Parameters: Name Type Argument Default Description elementId string The identifier of the element that we want to hide. checkValues boolean &lt;optional&gt; false If it is set to true, it will only perform the change if either the current visibility property is not &quot;hidden&quot; or the current display property is not &quot;none&quot;. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyle internally. onHide function &lt;optional&gt; Callback function that will be called if the element has been hidden, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the display property (not computed) which should be &quot;none&quot;. Source: CrossBase/general/CB_Elements.js, line 1209 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; id(id [, useCache]) → {Node|Object|null} Returns an element by its ID. Parameters: Name Type Argument Default Description id string The identifier of the element that we want to find. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_id_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 542 Returns: Returns the elements (Node or object, depending on the web client). It will return null when not found. Type Node | Object | null &lt;static&gt; idCacheClear( [id]) → {Object} Clears the internal cache used by CB_Elements.id and others. If no parameter is given, whole internal cache will be cleared. Parameters: Name Type Argument Description id string &lt;optional&gt; The identifier of the element whose internal cache we want to clear. If not provided, it will clear the whole internal cache. Source: CrossBase/general/CB_Elements.js, line 600 Returns: Returns the current internal cache after cleaning it (if it is has been possible), which is an associative array of one dimension (JavaScript object) whose first and unique index belongs to the identifier and the value belongs to each element. Type Object &lt;static&gt; idCacheUpdate(id) → {node|Object|null} Returns an element by its ID, updating (or creating) the internal cache. Calls the CB_Elements.id function internally, with the &quot;useCache&quot; parameter set to false. Parameters: Name Type Description id string The identifier of the element that we want to find. Source: CrossBase/general/CB_Elements.js, line 588 Returns: Returns the elements (Node or object, depending on the web client). It will return null when not found. Type node | Object | null &lt;static&gt; idRemove(id [, useCache]) Removes an element by its ID. Parameters: Name Type Argument Default Description id string The identifier of the element that we want to delete. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_id_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 620 &lt;static&gt; insertContent(container, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow] [, append] [, appendAtBeginning]) → {Node} Inserts the desired content inside a given element (using innerHTML). Parameters: Name Type Argument Default Description container Node The element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. append boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. appendAtBeginning boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. Source: CrossBase/general/CB_Elements.js, line 800 Returns: Returns the given container again. Type Node &lt;static&gt; insertContentById(containerId, content [, displayValue] [, checkValues] [, computed] [, onContentWritten] [, onShow] [, append] [, appendAtBeginning]) → {Node|null} Inserts the desired content inside a given element (using innerHTML), by its identifier. Parameters: Name Type Argument Default Description containerId string The identifier of the element whose content we want to modify. content string The content that we want to add. displayValue string &lt;optional&gt; If provided, it will call CB_Elements.show internally after inserting the content to set the given display property to the element. checkValues boolean &lt;optional&gt; false If it is set to true, it will only change the content if the current one is different from the given one and it will pass the same parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). computed boolean &lt;optional&gt; false If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show if it is called internally (when &quot;displayValue&quot; is given). onContentWritten function &lt;optional&gt; Callback function that will be called if the content has been written, after doing it (this will happens always if &quot;checkValues&quot; is false). The unique parameter passed will be the affected container itself. onShow function &lt;optional&gt; If &quot;displayValue&quot; is given, it will pass this parameter to CB_Elements.show when it is called internally. append boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. By default, it appends it at the end unless that the &quot;appendAtBeginning&quot; is set to true. appendAtBeginning boolean &lt;optional&gt; false If set to true, it will append the given content to the existing one instead of overwritten it. Source: CrossBase/general/CB_Elements.js, line 870 Returns: Returns the affected container (if any) or null otherwise. Type Node | null &lt;static&gt; preventSelection(element [, avoidSelection]) → {Node|null} Prevents or allows the possibility of selecting the content of a given element (makes it unselectable). Parameters: Name Type Argument Default Description element Node The element which we want to affect. avoidSelection boolean &lt;optional&gt; true If set to false, it will allow selecting the content. Otherwise, it will prevent it to be selected. Source: CrossBase/general/CB_Elements.js, line 1778 Returns: Returns the given element again or null. Type Node | null &lt;static&gt; preventSelectionById(elementId [, avoidSelection]) → {Node|null} Prevents or allows the possibility of selecting the content of a given element (makes it unselectable), by its ID. Parameters: Name Type Argument Default Description elementId string The identifier of the element which we want to affect. avoidSelection boolean &lt;optional&gt; true If set to false, it will allow selecting the content. Otherwise, it will prevent it to be selected. Source: CrossBase/general/CB_Elements.js, line 1825 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; remove(element) Removes an element given. Parameters: Name Type Description element Node The element that we want to delete. Source: CrossBase/general/CB_Elements.js, line 638 &lt;static&gt; removeByClasses() Alias for CB_Elements.classesRemove. Source: CrossBase/general/CB_Elements.js, line 483 See: CB_Elements.classesRemove &lt;static&gt; removeById() Alias for CB_Elements.idRemove. Source: CrossBase/general/CB_Elements.js, line 609 See: CB_Elements.idRemove &lt;static&gt; removeByTagName() Alias for CB_Elements.tagRemove. Source: CrossBase/general/CB_Elements.js, line 228 See: CB_Elements.tagRemove &lt;static&gt; removeClass(element, className [, checkValues] [, onRemoveClass]) → {Node} Removes a desired class from a given element. The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description element Node The element whose class we want to remove. className string The class that will be removed if the element is using it. checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to perform the action if the given &quot;className&quot; is being used. The result will be the same with either true or false, but depending on the client used it could gain or lose performance. onRemoveClass function &lt;optional&gt; Callback function that will be called if the class of the element has been tried to be removed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1278 To Do: Think about allowing to remove more than once class at the same time, regardless of the order given and order set. Returns: Returns the given element again. Type Node &lt;static&gt; removeClassById(elementId, className [, checkValues] [, onRemoveClass]) → {Node|null} Removes a desired class from a given element (by its identifier). The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose class we want to remove. className string The class that will be removed if the element is using it. checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to perform the action if the given &quot;className&quot; is being used. The result will be the same with either true or false, but depending on the client used it could gain or lose performance. onRemoveClass function &lt;optional&gt; Callback function that will be called if the class of the element has been tried to be removed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1305 To Do: Think about allowing to remove more than once class at the same time, regardless of the order given and order set. Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; setClass(element, classNames [, checkValues] [, onSetClass]) → {Node} Sets a desired class or classes to a given element. All previous classes (if any) will be replaced by the new one or new ones. Parameters: Name Type Argument Default Description element Node The element that will get the new given class or classes. classNames string The class or classes that will be set. More than one class can be given (separated by blank spaces). checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to set the given class or classes if they are not being used already. onSetClass function &lt;optional&gt; Callback function that will be called if the class or classes of the element have been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1363 Returns: Returns the given element again. Type Node &lt;static&gt; setClassById(elementId, classNames [, checkValues] [, onSetClass]) → {Node|null} Sets a desired class or classes to a given element (by its identifier). All previous classes (if any) will be replaced by the new one or new ones. Parameters: Name Type Argument Default Description elementId string The identifier of the element that will get the new given class or classes. classNames string The class or classes that will be set. More than one class can be given (separated by blank spaces). checkValues boolean &lt;optional&gt; false If it is set to true, it will only try to set the given class or classes if they are not being used already. onSetClass function &lt;optional&gt; Callback function that will be called if the class or classes of the element have been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 1386 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; setProperty(element, property, propertyValue [, checkValues] [, onSetProperty]) → {Node|null} Changes a desired element property with the given value. Parameters: Name Type Argument Default Description element Node The element whose property we want to modify. property string The name of the property that we want to modify. propertyValue * The value desired for the property. checkValues boolean &lt;optional&gt; false If set to true, it will only modify the property if the current value is different from the given one. onSetProperty function &lt;optional&gt; Callback function that will be called if the property of the element has been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 758 Returns: Returns the given element again or null. Type Node | null &lt;static&gt; setPropertyById(elementId, property, propertyValue [, checkValues] [, onSetProperty]) → {Node|null} Changes a desired element property with the given value (by its identifier). Parameters: Name Type Argument Default Description elementId string The identifier of the element whose property we want to modify. property string The name of the property that we want to modify. propertyValue * The value desired for the property. checkValues boolean &lt;optional&gt; false If set to true, it will only modify the property if the current value is different from the given one. onSetProperty function &lt;optional&gt; Callback function that will be called if the property of the element has been set, after doing it (this will happens always if &quot;checkValues&quot; is false). The first and unique parameter passed will be the affected element itself. Source: CrossBase/general/CB_Elements.js, line 780 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; show(element [, displayValue] [, checkValues] [, computed] [, onShow]) → {Node} Changes the display property to the desired value of a given element, to show it. Its visibility property will be set to &quot;visible&quot;. Parameters: Name Type Argument Default Description element Node The element whose display property we want to change. displayValue string &lt;optional&gt; 'block' The display value we want to set. If not provided or &quot;none&quot; is provided, it will use &quot;block&quot; instead. checkValues boolean &lt;optional&gt; false If it is set to true, it will only perform the change if either the current visibility property is not &quot;visible&quot; or the current display property is different from the given one. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyle internally. onShow function &lt;optional&gt; Callback function that will be called if the change has been performed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the display property (not computed). Source: CrossBase/general/CB_Elements.js, line 1141 Returns: Returns the given element again. Type Node &lt;static&gt; showById(elementId [, displayValue] [, checkValues] [, computed] [, onShow]) → {Node|null} Changes the display property to the desired value of a given element, to show it (by its identifier). Its visibility property will be set to &quot;visible&quot;. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose display property we want to change. displayValue string &lt;optional&gt; 'block' The display value we want to set. If not provided or &quot;none&quot; is provided, it will use &quot;block&quot; instead. checkValues boolean &lt;optional&gt; false If it is set to true, it will only perform the change if either the current visibility property is not &quot;visible&quot; or the current display property is different from the given one. computed boolean &lt;optional&gt; false This parameter will be used when it calls CB_Elements.getStyle internally. onShow function &lt;optional&gt; Callback function that will be called if the change has been performed, after doing it (this will happens always if &quot;checkValues&quot; is false). The first parameter passed will be the affected element itself and the second and last parameter will be the new value of the display property (not computed). Source: CrossBase/general/CB_Elements.js, line 1169 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; showHide(element [, displayValue] [, checkValues] [, computed] [, onToggleDisplay] [, onShow] [, onHide]) → {Node} Toggles the display property (from &quot;none&quot; to the desired value or vice versa) of a given element, to show or hide it.If the element is hidden (its display is &quot;none&quot;), it will call CB_Elements.show internally to show it. Otherwise, it will call CB_Elements.hide internally. Note that these two functions will also change the visibility property (setting it to either &quot;visible&quot; or &quot;hidden&quot;, respectively) of the element. Parameters: Name Type Argument Default Description element Node The element whose display property we want to toggle. displayValue string &lt;optional&gt; 'block' The display value when we want to show the element (it will be used only if the element is currently hidden, when it calls CB_Elements.show internally). The display value to hide the element is always &quot;none&quot;. checkValues boolean &lt;optional&gt; false This parameter will be used when it calls either CB_Elements.show or CB_Elements.hide internally. computed boolean &lt;optional&gt; false This parameter will be used to get the current style and also when it calls either CB_Elements.show or CB_Elements.hide internally. onToggleDisplay function &lt;optional&gt; This parameter will be used when it calls either CB_Elements.show if &quot;onShow&quot; is not provided or CB_Elements.hide if &quot;onHide&quot; is not provided, internally. onShow function &lt;optional&gt; This parameter will be used when it calls CB_Elements.show internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. onHide function &lt;optional&gt; This parameter will be used when it calls CB_Elements.hide internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. Source: CrossBase/general/CB_Elements.js, line 1100 Returns: Returns the given element again. Type Node &lt;static&gt; showHideById(elementId [, displayValue] [, checkValues] [, computed] [, onToggleDisplay] [, onShow] [, onHide]) → {Node|null} Toggles the display property (from &quot;none&quot; to the desired value or vice versa) of a given element, to show or hide it (by its identifier).If the element is hidden (its display is &quot;none&quot;), it will call CB_Elements.show internally to show it. Otherwise, it will call CB_Elements.hide internally. Note that these two functions will also change the visibility property (setting it to either &quot;visible&quot; or &quot;hidden&quot;, respectively) of the element. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose display property we want to toggle. displayValue string &lt;optional&gt; 'block' The display value when we want to show the element (it will be used only if the element is currently hidden, when it calls CB_Elements.show internally). The display value to hide the element is always &quot;none&quot;. checkValues boolean &lt;optional&gt; false This parameter will be used when it calls either CB_Elements.show or CB_Elements.hide internally. computed boolean &lt;optional&gt; false This parameter will be used to get the current style and also when it calls either CB_Elements.show or CB_Elements.hide internally. onToggleDisplay function &lt;optional&gt; This parameter will be used when it calls either CB_Elements.show if &quot;onShow&quot; is not provided or CB_Elements.hide if &quot;onHide&quot; is not provided, internally. onShow function &lt;optional&gt; This parameter will be used when it calls CB_Elements.show internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. onHide function &lt;optional&gt; This parameter will be used when it calls CB_Elements.hide internally. If not provided but &quot;onToggleDisplay&quot; is provided, it will use the latter instead. Source: CrossBase/general/CB_Elements.js, line 1125 Returns: Returns the affected element (if any) or null otherwise. Type Node | null &lt;static&gt; tag( [tagName] [, baseElement] [, useCache]) → {NodeList|array} Returns elements by their tag name. Parameters: Name Type Argument Default Description tagName string &lt;optional&gt; '*' The name of the tag whose elements we want to find. Use asterisk (&quot;*&quot;) in the case that we want all the elements. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_tag_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 51 Returns: Returns the elements (NodeList or array, depending on the web client). Type NodeList | array &lt;static&gt; tagCacheClear( [tagName] [, baseElement]) → {Object} Clears the internal cache user by CB_Elements.tag and others. If no parameter is given, whole internal cache will be cleared. Parameters: Name Type Argument Description tagName string &lt;optional&gt; The name of the tag whose internal cache we want to clear. Use asterisk (&quot;*&quot;) in the case that we want to clear the internal cache for CB_Elements.tag which is used when it is called with this exact parameter. If not provided, it will clear the whole internal cache or the internal cache that belongs to the &quot;baseElement&quot; given (if provided). baseElement Node &lt;optional&gt; The node element parent whose internal cache we want to clear. If not provided but &quot;tagName&quot; is provided, it will clear the internal cache which matches the given &quot;tagName&quot; for any nodes. If it is provided but &quot;tagName&quot; is not, it will clear all the internal cache that belongs to this node element. Source: CrossBase/general/CB_Elements.js, line 184 Returns: Returns the current internal cache after clearing it (if it is has been possible), which is an associative array of two dimensions (JavaScript object) whose first index belongs to the nodes, the second and last index belongs to the tag name and the value belongs to the returning value of the CB_Elements.tag function when it was called for those parameters. Type Object &lt;static&gt; tagCacheUpdate( [tagName] [, baseElement]) → {NodeList|array} Returns elements by their tag name, updating (or creating) the internal cache. Calls the CB_Elements.tag function internally, with the &quot;useCache&quot; parameter set to false. Parameters: Name Type Argument Default Description tagName string &lt;optional&gt; '*' The name of the tag whose elements we want to find. Use asterisk (&quot;*&quot;) in the case that we want all the elements. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. Source: CrossBase/general/CB_Elements.js, line 171 Returns: Returns the elements (NodeList or array, depending on the web client). Type NodeList | array &lt;static&gt; tagRemove( [tagName] [, baseElement] [, useCache]) Removes elements by their tag name. Parameters: Name Type Argument Default Description tagName string &lt;optional&gt; '*' The name of the tag whose elements we want to delete. Use asterisk (&quot;*&quot;) in the case that we want all the elements. baseElement Node &lt;optional&gt; document The node element parent where we want to focus our search. useCache boolean &lt;optional&gt; CB_Configuration.CrossBase.CB_Elements_tag_USE_CACHE Defines whether to try to get the result from an internal cache (it will exist if we previously called the function with the same parameters) or not. The internal cache will be updated when this parameter is set to false or it will be created automatically when it did not exist before. Source: CrossBase/general/CB_Elements.js, line 240 &lt;static&gt; toggleClass(element, classA [, classB] [, onToggleClass]) → {Node} Toggles the class of a given element between two given classes or adds/removes the given class. The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description element Node The element whose class we want to toggle. classA string The class that will be used in the case that the element is not using it already. classB string &lt;optional&gt; '' The class that will be used in the case that the given &quot;classA&quot; is being used by the element. If not given or an empty string is given, it will just remove the &quot;classA&quot; in the case it is being used by the element. onToggleClass function &lt;optional&gt; Callback function that will be called if the class of the element has been toggled or removed, after doing it. The first parameter passed will be the affected element itself and the second and last parameter will be the class used this time (or an empty string). Source: CrossBase/general/CB_Elements.js, line 1224 Returns: Returns the given element again. Type Node &lt;static&gt; toggleClassById(elementId, classA [, classB] [, onToggleClass]) → {Node|null} Toggles the class of a given element between two given classes (by its identifier). The element can contain other classes and they will be kept. Parameters: Name Type Argument Default Description elementId string The identifier of the element whose class we want to toggle. classA string The class that will be used in the case that the element is not using it already. classB string &lt;optional&gt; '' The class that will be used in the case that the given &quot;classA&quot; is being used by the element. If not given or an empty string is given, it will just remove the &quot;classA&quot; in the case it is being used by the element. onToggleClass function &lt;optional&gt; Callback function that will be called if the class of the element has been toggled or removed, after doing it. The first parameter passed will be the affected element itself and the second and last parameter will be the class used this time (or an empty string). Source: CrossBase/general/CB_Elements.js, line 1262 Returns: Returns the affected element (if any) or null otherwise. Type Node | null Type Definitions getScrollLeftById_getScrollTopById_ON_SCROLL_CHANGES(scrollLeftOrTop, scrollLeftOrTopPrevious, scrollWidthOrHeight, clientWidthOrHeight, scrollLeftOrTopRelative, scrollLeftOrTopRelativePrevious) Callback that is used as the &quot;onScrollLeftChanges&quot; parameter for the CB_Elements.getScrollLeftById function or as the &quot;onScrollTopChanges&quot; parameter for the CB_Elements.getScrollTopById function. All values received should be checked since some could be not numbers. Parameters: Name Type Description scrollLeftOrTop * The scroll left or scroll top position. scrollLeftOrTopPrevious * The previous scroll left or scroll top position. scrollWidthOrHeight * The scroll width or scroll height. clientWidthOrHeight * The client width or client height (element.clientWidth/element.offsetWidth or element.clientHeight/element.offsetHeight, depending on the web client). scrollLeftOrTopRelative * The relative scroll left or scroll top position. scrollLeftOrTopRelativePrevious * The previous relative scroll left or scroll top position. Source: CrossBase/general/CB_Elements.js, line 1929 × Search results Close "},"CB_Events.html":{"id":"CB_Events.html","title":"Namespace: CB_Events","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Events CB_Events Static class to manage events. It will return itself if it is tried to be instantiated. Source: CrossBase/general/CB_Events.js, line 11 Methods &lt;static&gt; add() Alias for CB_Events.on. Source: CrossBase/general/CB_Events.js, line 147 See: CB_Events.on &lt;static&gt; executeByName(eventTarget, eventName [, e] [, returnOnNothingExecuted]) → {boolean} Executes all event listeners for an specific event from a node (target). Parameters: Name Type Argument Description eventTarget Object The target whose event listeners we want to execute. It will be the value of &quot;this&quot; for every call to each listener. eventName string The name of the event whose event listeners we want to execute. e Event &lt;optional&gt; Event object that will be passed as the first and unique parameter for every call to each listener. returnOnNothingExecuted * &lt;optional&gt; The value that will be returned by the function if nothing is executed. Source: CrossBase/general/CB_Events.js, line 363 Returns: Returns the result of doing the AND operator of all return values of each listener executed. If only one listener is executed, it will return the result of doing the AND operator with its returning value and &quot;true&quot;. Returns the value of the &quot;returnOnNothingExecuted&quot; parameter if nothing is executed. Type boolean &lt;static&gt; getAll() → {array} Returns all stored event handlers (if any). Source: CrossBase/general/CB_Events.js, line 425 Returns: Returns an array of CB_Events.EVENT_HANDLER objects. Type array &lt;static&gt; getByName(eventTarget, eventName [, onlyWithFunction]) → {array} Returns all handlers for an specific event from a node (target), if any. Parameters: Name Type Argument Default Description eventTarget Object The target whose event listeners we want to get. eventName string The name of the event whose event listeners we want to get. onlyWithFunction boolean &lt;optional&gt; false Defines whether to return only the handlers which have a function as the listener. Source: CrossBase/general/CB_Events.js, line 397 Returns: Returns an array of CB_Events.EVENT_HANDLER objects. Type array &lt;static&gt; getType(e) → {string} Returns the type of an event, if any (otherwise, returns an empty string). Parameters: Name Type Description e Event Event object. Source: CrossBase/general/CB_Events.js, line 108 Returns: Type string &lt;static&gt; normalize(e) → {Event} Gets the right event object for the current web client and normalizes it attaching to it some methods and properties if they were not present (as preventDefault, stopPropagation, target, etc.). The new attached methods and properties may include polyfills, etc. Parameters: Name Type Description e Event Event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). Source: CrossBase/general/CB_Events.js, line 37 Returns: Returns the event object normalized. Type Event &lt;static&gt; on(eventTarget, eventName, eventFunction [, useCapture] [, keepOldEventFunction] [, erasable]) Adds an event listener. Parameters: Name Type Argument Default Description eventTarget Object The target where we want to attach the event listener. eventName string The name of the event that we want to add. eventFunction function The function (event listener) of the event that we want to add. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. keepOldEventFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. erasable boolean &lt;optional&gt; true Defines whether the event listener will be erasable by CB_Events.removeAll or CB_Events.removeByName functions later or not (it will always be erasable if we force delete). Source: CrossBase/general/CB_Events.js, line 163 To Do: Try to simulate &quot;useCapture&quot; when the &quot;addEventListener&quot; method is not available. &lt;static&gt; remove(eventTarget, eventName, eventFunction [, useCapture]) Removes an event listener (even if it is not erasable). Parameters: Name Type Argument Default Description eventTarget Object The target whose event listener we want to remove. eventName string The name of the event that we want to remove. eventFunction function The function (event listener) of the event that we want to remove. useCapture boolean &lt;optional&gt; false Defines whether the event we want to remove was defined to use capture or not. Source: CrossBase/general/CB_Events.js, line 124 &lt;static&gt; removeAll( [forceDelete]) Removes all event listeners. Parameters: Name Type Argument Default Description forceDelete boolean &lt;optional&gt; false If it is set to true, it will remove all event listeners (even the ones which were added as not erasable). Source: CrossBase/general/CB_Events.js, line 339 &lt;static&gt; removeByName(eventTarget, eventName [, forceDelete]) Deletes all handlers for an specific event from a node (target). Parameters: Name Type Argument Default Description eventTarget Object The target whose event listeners we want to remove. eventName string The name of the event whose event listeners we want to remove. forceDelete boolean &lt;optional&gt; false If it is set to true, it will remove any listener (even the ones which were added as not erasable). Source: CrossBase/general/CB_Events.js, line 312 Type Definitions EVENT_HANDLER Object that contains an event handler. Type: Object Properties: Name Type Description eventTarget Object The target of the event. eventName string The name of the event. eventFunction function The event listener. useCapture boolean Defines whether the event listener was defined to use capture or not. erasable boolean Defines whether the event handler is erasable (without forcing delete) or not. Source: CrossBase/general/CB_Events.js, line 253 × Search results Close "},"CB_GraphicSprites.html":{"id":"CB_GraphicSprites.html","title":"Class: CB_GraphicSprites","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_GraphicSprites CB_GraphicSprites Class to manage a group of graphic sprites (2D or 3D). new CB_GraphicSprites( [spritesGroup] [, byReference]) → {CB_GraphicSprites} Class to manage a group of graphic sprites (2D or 3D). Parameters: Name Type Argument Default Description spritesGroup CB_GraphicSprites.SPRITES_OBJECT &lt;optional&gt; Object with the desired sprites. The information will be used for the CB_GraphicSprites#spritesGroup property. Used as the &quot;spritesGroup&quot; parameter when calling the CB_GraphicSprites#insertSprites method internally. byReference boolean &lt;optional&gt; !!CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites (CB_GraphicSprites.SPRITE_OBJECT objects) or sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects). The value will be stored in the CB_GraphicSprites#byReference_DEFAULT property. If a boolean value is not provided, it will use the value of the CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT property of the given CB_GraphicSprites.SPRITES_OBJECT object (parsed to boolean). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 232 To Do: Think about a &quot;createCopy&quot; parameter on different the insert methods (to insert sprites groups/graphic sprites objects, etc.) so it will make a copy of the object to avoid using/modifying the original one. If the &quot;createCopy&quot; is set to false, it should always use the object as reference (using/modifying it). Think about a method to remove a sprite when the same sprite is received by parameter. The same with sub-sprites, receiving the sub-sprite by parameter. The same to remove the sprites group object, receiving a sprites group object by parameter. Only remove them if they match exactly. Returns: Returns a new CB_GraphicSprites object. Type CB_GraphicSprites Members &lt;static, constant&gt; filterProperties_DEFAULT_PROPERTIES :CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE Object used as the default value for the &quot;propertiesToKeepObject&quot; parameter if not provided when calling the CB_GraphicSprites.filterProperties function. Type: CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE Default Value: {&quot;spritesScene&quot;:&quot;&quot;,&quot;spritesGroups&quot;:&quot;&quot;,&quot;sprites&quot;:&quot;&quot;,&quot;spritesGroup&quot;:&quot;&quot;,&quot;sprite&quot;:&quot;&quot;,&quot;subSprite&quot;:&quot;&quot;} Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1882 &lt;static, constant&gt; HEIGHT_DEFAULT :number Default &quot;height&quot; of the destiny. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 412 &lt;static, constant&gt; HEIGHT_SOURCE_DEFAULT :number Default height (&quot;srcHeight&quot;) of the original source. Unit agnostic. Type: number Default Value: 32 Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 382 &lt;static, constant&gt; LEFT_DEFAULT :number Default &quot;left&quot; (horizontal position) in the destiny. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 420 &lt;static, constant&gt; LEFT_SOURCE_DEFAULT :number Default left (&quot;srcLeft&quot;, horizontal position) in the original source. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 390 &lt;static, constant&gt; SRC_TYPES :object Object with some &quot;srcType&quot;. Each property of this object belong to one source type, having an integer as value which represents it. You can define more source types here. Type: object Default Value: {&quot;IMAGE&quot;:0,&quot;TEXT&quot;:1,&quot;SEGMENT&quot;:2,&quot;PIXEL&quot;:3,&quot;RECTANGLE&quot;:4,&quot;CIRCLE&quot;:5,&quot;ARC&quot;:6,&quot;ELLIPSE&quot;:7,&quot;TRIANGLE&quot;:8,&quot;BEZIER_CURVE&quot;:9,&quot;QUADRATIC_BEZIER_CURVE&quot;:10,&quot;BITMAP&quot;:11,&quot;MAP&quot;:12} Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 343 &lt;static, constant&gt; TOP_DEFAULT :number Default &quot;top&quot; (vertical position) in the destiny. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 427 &lt;static, constant&gt; TOP_SOURCE_DEFAULT :number Default top (&quot;srcTop&quot;, vertical position) in the original source. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 397 &lt;static, constant&gt; WIDTH_DEFAULT :number Default &quot;width&quot; of the destiny. Unit agnostic. Type: number Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 405 &lt;static, constant&gt; WIDTH_SOURCE_DEFAULT :number Default width (&quot;srcWidth&quot;) of the original source. Unit agnostic. Type: number Default Value: 32 Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 375 &lt;static, constant&gt; ZINDEX_DEFAULT :number Default &quot;zIndex&quot; in the destiny. Type: number Default Value: 1 Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 435 byReference_DEFAULT :boolean This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites (CB_GraphicSprites.SPRITE_OBJECT objects) or sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects). Type: boolean Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 310 &lt;readonly&gt; id :string|* Identifier of the sprites group object (the &quot;id&quot; property of the CB_GraphicSprites.SPRITES_OBJECT stored in the CB_GraphicSprites#spritesGroup property) and the CB_GraphicSprites object itself (same one). It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). Type: string | * Default Value: 'CB_GraphicSprites_' + CB_GraphicSprites._idUnique++ Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 245 &lt;constant&gt; isSprites :boolean Property which is always set to true to help identify this type of object. Type: boolean Default Value: true Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 325 &lt;readonly&gt; parent :* Property pointing to or containing its parent. It could be a CB_GraphicSpritesScene object. It is the same as the &quot;parent&quot; property of the CB_GraphicSprites.SPRITES_OBJECT stored in the CB_GraphicSprites#spritesGroup property. Type: * Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 254 &lt;readonly&gt; pointer :integer Pointer with the position of the current sprite (belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array). Type: integer Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 281 &lt;readonly&gt; pointerPrevious :integer Keeps the previous value of the CB_GraphicSprites#pointer property (if any). Type: integer Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 291 &lt;readonly&gt; spritesGroup :CB_GraphicSprites.SPRITES_OBJECT Object with information about the sprites. Type: CB_GraphicSprites.SPRITES_OBJECT Default Value: {} Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 272 &lt;readonly&gt; time :integer Stores the time in milliseconds when the current sprite was started being pointed (time elapsed since the time origin which will be obtained calling the CB_Device.getTiming function internally). Type: integer Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 301 &lt;constant&gt; type :string Indicates the type of object (always &quot;sprites&quot;). Type: string Default Value: sprites Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 334 &lt;readonly&gt; zIndex :number Z-index of the sprites group object (the &quot;zIndex&quot; property of the CB_GraphicSprites.SPRITES_OBJECT stored in the CB_GraphicSprites#spritesGroup property) and the CB_GraphicSprites object itself (same one). To change the value of this property, use the CB_GraphicSprites#setZIndex method (which will call the CB_GraphicSpritesScene#updateGraphicSpritesByZIndex method internally if there is a CB_GraphicSpritesScene parent object). Only numeric values which are not zero (0) are allowed. Type: number Default Value: CB_GraphicSprites.ZINDEX_DEFAULT Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 263 Methods &lt;static&gt; clearReferences(element) → {*} Clears the &quot;container&quot;, the &quot;parent&quot; and the &quot;data.that&quot; properties (sets to null) of the given object and its sub-objects (works recursively, internally). Parameters: Name Type Description element * The object whose properties we want to clear. It can be different kinds (CB_GraphicSpritesScene, CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT, CB_GraphicSprites, CB_GraphicSprites.SPRITES_OBJECT, CB_GraphicSprites.SPRITE_OBJECT, CB_GraphicSprites.SUBSPRITE_OBJECT, etc.). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1839 Returns: Returns the same object with the the &quot;container&quot;, the &quot;parent&quot;, &quot;data.that&quot; and the &quot;data.getThis&quot; properties cleared (set to null), if possible. Type * &lt;static&gt; filterProperties(element [, propertiesToKeepObject]) → {*} Gets a new object with the properties filtered of a given element and its sub-elements, keeping only the ones that are in the given &quot;propertiesToKeepObject&quot; (works recursively, internally). Parameters: Name Type Argument Default Description element * The object whose properties we want to clear. It can be different kinds (CB_GraphicSpritesScene, CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT, CB_GraphicSprites, CB_GraphicSprites.SPRITES_OBJECT, CB_GraphicSprites.SPRITE_OBJECT, CB_GraphicSprites.SUBSPRITE_OBJECT, etc.). propertiesToKeepObject CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE &lt;optional&gt; CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES The object with the properties that we want to keep. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1909 To Do: Implement a boolean property and when it is true it will not keep the properties whose values are the default ones (for example, if &quot;byReference&quot; property is false it will not be kept as it is its default value). So the output can be reduced this way. Returns: Returns a new object with the properties filtered of a given element and its sub-elements, keeping only the ones that are in the given &quot;propertiesToKeepObject&quot;. If no valid &quot;element&quot; is provided, returns null. Type * current() Alias for CB_GraphicSprites#getCurrent. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1356 See: CB_GraphicSprites#getCurrent destructor() Destroys the graphic sprites object (removing all the sprites and their sub-sprites, etc.) and frees memory. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 457 executeAll() Alias for CB_GraphicSprites#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1214 See: CB_GraphicSprites#executeFunctionAll executeFunctionAll(functionEach [, orderedByZIndex] [, delayBetweenEach] [, sprites] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing sprites (CB_GraphicSprites.SPRITE_OBJECT objects) or on the desired ones (if provided). Calls the CB_Arrays.executeFunctionAll function internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Function that will be called for each sprite (CB_GraphicSprites.SPRITE_OBJECT object). As the first parameter it receives the CB_GraphicSprites.SPRITE_OBJECT object of the &quot;sprites&quot; being looped, as the second parameter the position of this CB_GraphicSprites.SPRITE_OBJECT object in the &quot;sprites&quot; array provided (or, if not provided, in the array returned by the CB_GraphicSprites#getSprites method), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the CB_GraphicSprites.SPRITE_OBJECT object itself. orderedByZIndex boolean &lt;optional&gt; false If set to true, it will loop the sprites sorted by their z-index (ascending order). delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the setTimeout function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each CB_GraphicSprites.SPRITE_OBJECT object). sprites array &lt;optional&gt; CB_GraphicSprites#getSprites() A numeric array containing the sprites (CB_GraphicSprites.SPRITE_OBJECT objects) that we want to loop. It should contain only CB_GraphicSprites.SPRITE_OBJECT objects which are already in the current CB_GraphicSprites object. If not provided, it will use all the CB_GraphicSprites.SPRITE_OBJECT objects contained in the CB_GraphicSprites object. returnSetTimeoutsArray boolean &lt;optional&gt; false Defines whether we want the method to return an integer or a numeric array with information of each setTimeout call. Returning an array with information of each setTimeout call is only useful when the setTimeout function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). delayBetweenEachAffectsFirst boolean &lt;optional&gt; false If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1242 To Do: Think about only allowing CB_GraphicSprites.SPRITE_OBJECT objects (in the &quot;sprites&quot; parameter) which are already in the CB_GraphicSprites (identify them by their ID), to avoid problems. Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_GraphicSprites.SPRITE_OBJECT objects given in the &quot;sprites&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_Arrays.executeFunctionAll_OBJECT object for each CB_GraphicSprites.SPRITE_OBJECT given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array executeFunctionAllSubSprites(functionEach [, orderedByZIndex] [, delayBetweenEach] [, sprite] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects) from a given sprite (CB_GraphicSprites.SPRITE_OBJECT object). Calls the CB_Arrays.executeFunctionAll function internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Function that will be called for each sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) from the given sprite (CB_GraphicSprites.SPRITE_OBJECT object). As the first parameter it receives the CB_GraphicSprites.SUBSPRITE_OBJECT object of the sub-sprites being looped, as the second parameter the position of this CB_GraphicSprites.SUBSPRITE_OBJECT object in the &quot;subSprites&quot; property of the sprite (CB_GraphicSprites.SPRITE_OBJECT object) provided (which is an array), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the CB_GraphicSprites.SUBSPRITE_OBJECT object itself. orderedByZIndex boolean &lt;optional&gt; false If set to true, it will loop the sub-sprites sorted by their z-index (ascending order). delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the setTimeout function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each CB_GraphicSprites.SUBSPRITE_OBJECT object). sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite and its sub-sprites. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). returnSetTimeoutsArray boolean &lt;optional&gt; false Defines whether we want the method to return an integer or a numeric array with information of each setTimeout call. Returning an array with information of each setTimeout call is only useful when the setTimeout function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). delayBetweenEachAffectsFirst boolean &lt;optional&gt; false If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1271 To Do: Think about only allowing CB_GraphicSprites.SPRITE_OBJECT objects (in the &quot;sprite&quot; parameter) which are already in the CB_GraphicSprites.SPRITE_OBJECT (identify them by their ID), to avoid problems. Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the existing CB_GraphicSprites.SUBSPRITE_OBJECT objects in the given CB_GraphicSprites.SPRITE_OBJECT object). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_Arrays.executeFunctionAll_OBJECT object for each CB_GraphicSprites.SUBSPRITE_OBJECT. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array forEach() Alias for CB_GraphicSprites#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1219 See: CB_GraphicSprites#executeFunctionAll forEachSprite() Alias for CB_GraphicSprites#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1224 See: CB_GraphicSprites#executeFunctionAll get() Alias for CB_GraphicSprites#getSprite. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1064 See: CB_GraphicSprites#getSprite getAll() Alias for CB_GraphicSprites#getSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1030 See: CB_GraphicSprites#getSprites getById() Alias for CB_GraphicSprites#getSpriteById. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1085 See: CB_GraphicSprites#getSpriteById getCopy( [avoidCopyingPointer] [, avoidCopyingTimes] [, clearReferences] [, filterProperties] [, propertiesToKeepObject]) → {CB_GraphicSprites} Gets a new copy of this object with the same attributes (all sub-objects will be a copy, they will not the same reference). Parameters: Name Type Argument Default Description avoidCopyingPointer boolean &lt;optional&gt; false If set to true, it will not copy the CB_GraphicSprites#pointer property of the object. avoidCopyingTimes boolean &lt;optional&gt; false If set to true, it will not copy neither the CB_GraphicSprites#time property property of the object nor the &quot;time&quot; property of each of its sprites (CB_GraphicSprites.SPRITE_OBJECT objects). clearReferences boolean &lt;optional&gt; false If set to true, it will not copy neither the &quot;container&quot; nor the &quot;parent&quot; nor the &quot;data.that&quot; nor the &quot;data.getThis&quot; properties of any element. Useful to be able to stringify the object preventing the &quot;TypeError: cyclic object value&quot; error. When set to true, calls the CB_GraphicSprites.clearReferences function internally. If set to true and the &quot;filterProperties&quot; parameter is also set to true, the CB_GraphicSprites.filterProperties will always be called before calling the CB_GraphicSprites.clearReferences function. filterProperties boolean &lt;optional&gt; false If set to true, it will call the CB_GraphicSprites.filterProperties function internally to filter the properties that we do not want to keep (using the given &quot;propertiesToKeepObject&quot; as the parameter to call it). When set to true, calls the CB_GraphicSprites.filterProperties function internally. If set to true and the &quot;clearReferences&quot; parameter is also set to true, the CB_GraphicSprites.filterProperties will always be called before calling the CB_GraphicSprites.clearReferences function. propertiesToKeepObject CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE &lt;optional&gt; CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES The object with the properties that we want to keep. Only used when the &quot;filterProperties&quot; parameter is set to true, as the &quot;propertiesToKeepObject&quot; when calling the CB_GraphicSprites.filterProperties function internally. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1755 Returns: Returns a copy of this object with the same attributes (all sub-objects will be a copy, not the same reference). Type CB_GraphicSprites getCurrent() → {CB_GraphicSprites.SPRITE_OBJECT|null} Gets the sprite (a CB_GraphicSprites.SPRITE_OBJECT object) which is being currently pointed (by the pointer set in the CB_GraphicSprites#pointer property). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1366 Returns: Returns the CB_GraphicSprites.SPRITE_OBJECT object which is currently pointed by the pointer (set in the CB_GraphicSprites#pointer property). Returns null if not found. Type CB_GraphicSprites.SPRITE_OBJECT | null getCurrentPosition() Alias for CB_GraphicSprites#getPointer. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1293 See: CB_GraphicSprites#getPointer getIndexById() Alias for CB_GraphicSprites#getSpriteIndexById. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1104 See: CB_GraphicSprites#getSpriteIndexById getPointer() → {integer} Gets the current position of the pointer. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Internally, it uses the CB_GraphicSprites#pointer property. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1303 Returns: Returns the position where the pointer is currently pointing to. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). If not found, returns zero (0) by default. Type integer getPointerPrevious() → {integer} Gets the previous position of the pointer. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Internally, it uses the CB_GraphicSprites#pointerPrevious property. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1287 Returns: Returns the position where the pointer was previously pointing to. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). If not found, returns -1 by default. Type integer getPrevious() → {CB_GraphicSprites.SPRITE_OBJECT|null} Gets the sprite (a CB_GraphicSprites.SPRITE_OBJECT object) which was previously pointed (by the previous value of the pointer set in the CB_GraphicSprites#pointer property, whose value is now in the CB_GraphicSprites#pointerPrevious property). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1344 Returns: Returns the CB_GraphicSprites.SPRITE_OBJECT object which was previously pointed by the pointer (by the previous value of the pointer set in the CB_GraphicSprites#pointer property, whose value is now in the CB_GraphicSprites#pointerPrevious property). Returns null if not found. Type CB_GraphicSprites.SPRITE_OBJECT | null getPreviousPosition() Alias for CB_GraphicSprites#getPointerPrevious. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1277 See: CB_GraphicSprites#getPointerPrevious getSprite( [index] [, returnValueOnFail]) → {CB_GraphicSprites.SPRITE_OBJECT|*} Gets a desired sprite object through its index (its position in the CB_GraphicSprites#spritesGroup.sprites array). Faster than getting it through its identifier with the CB_GraphicSprites#getSpriteById method. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the desired sprite must be located (its position in the CB_GraphicSprites#spritesGroup.sprites array). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1076 Returns: Returns a CB_GraphicSprites.SPRITE_OBJECT object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites.SPRITE_OBJECT | * getSpriteById( [id] [, returnValueOnFail]) → {CB_GraphicSprites.SPRITE_OBJECT|*} Gets a desired sprite object through its identifier. Slower than getting it through its index with the CB_GraphicSprites#getSprite method. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the sprite that we want to get. returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1097 Returns: Returns a CB_GraphicSprites.SPRITE_OBJECT object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites.SPRITE_OBJECT | * getSpriteIndexById( [id]) → {integer} Gets the index (the position in the CB_GraphicSprites#spritesGroup.sprites array) of a desired sprite by its identifier. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the sprite whose index we want to get. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1116 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns the index (the position in the CB_GraphicSprites#spritesGroup.sprites array) of the desired sprite or -1 if not found. Type integer getSprites( [orderedByZIndex] [, returnValueOnFail]) → {array|*} Gets all the sprites (the &quot;sprites&quot; property of the internal CB_GraphicSprites.SPRITES_OBJECT object, if any). Parameters: Name Type Argument Default Description orderedByZIndex boolean &lt;optional&gt; false If set to true, it will return the sprites sorted by their z-index (ascending order). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1047 Returns: Returns an array with all the CB_GraphicSprites.SPRITE_OBJECT objects or the value of &quot;returnValueOnFail&quot; otherwise. Type array | * getSpritesAll() Alias for CB_GraphicSprites#getSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1035 See: CB_GraphicSprites#getSprites getSpritesGroup( [returnValueOnFail]) → {CB_GraphicSprites.SPRITES_OBJECT|*} Gets the sprites group object (the internal CB_GraphicSprites.SPRITES_OBJECT object, if any). Parameters: Name Type Argument Description returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1024 Returns: Returns a CB_GraphicSprites.SPRITES_OBJECT object with all the sprites or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites.SPRITES_OBJECT | * getSubSprite( [index] [, sprite] [, returnValueOnFail]) → {CB_GraphicSprites.SUBSPRITE_OBJECT|*} Gets a desired sub-sprite object through its index (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object). Faster than getting it through its identifier with the CB_GraphicSprites#getSubSpriteById method. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the desired sub-sprite must be located (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object). sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite and its sub-sprites. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1165 Returns: Returns a CB_GraphicSprites.SUBSPRITE_OBJECT object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites.SUBSPRITE_OBJECT | * getSubSpriteById( [id] [, sprite] [, returnValueOnFail]) → {CB_GraphicSprites.SUBSPRITE_OBJECT|*} Gets a desired sub-sprite object through its identifier from the given CB_GraphicSprites.SPRITE_OBJECT object. Slower than getting it through its index with the CB_GraphicSprites#getSubSprite method. Parameters: Name Type Argument Default Description id string | * &lt;optional&gt; The identifier of the sub-sprite that we want to get. sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite and its sub-sprites. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1183 Returns: Returns a CB_GraphicSprites.SUBSPRITE_OBJECT object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites.SUBSPRITE_OBJECT | * getSubSpriteIndexById( [id] [, sprite]) → {integer} Gets the index (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object) of a desired sub-sprite by its identifier. Parameters: Name Type Argument Default Description id string | * &lt;optional&gt; The identifier of the sub-sprite whose index we want to get. sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite and its sub-sprites. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1199 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns the index (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object) of the desired sub-sprite or -1 if not found. Type integer getSubSprites( [sprite] [, orderedByZIndex] [, returnValueOnFail]) → {array|*} Gets an array with all the CB_GraphicSprites.SUBSPRITE_OBJECT objects of a given CB_GraphicSprites.SPRITE_OBJECT object. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite and its sub-sprites. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). orderedByZIndex boolean &lt;optional&gt; false If set to true, it will return the sub-sprites sorted by their z-index (ascending order). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1138 Returns: Returns an array with all the CB_GraphicSprites.SUBSPRITE_OBJECT objects of the given CB_GraphicSprites.SPRITE_OBJECT object or the value of &quot;returnValueOnFail&quot; otherwise. Type array | * getTime( [returnValueOnFail] [, parentTimeFallback]) → {number} Gets the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the time origin which was obtained calling the CB_Device.getTiming function internally). Parameters: Name Type Argument Default Description returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. parentTimeFallback boolean &lt;optional&gt; false If the &quot;time&quot; property of &quot;this&quot; is not found, it will try to get the &quot;time&quot; property of &quot;this.time&quot; before returning &quot;returnValueOnFail&quot;. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1669 Returns: Returns the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the time origin which was obtained calling the CB_Device.getTiming function internally). If it could not be found, it will return &quot;returnValueOnFail&quot;. Type number getTimeElapsed( [timeToCompare] [, parentTimeFallback]) → {number} Tells how many milliseconds elapsed since the current sprite or a sub-sprite was or will be pointed (checking the CB_GraphicSprites#time property), comparing with the time given in milliseconds (time elapsed since the time origin which can be obtained calling the CB_Device.getTiming function) or with the current one if none is given. Parameters: Name Type Argument Default Description timeToCompare number &lt;optional&gt; CB_Device.getTiming() The time (time elapsed since the time origin which can obtained calling the CB_Device.getTiming function) that we want to compare to (normally, it will be a newer time than the one stored in the CB_GraphicSprites#time property). It must be a positive number (or zero). If not provided, it will use the current time (by calling the CB_Device.getTiming function internally). parentTimeFallback boolean &lt;optional&gt; false If the &quot;time&quot; property of &quot;this&quot; is not found, it will try to get the &quot;time&quot; property of &quot;this.time&quot; before using &quot;returnValueOnFail&quot;. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1683 Returns: Returns how many milliseconds elapsed since the current sprite or a sub-sprite was or will be pointed, comparing with the time given (in milliseconds) or with the current one if none was given. This is just the given &quot;timeToCompare&quot; minus the returning value of calling the CB_GraphicSprites#getTime method. Type number getZIndex( [returnValueOnFail]) → {number} Gets the z-index (&quot;zIndex&quot; property) of the sprites group object (and the {@CB_GraphicSprites} object itself). Parameters: Name Type Argument Description returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1424 Returns: Returns the z-index (&quot;zIndex&quot;) of the sprites group object (and the {@CB_GraphicSprites} object itself). If not found, returns the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. Type number getZIndexSprite( [sprite] [, returnValueOnFail]) → {number} Gets the z-index (&quot;zIndex&quot; property) of a given sprite object. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1455 Returns: Returns the z-index (&quot;zIndex&quot;) of the given sprite. If not found, returns the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. Type number getZIndexSubSprite(subSprite [, returnValueOnFail]) → {number} Gets the z-index (&quot;zIndex&quot; property) of a given sub-sprite object. Parameters: Name Type Argument Description subSprite CB_GraphicSprites.SUBSPRITE_OBJECT The CB_GraphicSprites.SUBSPRITE_OBJECT object which contains the sub-sprite. returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1490 Returns: Returns the z-index (&quot;zIndex&quot;) of the given sub-sprite. If not found, returns the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or &quot;returnValueOnFail&quot; otherwise. Type number insert() Alias for CB_GraphicSprites#insertSprite. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 640 See: CB_GraphicSprites#insertSprite insertSprite( [sprite] [, avoidUpdatingSpritesByZIndex]) → {CB_GraphicSprites.SPRITE_OBJECT} Adds the desired graphic sprite. Calls CB_GraphicSprites#insertSubSprites internally. If a sprite with the same identifier already exists, it will be replaced by the new one in its same position. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; Object with the desired sprite. It will be stored inside the CB_GraphicSprites#spritesGroup property. avoidUpdatingSpritesByZIndex boolean &lt;optional&gt; false If set to true, it will not call the {CB_GraphicSprites#updateSpritesByZIndex} method internally. Internal usage recommended only. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 652 Returns: Returns the CB_GraphicSprites.SPRITE_OBJECT object which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). Type CB_GraphicSprites.SPRITE_OBJECT insertSprites( [spritesGroup] [, byReference]) → {CB_GraphicSprites.SPRITES_OBJECT} Adds the desired group of graphic sprites. Calls the CB_GraphicSprites#insertSprite and CB_GraphicSprites#updateSpritesByZIndex methods internally. Parameters: Name Type Argument Default Description spritesGroup CB_GraphicSprites.SPRITES_OBJECT &lt;optional&gt; Object with the desired sprites. They will be stored in the CB_GraphicSprites#spritesGroup property. byReference boolean &lt;optional&gt; !!CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT This value will be used as the default value when the &quot;byReference&quot; property is not given in the sprites (CB_GraphicSprites.SPRITE_OBJECT objects) or sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects). The value will be stored in the CB_GraphicSprites#byReference_DEFAULT property. If a boolean value is not provided, it will use the value of the CB_GraphicSprites.SPRITES_OBJECT.byReference_DEFAULT property of the given CB_GraphicSprites.SPRITES_OBJECT object (parsed to boolean). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 502 Returns: Returns the CB_GraphicSprites#spritesGroup property after updating it. Type CB_GraphicSprites.SPRITES_OBJECT insertSpritesGroup() Alias for CB_GraphicSprites#insertSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 490 See: CB_GraphicSprites#insertSprites insertSubSprite(subSprite, sprite [, avoidUpdatingSubSpritesByZIndex]) → {CB_GraphicSprites.SUBSPRITE_OBJECT} Adds the given sub-sprite to the desired sprite. If a sub-sprite with the same identifier already exists, it will be replaced by the new one in its same position. Parameters: Name Type Argument Default Description subSprite CB_GraphicSprites.SUBSPRITE_OBJECT Object with the desired sub-sprite. It will be stored inside the given sprite. sprite CB_GraphicSprites.SPRITE_OBJECT Object with the desired sprite. avoidUpdatingSubSpritesByZIndex boolean &lt;optional&gt; false If set to true, it will not call the {CB_GraphicSprites#updateSubSpritesByZIndex} method internally. Internal usage recommended only. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 932 Returns: Returns the CB_GraphicSprites.SUBSPRITE_OBJECT object which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). Type CB_GraphicSprites.SUBSPRITE_OBJECT insertSubSprites(subSprites [, sprite]) → {array} Adds the given sub-sprites to the desired sprite. Calls the CB_GraphicSprites#insertSubSprite and CB_GraphicSprites#updateSubSpritesByZIndex methods internally. Parameters: Name Type Argument Default Description subSprites array Numeric array with the desired sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects). They will be stored inside the given sprite. sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() Object with the desired sprite. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 790 Returns: Returns an array with the CB_GraphicSprites.SUBSPRITE_OBJECT objects which have been inserted (they could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited). Type array isDisabled() → {boolean} Tells whether the sprites group object (and the {@CB_GraphicSprites} object itself) is disabled or not. Internally, it checks the &quot;CB_GraphicSprites.spritesGroup.disabled&quot; property. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1521 Returns: Returns whether the sprites group object (and the CB_GraphicSprites object itself) is disabled or not. Type boolean isDisabledSprite( [sprite]) → {boolean} Tells whether the given sprite is disabled or not. Internally, it checks its &quot;disabled&quot; property and also the &quot;CB_GraphicSprites.spritesGroup.disabled&quot; property (calling the CB_GraphicSprites#isDisabled method internally). A sprite is considered disabled if its sprites group parent is also disabled. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1553 Returns: Returns whether the sprite is disabled or not. A sprite is considered disabled if its sprites group parent is also disabled. Type boolean isDisabledSubSprite(subSprite) → {boolean} Tells whether the given sub-sprite is disabled or not. Internally, it checks its &quot;disabled&quot; property and also whether its sprite parent is disabled (calling the CB_GraphicSprites#isDisabledSprite method internally, for its sprite parent). A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). Parameters: Name Type Description subSprite CB_GraphicSprites.SUBSPRITE_OBJECT The CB_GraphicSprites.SUBSPRITE_OBJECT object which contains the sub-sprite. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1602 Returns: Returns whether the sub-sprite is disabled or not. A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). Type boolean next() Alias for CB_GraphicSprites#setNext. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1397 See: CB_GraphicSprites#setNext now() Alias for CB_GraphicSprites#getCurrent. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1351 See: CB_GraphicSprites#getCurrent previous() Alias for CB_GraphicSprites#setPrevious. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1372 See: CB_GraphicSprites#setPrevious remove() Alias for CB_GraphicSprites#removeSprite. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 583 See: CB_GraphicSprites#removeSprite removeAll() Alias for CB_GraphicSprites#removeSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 464 See: CB_GraphicSprites#removeSprites removeById() Alias for CB_GraphicSprites#removeSpriteById. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 611 See: CB_GraphicSprites#removeSpriteById removeSprite( [index]) → {boolean} Removes a sprite by its index (its position in the CB_GraphicSprites#spritesGroup.sprites array). Calls the CB_GraphicSprites#updateSpritesByZIndex method internally. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the sprite is located (its position in the CB_GraphicSprites#spritesGroup.sprites array). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 594 Returns: Returns true if the sprite has been deleted or false otherwise. Type boolean removeSpriteById( [id]) → {boolean} Removes a sprite by its identifier. Calls the CB_GraphicSprites#updateSpritesByZIndex method internally. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the sprite. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 623 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns true if the sprite has been deleted or false otherwise. Type boolean removeSprites() Removes all the sprites by clearing the CB_GraphicSprites#spritesGroup property. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 483 removeSpritesAll() Alias for CB_GraphicSprites#removeSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 474 See: CB_GraphicSprites#removeSprites removeSpritesGroup() Alias for CB_GraphicSprites#removeSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 469 See: CB_GraphicSprites#removeSprites removeSubSprite( [index] [, sprite]) → {boolean} Removes a sub-sprite from a given sprite (CB_GraphicSprites.SPRITE_OBJECT object) by its index (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object). Calls the CB_GraphicSprites#updateSubSpritesByZIndex method internally. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the sub-sprite is located (its position in the array which is in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object). sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 847 Returns: Returns true if the sub-sprite has been deleted or false otherwise. Type boolean removeSubSpriteById( [id] [, sprite]) → {boolean} Removes a sub-sprite from a given sprite (CB_GraphicSprites.SPRITE_OBJECT object) by its identifier. Calls the CB_GraphicSprites#updateSubSpritesByZIndex method internally. Parameters: Name Type Argument Default Description id string | * &lt;optional&gt; The identifier of the sprite. sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent Object with the sprite whose sub-sprites we want to remove. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 891 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns true if the sub-sprite has been deleted or false otherwise. Type boolean removeSubSprites( [sprite]) → {boolean} Removes all the sub-sprites from a given sprite (CB_GraphicSprites.SPRITE_OBJECT object) by clearing its &quot;subSprites&quot; property (leaving an empty array). Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 764 Returns: Returns true if the sub-sprites have been deleted or false otherwise. Type boolean removeSubSpritesAll() Alias for CB_GraphicSprites#removeSubSprites. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 753 See: CB_GraphicSprites#removeSubSprites setCurrentPosition() Alias for CB_GraphicSprites#setPointer. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1309 See: CB_GraphicSprites#setPointer setDisabled( [disabled] [, affectChildren]) Sets whether the sprites group object (and the {@CB_GraphicSprites} object itself) is disabled or enabled. Internally, it edits the &quot;CB_GraphicSprites.spritesGroup.disabled&quot; property. Parameters: Name Type Argument Default Description disabled boolean &lt;optional&gt; false Set to true to disable it or false to enable it. affectChildren boolean &lt;optional&gt; disabled If this parameter is set to true, it will also modify the &quot;disabled&quot; property of all the sprites and their sub-sprites. By default, it is false if the &quot;disabled&quot; parameter is set to false or it is true otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1533 setDisabledSprite( [sprite] [, disabled] [, affectSubSprites] [, affectParent] [, affectParentChildren]) Sets a given sprite disabled or enabled. Internally, it edits its &quot;disabled&quot; property. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). disabled boolean &lt;optional&gt; false Set to true to disable it or false to enable it. affectSubSprites boolean &lt;optional&gt; disabled If this parameter is set to true, it will also modify the &quot;disabled&quot; property of all the sub-sprites of the given sprite. This parameter will be ignored if the &quot;affectParent&quot; parameter is set to true (as all existing sprites and sub-sprites in the CB_GraphicSprites object will be affected anyway). By default, it is false if the &quot;disabled&quot; parameter is set to false or it is true otherwise. affectParent boolean &lt;optional&gt; affectParentChildren|!disabled If this parameter is set to true, it will also modify the &quot;disabled&quot; property of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object). By default, it is true if either the &quot;affectParentChildren&quot; parameter is set to true or the &quot;disabled&quot; parameter is set to false and it is false otherwise. affectParentChildren boolean &lt;optional&gt; !disabled Defines whether to also affect the sprites and sub-sprites of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object) or not. If it is set to true and the &quot;affectParent&quot; is also set to true, it will also modify the &quot;disabled&quot; property of all the existing sprites and sub-sprites in the CB_GraphicSprites object. This parameter is ignored if the &quot;affectParent&quot; parameter is set to false. By default, it is false if the &quot;disabled&quot; parameter is set to true or it is false otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1569 setDisabledSubSprite(subSprite [, disabled] [, affectParents] [, affectParentsChildren]) Sets a given sub-sprite disabled or enabled. Internally, it edits its &quot;disabled&quot; property. Parameters: Name Type Argument Default Description subSprite CB_GraphicSprites.SUBSPRITE_OBJECT The CB_GraphicSprites.SUBSPRITE_OBJECT object which contains the sub-sprite. disabled boolean &lt;optional&gt; false Set to true to disable it or false to enable it. affectParents boolean &lt;optional&gt; affectParentsChildren|!disabled If this parameter is set to true, it will also modify the &quot;disabled&quot; property of the sprite parent and of the sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object). By default, it is true if either the &quot;affectParentChildren&quot; parameter is set to true or the &quot;disabled&quot; parameter is set to false and it is false otherwise. affectParentsChildren boolean &lt;optional&gt; !disabled Defines whether to also affect the sprites and sub-sprites of the sprite parent and its sprites group object (which is considered the status of the whole {@CB_GraphicSprites} object) or not. If it is set to true and the &quot;affectParents&quot; is also set to true, it will also modify the &quot;disabled&quot; property of all the existing sprites and sub-sprites in the CB_GraphicSprites object. This parameter is ignored if the &quot;affectParents&quot; parameter is set to false. By default, it is false if the &quot;disabled&quot; parameter is set to true or it is false otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1617 setNext( [loop]) → {CB_GraphicSprites.SPRITE_OBJECT|null} Makes the pointer to advance to the next position (if possible) and returns the sprite located there (if any). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will also update the CB_GraphicSprites#time property (setting the current time in milliseconds). Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; false If set to false and the next position is greater than the current number of sprites, it will return null. Otherwise, if set to true and the position is greater than the current number of sprites, it will modify the position making it cycle (from the end to the beginning). This parameter is ignored when the position has not reached the limit. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1408 Returns: Makes it to point to the next CB_GraphicSprites.SPRITE_OBJECT object (making it the current one) and returns it. Returns null if it cannot be found. Type CB_GraphicSprites.SPRITE_OBJECT | null setPointer( [position] [, loop]) → {integer} Sets the pointer to the desired position (if possible). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will also reset the CB_GraphicSprites#time property (setting the current time in milliseconds). Parameters: Name Type Argument Default Description position integer &lt;optional&gt; 0|CB_GraphicSprites#spritesGroup.sprites.length-1|position%CB_GraphicSprites#spritesGroup.sprites.length The position that we want the pointer to use. The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). loop boolean &lt;optional&gt; false If set to false and the &quot;position&quot; given is greater than the current number of sprites, the &quot;position&quot; used will be the one which belongs to the last sprite. If set to false and the &quot;position&quot; given is lower than zero, the &quot;position&quot; used will be zero (the first position). Otherwise, if set to true and the &quot;position&quot; given is greater than the current number of sprites or lower than zero, it will modify the given &quot;position&quot; making it cycle (from the end to the beginning) treating always the &quot;position&quot; as a positive number. This parameter is ignored when the given &quot;position&quot; has not reached the limit. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1321 Returns: Returns the position where the pointer is currently pointing to. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Type integer setPrevious( [loop]) → {CB_GraphicSprites.SPRITE_OBJECT|null} Makes the pointer to go back to the previous position (if possible) and returns the sprite located there (if any). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will update also the CB_GraphicSprites#time property (setting the current time in milliseconds). Parameters: Name Type Argument Default Description loop boolean &lt;optional&gt; false If set to false and the previous position is lower than zero, it will return null. Otherwise, if set to true and the position is lower than zero, it will modify the position making it cycle (from the beginning to the end). This parameter is ignored when the position has not reached the limit. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1383 Returns: Makes it to point to the previous CB_GraphicSprites.SPRITE_OBJECT object (making it the current one) and returns it. Returns null if it cannot be found. Type CB_GraphicSprites.SPRITE_OBJECT | null setPropertyCascade(propertyName [, value] [, onlyCurrent]) → {integer} Sets the desired value of a given property name to the CB_GraphicSprites.SPRITES_OBJECT object as well to its children elements (CB_GraphicSprites.SPRITE_OBJECT and CB_GraphicSprites.SUBSPRITE_OBJECT objects). Parameters: Name Type Argument Default Description propertyName number The name of the property we want to affect. value * &lt;optional&gt; The value desired for the given property. onlyCurrent boolean &lt;optional&gt; false If set to true, it will only affect the current sprite and its sub-sprites (and also the CB_GraphicSprites.SPRITES_OBJECT object). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1699 Returns: Returns the number of elements affected (counting the CB_GraphicSprites.SPRITES_OBJECT object). Type integer setTime( [time] [, updateTimeCurrentSprite] [, updateTimeCurrentSpriteSubSprites]) → {number} Sets (updates) the time in milliseconds when the current sprite or a sub-sprite started being pointed. Parameters: Name Type Argument Default Description time number &lt;optional&gt; CB_Device.getTiming() The time that we want to set, in milliseconds (time elapsed since the time origin which can be obtained calling the CB_Device.getTiming function). It must be a positive number (or zero). If not provided, it will use the current time (by calling the CB_Device.getTiming function internally). updateTimeCurrentSprite boolean &lt;optional&gt; false If set to true, it will also update the &quot;time&quot; property of the CB_GraphicSprites.SPRITE_OBJECT object which is currently pointed by the pointer (set in the CB_GraphicSprites#pointer property). updateTimeCurrentSpriteSubSprites boolean &lt;optional&gt; false If set to true and the &quot;updateTimeCurrentSprite&quot; is set to true, it will also update the &quot;time&quot; property of the CB_GraphicSprites.SUBSPRITE_OBJECT objects that belong to the sprite which is currently pointed by the pointer (set in the CB_GraphicSprites#pointer property). This parameter is ignored if the &quot;updateTimeCurrentSprite&quot; parameter is set to false. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1641 Returns: Returns the time in milliseconds when the current sprite or a sub-sprite started being pointed (time elapsed since the time origin which can be obtained calling the CB_Device.getTiming function). Type number setZIndex( [zIndex]) → {number} Sets the desired z-index (&quot;zIndex&quot; property) of the sprites group object (and the {@CB_GraphicSprites} object itself). If there is a CB_GraphicSpritesScene parent object (set in the CB_GraphicSprites.parent property), it will also call its CB_GraphicSpritesScene#updateGraphicSpritesByZIndex method internally. Parameters: Name Type Argument Default Description zIndex number &lt;optional&gt; parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||1 The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or 1 otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1436 Returns: Returns the z-index (&quot;zIndex&quot;) of the sprites group object (and the {@CB_GraphicSprites} object itself) after setting it (it could have been sanitized). Type number setZIndexSprite( [sprite] [, zIndex]) → {number} Sets the desired z-index (&quot;zIndex&quot;) of the given sprite object. Calls the CB_GraphicSprites#updateSpritesByZIndex method internally. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() The CB_GraphicSprites.SPRITE_OBJECT object which contains the sprite. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). zIndex number &lt;optional&gt; parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||1 The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or 1 otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1469 Returns: Returns the z-index (&quot;zIndex&quot;) of the given sprite after setting it (it could have been sanitized). Type number setZIndexSubSprite(sprite [, zIndex]) → {number} Sets the desired z-index (&quot;zIndex&quot;) of the given sub-sprite object. Calls the CB_GraphicSprites#updateSubSpritesByZIndex method internally. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SUBSPRITE_OBJECT The CB_GraphicSprites.SUBSPRITE_OBJECT object which contains the sub-sprite. zIndex number &lt;optional&gt; parseFloat(zIndex)||CB_GraphicSprites.ZINDEX_DEFAULT||0 The z-index value we want. It must be a number but never zero (0). If no valid number is given, it will use the value of the CB_GraphicSprites.ZINDEX_DEFAULT property of evaluates to true or 1 otherwise. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1503 Returns: Returns the z-index (&quot;zIndex&quot;) of the given sub-sprite after setting it (it could have been sanitized). Type number updateSpritesByZIndex() → {array} Updates (sorts again) the &quot;spritesByZIndex&quot; property (which is an array with the sprites ordered by z-index, whose data comes from the array in the &quot;sprites&quot; property of the CB_GraphicSprites#spritesGroup object) of the CB_GraphicSprites#spritesGroup object. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 560 Returns: Returns the &quot;spritesByZIndex&quot; array of the CB_GraphicSprites#spritesGroup object after updating it. Returns null if the property could not be obtained or updated. Type array updateSubSpritesByZIndex( [sprite]) → {array} Updates (sorts again) the &quot;subSpritesByZIndex&quot; property (which is an array with the sub-sprites ordered by z-index, whose data comes from the array in the &quot;subSprites&quot; property of the given CB_GraphicSprites.SPRITE_OBJECT object)) of the desired sprite. Parameters: Name Type Argument Default Description sprite CB_GraphicSprites.SPRITE_OBJECT &lt;optional&gt; CB_GraphicSprites#getCurrent() Object with the sprite whose sub-sprites we want to remove. If not provided, it will use the CB_GraphicSprites.SPRITE_OBJECT object which the pointer (set in the CB_GraphicSprites#pointer property) is currently pointing to (using the returning value of the CB_GraphicSprites#getCurrent method internally). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 817 Returns: Returns the &quot;subSpritesByZIndex&quot; array after updating it. Returns null if the property could not be obtained or updated. Type array Type Definitions filterProperties_propertiesToKeepObject_TYPE Object used to know what properties keep when calling the CB_GraphicSprites.filterProperties function (type used for its &quot;propertiesToKeepObject&quot; parameter). Its properties must have the name that matches the value returned by the &quot;type&quot; property of each element, being their value an array of strings with the name of the properties we want to keep. The property names which start with a &quot;&quot; symbol will not considered inherited from the element's parent and will always be copied. The other properties (which do not start with the &quot;&quot; symbol) will only be copied when the element contains a value which is different from the same property of its parent. Type: Object Properties: Name Type Argument Description spritesScene array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSpritesScene objects. If no provided, no properties will be kept for this kind of element. spritesGroups array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT objects. If no provided, no properties will be kept for this kind of element. sprites array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSprites objects. If no provided, no properties will be kept for this kind of element. spritesGroup array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSprites.SPRITES_OBJECT objects. If no provided, no properties will be kept for this kind of element. sprite array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSprites.SPRITE_OBJECT objects. If no provided, no properties will be kept for this kind of element. subSprite array &lt;optional&gt; Array of strings with the name of the properties to keep for the CB_GraphicSprites.SUBSPRITE_OBJECT objects. If no provided, no properties will be kept for this kind of element. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 1864 SPRITE_OBJECT An object with the information that belongs to a certain graphic sprite, being able to contain more than one source used by this graphic sprite (inside sub-sprites). Type: Object Properties: Name Type Argument Default Description id string | * &lt;optional&gt; 'CB_GraphicSprites.sprite_' + CB_GraphicSprites._idSpriteUnique++ Identifier of the sprite. It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). src * &lt;optional&gt; this.parent.src|&quot;&quot; Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. If not provided, as default it will use the value from the sprites group that it belongs to. srcType string &lt;optional&gt; this.parent.srcType|CB_GraphicSprites.SRC_TYPES.DEFAULT Type of the source of origin. If not provided, as default it will use the value from the sprites group that it belongs to. It should point to a property of the CB_GraphicSprites.SRC_TYPES object. You can use other values of the CB_GraphicSprites.SRC_TYPES object or create new ones. srcLeft number &lt;optional&gt; this.parent.srcLeft|CB_GraphicSprites.LEFT_SOURCE_DEFAULT Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. srcTop number &lt;optional&gt; this.parent.srcTop|CB_GraphicSprites.TOP_SOURCE_DEFAULT Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. srcWidth number &lt;optional&gt; this.parent.srcWidth|CB_GraphicSprites.WIDTH_SOURCE_DEFAULT Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. srcHeight number &lt;optional&gt; this.parent.srcHeight|CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. left number &lt;optional&gt; CB_GraphicSprites.LEFT_DEFAULT Left (horizontal) position in the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). top number &lt;optional&gt; CB_GraphicSprites.TOP_DEFAULT Top (vertical) position in the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). width number &lt;optional&gt; this.parent.width|CB_GraphicSprites.WIDTH_DEFAULT Width of the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. height number &lt;optional&gt; this.parent.height|CB_GraphicSprites.HEIGHT_DEFAULT Height of the destiny (inside the sprites group). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprites group that it belongs to. zIndex number &lt;optional&gt; this.parent.zIndex|CB_GraphicSprites.ZINDEX_DEFAULT The z-index for the destiny (inside the sprites group). Only numeric values which are not zero (0) are allowed. If not provided, as default it will use the value from the sprites group that it belongs to. To change the value of this property, use the &quot;setZIndex&quot; method of the sprite or the CB_GraphicSprites#setZIndexSprite method (which will call the CB_GraphicSpritesScene#updateSpritesByZIndex method internally). disabled boolean &lt;optional&gt; this.parent.disabled|false Tells whether this sprite is disabled or not. Regardless its value, it will be considered disabled if its sprites group parent is also disabled. If not provided, as default it will use the value from the sprites group that it belongs to. data object &lt;optional&gt; CB_combineJSON(this.parent.data, this.data)||this.parent.data||{ 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } } Object with any additional data desired which can be any kind. If not provided, missing properties as default will use the value from the sprites group that it belongs to. It will always have a &quot;that&quot; property pointing to the CB_GraphicSprites.SPRITE_OBJECT object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. subSprites array &lt;optional&gt; [] Numeric array containing CB_GraphicSprites.SUBSPRITE_OBJECT objects with the sub-sprites that this sprite uses. subSpritesByZIndex array Read-only property containing a numeric array of all the CB_GraphicSprites.SUBSPRITE_OBJECT objects of the sprite ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sub-sprite is set with its &quot;setZIndex&quot; method (or when calling the CB_GraphicSprites#setZIndexSubSprite method) or when inserting/removing sub-sprites through the CB_GraphicSprites#insertSubSprites, CB_GraphicSprites#insertSubSprite, CB_GraphicSprites#removeSubSprite or CB_GraphicSprites#removeSubSpriteById methods. byReference boolean &lt;optional&gt; false If set to true, when inserting the sprite, its &quot;subSprites&quot; property will use exactly the object given for that property (without making a copy) and the same sprite itself (CB_GraphicSprites.SPRITE_OBJECT object) will be inserted internally directly without making a copy of itself. parent CB_GraphicSprites.SPRITES_OBJECT Read-only property pointing to its parent (CB_GraphicSprites.SPRITES_OBJECT object). container CB_GraphicSprites Read-only property pointing to the CB_GraphicSprites object which contains it. isSprite boolean Read-only property which is always set to true to help identify this type of object. type 'sprite' Read-only property indicating the type of object (always &quot;sprite&quot;). position integer Read-only property indicating the position of this sprite in the array which is set the &quot;sprites&quot; property of the sprites group parent (CB_GraphicSprites.SPRITES_OBJECT object). positionByZIndex integer Read-only property indicating the position of this sprite in the array which is set the &quot;spritesByZIndex&quot; property of the sprites group parent (CB_GraphicSprites.SPRITES_OBJECT object). time integer Property which stores the time in milliseconds when the sprite was started being pointed for the last time (time elapsed since the time origin which was obtained calling the CB_Device.getTiming function internally). Note that it could being not pointed anymore. If it has never being pointed before, it will be set to 0. setTime function Read-only property which is a method that updates the &quot;time&quot; property of the sprite (calls CB_GraphicSprites#setTime internally and returns its returning value). With only one parameter which belongs to the &quot;time&quot; parameter of the CB_GraphicSprites#setTime method. getTime function Read-only property which is a method that returns the &quot;time&quot; property of the sprite (calls CB_GraphicSprites#getTime internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the CB_GraphicSprites#getTime method. getTimeElapsed function Read-only property which is a method that returns how many milliseconds elapsed since the sprite was or will be pointed (checking its &quot;time&quot; property), comparing with the time given in milliseconds (time elapsed since the time origin which can be obtained calling the CB_Device.getTiming function) or with the current one if none is given (calls CB_GraphicSprites#getTimeElapsed internally and returns its returning value). With only one parameter which belongs to the &quot;timeToCompare&quot; parameter of the CB_GraphicSprites#getTimeElapsed method. removeAll function Read-only property which is a method that removes all the internal sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects) from the sprite which are in the &quot;subSprites&quot; property (calls CB_GraphicSprites#removeSubSprites internally and returns its returning value). With no parameters. removeSubSprites function Alias for the &quot;removeAll&quot; method. insertSubSprites function Read-only property which is a method that inserts the given sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects) in the sprite, adding them to the &quot;subSprites&quot; property (calls CB_GraphicSprites#insertSubSprites internally and returns its returning value). With only one parameter which belongs to the &quot;subSprites&quot; parameter of the CB_GraphicSprites#insertSubSprites method. remove function Read-only property which is a method that removes an internal sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) by its index (position in the &quot;subSprites&quot; array) from the sprite, removing it from the &quot;subSprites&quot; property (calls CB_GraphicSprites#removeSubSprite internally and returns its returning value). With only one parameter which belongs to the &quot;index&quot; parameter of the CB_GraphicSprites#removeSubSprite method. removeById function Read-only property which is a method that removes an internal sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) by its identifier from the sprite, removing it from the &quot;subSprites&quot; property (calls CB_GraphicSprites#removeSubSpriteById internally and returns its returning value). With only one parameter which belongs to the &quot;id&quot; parameter of the CB_GraphicSprites#removeSubSpriteById method. insert function Read-only property which is a method that inserts a given sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) in the sprite, adding it to the &quot;subSprites&quot; property (calls CB_GraphicSprites#insertSubSprite internally and returns its returning value). With only one parameter which belongs to the &quot;subSprite&quot; parameter of the CB_GraphicSprites#insertSubSprite method. getAll function Read-only property which is a method that returns all the internal sub-sprites (CB_GraphicSprites.SUBSPRITE_OBJECT objects) in the sprite, getting them from the &quot;subSprites&quot; property (calls CB_GraphicSprites#getAll internally and returns its returning value). With two parameters (&quot;orderedByZIndex&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#getAll method. getSubSprites function Alias for the &quot;getAll&quot; method. get function Read-only property which is a method that returns a sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) by its index (position in the &quot;subSprites&quot; array) from the sprite, getting it from the &quot;subSprites&quot; property (calls CB_GraphicSprites#getSubSprite internally and returns its returning value). With two parameters (&quot;index&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#getSubSprite method. getById function Read-only property which is a method that returns a sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) by its identifier from the sprite, getting it from the &quot;subSprites&quot; property (calls CB_GraphicSprites#getSubSpriteById internally and returns its returning value). With two parameters (&quot;id&quot; and &quot;returnValueOnFail&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#getSubSpriteById method. getIndexById function Read-only property which is a method that returns the index (position in the &quot;subSprites&quot; array) of a sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT object) by its identifier (calls CB_GraphicSprites#getSubSpriteIndexById internally and returns its returning value). With only one parameter which belongs to the &quot;id&quot; parameter of the CB_GraphicSprites#getSubSpriteIndexById method. executeFunctionAll function Read-only property which is a method that executes the desired function for each sub-sprite (CB_GraphicSprites.SUBSPRITE_OBJECT objects which are in the &quot;subSprites&quot; property) in the sprite (calls CB_GraphicSprites#executeFunctionAllSubSprites internally and returns its returning value). With five parameters (&quot;functionEach&quot;, &quot;orderedByZIndex&quot;, &quot;delayBetweenEach&quot;, &quot;returnSetTimeoutsArray&quot;, &quot;delayBetweenEachAffectsFirst&quot; and &quot;functionFinish&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#executeFunctionAllSubSprites method. executeAll function Alias for the &quot;executeFunctionAll&quot; method. forEach function Alias for the &quot;executeFunctionAll&quot; method. getZIndex function Read-only property which is a method that returns the z-index (&quot;z-index&quot; property) of the sprite (calls CB_GraphicSprites#getZIndexSprite internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the CB_GraphicSprites#getZIndexSprite method. setZIndex function Read-only property which is a method to set the z-index (&quot;z-index&quot; property) of the sprite (calls CB_GraphicSprites#setZIndexSprite internally and returns its returning value). With only one parameter which belongs to the &quot;zIndex&quot; parameter of the CB_GraphicSprites#setZIndexSprite method. isDisabled function Read-only property which is a method that tells whether the sprite is disabled or not (calls CB_GraphicSprites#isDisabledSprite internally and returns its returning value). With no parameters. A sprite is considered disabled if its sprites group parent is also disabled. setDisabled function Read-only property which is a method to disable or enable the sprite (calls CB_GraphicSprites#setDisabledSprite internally and returns its returning value). With four parameters (&quot;disabled&quot;, &quot;affectSubSprites&quot;, &quot;affectParent&quot; and &quot;affectParentChildren&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#setDisabledSprite method. getPointer function Read-only property which is a method that gets the current position of the pointer. It belongs to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Internally, it uses the CB_GraphicSprites#pointer property. Calls CB_GraphicSprites#getPointer internally and returns its returning value. With no parameters. getCurrentPosition function Alias for the &quot;getPointer&quot; method. getPointerPrevious function Read-only property which is a method that gets the previous position of the pointer. Internally, it uses the CB_GraphicSprites#pointerPrevious property. Calls CB_GraphicSprites#getPointerPrevious internally and returns its returning value. With no parameters. getPreviousPosition function Alias for the &quot;getPointerPrevious&quot; method. setPointer function Read-only property which is a method that sets the pointer to the desired position (if possible). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite). Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will also reset the CB_GraphicSprites#time property (setting the current time in milliseconds). Calls CB_GraphicSprites#setPointer internally and returns the sprite (a CB_GraphicSprites.SPRITE_OBJECT object) which is being currently pointed (by the pointer set in the CB_GraphicSprites#pointer property). With two parameters (&quot;position&quot; and &quot;loop&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#setPointer method. setCurrentPosition function Alias for the &quot;setPointer&quot; method. getCurrent function Read-only property which is a method that gets the sprite (a CB_GraphicSprites.SPRITE_OBJECT object) which is being currently pointed (by the pointer set in the CB_GraphicSprites#pointer property). Calls CB_GraphicSprites#getCurrent internally and returns its returning value. With no parameters. current function Alias for the &quot;getCurrent&quot; method. now function Alias for the &quot;getCurrent&quot; method. getPrevious function Read-only property which is a method that gets the sprite which was previously pointed if any or returns null otherwise. It does not modify the CB_GraphicSprites#pointer property. Calls CB_GraphicSprites#getPrevious internally and returns its returning value. With no parameters. setPrevious function Read-only property which is a method that makes the pointer to go back to the previous position (if possible) and returns the sprite located there (if any). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will update also the CB_GraphicSprites#time property (setting the current time in milliseconds). Calls CB_GraphicSprites#setPrevious internally and returns its returning value. With only one parameter which belongs to the &quot;loop&quot; parameter of the CB_GraphicSprites#setPrevious method. previous function Alias for the &quot;setPrevious&quot; method. setNext function Read-only property which is a method that makes the pointer to advance to the next position (if possible) and returns the sprite located there (if any). The position should belong to an index of the CB_GraphicSprites#spritesGroup.sprites array where a CB_GraphicSprites.SPRITE_OBJECT object is placed (containing a sprite) and it will be returned if found. Internally, it modifies the CB_GraphicSprites#pointer property (if possible). If the position was updated, it will also update the CB_GraphicSprites#time property (setting the current time in milliseconds). Calls CB_GraphicSprites#setNext internally and returns its returning value. With only one parameter which belongs to the &quot;loop&quot; parameter of the CB_GraphicSprites#setNext method. next function Alias for the &quot;setNext&quot; method. setPropertyCascade function Read-only property which is a method that sets the desired value of a given property name to the sprite itself and all of its sub-sprites (if any). Calls CB_GraphicSprites#setPropertyCascade internally and returns its returning value. With two parameters (&quot;propertyName&quot; and &quot;value&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#setPropertyCascade method. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 60 Example { //'my_sprite_1': id: &quot;my_sprite_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, disabled: false, data: { datum_1 : &quot;value_1&quot;, datum_2 : 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] } SPRITES_OBJECT An object with the information that belongs to a group of graphic sprites. Type: Object Properties: Name Type Argument Default Description id string | * &lt;optional&gt; 'CB_GraphicSprites_' + CB_GraphicSprites._idUnique++ Identifier of the group of graphic sprites (also used as the CB_GraphicSprites.id property for the CB_GraphicSprites object). It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). src * &lt;optional&gt; &quot;&quot; Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. srcType string &lt;optional&gt; CB_GraphicSprites.SRC_TYPES.DEFAULT Type of the source of origin. It should point to a property of the CB_GraphicSprites.SRC_TYPES object. You can use other values of the CB_GraphicSprites.SRC_TYPES object or create new ones. srcLeft number &lt;optional&gt; CB_GraphicSprites.LEFT_SOURCE_DEFAULT Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.LEFT_SOURCE_DEFAULT. srcTop number &lt;optional&gt; CB_GraphicSprites.TOP_SOURCE_DEFAULT Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.TOP_SOURCE_DEFAULT. srcWidth number &lt;optional&gt; CB_GraphicSprites.WIDTH_SOURCE_DEFAULT Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.WIDTH_SOURCE_DEFAULT. srcHeight number &lt;optional&gt; CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT. left number &lt;optional&gt; CB_GraphicSprites.LEFT_DEFAULT Left (horizontal) position in the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.LEFT_DEFAULT. top number &lt;optional&gt; CB_GraphicSprites.TOP_DEFAULT Top (vertical) position in the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.TOP_DEFAULT. width number &lt;optional&gt; CB_GraphicSprites.WIDTH_DEFAULT Width of the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.WIDTH_DEFAULT. height number &lt;optional&gt; CB_GraphicSprites.HEIGHT_DEFAULT Height of the destiny. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from CB_GraphicSprites.HEIGHT_DEFAULT. zIndex number &lt;optional&gt; CB_GraphicSprites.ZINDEX_DEFAULT The z-index for the destiny (only numeric values which are not zero (0) are allowed). Also used as the CB_GraphicSprites.zIndex property for the CB_GraphicSprites object. If not provided, as default it will use the value from CB_GraphicSprites.ZINDEX_DEFAULT. To change the value of this property, use the CB_GraphicSprites#setZIndex method (which will call the CB_GraphicSpritesScene#updateGraphicSpritesByZIndex method internally if there is a CB_GraphicSpritesScene parent object). disabled boolean &lt;optional&gt; false Tells whether this sprites group (and the CB_GraphicSprites object itself) is disabled or not. If not provided, as default it will be false (which means it is enabled). data object &lt;optional&gt; { 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } } Object with any additional data desired which can be any kind. It will always have a &quot;that&quot; property pointing to the CB_GraphicSprites.SPRITES_OBJECT object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. sprites array &lt;optional&gt; [] Numeric array containing CB_GraphicSprites.SPRITE_OBJECT objects with all the sprites that will be used. Recommended at least to provide one CB_GraphicSprites.SPRITE_OBJECT object in the first index. spritesByZIndex array Read-only property containing a numeric array of all the CB_GraphicSprites.SPRITE_OBJECT objects ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sprite is set with its &quot;setZIndex&quot; method (or when calling the CB_GraphicSprites#setZIndexSprite method) or when inserting/removing sprites through the CB_GraphicSprites#insertSprites, CB_GraphicSprites#insertSprite, CB_GraphicSprites#removeSprite or CB_GraphicSprites#removeSpriteById methods. byReference_DEFAULT boolean &lt;optional&gt; false Default value to use as the &quot;byReference&quot; parameter for the constructor and for the CB_GraphicSprites#insertSprites method. If a boolean value is not provided, it will be parsed to boolean (resulting undefined to be false). parent * &lt;optional&gt; undefined|CB_GraphicSpritesScene Property pointing to or containing its parent (also used as the CB_GraphicSprites.parent property for the CB_GraphicSprites object). It could be a CB_GraphicSpritesScene object. container CB_GraphicSprites Read-only property pointing to the CB_GraphicSprites object which contains it. isSpritesGroup boolean Read-only property which is always set to true to help identify this type of object. type 'spritesGroup' Read-only property indicating the type of object (always &quot;spritesGroup&quot;). position integer &lt;optional&gt; Read-only property indicating the position of this CB_GraphicSprites object in the array which is set the &quot;items&quot; property inside the CB_GraphicSpritesScene#spritesGroups object which is in the CB_GraphicSpritesScene object parent (if any). positionByZIndex integer &lt;optional&gt; Read-only property indicating the position of this CB_GraphicSprites object in the array which is set the &quot;itemsByZIndex&quot; property inside the CB_GraphicSpritesScene#spritesGroups object which is in the CB_GraphicSpritesScene object parent (if any). Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 151 Example { //'my_sprites_1': id: &quot;my_sprites_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, sprites: [ //'my_sprite_1': { id: &quot;my_sprite_1&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_2': { id: &quot;my_sprite_2&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_3&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_4&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] } SUBSPRITE_OBJECT An object with the information that belongs to a sub-sprite (data which belongs to a certain source) used by a graphic sprite. Type: Object Properties: Name Type Argument Default Description id string | * &lt;optional&gt; 'CB_GraphicSprites.subSprite_' + CB_GraphicSprites._idSubSpriteUnique++ Identifier of the sub-sprite. It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). src * &lt;optional&gt; this.parent.src|&quot;&quot; Source of origin. Can be a path or identifier of an image, text, bitmap, 3D object, etc. They can be used for any kind of source you may think of, including (but not limited to) one sprites sheet or more, one atlas or more, etc. or even a mix of all of them. If not provided, as default it will use the value from the sprite that it belongs to. srcType string &lt;optional&gt; this.parent.srcType|CB_GraphicSprites.SRC_TYPES.DEFAULT Type of the source of origin. If not provided, as default it will use the value from the sprite that it belongs to. It should point to a property of the CB_GraphicSprites.SRC_TYPES object. You can use other values of the CB_GraphicSprites.SRC_TYPES object or create new ones. srcLeft number &lt;optional&gt; this.parent.srcLeft|CB_GraphicSprites.LEFT_SOURCE_DEFAULT Left (horizontal) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. srcTop number &lt;optional&gt; this.parent.srcTop|CB_GraphicSprites.TOP_SOURCE_DEFAULT Top (vertical) position in the original source (having in mind its real width and height). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. srcWidth number &lt;optional&gt; this.parent.srcWidth|CB_GraphicSprites.WIDTH_SOURCE_DEFAULT Width of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. srcHeight number &lt;optional&gt; this.parent.srcHeight|CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT Height of the original source. Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. left number &lt;optional&gt; CB_GraphicSprites.LEFT_DEFAULT Left (horizontal) position in the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). top number &lt;optional&gt; CB_GraphicSprites.TOP_DEFAULT Top (vertical) position in the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). width number &lt;optional&gt; this.parent.width|CB_GraphicSprites.WIDTH_DEFAULT Width of the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. height number &lt;optional&gt; this.parent.height|CB_GraphicSprites.HEIGHT_DEFAULT Height of the destiny (inside the sprite). Unit agnostic (only numeric values are allowed). If not provided, as default it will use the value from the sprite that it belongs to. zIndex number &lt;optional&gt; this.parent.zIndex|CB_GraphicSprites.ZINDEX_DEFAULT The z-index for the destiny (inside the sprite). Only numeric values which are not zero (0) are allowed. If not provided, as default it will use the value from the sprite that it belongs to. To change the value of this property, use the &quot;setZIndex&quot; method of the sub-sprite or the CB_GraphicSprites#setZIndexSubSprite method (which will call the CB_GraphicSpritesScene#updateSubSpritesByZIndex method internally). disabled boolean &lt;optional&gt; this.parent.disabled|false Tells whether this sub-sprite is disabled or not. Regardless its value, it will be considered disabled if its sprite parent is also disabled. If not provided, as default it will use the value from the sprite that it belongs to. data object &lt;optional&gt; CB_combineJSON(this.parent.data, this.data)||this.parent.data||{ 'that' : CB_GraphicSprites.SPRITES_OBJECT, 'getThis' = function() { return this.that; } } Object with any additional data desired which can be any kind. If not provided, missing properties as default will use the value from the sprite that it belongs to. It will always have a &quot;that&quot; property pointing to the CB_GraphicSprites.SUBSPRITE_OBJECT object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. byReference boolean &lt;optional&gt; false If set to true, when inserting the sub-sprite, the same sub-sprite itself (CB_GraphicSprites.SUBSPRITE_OBJECT object) will be inserted internally directly without making a copy of itself. parent CB_GraphicSprites.SPRITE_OBJECT Read-only property pointing to its parent (CB_GraphicSprites.SPRITE_OBJECT object). container CB_GraphicSprites Read-only property pointing to the CB_GraphicSprites object which contains it. isSubSprite boolean Read-only property which is always set to true to help identify this type of object. type 'subSprite' Read-only property indicating the type of object (always &quot;subSprite&quot;). position integer Read-only property indicating the position of this sub-sprite in the array which is set the &quot;subSprites&quot; property of the sprite parent (CB_GraphicSprites.SPRITE_OBJECT object). positionByZIndex integer Read-only property indicating the position of this sub-sprite in the array which is set the &quot;subSpritesByZIndex&quot; property of the sprite parent (CB_GraphicSprites.SPRITE_OBJECT object). time integer Property which stores the time in milliseconds when its parent sprite was started being pointed for the last time (time elapsed since the time origin which was obtained calling the CB_Device.getTiming function internally). Note that the parent could being not pointed anymore. If it has never being pointed before, it will be set to 0. It normally has the same value as the &quot;time&quot; property of its parent object but they can be modified independently. setTime function Read-only property which is a method that updates the &quot;time&quot; property of the sub-sprite (calls CB_GraphicSprites#setTime internally and returns its returning value). With only one parameter which belongs to the &quot;time&quot; parameter of the CB_GraphicSprites#setTime method. getTime function Read-only property which is a method that returns the &quot;time&quot; property of the sub-sprite (calls CB_GraphicSprites#getTime internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the CB_GraphicSprites#getTime method. If the &quot;time&quot; property of the sub-sprite is not found, it will use the &quot;time&quot; property from its sprite parent. getTimeElapsed function Read-only property which is a method that returns how many milliseconds elapsed since the sprite was or will be pointed (checking its &quot;time&quot; property), comparing with the time given in milliseconds (time elapsed since the time origin which can be obtained calling the CB_Device.getTiming function) or with the current one if none is given (calls CB_GraphicSprites#getTimeElapsed internally and returns its returning value). With only one parameter which belongs to the &quot;timeToCompare&quot; parameter of the CB_GraphicSprites#getTimeElapsed method. If the &quot;time&quot; property of the sub-sprite is not found, it will use the &quot;time&quot; property from its sprite parent. getZIndex function Read-only property which is a method that returns the z-index (&quot;z-index&quot; property) of the sub-sprite (calls CB_GraphicSprites#getZIndexSubSprite internally and returns its returning value). With only one parameter which belongs to the &quot;returnValueOnFail&quot; parameter of the CB_GraphicSprites#getZIndexSubSprite method. setZIndex function Read-only property which is a method to set the z-index (&quot;z-index&quot; property) of the sub-sprite (calls CB_GraphicSprites#setZIndexSubSprite internally and returns its returning value). With only one parameter which belongs to the &quot;zIndex&quot; parameter of the CB_GraphicSprites#setZIndexSubSprite method. isDisabled function Read-only property which is a method that tells whether the sub-sprite is disabled or not (calls CB_GraphicSprites#isDisabledSubSprite internally and returns its returning value). With no parameters. A sub-sprite is considered disabled if its sprite parent is disabled (a sprite is considered disabled if its sprites group parent is also disabled). setDisabled function Read-only property which is a method to disable or enable the sub-sprite (calls CB_GraphicSprites#setDisabledSubSprite internally and returns its returning value). With three parameters (&quot;disabled&quot;, &quot;affectParents&quot; and &quot;affectParentsChildren&quot;) which belong to the parameters with the same name of the CB_GraphicSprites#setDisabledSubSprite method. Source: CrossBase/audiovisual/image/CB_GraphicSprites.js, line 7 Example { id: &quot;my_subsprite_1&quot;, src: &quot;path/to/image.gif&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, zIndex: 1, disabled: false, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] } } × Search results Close "},"CB_GraphicSpritesScene.html":{"id":"CB_GraphicSpritesScene.html","title":"Class: CB_GraphicSpritesScene","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Class: CB_GraphicSpritesScene CB_GraphicSpritesScene Class to manage different groups of graphic sprites (2D or 3D). Internally, it manages CB_GraphicSprites objects. new CB_GraphicSpritesScene( [spritesGroups] [, byReference]) → {CB_GraphicSpritesScene} Class to manage different groups of graphic sprites (2D or 3D). Internally, it manages CB_GraphicSprites objects. Parameters: Name Type Argument Default Description spritesGroups CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT &lt;optional&gt; Object with the desired groups of sprites. The information will be used for the CB_GraphicSpritesScene#spritesGroups property. Used as the &quot;spritesGroups&quot; parameter when calling the CB_GraphicSpritesScene#insertSpritesGroups method internally. byReference boolean &lt;optional&gt; false This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal CB_GraphicSprites objects. If a boolean value is not provided, it will use the value of the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT property of the given CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object (parsed to boolean). Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 126 To Do: Think about a &quot;createCopy&quot; parameter on different the insert methods (to insert sprites groups/graphic sprites objects, etc.) so it will make a copy of the object to avoid using/modifying the original one. If the &quot;createCopy&quot; is set to false, it should always use the object as reference (using/modifying it). Think about a method to remove a sprite group object when the same sprite group is received by parameter. The same to remove a CB_GraphicSprites object, receiving a CB_GraphicSprites object by parameter. The same to remove the sprites groups object, receiving a sprites groups object by parameter. Only remove them if they match exactly. Think about a method to insert CB_GraphicSprites object directly. The same with a method that inserts many CB_GraphicSprites objects (receiving an array with them). Returns: Returns a new CB_GraphicSpritesScene object. Type CB_GraphicSpritesScene Members &lt;readonly&gt; id :string|* Identifier of the sprites groups object (the &quot;id&quot; property of the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT stored in the CB_GraphicSpritesScene#spritesGroups property) and the CB_GraphicSpritesScene object itself (same one). It should be unique. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). Type: string | * Default Value: 'CB_GraphicSpritesScene_' + CB_GraphicSpritesScene._idUnique++ Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 139 &lt;constant&gt; isSpritesScene :boolean Property which is always set to true to help identify this type of object. Type: boolean Default Value: true Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 172 &lt;readonly&gt; parent :* Property pointing to or containing its parent. It is the same as the &quot;parent&quot; property of the CB_GraphicSprites.SPRITES_GROUPS_OBJECT stored in the CB_GraphicSprites#spritesGroups property. Type: * Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 148 &lt;readonly&gt; spritesGroups :SPRITES_GROUPS_OBJECT Object containing all the internally-created CB_GraphicSprites objects and their information. Type: SPRITES_GROUPS_OBJECT Default Value: {} Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 158 &lt;constant&gt; type :string Indicates the type of object (always &quot;spritesScene&quot;). Type: string Default Value: spritesScene Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 181 Methods destructor() Destroys the graphic sprites scene object (removing all the sprites groups and the internal CB_GraphicSprites objects, etc.) and frees memory. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 200 executeAll() Alias for CB_GraphicSpritesScene#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 599 See: CB_GraphicSpritesScene#executeFunctionAll executeFunctionAll(functionEach [, orderedByZIndex] [, delayBetweenEach] [, graphicSpritesObjects] [, returnSetTimeoutsArray] [, delayBetweenEachAffectsFirst] [, functionFinish]) → {integer|array} Performs a desired action, using the provided function, on all the existing CB_GraphicSprites objects or on the desired ones (if provided). Calls the CB_Arrays.executeFunctionAll function internally and returns its returning value. Parameters: Name Type Argument Default Description functionEach CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK Function that will be called for each CB_GraphicSprites object. As the first parameter it receives the CB_GraphicSprites object of the &quot;graphicSpritesObjects&quot; being looped, as the second parameter the position of this CB_GraphicSprites object in the &quot;graphicSpritesObjects&quot; array provided (or, if not provided, in the array returned by the CB_GraphicSpritesScene#getGraphicSpritesAll method), the third parameter is the array being looped and the fourth parameter will be the &quot;delayBetweenEach&quot; being used, being &quot;this&quot; the CB_GraphicSprites object itself. orderedByZIndex boolean &lt;optional&gt; false If set to true, it will loop the CB_GraphicSprites sorted by their z-index (ascending order). delayBetweenEach number | CB_Arrays.executeFunctionAll_ON_LOOP_CALLBACK &lt;optional&gt; 0 If a value greater than zero is used, it will be used as the delay desired between each call to the &quot;functionEach&quot; function (calling them using the setTimeout function internally). If not provided or the value is 0 (zero) or lower, each call to the &quot;functionEach&quot; function will be performed immediately one after the other. If a function is provided, it will be called with the same parameters as the &quot;functionEach&quot; function and its returning value will be used as the delay (executed every loop for each CB_GraphicSprites object). graphicSpritesObjects array &lt;optional&gt; CB_GraphicSpritesScene#getGraphicSpritesAll() A numeric array containing the CB_GraphicSprites objects that we want to loop. It should contain only CB_GraphicSprites objects which are already in the current CB_GraphicSpritesScene object. If not provided, it will use all the CB_GraphicSprites objects contained in the CB_GraphicSpritesScene object. returnSetTimeoutsArray boolean &lt;optional&gt; false Defines whether we want the method to return an integer or a numeric array with information of each setTimeout call. Returning an array with information of each setTimeout call is only useful when the setTimeout function is called internally, which happens when the &quot;delayBetweenEach&quot; parameter is greater than 0 (zero). delayBetweenEachAffectsFirst boolean &lt;optional&gt; false If set to true, the desired delay (if any) will also affect the first call to the &quot;functionEach&quot; function. functionFinish CB_Arrays.executeFunctionAll_ON_FINISH_CALLBACK &lt;optional&gt; Function that will be called for when it has finished looping all the items. The first parameter will be the array which was looped, the second parameter will be the number of times that the &quot;functionEach&quot; callback was called (the most likely, matches the number of elements unless they are undefined or null), and the third parameter will be the maximum &quot;delay&quot; used, being &quot;this&quot; the array itself. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 627 To Do: Think about only allowing CB_GraphicSprites objects (in the &quot;graphicSpritesObjects&quot; parameter) which are already in the CB_GraphicSpritesScene (identify them by their ID), to avoid problems. Returns: If the &quot;returnSetTimeoutsArray&quot; parameter is set to false, it will return the number of calls to the &quot;functionEach&quot; function that were performed (which should be the same number as the CB_GraphicSprites objects given in the &quot;graphicSpritesObjects&quot; parameter). Otherwise, if the &quot;returnSetTimeoutsArray&quot; is set to true, it will return a numeric array with a CB_Arrays.executeFunctionAll_OBJECT object for each CB_GraphicSprites given. The length of this array will also be the number of calls to the &quot;functionEach&quot; function that were performed. Note that if a value greater than 0 (zero) for the &quot;delayBetweenEach&quot; parameter has been provided, perhaps not all calls of the &quot;functionEach&quot; function will have been performed yet when exiting this method because of the asynchronous nature of the setTimeout function. Type integer | array forEach() Alias for CB_GraphicSpritesScene#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 604 See: CB_GraphicSpritesScene#executeFunctionAll forEachGraphicSprites() Alias for CB_GraphicSpritesScene#executeFunctionAll. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 609 See: CB_GraphicSpritesScene#executeFunctionAll get() Alias for CB_GraphicSpritesScene#getGraphicSprites. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 533 See: CB_GraphicSpritesScene#getGraphicSprites getAll() Alias for CB_GraphicSpritesScene#getGraphicSpritesAll. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 504 See: CB_GraphicSpritesScene#getGraphicSpritesAll getById() Alias for CB_GraphicSpritesScene#getGraphicSpritesById. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 554 See: CB_GraphicSpritesScene#getGraphicSpritesById getCopy( [avoidCopyingPointers] [, avoidCopyingTimes] [, clearReferences] [, filterProperties] [, propertiesToKeepObject]) → {CB_GraphicSpritesScene} Gets a new copy of this object with the same attributes (all sub-objects will be a copy, they will not the same reference). Parameters: Name Type Argument Default Description avoidCopyingPointers boolean &lt;optional&gt; false If set to true, it will not copy the CB_GraphicSprites#pointer property of each CB_GraphicSprites object. avoidCopyingTimes boolean &lt;optional&gt; false If set to true, it will not copy neither the CB_GraphicSprites#time property of each CB_GraphicSprites object nor the &quot;time&quot; property of each of their sprites (CB_GraphicSprites.SPRITE_OBJECT objects). clearReferences boolean &lt;optional&gt; false If set to true, it will not copy neither the &quot;container&quot; nor the &quot;parent&quot; nor the &quot;data.that&quot; nor the &quot;data.getThis&quot; properties of any element. Useful to be able to stringify the object preventing the &quot;TypeError: cyclic object value&quot; error. When set to true, calls the CB_GraphicSprites.clearReferences function internally. If set to true and the &quot;filterProperties&quot; parameter is also set to true, the CB_GraphicSprites.filterProperties will always be called before calling the CB_GraphicSprites.clearReferences function. filterProperties boolean &lt;optional&gt; false If set to true, it will call the CB_GraphicSprites.filterProperties function internally to filter the properties that we do not want to keep (using the given &quot;propertiesToKeepObject&quot; as the parameter to call it). When set to true, calls the CB_GraphicSprites.filterProperties function internally. If set to true and the &quot;clearReferences&quot; parameter is also set to true, the CB_GraphicSprites.filterProperties will always be called before calling the CB_GraphicSprites.clearReferences function. propertiesToKeepObject CB_GraphicSprites.filterProperties_propertiesToKeepObject_TYPE &lt;optional&gt; CB_GraphicSprites.filterProperties_DEFAULT_PROPERTIES The object with the properties that we want to keep. Only used when the &quot;filterProperties&quot; parameter is set to true, as the &quot;propertiesToKeepObject&quot; when calling the CB_GraphicSprites.filterProperties function internally. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 664 Returns: Returns a copy of this object with the same attributes (all sub-objects will be a copy, not the same reference). Type CB_GraphicSpritesScene getGraphicSprites( [index] [, returnValueOnFail]) → {CB_GraphicSprites|*} Gets a desired CB_GraphicSprites object through its index (its position in the CB_GraphicSpritesScene#spritesGroups.items array). Faster than getting it through its identifier with the CB_GraphicSpritesScene#getGraphicSpritesById method. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the desired CB_GraphicSprites object must be located (its position in the CB_GraphicSpritesScene#spritesGroups.items array). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 545 Returns: Returns a CB_GraphicSprites object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites | * getGraphicSpritesAll( [orderedByZIndex] [, returnValueOnFail]) → {array|*} Gets all the sprites graphic objects (the &quot;items&quot; property of the internal CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object, if any). Parameters: Name Type Argument Default Description orderedByZIndex boolean &lt;optional&gt; false If set to true, it will return the CB_GraphicSprites objects sorted by their z-index (ascending order). returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 516 Returns: Returns an array with all the CB_GraphicSprites objects or the value of &quot;returnValueOnFail&quot; otherwise. Type array | * getGraphicSpritesById( [id] [, returnValueOnFail]) → {CB_GraphicSprites|*} Gets a desired CB_GraphicSprites object through its identifier. Slower than getting it through its index with the CB_GraphicSpritesScene#getGraphicSprites method. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the CB_GraphicSprites object that we want to get. returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 566 Returns: Returns a CB_GraphicSprites object if found or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSprites | * getGraphicSpritesIndexById( [id]) → {integer} Gets the index (the position in the CB_GraphicSpritesScene#spritesGroups.items array) of a desired CB_GraphicSprites object by its identifier. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the CB_GraphicSprites object whose index we want to get. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 585 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns the index (the position in the CB_GraphicSpritesScene#spritesGroups.items array) of the desired CB_GraphicSprites object or -1 if not found. Type integer getIndexById() Alias for CB_GraphicSpritesScene#getGraphicSpritesIndexById. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 573 See: CB_GraphicSpritesScene#getGraphicSpritesIndexById getSpritesGroups( [returnValueOnFail]) → {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT|*} Gets the sprites groups object (the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object which is in the CB_GraphicSpritesScene#spritesGroups property), if any. Parameters: Name Type Argument Description returnValueOnFail * &lt;optional&gt; The value we want it to return in the case that no value is found. If not provided, undefined will be returned. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 498 Returns: Returns the sprites groups object (the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object which is in the CB_GraphicSpritesScene#spritesGroups property), if any, or the value of &quot;returnValueOnFail&quot; otherwise. Type CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT | * getSpritesGroupsAll() Alias for CB_GraphicSpritesScene#getSpritesGroups. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 487 See: CB_GraphicSpritesScene#getSpritesGroups insert() Alias for CB_GraphicSpritesScene#insertSpritesGroup. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 396 See: CB_GraphicSpritesScene#insertSpritesGroup insertSpritesGroup( [spritesGroup] [, avoidUpdatingGraphicSpritesByZIndex] [, byReference]) → {CB_GraphicSpritesScene.insertSpritesGroup_OBJECT} Adds the desired group of graphic sprites. Creates internal CB_GraphicSprites objects. Parameters: Name Type Argument Default Description spritesGroup CB_GraphicSprites.SPRITES_OBJECT &lt;optional&gt; Object with the desired sprites group. It will be stored in the &quot;CB_GraphicSpritesScene#spritesGroups.spritesGroups&quot; property and the CB_GraphicSprites object created internally will be stored in the &quot;CB_GraphicSpritesScene#spritesGroups.items&quot; property. avoidUpdatingGraphicSpritesByZIndex boolean &lt;optional&gt; false If set to true, it will not call the {CB_GraphicSpritesScene#updateGraphicSpritesByZIndex} method internally. Internal usage recommended only. byReference boolean &lt;optional&gt; false This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal CB_GraphicSprites objects. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 409 Returns: Returns an object whose &quot;spritesGroup&quot; property contains the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited) and was used to create the internal CB_GraphicSprites object when calling its constructor and the &quot;item&quot; property contains the CB_GraphicSprites object created and inserted. Type CB_GraphicSpritesScene.insertSpritesGroup_OBJECT insertSpritesGroups( [spritesGroups] [, byReference]) → {CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT} Adds the desired groups of graphic sprites. Calls the CB_GraphicSpritesScene#insertSpritesGroup and CB_GraphicSpritesScene#updateGraphicSpritesByZIndex methods internally. Parameters: Name Type Argument Default Description spritesGroups CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT &lt;optional&gt; Object with the desired sprites groups. They will be stored in the &quot;CB_GraphicSpritesScene#spritesGroups.spritesGroups&quot; property and the CB_GraphicSprites objects created internally will be stored in the &quot;CB_GraphicSpritesScene#spritesGroups.items&quot; property. byReference boolean &lt;optional&gt; !!CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT This value will be used as the &quot;byReference&quot; parameter of the constructor when creating the new internal CB_GraphicSprites objects. If a boolean value is not provided, it will use the value of the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT.byReference_DEFAULT property of the given CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object (parsed to boolean). Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 237 Returns: Returns the CB_GraphicSpritesScene#spritesGroups property after updating it. Type CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT remove() Alias for CB_GraphicSpritesScene#removeSpritesGroup. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 322 See: CB_GraphicSpritesScene#removeSpritesGroup removeAll() Alias for CB_GraphicSpritesScene#removeSpritesGroups. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 210 See: CB_GraphicSpritesScene#removeSpritesGroups removeById() Alias for CB_GraphicSpritesScene#removeSpritesGroupById. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 354 See: CB_GraphicSpritesScene#removeSpritesGroupById removeGraphicSprites() Alias for CB_GraphicSpritesScene#removeSpritesGroup. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 327 See: CB_GraphicSpritesScene#removeSpritesGroup removeGraphicSpritesById() Alias for CB_GraphicSpritesScene#removeSpritesGroupById. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 359 See: CB_GraphicSpritesScene#removeSpritesGroupById removeSpritesGroup( [index]) → {boolean} Removes a sprites group and its CB_GraphicSprites object by its index (its position in the CB_GraphicSpritesScene#spritesGroups.items array). Calls the CB_GraphicSpritesScene#updateGraphicSpritesByZIndex method internally. Parameters: Name Type Argument Default Description index integer &lt;optional&gt; 0 The index where the CB_GraphicSprites object is located (its position in the CB_GraphicSpritesScene#spritesGroups.items array). Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 338 Returns: Returns true if the CB_GraphicSprites object has been deleted from the graphic sprites scene object or false otherwise. Type boolean removeSpritesGroupById( [id]) → {boolean} Removes a sprites group and its CB_GraphicSprites object by its identifier. Calls the CB_GraphicSpritesScene#updateGraphicSpritesByZIndex method internally. Parameters: Name Type Argument Description id string | * &lt;optional&gt; The identifier of the CB_GraphicSprites object. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 371 To Do: Optimize it (perhaps using a cache matching the IDs with their position, maybe using the &quot;position&quot; or &quot;positionByZIndex&quot; properties). Returns: Returns true if the CB_GraphicSprites object has been deleted from the graphic sprites scene object or false otherwise. Type boolean removeSpritesGroups() Removes all the sprites groups (and all the CB_GraphicSprites objects) by clearing the CB_GraphicSprites#spritesGroups property. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 224 removeSpritesGroupsAll() Alias for CB_GraphicSpritesScene#removeSpritesGroups. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 215 See: CB_GraphicSpritesScene#removeSpritesGroups setPropertyCascade(propertyName [, value] [, onlyCurrent]) → {integer} Sets the desired value of a given property name to the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object as well to its CB_GraphicSprites objects and their children (their CB_GraphicSprites.SPRITES_OBJECT object, including their CB_GraphicSprites.SPRITE_OBJECT and their CB_GraphicSprites.SUBSPRITE_OBJECT objects). Calls the CB_GraphicSprites#setPropertyCascade method internally. Parameters: Name Type Argument Default Description propertyName number The name of the property we want to affect. Also used as the &quot;propertyName&quot; parameter when calling the CB_GraphicSprites#setPropertyCascade method internally. value * &lt;optional&gt; The value desired for the given property. Also used as the &quot;value&quot; parameter when calling the CB_GraphicSprites#setPropertyCascade method internally. onlyCurrent boolean &lt;optional&gt; false If set to true, it will only affect the current sprite and its sub-sprites of each CB_GraphicSprites object (and also the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object and the CB_GraphicSprites.SPRITES_OBJECT object of each CB_GraphicSprites object). Used as the &quot;propertyName&quot; parameter when calling the CB_GraphicSprites#setPropertyCascade method internally. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 641 Returns: Returns the number of elements affected (counting the CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT object and the CB_GraphicSprites.SPRITES_OBJECT objects). Type integer updateGraphicSpritesByZIndex() → {array} Updates (sorts again) the &quot;itemsByZIndex&quot; property (which is an array with the CB_GraphicSprites objects ordered by z-index, whose data comes from the array in the &quot;items&quot; property of the CB_GraphicSpritesScene#spritesGroups object) of the CB_GraphicSpritesScene#spritesGroups object. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 299 Returns: Returns the &quot;itemsByZIndex&quot; array of the CB_GraphicSpritesScene#spritesGroups object after updating it. Returns null if the property could not be obtained or updated. Type array updateItemsByZIndex() Alias for CB_GraphicSpritesScene#updateGraphicSpritesByZIndex. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 289 See: CB_GraphicSpritesScene#updateGraphicSpritesByZIndex Type Definitions insertSpritesGroup_OBJECT Object used as the returning value of the CB_GraphicSpritesScene#insertSpritesGroup method. Type: Object Properties: Name Type Description spritesGroup CB_GraphicSprites.SPRITES_OBJECT The CB_GraphicSpritesScene.SPRITES_GROUPS_OBJECT which has been inserted (it could have been modified/sanitized from the given one and some missing properties or those which were wrong could have been inherited) and was used to create the internal CB_GraphicSprites object when calling its constructor. item CB_GraphicSprites The CB_GraphicSprites object created and inserted from the CB_GraphicSprites.SPRITES_OBJECT. Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 388 SPRITES_GROUPS_OBJECT An object with the information that belongs to a group of graphic sprites. Type: Object Properties: Name Type Argument Default Description id string | * &lt;optional&gt; 'CB_GraphicSpritesScene_' + CB_GraphicSpritesScene._idUnique++ Identifier of the sprites groups object and also for the graphic sprites scene (also used as the CB_GraphicSprites.id property for the CB_GraphicSpritesScene object). It should be unique. Recommended. It must be a value which evaluates to true. By default, it is generated automatically (with an internal counter). src * &lt;optional&gt; &quot;&quot; The value for the &quot;src&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. srcType string &lt;optional&gt; CB_GraphicSprites.SRC_TYPES.DEFAULT The value for the &quot;srcType&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. It should point to a property of the CB_GraphicSprites.SRC_TYPES object. You can use other values of the CB_GraphicSprites.SRC_TYPES object or create new ones. srcLeft number &lt;optional&gt; CB_GraphicSprites.LEFT_SOURCE_DEFAULT The value for the &quot;srcLeft&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. srcTop number &lt;optional&gt; CB_GraphicSprites.TOP_SOURCE_DEFAULT The value for the &quot;srcTop&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. srcWidth number &lt;optional&gt; CB_GraphicSprites.WIDTH_SOURCE_DEFAULT The value for the &quot;srcWidth&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. srcHeight number &lt;optional&gt; CB_GraphicSprites.HEIGHT_SOURCE_DEFAULT The value for the &quot;srcHeight&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. left number &lt;optional&gt; CB_GraphicSprites.LEFT_DEFAULT The value for the &quot;left&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. top number &lt;optional&gt; CB_GraphicSprites.TOP_DEFAULT The value for the &quot;top&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. width number &lt;optional&gt; CB_GraphicSprites.WIDTH_DEFAULT The value for the &quot;width&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. height number &lt;optional&gt; CB_GraphicSprites.HEIGHT_DEFAULT The value for the &quot;height&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. zIndex number &lt;optional&gt; CB_GraphicSprites.ZINDEX_DEFAULT The value for the &quot;zIndex&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. disabled boolean &lt;optional&gt; false The value for the &quot;disabled&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. data object &lt;optional&gt; { 'that' : CB_GraphicSprites.SPRITES_GROUPS_OBJECT, 'getThis' = function() { return this.that; } } Object with any additional data desired which can be any kind. It will always have a &quot;that&quot; property pointing to the CB_GraphicSprites.SPRITES_GROUPS_OBJECT object where it belongs to and a function in its &quot;getThis&quot; property returning the same value (added automatically). These properties (&quot;that&quot; and &quot;getThis&quot;) cannot be overridden. The value given will also be used for the &quot;data&quot; property which will be used as default if not provided (or the provided one was wrong) in the given CB_GraphicSprites.SPRITES_OBJECT objects (in the &quot;spritesGroups&quot; property), when creating the internal CB_GraphicSprites objects. spritesGroups array &lt;optional&gt; [] Numeric array containing CB_GraphicSprites.SPRITES_OBJECT objects with all the sprites groups that are useful for creating the internal CB_GraphicSprites objects. Recommended at least to provide one CB_GraphicSprites.SPRITES_OBJECT object in the first index. parent * &lt;optional&gt; Property pointing to or containing its parent (also used as the CB_GraphicSpritesScene.parent property for the CB_GraphicSpritesScene object). items array Read-only numeric array containing CB_GraphicSprites objects created internally. Their &quot;parent&quot; property will be set to point the current CB_GraphicSpritesScene object which contains them. itemsByZIndex array Read-only property containing a numeric array of all the CB_GraphicSprites objects ordered by their z-index (&quot;zIndex&quot; property). It is updated automatically when the z-index of a sprite is set with its CB_GraphicSprites#setZIndex method or when inserting/removing CB_GraphicSprites objects through the CB_GraphicSpritesScene#insertSpritesGroups, CB_GraphicSpritesScene#insertSpritesGroup, CB_GraphicSpritesScene#removeSpritesGroup or CB_GraphicSpritesScene#removeSpritesGroupById methods. byReference_DEFAULT boolean &lt;optional&gt; false Default value to use as the &quot;byReference&quot; parameter for the constructor and for the CB_GraphicSpritesScene#insertSpritesGroups method. If a boolean value is not provided, it will be parsed to boolean (resulting undefined to be false). container CB_GraphicSpritesScene Read-only property pointing to the CB_GraphicSpritesScene object which contains it. isSpritesGroups boolean Read-only property which is always set to true to help identify this type of object. type 'spritesGroups' Read-only property indicating the type of object (always &quot;spritesGroups&quot;). Source: CrossBase/audiovisual/image/CB_GraphicSpritesScene.js, line 7 Example { //'my_sprites_scene_1': id: &quot;my_sprites_scene_1&quot;, srcType: CB_GraphicSprites.SRC_TYPES.IMAGE, srcLeft: 10, srcTop: 20, srcWidth: 64, srcHeight: 32, left: 10, top: 20, width: 64, height: 32, data: { datum_1: &quot;value_1&quot;, datum_2: 2, datum_3: [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] }, //Sprites groups: spritesGroups: [ //'my_sprites_1': { id: &quot;my_sprites_1&quot;, src: &quot;path/to/image.gif&quot;, sprites: [ //'my_sprite_1': { id: &quot;my_sprite_1&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_1&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_2&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_2': { id: &quot;my_sprite_2&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_3&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_4&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] }, //'my_sprites_2': { id: &quot;my_sprites_2&quot;, src: &quot;path/to/image2.gif&quot;, sprites: [ //'my_sprite_3': { id: &quot;my_sprite_3&quot;, subSprites: [ //'my_subsprite_1': { id: &quot;my_subsprite_5&quot;, srcLeft: 10, srcTop: 20, zIndex: 1 }, //'my_subsprite_2': { id: &quot;my_subsprite_6&quot;, srcLeft: 20, srcTop: 40, zIndex: 2 } ] }, //'my_sprite_4': { id: &quot;my_sprite_4&quot;, subSprites: [ //'my_subsprite_3': { id: &quot;my_subsprite_7&quot;, srcLeft: 30, srcTop: 60, zIndex: 1 }, //'my_subsprite_4': { id: &quot;my_subsprite_8&quot;, srcLeft: 40, srcTop: 80, zIndex: 2 } ] } ] } ] } × Search results Close "},"CB_Keyboard.html":{"id":"CB_Keyboard.html","title":"Namespace: CB_Keyboard","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Keyboard CB_Keyboard Static class to manage the keyboard and other input devices that generate key codes. It will return itself if it is tried to be instantiated. Source: CrossBase/input/CB_Keyboard.js, line 10 Namespaces chars extended keys Members &lt;static, readonly&gt; keysDown :Object Object that will store the status for each key detected, using the key code as index and a boolean as their value (true when down or false when released). Type: Object Default Value: {} Source: CrossBase/input/CB_Keyboard.js, line 25 &lt;static, readonly&gt; keysPressed :array Array with the codes of the keys pressed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setKeysPressedExpiration function). Type: array Default Value: [] Source: CrossBase/input/CB_Keyboard.js, line 35 &lt;static, readonly&gt; typedString :string Stores the string typed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setTypedStringExpiration function). Type: string Source: CrossBase/input/CB_Keyboard.js, line 57 &lt;static, readonly&gt; typedStringCodes :array Array with the codes of the string typed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setTypedStringExpiration function). Type: array Default Value: [] Source: CrossBase/input/CB_Keyboard.js, line 47 Methods &lt;static&gt; clearKeysDown(keepPressed) Clears (empties totally or partially) the CB_Keyboard.keysDown object which contains the detected keys pressed or released. Parameters: Name Type Description keepPressed boolean If set to true, it will keep the pressed keys. Source: CrossBase/input/CB_Keyboard.js, line 3206 &lt;static&gt; clearKeysPressed(keepPressed) Clears (empties totally or partially) the CB_Keyboard.keysPressed array which contains the key codes pressed recently. Parameters: Name Type Description keepPressed boolean If set to true, it will keep the pressed keys (taken from the CB_Keyboard.keysDown object). Source: CrossBase/input/CB_Keyboard.js, line 3314 &lt;static&gt; clearTypedString(keepPressed) Clears (empties totally or partially) the CB_Keyboard.typedString string and the CB_Keyboard.typedStringCodes array. Parameters: Name Type Description keepPressed boolean If set to true, it will keep the values belonging to the currently-pressed keys (taken from the CB_Keyboard.keysDown object). Source: CrossBase/input/CB_Keyboard.js, line 3433 &lt;static&gt; getKeyCode(e [, avoidNormalize]) → {integer} Returns the key code that is contained in the given keyboard event. Parameters: Name Type Argument Default Description e Event Keyboard event object. avoidNormalize boolean &lt;optional&gt; false If it is not set to true, it will call the CB_Events.normalize function internally before. Source: CrossBase/input/CB_Keyboard.js, line 3158 To Do: Have in mind that keyCode is deprecated. Returns: Returns the key code. Type integer &lt;static&gt; getKeysDown() → {Object} Returns the CB_Keyboard.keysDown object which contains the detected keys pressed or released. Source: CrossBase/input/CB_Keyboard.js, line 3226 Returns: Returns the CB_Keyboard.keysDown object. Type Object &lt;static&gt; getKeysPressed() → {array} Returns the CB_Keyboard.keysPressed array which contains the key codes pressed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setKeysPressedExpiration function). Source: CrossBase/input/CB_Keyboard.js, line 3337 Returns: Returns the CB_Keyboard.keysPressed array. Type array &lt;static&gt; getKeysPressedExpiration() → {integer} Returns the milliseconds after which the CB_Keyboard.keysPressed array is always cleared (emptied). The time always starts counting from zero again when a key is pressed (onKeyDown event is fired). To define this amount of time, the CB_Keyboard.setKeysPressedExpiration method must be used. Source: CrossBase/input/CB_Keyboard.js, line 3367 Returns: Returns the milliseconds of expiration defined for the CB_Keyboard.keysPressed array. Type integer &lt;static&gt; getTypedString() → {string} Returns the CB_Keyboard.typedString string which contains the string typed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setTypedStringExpiration function). Source: CrossBase/input/CB_Keyboard.js, line 3484 Returns: Returns the CB_Keyboard.typedString string. Type string &lt;static&gt; getTypedStringCodes() → {array} Returns the CB_Keyboard.typedStringCodes array which contains the key codes pressed that belongs to the string typed recently (it will be cleared after the chosen milliseconds set with the CB_Keyboard.setTypedStringExpiration function). Source: CrossBase/input/CB_Keyboard.js, line 3495 Returns: Returns the CB_Keyboard.typedStringCodes array. Type array &lt;static&gt; getTypedStringExpiration() → {integer} Returns the milliseconds after which the CB_Keyboard.typedString string and the CB_Keyboard.typedStringCodes array are always cleared (emptied). The time always starts counting from zero again when a key is pressed (onKeyPress event is fired). To define this amount of time, the CB_Keyboard.setTypedStringExpiration method must be used. Source: CrossBase/input/CB_Keyboard.js, line 3525 Returns: Returns the milliseconds of expiration defined for the CB_Keyboard.typedString string and the CB_Keyboard.typedStringCodes array. Type integer &lt;static&gt; isKeyDown(keyCodes [, allPressed]) → {boolean} Returns whether the given key codes are being pressed (any of them or all at the same time, depending on the &quot;allPressed&quot; parameter). Parameters: Name Type Argument Default Description keyCodes integer | array | Object An integer with the key code or a numeric array with the key codes that we want to check. It can also be an array of arrays, being each element a numeric array with the key codes that we want to check. Although not recommended (for performance purposes), this parameter can also support an object whose indexes are the keycodes (it will be converted to a numeric array internally). allPressed boolean &lt;optional&gt; false If set true, the function will only return true in the case that all given key codes are currently being pressed. Otherwise, if set to false, the function will return true in the case that any of the given key codes is currently being pressed. When the &quot;keyCodes&quot; is an array of arrays with key codes, it will be considered that all keys are being pressed if each single array (all of them) has at least one of its key codes pressed. Source: CrossBase/input/CB_Keyboard.js, line 3239 Returns: If &quot;allPressed&quot; parameter is set to true, returns true in the case that all given key codes are currently being pressed. If &quot;allPressed&quot; parameter is set to false, returns true in the case that any of the given key codes is currently being pressed. In all other cases, it returns false. Type boolean &lt;static&gt; normalizeEvent(e) → {Event} Tries to return the given keyboard event with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the CB_Events.normalize function internally. Some properties added or affected could be keyCode, location, ctrlKey, altKey, shiftKey, etc. Parameters: Name Type Description e Event Keyboard event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). Source: CrossBase/input/CB_Keyboard.js, line 3108 To Do: Calculate (if possible) the values for location, ctrlKey, altKey, etc. when added, to simulate the expected behaviour. Returns: Returns the keyboard event object normalized. Type Event &lt;static&gt; onKeyDown(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a key is down (onKeyDown event) or removes it. Parameters: Name Type Argument Default Description callbackFunction CB_Keyboard.EVENT_CALLBACK | null The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the CB_Keyboard.normalizeEvent function) and the second one will be the key code associated. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Keyboard.js, line 3600 &lt;static&gt; onKeyPress(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a key is pressed (onKeyPress event) or removes it. Parameters: Name Type Argument Default Description callbackFunction CB_Keyboard.EVENT_CALLBACK | null The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the CB_Keyboard.normalizeEvent function) and the second one will be the key code associated. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Keyboard.js, line 3586 &lt;static&gt; onKeyUp(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a key is released (onKeyUp event) or removes it. Parameters: Name Type Argument Default Description callbackFunction CB_Keyboard.EVENT_CALLBACK | null The function (event listener) that we want to execute when the event is fired. The first parameter received for this function will be the event object (already normalized by the CB_Keyboard.normalizeEvent function) and the second one will be the key code associated. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Keyboard.js, line 3614 &lt;static&gt; preventF11Key(e) Tries to prevent the default behaviour that would produce the &quot;F11&quot; key of a given keyboard event when the client is compatible with the HTML5 Fullscreen API and uses it to toggle (enable or disable) the fullscreen mode. It calls the CB_Keyboard.normalizeEvent function internally. Parameters: Name Type Description e Event Keyboard event object. Source: CrossBase/input/CB_Keyboard.js, line 3536 &lt;static&gt; setKeysPressedExpiration(keysPressedExpiration) → {boolean} Sets the milliseconds after which the CB_Keyboard.keysPressed array is always cleared (emptied). The time always starts counting from zero when a key is pressed (onKeyDown event is fired). Parameters: Name Type Description keysPressedExpiration integer An integer greater than 0 (zero) representing the milliseconds after which we desire that the CB_Keyboard.keysPressed array is cleared (emptied), if no key is pressed during this time. Source: CrossBase/input/CB_Keyboard.js, line 3349 Returns: Returns true if the given time could be applied or false otherwise. Type boolean &lt;static&gt; setTypedStringExpiration(keysPressedExpiration) → {boolean} Sets the milliseconds after which the CB_Keyboard.typedString string and the CB_Keyboard.typedStringCodes array are always cleared (emptied). The time always starts counting from zero when a key is pressed (onKeyPress event is fired). Parameters: Name Type Description keysPressedExpiration integer An integer greater than 0 (zero) representing the milliseconds after which we desire that the CB_Keyboard.typedString string and the CB_Keyboard.typedStringCodes array are cleared (emptied), if no key is pressed during this time. Source: CrossBase/input/CB_Keyboard.js, line 3507 Returns: Returns true if the given time could be applied or false otherwise. Type boolean Type Definitions EVENT_CALLBACK(e, keyCode) Callback that is called before loading a file and should return true if we want to load the file or false otherwise. Parameters: Name Type Description e Event Keyboard event object. keyCode integer Key code which fired the event. Source: CrossBase/input/CB_Keyboard.js, line 3569 × Search results Close "},"CB_Keyboard.chars.html":{"id":"CB_Keyboard.chars.html","title":"Namespace: chars","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: chars CB_Keyboard. chars Object whose properties are aliases for char codes (each property can contain an array with one or more integers which belong to the char codes). Source: CrossBase/input/CB_Keyboard.js, line 2560 Members &lt;static&gt; 0 :array The &quot;0&quot; (zero) character. Type: array Default Value: [48] Source: CrossBase/input/CB_Keyboard.js, line 2567 &lt;static&gt; 1 :array The &quot;1&quot; character. Type: array Default Value: [49] Source: CrossBase/input/CB_Keyboard.js, line 2574 &lt;static&gt; 2 :array The &quot;2&quot; character. Type: array Default Value: [50] Source: CrossBase/input/CB_Keyboard.js, line 2581 &lt;static&gt; 3 :array The &quot;3&quot; character. Type: array Default Value: [51] Source: CrossBase/input/CB_Keyboard.js, line 2588 &lt;static&gt; 4 :array The &quot;4&quot; character. Type: array Default Value: [52] Source: CrossBase/input/CB_Keyboard.js, line 2595 &lt;static&gt; 5 :array The &quot;5&quot; character. Type: array Default Value: [53] Source: CrossBase/input/CB_Keyboard.js, line 2602 &lt;static&gt; 6 :array The &quot;6&quot; character. Type: array Default Value: [54] Source: CrossBase/input/CB_Keyboard.js, line 2609 &lt;static&gt; 7 :array The &quot;7&quot; character. Type: array Default Value: [55] Source: CrossBase/input/CB_Keyboard.js, line 2616 &lt;static&gt; 8 :array The &quot;8&quot; character. Type: array Default Value: [56] Source: CrossBase/input/CB_Keyboard.js, line 2623 &lt;static&gt; 9 :array The &quot;9&quot; character. Type: array Default Value: [57] Source: CrossBase/input/CB_Keyboard.js, line 2630 &lt;static&gt; a :array The &quot;a&quot; letter, lower case. Type: array Default Value: [97] Source: CrossBase/input/CB_Keyboard.js, line 2686 &lt;static&gt; A :array The &quot;A&quot; letter, upper case (capitalized). Type: array Default Value: [65] Source: CrossBase/input/CB_Keyboard.js, line 2679 &lt;static&gt; ASTERISK :array The &quot;*&quot; (asterisk) character. Type: array Default Value: [42] Source: CrossBase/input/CB_Keyboard.js, line 2651 &lt;static&gt; b :array The &quot;b&quot; letter, lower case. Type: array Default Value: [98] Source: CrossBase/input/CB_Keyboard.js, line 2700 &lt;static&gt; B :array The &quot;B&quot; letter, upper case (capitalized). Type: array Default Value: [66] Source: CrossBase/input/CB_Keyboard.js, line 2693 &lt;static&gt; c :array The &quot;c&quot; letter, lower case. Type: array Default Value: [99] Source: CrossBase/input/CB_Keyboard.js, line 2714 &lt;static&gt; C :array The &quot;C&quot; letter, upper case (capitalized). Type: array Default Value: [67] Source: CrossBase/input/CB_Keyboard.js, line 2707 &lt;static&gt; COMMA :array The &quot;,&quot; (comma) character. Type: array Default Value: [44] Source: CrossBase/input/CB_Keyboard.js, line 2672 &lt;static&gt; d :array The &quot;d&quot; letter, lower case. Type: array Default Value: [100] Source: CrossBase/input/CB_Keyboard.js, line 2728 &lt;static&gt; D :array The &quot;D&quot; letter, upper case (capitalized). Type: array Default Value: [68] Source: CrossBase/input/CB_Keyboard.js, line 2721 &lt;static&gt; DOT :array The &quot;.&quot; (dot) character. Type: array Default Value: [46] Source: CrossBase/input/CB_Keyboard.js, line 2665 &lt;static&gt; E :array The &quot;E&quot; letter, upper case (capitalized). Type: array Default Value: [69] Source: CrossBase/input/CB_Keyboard.js, line 2735 &lt;static&gt; e :array The &quot;e&quot; letter, lower case. Type: array Default Value: [101] Source: CrossBase/input/CB_Keyboard.js, line 2742 &lt;static&gt; f :array The &quot;f&quot; letter, lower case. Type: array Default Value: [102] Source: CrossBase/input/CB_Keyboard.js, line 2756 &lt;static&gt; F :array The &quot;F&quot; letter, upper case (capitalized). Type: array Default Value: [70] Source: CrossBase/input/CB_Keyboard.js, line 2749 &lt;static&gt; G :array The &quot;G&quot; letter, upper case (capitalized). Type: array Default Value: [71] Source: CrossBase/input/CB_Keyboard.js, line 2763 &lt;static&gt; g :array The &quot;g&quot; letter, lower case. Type: array Default Value: [103] Source: CrossBase/input/CB_Keyboard.js, line 2770 &lt;static&gt; H :array The &quot;H&quot; letter, upper case (capitalized). Type: array Default Value: [72] Source: CrossBase/input/CB_Keyboard.js, line 2777 &lt;static&gt; h :array The &quot;h&quot; letter, lower case. Type: array Default Value: [104] Source: CrossBase/input/CB_Keyboard.js, line 2784 &lt;static&gt; i :array The &quot;i&quot; letter, lower case. Type: array Default Value: [105] Source: CrossBase/input/CB_Keyboard.js, line 2798 &lt;static&gt; I :array The &quot;I&quot; letter, upper case (capitalized). Type: array Default Value: [73] Source: CrossBase/input/CB_Keyboard.js, line 2791 &lt;static&gt; J :array The &quot;J&quot; letter, upper case (capitalized). Type: array Default Value: [74] Source: CrossBase/input/CB_Keyboard.js, line 2805 &lt;static&gt; j :array The &quot;j&quot; letter, lower case. Type: array Default Value: [106] Source: CrossBase/input/CB_Keyboard.js, line 2812 &lt;static&gt; k :array The &quot;k&quot; letter, lower case. Type: array Default Value: [107] Source: CrossBase/input/CB_Keyboard.js, line 2826 &lt;static&gt; K :array The &quot;K&quot; letter, upper case (capitalized). Type: array Default Value: [75] Source: CrossBase/input/CB_Keyboard.js, line 2819 &lt;static&gt; L :array The &quot;L&quot; letter, upper case (capitalized). Type: array Default Value: [76] Source: CrossBase/input/CB_Keyboard.js, line 2833 &lt;static&gt; l :array The &quot;l&quot; letter, lower case. Type: array Default Value: [108] Source: CrossBase/input/CB_Keyboard.js, line 2840 &lt;static&gt; M :array The &quot;M&quot; letter, upper case (capitalized). Type: array Default Value: [77] Source: CrossBase/input/CB_Keyboard.js, line 2847 &lt;static&gt; m :array The &quot;m&quot; letter, lower case. Type: array Default Value: [109] Source: CrossBase/input/CB_Keyboard.js, line 2854 &lt;static&gt; MINUS :array The &quot;-&quot; (minus) character. Type: array Default Value: [45] Source: CrossBase/input/CB_Keyboard.js, line 2644 &lt;static&gt; N :array The &quot;N&quot; letter, upper case (capitalized). Type: array Default Value: [78] Source: CrossBase/input/CB_Keyboard.js, line 2861 &lt;static&gt; n :array The &quot;n&quot; letter, lower case. Type: array Default Value: [110] Source: CrossBase/input/CB_Keyboard.js, line 2868 &lt;static&gt; o :array The &quot;o&quot; letter, lower case. Type: array Default Value: [111] Source: CrossBase/input/CB_Keyboard.js, line 2882 &lt;static&gt; O :array The &quot;O&quot; letter, upper case (capitalized). Type: array Default Value: [79] Source: CrossBase/input/CB_Keyboard.js, line 2875 &lt;static&gt; P :array The &quot;P&quot; letter, upper case (capitalized). Type: array Default Value: [80] Source: CrossBase/input/CB_Keyboard.js, line 2889 &lt;static&gt; p :array The &quot;p&quot; letter, lower case. Type: array Default Value: [112] Source: CrossBase/input/CB_Keyboard.js, line 2896 &lt;static&gt; PLUS :array The &quot;+&quot; (plus) character. Type: array Default Value: [43] Source: CrossBase/input/CB_Keyboard.js, line 2637 &lt;static&gt; Q :array The &quot;Q&quot; letter, upper case (capitalized). Type: array Default Value: [81] Source: CrossBase/input/CB_Keyboard.js, line 2903 &lt;static&gt; q :array The &quot;q&quot; letter, lower case. Type: array Default Value: [113] Source: CrossBase/input/CB_Keyboard.js, line 2910 &lt;static&gt; R :array The &quot;R&quot; letter, upper case (capitalized). Type: array Default Value: [82] Source: CrossBase/input/CB_Keyboard.js, line 2917 &lt;static&gt; r :array The &quot;r&quot; letter, lower case. Type: array Default Value: [114] Source: CrossBase/input/CB_Keyboard.js, line 2924 &lt;static&gt; S :array The &quot;S&quot; letter, upper case (capitalized). Type: array Default Value: [83] Source: CrossBase/input/CB_Keyboard.js, line 2931 &lt;static&gt; s :array The &quot;s&quot; letter, lower case. Type: array Default Value: [115] Source: CrossBase/input/CB_Keyboard.js, line 2938 &lt;static&gt; SLASH :array The &quot;/&quot; (slash) character. Type: array Default Value: [47] Source: CrossBase/input/CB_Keyboard.js, line 2658 &lt;static&gt; T :array The &quot;T&quot; letter, upper case (capitalized). Type: array Default Value: [84] Source: CrossBase/input/CB_Keyboard.js, line 2945 &lt;static&gt; t :array The &quot;t&quot; letter, lower case. Type: array Default Value: [116] Source: CrossBase/input/CB_Keyboard.js, line 2952 &lt;static&gt; u :array The &quot;u&quot; letter, lower case. Type: array Default Value: [117] Source: CrossBase/input/CB_Keyboard.js, line 2966 &lt;static&gt; U :array The &quot;U&quot; letter, upper case (capitalized). Type: array Default Value: [85] Source: CrossBase/input/CB_Keyboard.js, line 2959 &lt;static&gt; v :array The &quot;v&quot; letter, lower case. Type: array Default Value: [118] Source: CrossBase/input/CB_Keyboard.js, line 2980 &lt;static&gt; V :array The &quot;V&quot; letter, upper case (capitalized). Type: array Default Value: [86] Source: CrossBase/input/CB_Keyboard.js, line 2973 &lt;static&gt; w :array The &quot;w&quot; letter, lower case. Type: array Default Value: [119] Source: CrossBase/input/CB_Keyboard.js, line 2994 &lt;static&gt; W :array The &quot;W&quot; letter, upper case (capitalized). Type: array Default Value: [87] Source: CrossBase/input/CB_Keyboard.js, line 2987 &lt;static&gt; X :array The &quot;X&quot; letter, upper case (capitalized). Type: array Default Value: [88] Source: CrossBase/input/CB_Keyboard.js, line 3001 &lt;static&gt; x :array The &quot;x&quot; letter, lower case. Type: array Default Value: [120] Source: CrossBase/input/CB_Keyboard.js, line 3008 &lt;static&gt; Y :array The &quot;Y&quot; letter, upper case (capitalized). Type: array Default Value: [89] Source: CrossBase/input/CB_Keyboard.js, line 3015 &lt;static&gt; y :array The &quot;y&quot; letter, lower case. Type: array Default Value: [121] Source: CrossBase/input/CB_Keyboard.js, line 3022 &lt;static&gt; Z :array The &quot;Z&quot; letter, upper case (capitalized). Type: array Default Value: [90] Source: CrossBase/input/CB_Keyboard.js, line 3029 &lt;static&gt; z :array The &quot;z&quot; letter, lower case. Type: array Default Value: [122] Source: CrossBase/input/CB_Keyboard.js, line 3036 × Search results Close "},"CB_Keyboard.extended.html":{"id":"CB_Keyboard.extended.html","title":"Namespace: extended","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: extended CB_Keyboard. extended Property that keeps extended key codes for different systems and platforms. Source: CrossBase/input/CB_Keyboard.js, line 65 Members &lt;static, constant&gt; AMAZON_FIRE_TV_GAME_CONTROLLER :Object Amazon Fire TV game controller key codes. Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. A number &quot;A&quot; button. B number &quot;B&quot; button. X number &quot;X&quot; button. Y number &quot;Y&quot; button. Source: CrossBase/input/CB_Keyboard.js, line 1022 &lt;static, constant&gt; AMAZON_FIRE_TV_REMOTE :Object Amazon Fire TV remote control key codes. Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. SELECT number SELECT button. PLAY_PAUSE number PLAY/PAUSE button. RW number RW (REWIND) button. FF number FF (FAST FORWARD) button. Source: CrossBase/input/CB_Keyboard.js, line 993 &lt;static, constant&gt; LG_SMART_TV_LINUX_35230 :Object LG Smart TV (Linux 35230) key codes. Type: Object Properties: Name Type Description _0 number 0 (zero) button. _1 number 1 button. _2 number 2 button. _3 number 3 button. _4 number 4 button. _5 number 5 button. _6 number 6 button. _7 number 7 button. _8 number 8 button. _9 number 9 button. 0 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._0. 1 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._1. 2 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._2. 3 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._3. 4 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._4. 5 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._5. 6 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._6. 7 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._7. 8 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._8. 9 number Alias for CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._9. FORWARD number FORWARD button. REWIND number REWIND button. PLAY number PLAY button. PAUSE number PAUSE button. Source: CrossBase/input/CB_Keyboard.js, line 1186 &lt;static, constant&gt; PS3 :Object Sony PlayStation 3 key codes. Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. CROSS number CROSS button. Source: CrossBase/input/CB_Keyboard.js, line 1094 &lt;static, constant&gt; PS4 :Object Sony PlayStation 4 key codes. Type: Object Properties: Name Type Description UP number D-PAD UP button. DOWN number D-PAD DOWN button. LEFT number D-PAD LEFT button. RIGHT number D-PAD RIGHT button. TRIANGLE number TRIANGLE button. SQUARE number SQUARE button. CIRCLE number CIRCLE button. L1 number L1 button. L2 number L2 button. R1 number R1 button. R2 number R2 button. LEFT_STICK_CLICK number LEFT STICK CLICK button. RIGHT_STICK_CLICK number RIGHT STICK CLICK button. OPTIONS number OPTIONS button. Source: CrossBase/input/CB_Keyboard.js, line 1119 &lt;static, constant&gt; PSVITA :Object Sony PlayStation Vita key codes. Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. Source: CrossBase/input/CB_Keyboard.js, line 1164 &lt;static, constant&gt; SAMSUNG_TIZEN_TV :Object Samsung Tizen TV key codes. Type: Object Properties: Name Type Description UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. ENTER number ENTER button. MEDIA_PLAY_PAUSE number PLAY/PAUSE MEDIA button. MEDIA_REWIND number RW (REWIND) MEDIA button. MEDIA_FORWARD number FW (FORWARD) MEDIA button. MEDIA_PLAY number PLAY MEDIA button. MEDIA_PAUSE number PAUSE MEDIA button. MEDIA_STOP number STOP MEDIA button. RETURN number RETURN button. MEDIA_RECORD number RECORD MEDIA button. MEDIA_TRACK_PREVIOUS number PREVIOUS TRACK MEDIA button. MEDIA_TRACK_NEXT number NEXT TRACK MEDIA button. VOLUME_UP number VOLUME UP button. VOLUME_DOWN number VOLUME DOWN button. MUTE number MUTE button. _0 number 0 (zero) button. _1 number 1 button. _2 number 2 button. _3 number 3 button. _4 number 4 button. _5 number 5 button. _6 number 6 button. _7 number 7 button. _8 number 8 button. _9 number 9 button. 0 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._0. 1 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._1. 2 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._2. 3 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3. 4 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._4. 5 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._5. 6 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._6. 7 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._7. 8 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._8. 9 number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._9. RED number RED button. GREEN number GREEN button. YELLOW number YELLOW button. BLUE number BLUE button. INFO number INFORMATION button. EXIT number EXIT button. MINUS number MINUS button. CAPTION number CAPTION button. CH_UP number CHANNEL UP button. CH_DOWN number CHANNEL DOWN button. CH_PREVIOUS number PREVIOUS CHANNEL button. CH_LIST number CHANNEL LIST button. E_MANUAL number E-MANUAL button. SEARCH number SEARCH button. _3D number 3D button. 3D number Alias for CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3D. GUIDE number GUIDE button. SOURCE number SOURCE button. PICTURE_SIZE number PICTURE SIZE button. EXTRA number EXTRA button. SOCCER number SOCCER button. MTS number MTS (Multichannel Television Sound) button. TELETEXT number TELETEXT button. MENU number MENU button. TOOLS number TOOLS button. Source: CrossBase/input/CB_Keyboard.js, line 244 &lt;static, constant&gt; SAMSUNG_TV :Object Samsung TV key codes. Type: Object Properties: Name Type Description TOOLS number TOOLS button. EMODE number EMODE button. DMA number DMA (Digital Media Adapter) button. SOURCE number SOURCE button. CHDOWN number CHANNEL DOWN button. CHUP number CHANNEL UP button. PANEL_CH_UP number CHANNEL UP PANEL button #1. PANEL_CH_DOWN number CHANNEL DOWN PANEL button #1. PANEL_CHUP number CHANNEL UP PANEL button #2. PANEL_CHDOWN number CHANNEL DOWN PANEL button #2. PIP_CHUP number CHANNEL UP PIP (Picture In Picture) button. PIP_CHDOWN number CHANNEL DOWN PIP (Picture In Picture) button. PRECH number PRE-CHANNEL (PREVIOUS CHANNEL) button. FAVCH number FAVOURITE CHANNEL button. CHLIST number CHANNEL LIST button. TTX_MIX number TELETEXT button. GUIDE number GUIDE button. ASPECT number ASPECT button. DOLBY_SRR number DOLBY SRR (SuRroundRight) button. MTS number MTS (Multichannel Television Sound) button. WHEELDOWN number WHEEL DOWN #1. WHEEL_DOWN number WHEEL DOWN #2. WHEELUP number WHEEL UP #1. WHEEL_UP number WHEEL UP #2. WHEELLEFT number WHEEL LEFT #1. WHEEL_LEFT number WHEEL LEFT #2. WHEELRIGHT number WHEEL RIGHT #1. WHEEL_RIGHT number WHEEL RIGHT #2. SMART number SMART TV button. EXIT number EXIT button. POWER number POWER button. PANEL_POWER number POWER PANEL button. POWEROFF number POWER OFF button. POWERON number POWER ON button. CONTENT number CONTENT button. WLINK number WLINK (Wiselink) button #1. W_LINK number WLINK (Wiselink) button #2. EMPTY number EMPTY button. CC number CC (Closed Captioning) button. REC number REC button. VOLUP number VOLUME UP button #1. VOL_UP number VOLUME UP button #2. VOLDOWN number VOLUME DOWN button #1. VOL_DOWN number VOLUME DOWN button #2. PANEL_VOLUP number PANEL VOLUME UP button #1. PANEL_VOL_UP number PANEL VOLUME UP button #2. PANEL_VOLDOW number PANEL VOLUME DOWN button #1. PANEL_VOLDOWN number PANEL VOLUME DOWN button #2. PANEL_VOL_DOWN number PANEL VOLUME DOWN button #3. MUTE number MUTE button. INFO number INFORMATION button. INFOLINK number INFOLINK button. MENU number MENU button. SUBTITLE number SUBTITLE button #1. SUB_TITLE number SUBTITLE button #2. PANEL_SOURCE number SOURCE PANEL button. _0 number 0 (zero) button. _1 number 1 button. _2 number 2 button. _3 number 3 button. _4 number 4 button. _5 number 5 button. _6 number 6 button. _7 number 7 button. _8 number 8 button. _9 number 9 button. _10 number 10 button. _11 number 11 button. _12 number 12 button. 0 number Alias for CB_Keyboard.extended.SAMSUNG_TV._0. 1 number Alias for CB_Keyboard.extended.SAMSUNG_TV._1. 2 number Alias for CB_Keyboard.extended.SAMSUNG_TV._2. 3 number Alias for CB_Keyboard.extended.SAMSUNG_TV._3. 4 number Alias for CB_Keyboard.extended.SAMSUNG_TV._4. 5 number Alias for CB_Keyboard.extended.SAMSUNG_TV._5. 6 number Alias for CB_Keyboard.extended.SAMSUNG_TV._6. 7 number Alias for CB_Keyboard.extended.SAMSUNG_TV._7. 8 number Alias for CB_Keyboard.extended.SAMSUNG_TV._8. 9 number Alias for CB_Keyboard.extended.SAMSUNG_TV._9. 10 number Alias for CB_Keyboard.extended.SAMSUNG_TV._10. 11 number Alias for CB_Keyboard.extended.SAMSUNG_TV._11. 12 number Alias for CB_Keyboard.extended.SAMSUNG_TV._12. RED number RED button. GREEN number GREEN button. YELLOW number YELLOW button. BLUE number BLUE button. CYAN number CYAN button. RW number RW (REWIND) button #1. REWIND number RW (REWIND) button #2. REWIND_ number RW (REWIND) button #3. FF number FF (FAST FORWARD) button #1. FF_ number FF (FAST FORWARD) button #2. PAUSE number PAUSE button. PLAY number PLAY button. STOP number STOP button. SEARCH number SEARCH button. UP number UP button. DOWN number DOWN button. LEFT number LEFT button. RIGHT number RIGHT button. CH_UP number CHANNEL UP button. CH_DOWN number CHANNEL DOWN button. DISC_MENU number DISC MENU button. _3D number 3D button. 3D number Alias for CB_Keyboard.extended.SAMSUNG_TV._3D. PIP_ONOFF number PIP (Picture In Picture) ON/OFF button. AD number AD (Audio Description) button. PMODE number PICTURE MODE button. SMODE number SOUND MODE button. SLEEP number SLEEP button. D_AUDIO number DIGITAL AUDIO button. D_FRONT_PLAY number DIGITAL FRONT PLAY button. D_VIEW_MODE number DIGITAL VIEW MODE button. STEP number STEP button. CALLER_ID number CALLED ID button. ANTENNA number ANTENNA button. ZOOM_MOVE number MOVE ZOOM button. ZOOM1 number ZOOM 1 button. ZOOM2 number ZOOM 2 button. ZOOM_IN number ZOOM IN button. ZOOM_OUT number ZOOM OUT button. RETURN number RETURN button. PANEL_RETURN number RETURN PANEL button. ENTER number ENTER button. PANEL_ENTER number ENTER PANEL button. PANEL_MENU number MENU PANEL button. ADDDEL number ADD/DEL button. PIP_SWAP number PIP (Picture In Picture) SWAP button. PLUS100 number SAMSUNG AUTO MOTION PLUS 100 HZ button. CAPTION number CAPTION button. PICTURE_SIZE number PICTURE SIZE button. PIP_SIZE number PIP (Picture In Picture) SIZE button. MAGIC_CHANNEL number MAGIC CHANNEL button. PIP_SCAN number PIP (Picture In Picture) SCAN button. DEVICE_CONNECT number DEVICE CONNECT button. HELP number HELP button. CONVERGENCE number CONVERGENCE button. AUTO_PROGRAM number AUTO PROGRAM button. FACTORY number FACTORY button. _3SPEED number 3SPEED button. 3SPEED number Alias for CB_Keyboard.extended.SAMSUNG_TV._3SPEED. RSURF number R.SURF button. TOPMENU number TOP MENU button. GAME number GAME button. QUICK_REPLAY number QUICK REPLAY button. STILL_PICTURE number STILL PICTURE button. DTV number DTV (Digital Television) button. INSTANT_REPLAY number INSTANT REPLAY button. LINK number LINK button. ANGLE number ANGLE button. RESERVED1 number RESERVED1 button. RESERVED5 number RESERVED5 button. PROGRAM number PROGRAM button. BOOKMARK number BOOKMARK button. PRINT number PRINT button. CLEAR number CLEAR button. VCHIP number V-CHIP button. REPEAT number REPEAT button. DOOR number DOOR button. OPEN number OPEN button. TURBO number TURBO button. DVR_MENU number DVR (Digital Video Recorder) MENU button. TTX_SUBFACE number Teletext Subface button. CH_LIST number CHANNEL LIST button. DNIe number DNIe (Digital Natural Image Engine) button. DNSe number DNSe (Digital Natural Sound Engine) button. SRS number SRS (Sound Retrieval System) button. CONVERT_AUDIO_MAINSUB number CONVERT AUDIO MAIN/SUB button. MDC number MDC button. SEFFECT number SOUND EFFECT button. DVR number DVR (Digital Video Recorder) button. DTV_SIGNAL number DTV (Digital Television) SIGNAL button. LIVE number LIVE button. PERPECT_FOCUS number PERPECT FOCUS button. HOME number HOME button. ESAVING number ENERGY SAVING button. CONTENTS number CONTENTS button. SCALE number SCALE button. CLOCK_DISPLAY number CLOCK DISPLAY button. SETUP_CLOCK_TIMER number SETUP CLOCK TIMER button. MAGIC_BRIGHT number MAGIC BRIGHT button. FM_RADIO number FM RADIO button. VCR_MODE number VCR MODE button. CATV_MODE number CATV (Community Antenna Television) MODE button. DSS_MODE number DSS MODE button. DVD_MODE number DVD MODE button. STB_MODE number STB (Set-Top Box) MODE button. PCMODE number PC MODE button. TV_MODE number TV MODE button. TV number TV button. AV1 number AV #1 button. AV2 number AV #2 button. AV3 number AV #3 button. SVIDEO1 number S-VIDEO (Separated-Video) #1 button. SVIDEO2 number S-VIDEO (Separated-Video) #2 button. SVIDEO3 number S-VIDEO (Separated-Video) #3 button. COMPONENT1 number COMPONENT #1 button. COMPONENT2 number COMPONENT #2 button. DVI number DVI (Digital Visual Interface) button. HDMI number HDMI button. HDMI1 number HDMI #1 button. HDMI2 number HDMI #2 button. HDMI3 number HDMI #3 button. HDMI4 number HDMI #4 button. DTV_LINK number DTVLINK (DIGITAL TELEVISION LINK) button. APP_LIST number APP LIST button. BACK_MHP number BACK MHP (Multimedia Home Platform) button. ALT_MHP number ALTERNATE MHP (Multimedia Home Platform) button. RSS number RSS button. ENTERTAINMENT number ENTERTAINMENT button. ID_INPUT number ID INPUT button. ID_SETUP number ID SETUP button. ANYNET number ANYNET button. ANYVIEW number ANYVIEW button. MS number MS button. MORE number MORE button. _4_3 number 4:3 button. 4_3 number Alias for CB_Keyboard.extended.SAMSUNG_TV._4_3. _16_9 number 16:9 button. 16_9 number Alias for CB_Keyboard.extended.SAMSUNG_TV._16_9. PANORAMA number PICTURE MODE PANORAMA button. DYNAMIC number PICTURE MODE DYNAMIC button. STANDARD number PICTURE MODE STANDARD button. MOVIE1 number PICTURE MODE MOVIE1 button. CUSTOM number PICTURE MODE CUSTOM button. AUTO_ARC_RESET number AUTO ARC (Audio Return Channel) RESET button. AUTO_ARC_LNA_ON number AUTO ARC (Audio Return Channel) LNA (Low Noise Amplifier) ON button. AUTO_ARC_LNA_OFF number AUTO ARC (Audio Return Channel) LNA (Low Noise Amplifier) OFF button. AUTO_ARC_ANYNET_MODE_OK number AUTO ARC (Audio Return Channel) ANYNET MODE OK button. AUTO_ARC_ANYNET_AUTO_START number AUTO ARC (Audio Return Channel) ANYNET AUTO START button. AUTO_ARC_CAPTION_ON number AUTO ARC (Audio Return Channel) CAPTION ON button. AUTO_ARC_CAPTION_OFF number AUTO ARC (Audio Return Channel) CAPTION OFF button. AUTO_ARC_PIP_DOUBLE number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) DOUBLE button. AUTO_ARC_PIP_LARGE number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LARGE button. AUTO_ARC_PIP_SMALL number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) SMALL button. AUTO_ARC_PIP_WIDE number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) WIDE button. AUTO_ARC_PIP_LEFT_TOP number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LEFT TOP button. AUTO_ARC_PIP_RIGHT_TOP number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) RIGHT TOP button. AUTO_ARC_PIP_LEFT_BOTTOM number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) LEFT BOTTOM button. AUTO_ARC_PIP_RIGHT_BOTTOM number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) RIGHT BOTTOM button. AUTO_ARC_PIP_CH_CHANGE number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) CHANNEL CHANGE button. AUTO_ARC_PIP_SOURCE_CHANGE number AUTO ARC (Audio Return Channel) PIP (Picture In Picture) SOURCE CHANGE button. AUTO_ARC_AUTOCOLOR_SUCCESS number AUTO ARC (Audio Return Channel) AUTOCOLOR SUCCESS button. AUTO_ARC_AUTOCOLOR_FAIL number AUTO ARC (Audio Return Channel) AUTOCOLOR FAIL button. AUTO_ARC_C_FORCE_AGING number AUTO ARC (Audio Return Channel) C-FORCE AGING button. AUTO_ARC_USBJACK_INSPECT number AUTO ARC (Audio Return Channel) USB JACK INSPECT button. AUTO_ARC_JACK_IDENT number AUTO ARC (Audio Return Channel) JACK IDENT button. AUTO_ARC_CAPTION_KOR number AUTO ARC (Audio Return Channel) CAPTION KOREAN button. AUTO_ARC_CAPTION_ENG number AUTO ARC (Audio Return Channel) CAPTION ENGLISH button. AUTO_ARC_ANTENNA_AIR number AUTO ARC (Audio Return Channel) ANTENNA AIR button. AUTO_ARC_ANTENNA_CABLE number AUTO ARC (Audio Return Channel) ANTENNA CABLE button. AUTO_ARC_ANTENNA_SATELLITE number AUTO ARC (Audio Return Channel) ANTENNA SATELLITE button. AUTO_FORMAT number AUTO FORMAT button. DNET number D-NET button. NINE_SEPARATE number NINE SEPARATE button. MIC number MIC (MICROPHONE) button. EXT1 number EXT1 button. EXT2 number EXT2 button. EXT3 number EXT3 button. EXT4 number EXT4 button. EXT5 number EXT5 button. EXT6 number EXT6 button. EXT7 number EXT7 button. EXT8 number EXT8 button. EXT9 number EXT9 button. EXT10 number EXT10 button. EXT11 number EXT11 button. EXT12 number EXT12 button. EXT13 number EXT13 button. EXT14 number EXT14 button. EXT15 number EXT15 button. EXT16 number EXT16 button. EXT17 number EXT17 button. EXT18 number EXT18 button. EXT19 number EXT19 button. EXT20 number EXT20 button. EXT21 number EXT21 button. EXT22 number EXT22 button. EXT23 number EXT23 button. EXT24 number EXT24 button. EXT25 number EXT25 button. EXT26 number EXT26 button. EXT27 number EXT27 button. EXT28 number EXT28 button. EXT29 number EXT29 button. EXT30 number EXT30 button. EXT31 number EXT31 button. EXT32 number EXT32 button. EXT33 number EXT33 button. EXT34 number EXT34 button. EXT35 number EXT35 button. EXT36 number EXT36 button. EXT37 number EXT37 button. EXT38 number EXT38 button. EXT39 number EXT39 button. EXT40 number EXT40 button. EXT41 number EXT41 button. Source: CrossBase/input/CB_Keyboard.js, line 384 &lt;static, constant&gt; VK :Object Smart TV Alliance and virtual keyboard key codes. Type: Object Properties: Name Type Description ENTER number ENTER key. PAUSE number PAUSE key. PAGE_UP number PAGE UP key. PAGE_DOWN number PAGE DOWN key. LEFT number LEFT key. UP number UP key. RIGHT number RIGHT key. DOWN number DOWN key. _0 number 0 (zero) key. _1 number 1 key. _2 number 2 key. _3 number 3 key. _4 number 4 key. _5 number 5 key. _6 number 6 key. _7 number 7 key. _8 number 8 key. _9 number 9 key. 0 number Alias for CB_Keyboard.extended.VK._0. 1 number Alias for CB_Keyboard.extended.VK._1. 2 number Alias for CB_Keyboard.extended.VK._2. 3 number Alias for CB_Keyboard.extended.VK._3. 4 number Alias for CB_Keyboard.extended.VK._4. 5 number Alias for CB_Keyboard.extended.VK._5. 6 number Alias for CB_Keyboard.extended.VK._6. 7 number Alias for CB_Keyboard.extended.VK._7. 8 number Alias for CB_Keyboard.extended.VK._8. 9 number Alias for CB_Keyboard.extended.VK._9. REWIND number RW (REWIND) key. STOP number STOP key. PLAY number PLAY key. FAST_FWD number FF (FAST FORWARD) key. BACK number BACK key. PREV number PREVIOUS key. NEXT number NEXT key. INFO number INFORMATION key. RED number RED key. GREEN number GREEN key. YELLOW number YELLOW key. BLUE number BLUE key. SPACE number SPACE key. BACK_SPACE number BACK SPACE key. A number A key. B number B key. C number C key. D number D key. E number E key. F number F key. G number G key. H number H key. I number I key. J number J key. K number K key. L number L key. M number M key. N number N key. O number O key. P number P key. Q number Q key. R number R key. S number S key. T number T key. U number U key. V number V key. W number W key. X number X key. Y number Y key. Z number Z key. VOLUME_UP number VOLUME UP key. VOLUME_DOWN number VOLUME DOWN key. MUTE number MUTE key. PLAY_PAUSE number PLAY/PAUSE key. HELP number HELP key. SUBTITLE number SUBTITLE key. SEARCH number SEARCH key. AUDIODESCRIPTION number AUDIODESCRIPTION key. HD number HD (High Definition) key. Source: CrossBase/input/CB_Keyboard.js, line 71 To Do: Consider adding more (found in https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx and http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/) &lt;static, constant&gt; WII :Object Nintendo Wii (Wiimote) key codes. Type: Object Properties: Name Type Description UP number D-PAD UP button. DOWN number D-PAD DOWN button. LEFT number D-PAD LEFT button. RIGHT number D-PAD RIGHT button. A number &quot;A&quot; button. B number &quot;B&quot; button. MINUS number MINUS (&quot;-&quot;) button. PLUS number PLUS (&quot;+&quot;) button. ONE number &quot;1&quot; button. _1 number Alias for CB_Keyboard.extended.WII.ONE. 1 number Alias for CB_Keyboard.extended.WII.ONE. TWO number &quot;2&quot; button. _2 number Alias for CB_Keyboard.extended.WII.TWO. 2 number Alias for CB_Keyboard.extended.WII.TWO. HOME number HOME button. Source: CrossBase/input/CB_Keyboard.js, line 1051 × Search results Close "},"CB_Keyboard.keys.html":{"id":"CB_Keyboard.keys.html","title":"Namespace: keys","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: keys CB_Keyboard. keys Object whose properties are aliases for key codes (each property can contain an array with one or more integers which belong to the key codes). Source: CrossBase/input/CB_Keyboard.js, line 1254 Members &lt;static&gt; 0 :array The 0 (zero) key. Type: array Default Value: [48,96,&quot;CB_Keyboard.extended.VK._0&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._0&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._0&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1531 &lt;static&gt; 1 :array The 1 key. Type: array Default Value: [49,97,&quot;CB_Keyboard.extended.VK._1&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._1&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._1&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1551 &lt;static&gt; 2 :array The 2 key. Type: array Default Value: [50,98,&quot;CB_Keyboard.extended.VK._2&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._2&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._2&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1571 &lt;static&gt; 3 :array The 3 key. Type: array Default Value: [51,99,&quot;CB_Keyboard.extended.VK._3&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._3&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._3&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._3&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1591 &lt;static&gt; 4 :array The 4 key. Type: array Default Value: [52,100,&quot;CB_Keyboard.extended.VK._4&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._4&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._4&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._4&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1611 &lt;static&gt; 5 :array The 5 key. Type: array Default Value: [53,101,&quot;CB_Keyboard.extended.VK._5&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._5&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._5&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._5&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1631 &lt;static&gt; 6 :array The 6 key. Type: array Default Value: [54,102,&quot;CB_Keyboard.extended.VK._6&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._6&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._6&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._6&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1651 &lt;static&gt; 7 :array The 7 key. Type: array Default Value: [55,103,&quot;CB_Keyboard.extended.VK._7&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._7&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._7&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._7&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1671 &lt;static&gt; 8 :array The 8 key. Type: array Default Value: [56,104,&quot;CB_Keyboard.extended.VK._8&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._8&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._8&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._8&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1691 &lt;static&gt; 9 :array The 9 key. Type: array Default Value: [57,105,&quot;CB_Keyboard.extended.VK._9&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV._9&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV._9&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230._9&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1711 &lt;static&gt; _0 Alias for CB_Keyboard.keys.0. Source: CrossBase/input/CB_Keyboard.js, line 1521 See: CB_Keyboard.keys.0 &lt;static&gt; _1 Alias for CB_Keyboard.keys.1. Source: CrossBase/input/CB_Keyboard.js, line 1541 See: CB_Keyboard.keys.1 &lt;static&gt; _2 Alias for CB_Keyboard.keys.2. Source: CrossBase/input/CB_Keyboard.js, line 1561 See: CB_Keyboard.keys.2 &lt;static&gt; _3 Alias for CB_Keyboard.keys.3. Source: CrossBase/input/CB_Keyboard.js, line 1581 See: CB_Keyboard.keys.3 &lt;static&gt; _4 Alias for CB_Keyboard.keys.4. Source: CrossBase/input/CB_Keyboard.js, line 1601 See: CB_Keyboard.keys.4 &lt;static&gt; _5 Alias for CB_Keyboard.keys.5. Source: CrossBase/input/CB_Keyboard.js, line 1621 See: CB_Keyboard.keys.5 &lt;static&gt; _6 Alias for CB_Keyboard.keys.6. Source: CrossBase/input/CB_Keyboard.js, line 1641 See: CB_Keyboard.keys.6 &lt;static&gt; _7 Alias for CB_Keyboard.keys.7. Source: CrossBase/input/CB_Keyboard.js, line 1661 See: CB_Keyboard.keys.7 &lt;static&gt; _8 Alias for CB_Keyboard.keys.8. Source: CrossBase/input/CB_Keyboard.js, line 1681 See: CB_Keyboard.keys.8 &lt;static&gt; _9 Alias for CB_Keyboard.keys.9. Source: CrossBase/input/CB_Keyboard.js, line 1701 See: CB_Keyboard.keys.9 &lt;static&gt; A :array The &quot;A&quot; key. Type: array Default Value: [65,&quot;CB_Keyboard.extended.VK.A&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1847 &lt;static&gt; ALT :array The Alt key. Type: array Default Value: [18] Source: CrossBase/input/CB_Keyboard.js, line 1359 &lt;static&gt; APP1 :array The App1 key. Type: array Default Value: [182] Source: CrossBase/input/CB_Keyboard.js, line 2376 &lt;static&gt; APP2 :array The App2 key. Type: array Default Value: [183] Source: CrossBase/input/CB_Keyboard.js, line 2383 &lt;static&gt; APPS :array The Apps (Applications) key. Type: array Default Value: [93] Source: CrossBase/input/CB_Keyboard.js, line 2099 &lt;static&gt; ASTERISK :array The &quot;*&quot; (asterisk) symbol key. NOTE: In some keyboards (for example in Spanish for Spain ones), you have to press PLUS (code 187) with SHIFT to access to &quot;*&quot;. Type: array Default Value: [106] Source: CrossBase/input/CB_Keyboard.js, line 1751 &lt;static&gt; ATTN :array The Attn key. Type: array Default Value: [246] Source: CrossBase/input/CB_Keyboard.js, line 2390 &lt;static&gt; AUDIODESCRIPTION :array The Audio Description key. Type: array Default Value: [&quot;&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.CAPTION&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2465 &lt;static&gt; B :array The &quot;B&quot; key. Type: array Default Value: [66,&quot;CB_Keyboard.extended.VK.B&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1854 &lt;static&gt; BACKSPACE :array The Backspace key. Type: array Default Value: [8,127,&quot;CB_Keyboard.extended.VK.BACK_SPACE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1473 &lt;static&gt; BLUE :array The Blue colour button. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.BLUE&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.BLUE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2535 &lt;static&gt; BROWSER_BACK :array The Browser's Back key. Type: array Default Value: [166,&quot;CB_Keyboard.extended.VK.PREV&quot;,&quot;&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RETURN&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_TRACK_PREVIOUS&quot;,&quot;CB_Keyboard.extended.VK.BACK&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2290 &lt;static&gt; BROWSER_FAVORITES :array The Browser's Favorites key. Type: array Default Value: [171] Source: CrossBase/input/CB_Keyboard.js, line 2345 &lt;static&gt; BROWSER_FORWARD :array The Browser's Forward key. Type: array Default Value: [167,&quot;CB_Keyboard.extended.VK.NEXT&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_TRACK_NEXT&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2306 &lt;static&gt; BROWSER_HOME :array The Browser's Home key. Type: array Default Value: [172] Source: CrossBase/input/CB_Keyboard.js, line 2352 &lt;static&gt; BROWSER_REFRESH :array The Browser's Refresh (Reload) key. Type: array Default Value: [168] Source: CrossBase/input/CB_Keyboard.js, line 2318 &lt;static&gt; BROWSER_SEARCH :array The Browser's Search key. Type: array Default Value: [170,&quot;&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.SEARCH&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2332 &lt;static&gt; BROWSER_STOP :array The Browser's Stop key. Type: array Default Value: [169] Source: CrossBase/input/CB_Keyboard.js, line 2325 &lt;static&gt; C :array The &quot;C&quot; key. Type: array Default Value: [67,&quot;CB_Keyboard.extended.VK.C&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1861 &lt;static&gt; CAPS_LOCK :array The Caps Lock key. Type: array Default Value: [20] Source: CrossBase/input/CB_Keyboard.js, line 1503 &lt;static&gt; CLEAR :array The Clear key. Type: array Default Value: [12,254,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2043 &lt;static&gt; COMMA :array The &quot;,&quot; (comma) symbol key. Type: array Default Value: [188] Source: CrossBase/input/CB_Keyboard.js, line 1783 &lt;static&gt; CRSEL :array The CrSel key. Type: array Default Value: [247] Source: CrossBase/input/CB_Keyboard.js, line 2397 &lt;static&gt; CTRL :array The Control key. Type: array Default Value: [17,162,163] Source: CrossBase/input/CB_Keyboard.js, line 1352 &lt;static&gt; CYAN :array The Cyan colour button. Type: array Default Value: [&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2547 &lt;static&gt; D :array The &quot;D&quot; key. Type: array Default Value: [68,&quot;CB_Keyboard.extended.VK.D&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1868 &lt;static&gt; DECIMAL :array The Decimal key (for numeric pads). NOTE: In some decimal systems, as in Spanish, it is a comma (&quot;,&quot;). Normally, numeric keypads in Spanish for Spain keyboards show a dot (&quot;.&quot;) but others as German keyboards shows a comma (&quot;,&quot;). Type: array Default Value: [110] Source: CrossBase/input/CB_Keyboard.js, line 2124 &lt;static&gt; DEL :array The Del (Delete) key. Type: array Default Value: [46] Source: CrossBase/input/CB_Keyboard.js, line 1840 &lt;static&gt; DOT :array The &quot;.&quot; (dot) symbol key. Type: array Default Value: [190] Source: CrossBase/input/CB_Keyboard.js, line 1773 &lt;static&gt; DOWN :array The down arrow key. Type: array Default Value: [40,&quot;&quot;,&quot;CB_Keyboard.extended.VK.DOWN&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.DOWN&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.DOWN&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.DOWN&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.DOWN&quot;,&quot;CB_Keyboard.extended.PS3.DOWN&quot;,&quot;CB_Keyboard.extended.PS4.DOWN&quot;,&quot;CB_Keyboard.extended.PSVITA.DOWN&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1399 &lt;static&gt; E :array The &quot;E&quot; key. Type: array Default Value: [69,&quot;CB_Keyboard.extended.VK.E&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1875 &lt;static&gt; END :array The End key. Type: array Default Value: [35] Source: CrossBase/input/CB_Keyboard.js, line 1804 &lt;static&gt; ENTER :array The Enter (Return) key. Type: array Default Value: [13,&quot;CB_Keyboard.extended.VK.ENTER&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.ENTER&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.PANEL_ENTER&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.ENTER&quot;,&quot;CB_Keyboard.extended.PS3.CROSS&quot;,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1456 &lt;static&gt; EREOF :array The EREOF (Erase EOF) key. Type: array Default Value: [249] Source: CrossBase/input/CB_Keyboard.js, line 2411 &lt;static&gt; ESC :array The Escape (ESC) key. Type: array Default Value: [27] Source: CrossBase/input/CB_Keyboard.js, line 1261 &lt;static&gt; EXECUTE :array The Execute key. Type: array Default Value: [43] Source: CrossBase/input/CB_Keyboard.js, line 2080 &lt;static&gt; EXSEL :array The ExSel key. Type: array Default Value: [248] Source: CrossBase/input/CB_Keyboard.js, line 2404 &lt;static&gt; F :array The &quot;F&quot; key. Type: array Default Value: [70,&quot;CB_Keyboard.extended.VK.F&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1882 &lt;static&gt; F1 :array The F1 key. Type: array Default Value: [112] Source: CrossBase/input/CB_Keyboard.js, line 1268 &lt;static&gt; F2 :array The F2 key. Type: array Default Value: [113] Source: CrossBase/input/CB_Keyboard.js, line 1275 &lt;static&gt; F3 :array The F3 key. Type: array Default Value: [114] Source: CrossBase/input/CB_Keyboard.js, line 1282 &lt;static&gt; F4 :array The F4 key. Type: array Default Value: [115] Source: CrossBase/input/CB_Keyboard.js, line 1289 &lt;static&gt; F5 :array The F5 key. Type: array Default Value: [116] Source: CrossBase/input/CB_Keyboard.js, line 1296 &lt;static&gt; F6 :array The F6 key. Type: array Default Value: [117] Source: CrossBase/input/CB_Keyboard.js, line 1303 &lt;static&gt; F7 :array The F7 key. Type: array Default Value: [118] Source: CrossBase/input/CB_Keyboard.js, line 1310 &lt;static&gt; F8 :array The F8 key. Type: array Default Value: [119] Source: CrossBase/input/CB_Keyboard.js, line 1317 &lt;static&gt; F9 :array The F9 key. Type: array Default Value: [120] Source: CrossBase/input/CB_Keyboard.js, line 1324 &lt;static&gt; F10 :array The F10 key. Type: array Default Value: [121] Source: CrossBase/input/CB_Keyboard.js, line 1331 &lt;static&gt; F11 :array The F11 key. Type: array Default Value: [122] Source: CrossBase/input/CB_Keyboard.js, line 1338 &lt;static&gt; F12 :array The F12 key. Type: array Default Value: [123] Source: CrossBase/input/CB_Keyboard.js, line 1345 &lt;static&gt; G :array The &quot;G&quot; key. Type: array Default Value: [71,&quot;CB_Keyboard.extended.VK.G&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1889 &lt;static&gt; GREEN :array The Green colour button. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.GREEN&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.GREEN&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2511 &lt;static&gt; H :array The &quot;H&quot; key. Type: array Default Value: [72,&quot;CB_Keyboard.extended.VK.H&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1896 &lt;static&gt; HD :array The HD (High Definition) key. Type: array Default Value: [&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2489 &lt;static&gt; HELP :array The Help key. Type: array Default Value: [47,&quot;CB_Keyboard.extended.VK.HELP&quot;,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2087 &lt;static&gt; HOME :array The Home key. Type: array Default Value: [36,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1793 &lt;static&gt; I :array The &quot;I&quot; key. Type: array Default Value: [73,&quot;CB_Keyboard.extended.VK.I&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1903 &lt;static&gt; INFO :array The Info (Information) key. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.INFO&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.INFO&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2453 &lt;static&gt; INS :array The Ins (Insert) key. Type: array Default Value: [45] Source: CrossBase/input/CB_Keyboard.js, line 1833 &lt;static&gt; J :array The &quot;J&quot; key. Type: array Default Value: [74,&quot;CB_Keyboard.extended.VK.J&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1910 &lt;static&gt; K :array The &quot;K&quot; key. Type: array Default Value: [75,&quot;CB_Keyboard.extended.VK.K&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1917 &lt;static&gt; L :array The &quot;L&quot; key. Type: array Default Value: [76,&quot;CB_Keyboard.extended.VK.L&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1924 &lt;static&gt; LEFT :array The left arrow key. Type: array Default Value: [37,&quot;&quot;,&quot;CB_Keyboard.extended.VK.LEFT&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.LEFT&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.LEFT&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.LEFT&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.LEFT&quot;,&quot;CB_Keyboard.extended.PS3.LEFT&quot;,&quot;CB_Keyboard.extended.PS4.LEFT&quot;,&quot;CB_Keyboard.extended.PSVITA.LEFT&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1418 &lt;static&gt; M :array The &quot;M&quot; key. Type: array Default Value: [77,&quot;CB_Keyboard.extended.VK.M&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1931 &lt;static&gt; MAIL :array The Mail key. Type: array Default Value: [180] Source: CrossBase/input/CB_Keyboard.js, line 2362 &lt;static&gt; MEDIA_FORWARD :array The Multimedia Forward key. Type: array Default Value: [176,228,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.FORWARD&quot;,&quot;CB_Keyboard.extended.VK.FAST_FWD&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.FF_&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_FORWARD&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.FF&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2229 &lt;static&gt; MEDIA_PLAY_PAUSE :array The Multimedia Play/Pause key. Type: array Default Value: [179,&quot;CB_Keyboard.extended.VK.PLAY_PAUSE&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PLAY_PAUSE&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.PLAY_PAUSE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2277 &lt;static&gt; MEDIA_REWIND :array The Multimedia Rewind key. Type: array Default Value: [177,227,&quot;CB_Keyboard.extended.VK.REWIND&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.REWIND&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.REWIND_&quot;,&quot;&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_REWIND&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.RW&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2246 &lt;static&gt; MEDIA_SELECT :array The Select Media key. Type: array Default Value: [181] Source: CrossBase/input/CB_Keyboard.js, line 2369 &lt;static&gt; MEDIA_STOP :array The Multimedia Stop key. Type: array Default Value: [178,&quot;CB_Keyboard.extended.VK.STOP&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_STOP&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2264 &lt;static&gt; MENU :array The Menu key. Type: array Default Value: [164,165,&quot;CB_Keyboard.extended.SAMSUNG_TV.MENU&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MENU&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2131 &lt;static&gt; META :array The meta (Windows Start, Apple Command, etc.) key. Type: array Default Value: [91,92,219,220,224] Source: CrossBase/input/CB_Keyboard.js, line 1373 &lt;static&gt; MINUS :array The &quot;-&quot; (minus) symbol key. Type: array Default Value: [109,173,189,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MINUS&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1738 &lt;static&gt; MOUSE_LEFT_BUTTON :array The mouse's left button (for Windows' Virtual Keyboard). Type: array Default Value: [1] Source: CrossBase/input/CB_Keyboard.js, line 2145 &lt;static&gt; MOUSE_MIDDLE_BUTTON :array The mouse's middle button (for Windows' Virtual Keyboard). Type: array Default Value: [4] Source: CrossBase/input/CB_Keyboard.js, line 2152 &lt;static&gt; MOUSE_RIGHT_BUTTON :array The mouse's right button (for Windows' Virtual Keyboard). Type: array Default Value: [2] Source: CrossBase/input/CB_Keyboard.js, line 2159 &lt;static&gt; MOUSE_X1_BUTTON :array The mouse's X1 button (for Windows' Virtual Keyboard). Type: array Default Value: [5] Source: CrossBase/input/CB_Keyboard.js, line 2166 &lt;static&gt; MOUSE_X2_BUTTON :array The mouse's X2 button (for Windows' Virtual Keyboard). Type: array Default Value: [6] Source: CrossBase/input/CB_Keyboard.js, line 2173 &lt;static&gt; MUTE :array The Mute key. Type: array Default Value: [173,181,&quot;CB_Keyboard.extended.VK.MUTE&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MUTE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2180 &lt;static&gt; N :array The &quot;N&quot; key. Type: array Default Value: [78,&quot;CB_Keyboard.extended.VK.N&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1938 &lt;static&gt; NUM_LOCK :array The Num Lock (Numeric Lock) key. Type: array Default Value: [144] Source: CrossBase/input/CB_Keyboard.js, line 1511 &lt;static&gt; O :array The &quot;O&quot; key. Type: array Default Value: [79,&quot;CB_Keyboard.extended.VK.O&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1945 &lt;static&gt; P :array The &quot;P&quot; key. Type: array Default Value: [80,&quot;CB_Keyboard.extended.VK.P&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1952 &lt;static&gt; PA1 :array The PA1 key. Type: array Default Value: [253] Source: CrossBase/input/CB_Keyboard.js, line 2446 &lt;static&gt; PAGE_DOWN :array The Page Down key. Type: array Default Value: [34,&quot;CB_Keyboard.extended.VK.PAGE_DOWN&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1822 &lt;static&gt; PAGE_UP :array The Page Up key. Type: array Default Value: [33,&quot;CB_Keyboard.extended.VK.PAGE_UP&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1811 &lt;static&gt; PAUSE :array The Pause key. Type: array Default Value: [19,&quot;CB_Keyboard.extended.VK.PAUSE&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PAUSE&quot;,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.PAUSE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2029 &lt;static&gt; PLAY :array The Play key. Type: array Default Value: [250,&quot;CB_Keyboard.extended.LG_SMART_TV_LINUX_35230.PLAY&quot;,&quot;CB_Keyboard.extended.VK.PLAY&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.MEDIA_PLAY&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2418 &lt;static&gt; PLUS :array The &quot;+&quot; (plus) symbol key. NOTE: In some keyboards (for example in Chinese ones), you have to press EQUAL (code 61) with SHIFT to access to &quot;+&quot;. Type: array Default Value: [107,171,187] Source: CrossBase/input/CB_Keyboard.js, line 1726 &lt;static&gt; PRINT :array The Print key. Type: array Default Value: [42,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2062 &lt;static&gt; PRINT_SCREEN :array The Print Screen key. Type: array Default Value: [44] Source: CrossBase/input/CB_Keyboard.js, line 2073 &lt;static&gt; Q :array The &quot;Q&quot; key. Type: array Default Value: [81,&quot;CB_Keyboard.extended.VK.Q&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1959 &lt;static&gt; R :array The &quot;R&quot; key. Type: array Default Value: [82,&quot;CB_Keyboard.extended.VK.R&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1966 &lt;static&gt; RED :array The Red colour button. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.RED&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RED&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2499 &lt;static&gt; RIGHT :array The right arrow key. Type: array Default Value: [39,&quot;&quot;,&quot;CB_Keyboard.extended.VK.RIGHT&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.RIGHT&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.RIGHT&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.RIGHT&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.RIGHT&quot;,&quot;CB_Keyboard.extended.PS3.RIGHT&quot;,&quot;CB_Keyboard.extended.PS4.RIGHT&quot;,&quot;CB_Keyboard.extended.PSVITA.RIGHT&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1437 &lt;static&gt; S :array The &quot;S&quot; key. Type: array Default Value: [83,&quot;CB_Keyboard.extended.VK.S&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1973 &lt;static&gt; SCROLL_LOCK :array The Scroll Lock key. Type: array Default Value: [145] Source: CrossBase/input/CB_Keyboard.js, line 1518 &lt;static&gt; SELECT :array The Select key (for Windows' Virtual keyboard). Type: array Default Value: [41] Source: CrossBase/input/CB_Keyboard.js, line 2055 &lt;static&gt; SEPARATOR :array The Separator key. Type: array Default Value: [108] Source: CrossBase/input/CB_Keyboard.js, line 2117 &lt;static&gt; SHIFT :array The Shift (left or right) key. Type: array Default Value: [16,160,161] Source: CrossBase/input/CB_Keyboard.js, line 1366 &lt;static&gt; SLASH :array The &quot;/&quot; (slash) symbol key. NOTE: In some keyboards (for example in Spanish for Spain ones), you have to press 7 (code 55) with SHIFT to access to &quot;/&quot;. Type: array Default Value: [111] Source: CrossBase/input/CB_Keyboard.js, line 1763 &lt;static&gt; SLEEP :array The Sleep key. Type: array Default Value: [95,&quot;CB_Keyboard.extended.SAMSUNG_TV.SLEEP&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2106 &lt;static&gt; SPACEBAR :array The Spacebar key. Type: array Default Value: [32,&quot;CB_Keyboard.extended.VK.SPACE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1485 &lt;static&gt; SUBTITLE :array The Subtitle key. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.SUBTITLE&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.SUBTITLE&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.SUB_TITLE&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2477 &lt;static&gt; T :array The &quot;T&quot; key. Type: array Default Value: [84,&quot;CB_Keyboard.extended.VK.T&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1980 &lt;static&gt; TAB :array The Tabulator (Tab) key. Type: array Default Value: [9] Source: CrossBase/input/CB_Keyboard.js, line 1496 &lt;static&gt; U :array The &quot;U&quot; key. Type: array Default Value: [85,&quot;CB_Keyboard.extended.VK.U&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1987 &lt;static&gt; UP :array The up arrow key. Type: array Default Value: [38,&quot;&quot;,&quot;CB_Keyboard.extended.VK.UP&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.UP&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.UP&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_REMOTE.UP&quot;,&quot;CB_Keyboard.extended.AMAZON_FIRE_TV_GAME_CONTROLLER.UP&quot;,&quot;CB_Keyboard.extended.PS3.UP&quot;,&quot;CB_Keyboard.extended.PS4.UP&quot;,&quot;CB_Keyboard.extended.PSVITA.UP&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1380 &lt;static&gt; V :array The &quot;V&quot; key. Type: array Default Value: [86,&quot;CB_Keyboard.extended.VK.V&quot;] Source: CrossBase/input/CB_Keyboard.js, line 1994 &lt;static&gt; VOL_DOWN :array The Volume Down key. Type: array Default Value: [174,182,&quot;CB_Keyboard.extended.VK.VOLUME_DOWN&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.VOL_DOWN&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOL_DOWN&quot;,&quot;&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.VOLUME_DOWN&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2211 &lt;static&gt; VOL_UP :array The Volume Up key. Type: array Default Value: [175,183,&quot;CB_Keyboard.extended.VK.VOLUME_UP&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.VOL_UP&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TV.PANEL_VOL_UP&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.VOLUME_UP&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2194 &lt;static&gt; W :array The &quot;W&quot; key. Type: array Default Value: [87,&quot;CB_Keyboard.extended.VK.W&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2001 &lt;static&gt; X :array The &quot;X&quot; key. Type: array Default Value: [88,&quot;CB_Keyboard.extended.VK.X&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2008 &lt;static&gt; Y :array The &quot;Y&quot; key. Type: array Default Value: [89,&quot;CB_Keyboard.extended.VK.Y&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2015 &lt;static&gt; YELLOW :array The Yellow colour button. Type: array Default Value: [&quot;CB_Keyboard.extended.VK.YELLOW&quot;,&quot;&quot;,&quot;CB_Keyboard.extended.SAMSUNG_TIZEN_TV.YELLOW&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2523 &lt;static&gt; Z :array The &quot;Z&quot; key. Type: array Default Value: [90,&quot;CB_Keyboard.extended.VK.Z&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2022 &lt;static&gt; ZOOM :array The Zoom key. Type: array Default Value: [251,&quot;CB_Keyboard.extended.SAMSUNG_TV.ZOOM1&quot;,&quot;&quot;,&quot;&quot;] Source: CrossBase/input/CB_Keyboard.js, line 2432 × Search results Close "},"CB_Modules.html":{"id":"CB_Modules.html","title":"Namespace: CB_Modules","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Modules CB_Modules Static class that contains all the modules and the tools to manage them. Source: CrossBrowdy.js, line 156 Members &lt;static&gt; modules :Object Contains all the modules, one per property. Type: Object Properties: Name Type Description name_of_the_module CB_Modules.MODULE Object that contains the module data. The property name must be the name of the module. Source: CrossBrowdy.js, line 241 &lt;static, readonly&gt; STATUSES :integer Enum which defines possible module statuses. Type: integer Properties: Name Type Default Description FAILED integer -1 The module has failed to load. UNKNOWN integer 0 The module has an unkwnown status. UNLOADED integer 1 The module is not loaded yet. Default status. LOADING integer 2 The module is being loading. LOADED integer 3 The module has loaded successfully (coudl be not ready yet). READY integer 4 The module has loaded successfully and it is ready to be used. Source: CrossBrowdy.js, line 165 Methods &lt;static&gt; addNeededFiles(moduleName, neededFiles) → {boolean} Attaches files to a module. Parameters: Name Type Description moduleName string Name of the module which will contain the new files. neededFiles CB_Modules.NEEDED_FILES The &quot;neededFiles&quot; parameter for the module. Source: CrossBrowdy.js, line 946 Returns: It will return true if succeeded or false otherwise. Type boolean &lt;static&gt; addNeededModule(moduleNameParent, moduleName, neededFiles) → {boolean} Attaches one module to another one. Parameters: Name Type Description moduleNameParent string Name of the parent module where the new child module will be attached to. moduleName string Name of the new child module which will be attached to the given parent. neededFiles CB_Modules.NEEDED_FILES The &quot;neededFiles&quot; parameter for the new child module. Source: CrossBrowdy.js, line 932 Returns: It will return true if succeeded or false otherwise. Type boolean &lt;static&gt; editProperty(moduleName, property, value [, type] [, iterateArray]) → {boolean} Modifies a desired property of a given module. Parameters: Name Type Argument Default Description moduleName string Name of the module which contains the property to modify. property string Name of the property to modify. value * Value desired for the property. type 'array' | 'object' | 'scalar' &lt;optional&gt; 'scalar' Type that the property uses. If it is &quot;array&quot;, the given &quot;value&quot; will be attached at the end of the array (all in a new single index if the &quot;iterateArray&quot; parameter is set to false, or each value in a new index otherwise). If it is &quot;object&quot;, the given &quot;value&quot; and the given &quot;property&quot; to modify will be treated as objects and the members of the &quot;value&quot; will be copied one by one (overwriting previous members in the case they existed). If it is &quot;scalar&quot; or any other, the given &quot;property&quot; value will be replaced with the given &quot;value&quot;. iterateArray boolean &lt;optional&gt; false If is set to true and the given &quot;type&quot; is &quot;array&quot;, the given &quot;value&quot; will be considered an array and will be iterated to copy each of its values to a new index in the destiny. Otherwise, if it is set to false and the given &quot;type&quot; is &quot;array&quot;, the given &quot;value&quot; will be attached at the end of the array in a new single index. Source: CrossBrowdy.js, line 871 Returns: It will return true if succeeded or false otherwise. Type boolean &lt;static&gt; get(moduleName) → {CB_Modules.MODULE|null} Returns a CB_Modules.MODULE object for module management. Parameters: Name Type Description moduleName string Name of the desired module. Source: CrossBrowdy.js, line 827 Returns: If found, it will return the CB_Modules.MODULE object desired. Otherwise, it will return null. Type CB_Modules.MODULE | null &lt;static&gt; getProperty(moduleName, property) → {*|null} Gets the value of a desired module property (or returns null). Parameters: Name Type Description moduleName string Name of the desired module. property string Name of the desired property. Source: CrossBrowdy.js, line 845 Returns: If found, it will return the value of the desired module property. Otherwise, it will return null. Type * | null &lt;static&gt; setStatus(moduleName, status) → {boolean} Sets a status for a given module. Parameters: Name Type Description moduleName string Name of the module. status integer The desired status. Must be a value that exists in the CB_Modules.STATUSES enum. Source: CrossBrowdy.js, line 739 Returns: It will return true if succeeded or false otherwise. Type boolean Type Definitions CALLBACK(scriptPath) Callback for the different events of a module. Parameters: Name Type Description scriptPath string The value for the &quot;scriptPath&quot; parameter used by CB_init when it was called. Source: CrossBrowdy.js, line 218 MODULE Object that contains a module. Type: Object Properties: Name Type Description name string Name of the module. status CB_Modules.STATUSES Module status. onCall CB_Modules.CALLBACK Callback for when the module is called to be loaded. Being &quot;this&quot; the CB_Modules.MODULE object itself. onLoad CB_Modules.CALLBACK Callback for when the module loads successfully. Being &quot;this&quot; the CB_Modules.MODULE object itself. onReady CB_Modules.CALLBACK Callback for when the module is totally ready. Being &quot;this&quot; the CB_Modules.MODULE object itself. onFail CB_Modules.CALLBACK Callback for when the module fails to load. Being &quot;this&quot; the CB_Modules.MODULE object itself. NOT IMPLEMENTED YET. neededFiles CB_Modules.NEEDED_FILES Object containing the needed files. neededModules array Array of CB_Modules.NEEDED_MODULE objects, containing the needed modules. credits string Credits of the module. Source: CrossBrowdy.js, line 225 NEEDED_FILE Object that contains a needed file for a module. Type: Object Properties: Name Type Argument Default Description load boolean &lt;optional&gt; false Defines whether to load the file or not. mandatory boolean &lt;optional&gt; false Defines whether the file is mandatory. If the file is not mandatory, its module could be declared as loaded successfully before the file is loaded (and maybe never will). absolutePath boolean &lt;optional&gt; false Defines whether the path of the file is relative to the path of the main script or absolute. loadChecker CB_Modules.neededFile_LOAD_CHECKER &lt;optional&gt; Callback that will be called when the file tries to be loaded and should return true if the file needs to be loaded. id string &lt;optional&gt; Desired string to identify the file. requires array &lt;optional&gt; Array of strings with the IDs of the files that must be loaded before loading this file. The file will not be loaded until the required files are loaded first. Source: CrossBrowdy.js, line 190 NEEDED_FILES Object that contains the needed files for a module. Each property will represent a needed file. Type: Object Properties: Name Type Description path_to_the_file CB_Modules.NEEDED_FILE Object that contains a needed file for a module. The property name must be either the path to the file or a variable containing it. Tto use a variable, the name of the property must start with &quot;VALUEOF_&quot; and continue with the name of the variable. In the case that the variable is an object, each property must be separated by a dot (&quot;.&quot;). Source: CrossBrowdy.js, line 202 NEEDED_MODULE Object that contains a needed module for a parent module. Type: Object Properties: Name Type Description name string Name of the module. neededFiles CB_Modules.NEEDED_FILES Object containing the needed files. Source: CrossBrowdy.js, line 210 neededFile_LOAD_CHECKER(filepath, neededFile) → {boolean} Callback that is called before loading a file and should return true if we want to load the file or false otherwise. Parameters: Name Type Description filepath string Filepath of the needed file (including the filename). neededFile CB_Modules.NEEDED_FILE Object that contains the needed file. Source: CrossBrowdy.js, line 181 Returns: Returns true if we want to load the file or false otherwise. Type boolean × Search results Close "},"CB_Mouse.html":{"id":"CB_Mouse.html","title":"Namespace: CB_Mouse","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Mouse CB_Mouse Static class to manage the mouse and related. It will return itself if it is tried to be instantiated. Source: CrossBase/input/CB_Mouse.js, line 11 Namespaces CursorImage Methods &lt;static&gt; getButtons() → {Object} Tells what mouse buttons are down (LEFT, MIDDLE and/or RIGHT buttons). Source: CrossBase/input/CB_Mouse.js, line 300 Returns: Returns an object using the following format (where &quot;true&quot; means that the button is being pressed): { LEFT : boolean, MIDDLE : boolean, RIGHT : boolean } Type Object &lt;static&gt; getLockElement( [avoidCache]) → {Element|null} Gets the lock element for the mouse pointer (if any) or null otherwise. More information: Pointer Lock API. Parameters: Name Type Argument Default Description avoidCache boolean &lt;optional&gt; false If set to false, the returning value will use the previously-cached value (updated when this function is called with this parameter set to true or the onPointerLockChange or analog event is fired or when the CB_Mouse.lock or CB_Mouse.unlock functions are called successfully). Source: CrossBase/input/CB_Mouse.js, line 690 Returns: Returns the lock element for the mouse pointer (if any) or null otherwise. Type Element | null &lt;static&gt; getX( [e] [, ignoreScroll] [, ignoreLock]) → {number} Gets and returns the X coordinate (horizontal position) of the mouse (relative to the window in desktop) in pixels. Parameters: Name Type Argument Default Description e Event &lt;optional&gt; Mouse event object. If not provided, the returning value will use the previously-cached value (updated the last time that the onMouseMove event was fired). ignoreScroll boolean &lt;optional&gt; false If set to true, the horizontal scroll position will not be added to the returning value. ignoreLock boolean &lt;optional&gt; false If set to true, it will ignore whether the cursor is being locked or not. Otherwise, if set to false and the cursor is locked, the returning value will only have in mind the position in the locking element. Source: CrossBase/input/CB_Mouse.js, line 314 Returns: Returns the X coordinate (horizontal position) of the mouse (relative to the window in desktop) in pixels. Type number &lt;static&gt; getXMovement( [e]) → {number} Returns the current X (horizontal) movement (useful when the mouse pointer is locked) in pixels. More information: MouseEvent.movementX. Parameters: Name Type Argument Description e Event &lt;optional&gt; Mouse event object. If not provided, the returning value will use the previously-cached value (updated the last time that the onMouseMove event was fired). Source: CrossBase/input/CB_Mouse.js, line 474 Returns: Returns the current X (horizontal) movement (useful when the mouse pointer is locked) in pixels. Type number &lt;static&gt; getXRelative(x [, ignoreScroll]) → {number} Gets and returns the current X coordinate (horizontal position) in pixels of the mouse relative to a given X position. The returning value uses the previously-cached value (updated the last time that the onMouseMove event was fired). Parameters: Name Type Argument Default Description x number The X coordinate (horizontal position) in pixels. The returning value will be calculated relatively to it. ignoreScroll boolean &lt;optional&gt; false If set to true, the horizontal scroll position will not be added to the returning value. Source: CrossBase/input/CB_Mouse.js, line 434 To Do: Think about allowing to define an &quot;e&quot; parameter with the mouse event object. Returns: Returns the current X coordinate (horizontal position) in pixels of the mouse relative to a given X position. Type number &lt;static&gt; getY( [e] [, ignoreScroll] [, ignoreLock]) → {number} Gets and returns the Y coordinate (vertical position) of the mouse (relative to the window in desktop) in pixels. Parameters: Name Type Argument Default Description e Event &lt;optional&gt; Mouse event object. If not provided, the returning value will use the previously-cached value (updated the last time that the onMouseMove event was fired). ignoreScroll boolean &lt;optional&gt; false If set to true, the vertical scroll position will not be added to the returning value. ignoreLock boolean &lt;optional&gt; false If set to true, it will ignore whether the cursor is being locked or not. Otherwise, if set to false and the cursor is locked, the returning value will only have in mind the position in the locking element. Source: CrossBase/input/CB_Mouse.js, line 374 Returns: Returns the Y coordinate (vertical position) of the mouse (relative to the window in desktop) in pixels. Type number &lt;static&gt; getYMovement( [e]) → {number} Returns the current Y (vertical) movement (useful when the mouse pointer is locked) in pixels. More information: MouseEvent.movementY. Parameters: Name Type Argument Description e Event &lt;optional&gt; Mouse event object. If not provided, the returning value will use the previously-cached value (updated the last time that the onMouseMove event was fired). Source: CrossBase/input/CB_Mouse.js, line 488 Returns: Returns the current Y (vertical) movement (useful when the mouse pointer is locked) in pixels. Type number &lt;static&gt; getYRelative(y [, ignoreScroll]) → {number} Gets and returns the current Y coordinate (vertical position) in pixels of the mouse relative to a given Y position. The returning value uses the previously-cached value (updated the last time that the onMouseMove event was fired). Parameters: Name Type Argument Default Description y number The Y coordinate (vertical position) in pixels. The returning value will be calculated relatively to it. ignoreScroll boolean &lt;optional&gt; false If set to true, the vertical scroll position will not be added to the returning value. Source: CrossBase/input/CB_Mouse.js, line 455 To Do: Think about allowing to define an &quot;e&quot; parameter with the mouse event object. Returns: Returns the current Y coordinate (vertical position) in pixels of the mouse relative to a given Y position. Type number &lt;static&gt; hide( [element] [, recursive]) Hides the mouse cursor in a given DOM element by changing its internal CSS code of the style.cursor property. Parameters: Name Type Argument Default Description element Element &lt;optional&gt; document.body If a DOM element is given, the mouse cursor will be hidden when it is over this DOM element. Otherwise, it will be hidden in the whole document (using document.body as element). recursive boolean &lt;optional&gt; true If it is set to true, all the child DOM elements will also be affected. Source: CrossBase/input/CB_Mouse.js, line 1008 To Do: Check whether the path used in the &quot;url&quot; is right or not (now it uses the CB_scriptPath variable). &lt;static&gt; isLocked( [avoidCache]) → {boolean} Tells whether the mouse pointer is locked or not. More information: Pointer Lock API. Parameters: Name Type Argument Default Description avoidCache boolean &lt;optional&gt; false Used as the parameter to call the CB_Mouse.getLockElement function internally. Source: CrossBase/input/CB_Mouse.js, line 654 Returns: Returns whether the mouse pointer is locked or not. Type boolean &lt;static&gt; isLockSupported() → {boolean} Tells whether mouse pointer lock is supported or not. More information: Pointer Lock API. Source: CrossBase/input/CB_Mouse.js, line 638 Returns: Returns whether mouse pointer lock is supported or not. Type boolean &lt;static&gt; isOverCircle(centreX, centreY, radius [, element]) → {boolean} Tells whether the mouse is over a given circle or not. Parameters: Name Type Argument Description centreX number The X coordinate (horizontal position) of the center of the circle in pixels. centreY number The Y coordinate (vertical position) of the center of the circle in pixels. radius number The radius of the circle in pixels. element Element &lt;optional&gt; If a DOM element is given, the mouse coordinates will be calculated relatively to the position of this DOM element. Source: CrossBase/input/CB_Mouse.js, line 956 Returns: Returns whether the mouse is over the given circle or not. Type boolean &lt;static&gt; isOverElement(element) → {boolean} Tells whether the mouse is over a given DOM element or not. Parameters: Name Type Description element Element The DOM element where we want to know whether the mouse is over or not. Source: CrossBase/input/CB_Mouse.js, line 852 Returns: Returns whether the mouse is over the given DOM element or not. Type boolean &lt;static&gt; isOverEllipse(centreX, centreY, radiusX, radiusY [, rotation] [, rotationUseDegrees]) → {boolean} Tells whether the mouse is over a given ellipse or not. Parameters: Name Type Argument Default Description centreX number The &quot;X&quot; coordinate of the center of the ellipse. centreY number The &quot;Y&quot; coordinate of the center of the ellipse. radiusX number The X (horizontal) radius of the ellipse. radiusY number The Y (vertical) radius of the ellipse. rotation number &lt;optional&gt; 0 The ellipse rotation. The value given will be considered either degrees or radians depending on the given &quot;rotationUseDegrees&quot; parameter (by default, it is considered radians). Not implemented yet! rotationUseDegrees boolean &lt;optional&gt; false Defines whether the &quot;rotation&quot; given should be considered degrees or not (radians). Not implemented yet! Source: CrossBase/input/CB_Mouse.js, line 984 Returns: Returns whether the mouse is over the given ellipse or not. Type boolean &lt;static&gt; isOverLine(lineX1, lineY1, lineX2, lineY2 [, tolerance] [, element]) → {boolean} Tells whether the mouse is over a given line (infinite line) or not. Parameters: Name Type Argument Default Description lineX1 number The X coordinate (horizontal position) of the first pixel of the line. lineY1 number The Y coordinate (vertical position) of the first pixel of the line. lineX2 number The X coordinate (horizontal position) of the second pixel of the line. lineY2 number The Y coordinate (vertical position) of the second pixel of the line. tolerance number &lt;optional&gt; 1 The amount of loss of precision we can tolerate to consider a collision. element Element &lt;optional&gt; If a DOM element is given, the mouse coordinates will be calculated relatively to the position of this DOM element. Source: CrossBase/input/CB_Mouse.js, line 870 To Do: Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). Returns: Returns whether the mouse is over the given line (infinite line) or not. Type boolean &lt;static&gt; isOverRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight [, element]) → {boolean} Tells whether the mouse is over a given rectangle or not. Parameters: Name Type Argument Description rectangleX number The X coordinate (horizontal position) of the first pixel of the rectangle (upper left corner). rectangleY number The Y coordinate (vertical position) of the first pixel of the rectangle (upper left corner). rectangleWidth number The width of the rectangle in pixels. rectangleHeight number The height of the rectangle in pixels. element Element &lt;optional&gt; If a DOM element is given, the mouse coordinates will be calculated relatively to the position of this DOM element. Source: CrossBase/input/CB_Mouse.js, line 930 Returns: Returns whether the mouse is over the given rectangle or not. Type boolean &lt;static&gt; isOverSegment(lineX1, lineY1, lineX2, lineY2 [, tolerance] [, element]) → {boolean} Tells whether the mouse is over a given line segment or not. Parameters: Name Type Argument Default Description lineX1 number The X coordinate (horizontal position) of the first pixel of the line segment. lineY1 number The Y coordinate (vertical position) of the first pixel of the line segment. lineX2 number The X coordinate (horizontal position) of the second pixel of the line segment. lineY2 number The Y coordinate (vertical position) of the second pixel of the line segment. tolerance number &lt;optional&gt; 1 The amount of loss of precision we can tolerate to consider a collision. element Element &lt;optional&gt; If a DOM element is given, the mouse coordinates will be calculated relatively to the position of this DOM element. Source: CrossBase/input/CB_Mouse.js, line 901 To Do: Think about using a &quot;width&quot; parameter (apart from the &quot;tolerance&quot; parameter). Returns: Returns whether the mouse is over the given line segment or not. Type boolean &lt;static&gt; lock( [target], callbackOk, callbackError) → {Element|null} Locks the mouse pointer (if possible). More information: Pointer Lock API. Parameters: Name Type Argument Default Description target Element &lt;optional&gt; document.body The DOM element that the mouse pointer will be locked to. callbackOk function Function callback that will be called (without parameters) if the mouse pointer could be locked successfully. callbackError function Function callback that will be called (without parameters) if the mouse pointer could not be locked successfully. Source: CrossBase/input/CB_Mouse.js, line 712 Returns: Returns the current lock element for the mouse pointer (if any) or null otherwise. Type Element | null &lt;static&gt; normalizeEvent(e) → {Event} Tries to return the given mouse event object with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the CB_Events.normalize function internally. Some properties added or affected could be deltaX, deltaY, deltaZ, force, clientX, clientY, etc. Parameters: Name Type Description e Event Mouse event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). Source: CrossBase/input/CB_Mouse.js, line 127 To Do: Add more properties and methods to normalize (pageX, pageY, offsetX, offsetY, etc.). Returns: Returns the mouse event object normalized. Type Event &lt;static&gt; onButtonDown(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a mouse button is down (onMouseDown event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 546 &lt;static&gt; onButtonUp(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a mouse button is up (onMouseUp event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 560 &lt;static&gt; onClick(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a click happens (onClick event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 518 &lt;static&gt; onDblClick(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a click happens (onDblClick event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 532 &lt;static&gt; onLeave(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a mouse leaves a DOM element (onMouseLeave event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; window The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 574 &lt;static&gt; onLockChange(callbackFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the mouse pointer lock functionality changes its state (it has been either locked or unlocked, using pointerlockchange}, mozpointerlockchange or webkitpointerlockchange event) or removes it. More information: Pointer Lock API. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/input/CB_Mouse.js, line 776 &lt;static&gt; onLockError(callbackFunction [, keepOldFunction] [, useCapture]) Sets a function to execute when the mouse pointer fails to either lock or unlock (using pointerlockerror, mozpointerlockerror or webkitpointerlockerror event) or removes it. More information: Pointer Lock API. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. Source: CrossBase/input/CB_Mouse.js, line 791 &lt;static&gt; onMove(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a click happens (onMouseMove event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 504 &lt;static&gt; onOut(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a mouse gets out of a DOM element (onMouseOut event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 602 &lt;static&gt; onOver(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when a mouse is over a DOM element (onMouseOver event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 588 &lt;static&gt; onWheel(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the mouse wheel is used (onWheel, onMouseWheel or DOMMouseScroll event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the mouse event object (already normalized by the CB_Mouse.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Mouse.js, line 616 &lt;static&gt; restore( [element] [, recursive]) Restores (unhides) the mouse cursor in a given DOM element by changing its internal CSS code of the style.cursor property to the default one (using &quot;default&quot; as the CSS code). Parameters: Name Type Argument Default Description element Element &lt;optional&gt; document.body If a DOM element is given, the mouse cursor will be restored (unhidden) when it is over this DOM element. Otherwise, it will be restored (unhidden) in the whole document (using document.body as the &quot;element&quot;). recursive boolean &lt;optional&gt; true If it is set to true, all the child DOM elements will also be affected. Source: CrossBase/input/CB_Mouse.js, line 1026 &lt;static&gt; setCSS( [CSS] [, element] [, recursive]) Sets the desired CSS code for the style.cursor property of the given DOM element. Parameters: Name Type Argument Default Description CSS string &lt;optional&gt; &quot;&quot; CSS code for the style.cursor property of the given DOM element. If not given, an empty string will be used. element Element &lt;optional&gt; document.body If a DOM element is given, the CSS code updated will affect the given DOM element. Otherwise, it will affect the whole document (using document.body as the &quot;element&quot;). recursive boolean &lt;optional&gt; true If it is set to true, all the child DOM elements will also be affected. Source: CrossBase/input/CB_Mouse.js, line 1049 &lt;static&gt; unlock() → {boolean} Unlocks the mouse pointer (if possible). More information: Pointer Lock API. Source: CrossBase/input/CB_Mouse.js, line 750 Returns: Returns true if the mouse pointer has been unlocked or false otherwise. Type boolean &lt;static&gt; wasLocked() → {boolean} Tells whether the mouse pointer was locked before or not when the CB_Mouse.isLocked function was called the last time. More information: Pointer Lock API. Source: CrossBase/input/CB_Mouse.js, line 678 Returns: Returns whether the mouse pointer was locked before or not when the CB_Mouse.isLocked function was called the last time. Type boolean × Search results Close "},"CB_Mouse.CursorImage.html":{"id":"CB_Mouse.CursorImage.html","title":"Namespace: CursorImage","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CursorImage CB_Mouse. CursorImage Property that keeps an object to manage the mouse cursor using a DOM element containing an image for clients that do not support changing the cursor image by CSS. Caution: Performance could be dramatically decreased while using this workaround. Source: CrossBase/input/CB_Mouse.js, line 27 Methods &lt;static&gt; get() → {Element} Gets the DIV element that contains the IMG element of the fake cursor (if any). Source: CrossBase/input/CB_Mouse.js, line 1190 Returns: Returns the DIV element that contains the IMG element of the fake cursor (if any). Type Element &lt;static&gt; getImage() → {Element} Gets the IMG element of the fake cursor (if any). Source: CrossBase/input/CB_Mouse.js, line 1201 Returns: Returns the IMG element of the fake cursor (if any). Type Element &lt;static&gt; hide( [showNormalCursor]) Hides the fake cursor image. Parameters: Name Type Argument Default Description showNormalCursor boolean &lt;optional&gt; true If set to true, restores (shows) the system cursor (calls the CB_Mouse.restore function internally). Source: CrossBase/input/CB_Mouse.js, line 1223 &lt;static&gt; isShowing() → {boolean} Tells whether the fake cursor is showing or not Source: CrossBase/input/CB_Mouse.js, line 1212 Returns: Returns whether the fake cursor is showing or not. Type boolean &lt;static&gt; move( [x] [, y]) Moves the fake cursor image (if it is not hidden). Automatically called when the onMouseMove event is fired. Parameters: Name Type Argument Default Description x number &lt;optional&gt; CB_Mouse.getX(null, false) The X coordinate (horizontal position) in pixels where the fake cursor image wants to be moved to. If not provided, it will use the value returned by calling CB_Mouse.getX(null, false) internally. y number &lt;optional&gt; CB_Mouse.getY(null, false) The Y coordinate (vertical position) in pixels where the fake cursor image wants to be moved to. If not provided, it will use the value returned by calling CB_Mouse.getY(null, false) internally. Source: CrossBase/input/CB_Mouse.js, line 1242 &lt;static&gt; set( [showCursorImage] [, cursorImage] [, cursorImageWidth] [, cursorImageHeight] [, hideNormalCursor] [, isSprite] [, numberOfFrames] [, framesMs] [, divElement] [, imageElement]) Uses an IMG element inside a DIV element (fakes the cursor) to simulate the mouse cursor (following its movements). If it was already called before and a fake cursor is already being used, the CB_Mouse.CursorImage.hide function must be called before in order to start using a different fake cursor image. Caution: Performance could be dramatically decreased while using this workaround. Parameters: Name Type Argument Default Description showCursorImage boolean &lt;optional&gt; true If set to true and a valid cursor image is given, the fake cursor functionality will be used. Otherwise, the fake cursor will stop being used. cursorImage string &lt;optional&gt; If a valid image path is given and &quot;showCursorImage&quot; is set to true, the fake cursor functionality will be used with the given image. Otherwise, the fake cursor will stop being used. cursorImageWidth number &lt;optional&gt; 32 Width in pixels of the cursor image. cursorImageHeight number &lt;optional&gt; 32 Height in pixels of the cursor image. hideNormalCursor boolean &lt;optional&gt; true If set to true, hides the system cursor (calls the CB_Mouse.hide function internally). Otherwise, shows the system cursor (calls the CB_Mouse.restore function internally). isSprite boolean &lt;optional&gt; false Defines whether the cursor will be animated (using sprites) or not. If so, the cursorImage must be an image containing sprites horizontally (their individual width is defined by the &quot;cursorImageWidth&quot; parameter). Once the last sprite is reached, it returns to the first one automatically and continues to the next one again (without stopping). numberOfFrames number &lt;optional&gt; 1 Number of frames (sprites) being used from the cursor image (&quot;cursorImage&quot; parameter). Used when the &quot;isSprite&quot; parameter is set to true. framesMs number &lt;optional&gt; 100 Number of milliseconds between each frame (between one sprite and next one). Used when the &quot;isSprite&quot; parameter is set to true. divElement Element &lt;optional&gt; CB_Elements.id('CB_fakeCursorImageDiv') The ID of the DIV element that will contain the image of the fake cursor (uses a DOM element with &quot;CB_fakeCursorImageDiv&quot; ID by default). imageElement Element &lt;optional&gt; CB_Elements.id('CB_fakeCursorImage') The ID of the IMG element that will contain the fake cursor (uses a DOM element with &quot;CB_fakeCursorImage&quot; ID by default). Source: CrossBase/input/CB_Mouse.js, line 1092 To Do: Allow defining an &quot;onMove&quot; parameter (a callback) to be able to call the &quot;move&quot; method with non-default parameters, etc. × Search results Close "},"CB_Net.html":{"id":"CB_Net.html","title":"Namespace: CB_Net","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Net CB_Net Static class to manage things related to the net. It will return itself if it is tried to be instantiated. Source: CrossBase/net/CB_Net.js, line 7 Namespaces Fetch REST Sockets XHR Methods &lt;static&gt; combineURIParameters() Alias for CB_combineURIParameters. Source: CrossBase/net/CB_Net.js, line 321 See: CB_combineURIParameters &lt;static&gt; combineURLParameters() Alias for CB_Net.combineURIParameters. Source: CrossBase/net/CB_Net.js, line 316 See: CB_Net.combineURIParameters &lt;static&gt; getHashParameters( [URI] [, exclude] [, includeOnly] [, includeIfNotExists] [, trim]) → {string} Gets all the hash parameters (names and their values) from a given URI or from the current URL. For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;parameter2=value2#hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot;, it will return &quot;hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot; (using the default options). Parameters: Name Type Argument Default Description URI string &lt;optional&gt; window.location.href The URI that we want to work with. If not provided, it will try to use the current URL (by using window.location.href). exclude array &lt;optional&gt; A numeric array containing the name of the parameters that we want to exclude in the returned string. It will exclude them even if they are contained in the given &quot;includeOnly&quot; parameter (if any). includeOnly array &lt;optional&gt; A numeric array containing the name of the parameters that we want to include in the returned string. If provided, it will only include these ones to the returned string (unless they are included in the &quot;exclude&quot; parameter). includeIfNotExists boolean &lt;optional&gt; false If it is set to true and an array is given as the &quot;includeOnly&quot; parameter, it will add the parameters in the &quot;includeOnly&quot; array (with empty values) in the returned string even when they did not exist in the original URI provided. trim boolean &lt;optional&gt; true It will use this option when it calls the CB_Net.getURIParameters function internally. Source: CrossBase/net/CB_Net.js, line 215 Returns: An empty string will be returned if no parameters can be found. Type string &lt;static&gt; getHashValue(index [, trim] [, URI]) → {string} Gets the value of a specific hash (string after &quot;#&quot;) parameter from the current URL or a desired URI. For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;parameter2=value2#hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot; and the index given is &quot;hash_parameter1&quot;, it will return &quot;hash_value1&quot; (using the default options). Parameters: Name Type Argument Default Description index string The name of the parameter whose value we want to get. trim boolean &lt;optional&gt; true It will trim the value (using CB_Net.getParameter internally) before returning it. URI string &lt;optional&gt; window.location.href The URI that we want to work with. If not provided, it will try to use the current URL (by using window.location.href). Source: CrossBase/net/CB_Net.js, line 310 Returns: An empty string will be returned if the value of the given parameter cannot be found. Type string &lt;static&gt; getParameter(index [, trim] [, URI] [, firstDelimiter] [, lastDelimiter] [, concatenator] [, nameValueSeparator]) → {string} Gets the value of a specific URI parameter (query or hash), respecting GET/URL rules by default, from the current URL or a desired one (with the given delimiters). For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;parameter2=value2#hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot; and the index given is &quot;parameter1&quot;, it will return &quot;value1&quot; (using the default options). Parameters: Name Type Argument Default Description index string The name of the parameter whose value we want to get. trim boolean &lt;optional&gt; true It will trim the value (using CB_trim internally) before returning it. URI string &lt;optional&gt; window.location.href The URI that we want to work with. If not provided, it will try to use the current URL (by using window.location.href). firstDelimiter string &lt;optional&gt; '?' The string that indicates where the parameters start. If it is not provided, it will be &quot;?&quot; as default. If not provided and &quot;lastDelimiter&quot; is not provided either, it will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. lastDelimiter string &lt;optional&gt; undefined|'#' The string that indicates where the parameters end. If not provided and &quot;firstDelimiter&quot; is provided, it will stop at the end of the given URI. If it is not provided and &quot;firstDelimiter&quot; is not provided either, &quot;firstDelimiter&quot; will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. concatenator string &lt;optional&gt; '&amp;' The string that joints the different parameters. nameValueSeparator string &lt;optional&gt; '=' The string that is the separator for the parameters and their values. Source: CrossBase/net/CB_Net.js, line 235 Returns: An empty string will be returned if the value of the given parameter cannot be found. Type string &lt;static&gt; getURIParameters( [URI] [, exclude] [, includeOnly] [, includeIfNotExists] [, trim] [, firstDelimiter] [, lastDelimiter] [, concatenator] [, nameValueSeparator]) → {string} Gets all the &quot;GET&quot; (query) parameters (names and their values) from a given URI or from the current URL. For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;parameter2=value2#hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot;, it will return &quot;parameter1=value1&amp;parameter2=value2&quot; (using the default options). Parameters: Name Type Argument Default Description URI string &lt;optional&gt; window.location.href The URI that we want to work with. If not provided, it will try to use the current URL (by using window.location.href). exclude array &lt;optional&gt; A numeric array containing the name of the parameters that we want to exclude in the returned string. It will exclude them even if they are contained in the given &quot;includeOnly&quot; parameter (if any). includeOnly array &lt;optional&gt; A numeric array containing the name of the parameters that we want to include in the returned string. If provided, it will only include these ones to the returned string (unless they are included in the &quot;exclude&quot; parameter). includeIfNotExists boolean &lt;optional&gt; false If it is set to true and an array is given as the &quot;includeOnly&quot; parameter, it will add the parameters in the &quot;includeOnly&quot; array (with empty values) in the returned string even when they did not exist in the original URI provided. trim boolean &lt;optional&gt; true Defines whether we want to trim the spaces around the values or not. firstDelimiter string &lt;optional&gt; '?' The string that indicates where the parameters start. If it is not provided, it will be &quot;?&quot; as default. If not provided and &quot;lastDelimiter&quot; is not provided either, it will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. lastDelimiter string &lt;optional&gt; undefined|'#' The string that indicates where the parameters end. If not provided and &quot;firstDelimiter&quot; is provided, it will stop at the end of the given URI. If it is not provided and &quot;firstDelimiter&quot; is not provided either, &quot;firstDelimiter&quot; will be &quot;?&quot; and &quot;lastDelimiter&quot; will be &quot;#&quot;. concatenator string &lt;optional&gt; '&amp;' The string that joints the different parameters. nameValueSeparator string &lt;optional&gt; '=' The string that is the separator for the parameters and their values. Source: CrossBase/net/CB_Net.js, line 122 Returns: An empty string will be returned if no parameters can be found. Type string &lt;static&gt; getURIValue(index [, trim] [, URI]) → {string} Gets the value of a specific URI &quot;GET&quot; parameter (query) from the current URL or a desired URI. For example, if the URI provided is &quot;http://whatever.com/index.html?parameter1=value1&amp;parameter2=value2#hash_parameter1=hash_value1&amp;hash_parameter2=hash_value2&quot; and the index given is &quot;parameter1&quot;, it will return &quot;value1&quot; (using the default options). Parameters: Name Type Argument Default Description index string The name of the parameter whose value we want to get. trim boolean &lt;optional&gt; true It will trim the value (using CB_Net.getParameter internally) before returning it. URI string &lt;optional&gt; window.location.href The URI that we want to work with. If not provided, it will try to use the current URL (by using window.location.href). Source: CrossBase/net/CB_Net.js, line 293 Returns: An empty string will be returned if the value of the given parameter cannot be found. Type string &lt;static&gt; URIDecode(URI) → {string} Encodes a given URI. Uses the native decodeURI function internally if available or fallbacks to the native unescape function otherwise. Parameters: Name Type Description URI string | number The URI that we want to decode. Normally, it should be either a string or a number. Source: CrossBase/net/CB_Net.js, line 99 To Do: Think about using another thing since unescape maybe is not a good fallback. Probably a polyfill to simulate the decodeURI function. Returns: Type string &lt;static&gt; URIEncode(URI) → {string} Encodes a given URI. Uses the native encodeURI function internally if available or fallbacks to the native escape function otherwise. Parameters: Name Type Description URI string | number The URI that we want to encode. Normally, it should be either a string or a number. Source: CrossBase/net/CB_Net.js, line 80 To Do: Think about using another thing since escape maybe is not a good fallback. Probably a polyfill to simulate the encodeURI function. Returns: Type string &lt;static&gt; URIValueDecode(value) → {string} Decodes a given URI value. Uses the native decodeURIComponent function internally if available or fallbacks to the native unescape function otherwise. Parameters: Name Type Description value string | number The value that we want to decode. Normally, it should be either a string or a number. Source: CrossBase/net/CB_Net.js, line 61 To Do: Think about using another thing since unescape maybe is not a good fallback. Probably a polyfill to simulate the decodeURIComponent function. Returns: Type string &lt;static&gt; URIValueEncode(value) → {string} Encodes a given URI value. Uses the native encodeURIComponent function internally if available or fallbacks to the native escape function otherwise. Parameters: Name Type Description value string | number The value that we want to encode. Normally, it should be either a string or a number. Source: CrossBase/net/CB_Net.js, line 42 To Do: Think about using another thing since escape maybe is not a good fallback. Probably a polyfill to simulate the encodeURIComponent function. Returns: Type string &lt;static&gt; URLDecode() Alias for CB_Net.URIDecode. Source: CrossBase/net/CB_Net.js, line 87 See: CB_Net.URIDecode &lt;static&gt; URLEncode() Alias for CB_Net.URIEncode. Source: CrossBase/net/CB_Net.js, line 68 See: CB_Net.URIEncode &lt;static&gt; URLValueDecode() Alias for CB_Net.URIValueDecode. Source: CrossBase/net/CB_Net.js, line 49 See: CB_Net.URIValueDecode &lt;static&gt; URLValueEncode() Alias for CB_Net.URIValueEncode. Source: CrossBase/net/CB_Net.js, line 30 See: CB_Net.URIValueEncode × Search results Close "},"CB_Net.Fetch.html":{"id":"CB_Net.Fetch.html","title":"Namespace: Fetch","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Fetch CB_Net. Fetch Static class to manage things related to the Fetch API. It will return itself if it is tried to be instantiated. Source: CrossBase/net/fetch/CB_Net_Fetch.js, line 14 Methods &lt;static&gt; get(resource [, init]) → {Promise} Function that points to the fetch method. If the Fetch API is not supported natively, the fetch function will be a polyfill. Parameters: Name Type Argument Description resource string | Request First parameter of the fetch method. init Object &lt;optional&gt; Second parameter of the fetch method. Source: CrossBase/net/fetch/CB_Net_Fetch.js, line 40 Returns: Type Promise × Search results Close "},"CB_Net.REST.html":{"id":"CB_Net.REST.html","title":"Namespace: REST","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: REST CB_Net. REST Static class to manage REST services and related. It will return itself if it is tried to be instantiated. Source: CrossBase/net/REST/CB_Net_REST.js, line 13 To Do: Think about accepting an onAbort function as option (with also default and permanent). Members &lt;static&gt; actions :Object List of REST actions. Each property name is the name of the action and its value is a CB_Net.REST.actionProcess_ACTIONS object. Used by the CB_Net.REST.actionProcess function. Type: Object Default Value: {} Source: CrossBase/net/REST/CB_Net_REST.js, line 413 &lt;static&gt; allowedSuccessStatuses_DEFAULT :array Default &quot;allowedSuccessStatuses&quot;, containing the statuses to considerer a successful REST action (must be a numeric array of integers). Used by the CB_Net.REST.actionProcess function. Type: array Default Value: [200,201,206] Source: CrossBase/net/REST/CB_Net_REST.js, line 271 &lt;static&gt; allowedSuccessStatuses_PERMANENT :array Permanent values for the &quot;allowedSuccessStatuses&quot; parameter, containing the statuses to considerer a successful REST action (must be a numeric array of integers). Used by the CB_Net.REST.actionProcess function. This is permanent for each REST action. Type: array Default Value: [] Source: CrossBase/net/REST/CB_Net_REST.js, line 262 &lt;static&gt; avoidProxy_DEFAULT :boolean Default value when the &quot;avoidProxy&quot; parameter is not available. Used by the CB_Net.REST.actionProcess function. NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. Type: boolean Source: CrossBase/net/REST/CB_Net_REST.js, line 36 &lt;static&gt; callbackBefore_DEFAULT :CB_Net.REST.actionProcess_CALLBACK_BEFORE Default &quot;callbackBefore&quot;, containing a callback function before performing each REST action returning a boolean (to decide whether to do it or not). The function assigned by default returns true. Used by the CB_Net.REST.actionProcess function. Type: CB_Net.REST.actionProcess_CALLBACK_BEFORE Source: CrossBase/net/REST/CB_Net_REST.js, line 302 &lt;static&gt; callbackBefore_PERMANENT :CB_Net.REST.actionProcess_CALLBACK_BEFORE Permanent callback function before performing each REST action returning a boolean (to decide whether to do it or not). Executed before the default or the set &quot;callbackBefore&quot; function (if any). The function assigned by default returns true. Used by the CB_Net.REST.actionProcess function. This is permanent for each REST action. Type: CB_Net.REST.actionProcess_CALLBACK_BEFORE Source: CrossBase/net/REST/CB_Net_REST.js, line 289 &lt;static&gt; callbackError_DEFAULT :CB_Net.REST.actionProcess_CALLBACK_ERROR Default &quot;callbackError&quot;, containing a callback function when an error happens processing the REST action. Used by the CB_Net.REST.actionProcess function. Type: CB_Net.REST.actionProcess_CALLBACK_ERROR Source: CrossBase/net/REST/CB_Net_REST.js, line 374 &lt;static&gt; callbackError_PERMANENT :CB_Net.REST.actionProcess_CALLBACK_ERROR Permanent callback function when an error happens processing any REST action. Used by the CB_Net.REST.actionProcess function. Executed before the default or the set &quot;callbackError&quot; function (if any). This is permanent for each REST action. Type: CB_Net.REST.actionProcess_CALLBACK_ERROR Source: CrossBase/net/REST/CB_Net_REST.js, line 361 &lt;static&gt; callbackOk_DEFAULT :CB_Net.REST.actionProcess_CALLBACK_OK Default &quot;callbackOk&quot;, containing a callback function when the REST action has been successful. Used by the CB_Net.REST.actionProcess function. Type: CB_Net.REST.actionProcess_CALLBACK_OK Source: CrossBase/net/REST/CB_Net_REST.js, line 339 &lt;static&gt; callbackOk_PERMANENT :CB_Net.REST.actionProcess_CALLBACK_OK Permanent callback function when each REST action has been successful. Used by the CB_Net.REST.actionProcess function. Executed before the default or the set &quot;callbackOk&quot; function (if any). This is permanent for each REST action. Type: CB_Net.REST.actionProcess_CALLBACK_OK Source: CrossBase/net/REST/CB_Net_REST.js, line 326 &lt;static&gt; data_DEFAULT :CB_Net.REST.actionProcess_DATA Default &quot;data&quot; for REST actions (must return a string in URL/GET parameters format or a JSON format string). The function assigned by default returns an empty string (&quot;&quot;). Used by the CB_Net.REST.actionProcess function. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since CB_Net.REST.actionProcess will use the CB_combineAutomatically function to combine them. NOTE: remember to use CB_Net.URLValueEncode if needed. Type: CB_Net.REST.actionProcess_DATA Source: CrossBase/net/REST/CB_Net_REST.js, line 249 &lt;static&gt; data_PERMANENT :CB_Net.REST.actionProcess_DATA Permanent function (must return a string in URL/GET parameters format or a JSON format string) to execute the same way as the &quot;data&quot; parameter. The function assigned by default returns an empty string (&quot;&quot;). Used by the CB_Net.REST.actionProcess function. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since CB_Net.REST.actionProcess will use the CB_combineAutomatically function to combine them. This is permanent for each REST action. NOTE: remember to use CB_Net.URLValueEncode if needed. Type: CB_Net.REST.actionProcess_DATA Source: CrossBase/net/REST/CB_Net_REST.js, line 236 &lt;static&gt; dataURL_DEFAULT :CB_Net.REST.actionProcess_DATA_URL Default &quot;dataURL&quot; for REST actions (must return a string in URL/GET parameters format). The function assigned by default returns an empty string (&quot;&quot;). Used by the CB_Net.REST.actionProcess function. NOTE: remember to use CB_Net.URLValueEncode if needed. Type: CB_Net.REST.actionProcess_DATA_URL Source: CrossBase/net/REST/CB_Net_REST.js, line 214 &lt;static&gt; dataURL_PERMANENT :CB_Net.REST.actionProcess_DATA_URL Permanent function (must return a string in URL/GET parameters format) to execute the same way as the &quot;dataURL&quot; parameter. The function assigned by default returns an empty string (&quot;&quot;). Used by the CB_Net.REST.actionProcess function. The returning data will be placed in the beginning of the URL, followed by the rest of the &quot;dataURL&quot; desired (if any). NOTE: remember to use CB_Net.URLValueEncode if needed. This is permanent for each REST action. Type: CB_Net.REST.actionProcess_DATA_URL Source: CrossBase/net/REST/CB_Net_REST.js, line 201 &lt;static&gt; forceJSON_DEFAULT :boolean Tells whether to force JSON response by default or not. Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;forceJSON&quot; option. Type: boolean Default Value: true Source: CrossBase/net/REST/CB_Net_REST.js, line 98 &lt;static&gt; getHeaders_DEFAULT :boolean Tells whether get response HTTP headers by default or not. Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;getHeaders&quot; option. Type: boolean Source: CrossBase/net/REST/CB_Net_REST.js, line 107 &lt;static&gt; getHeadersOneDimension_DEFAULT :boolean Tells whether to get response HTTP headers in one-dimension array by default or not (needs &quot;getHeaders&quot; set to true). Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;getHeadersOneDimension&quot; option. Type: boolean Source: CrossBase/net/REST/CB_Net_REST.js, line 116 &lt;static&gt; getHeadersOneDimensionValues_DEFAULT :boolean Tells whether to get response HTTP headers values in one-dimension (just one value per key) by default or not (needs &quot;getHeaders&quot; set to true). Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;getHeadersOneDimensionValues&quot; option. Type: boolean Source: CrossBase/net/REST/CB_Net_REST.js, line 125 &lt;static&gt; headers_DEFAULT :CB_Net.REST.actionProcess_HEADERS Default &quot;headers&quot; for REST actions (must be a function returning a CB_Net.XHR.HEADERS object with the HTTP headers). The function assigned by default returns { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot; }. Used by the CB_Net.REST.actionProcess function. Type: CB_Net.REST.actionProcess_HEADERS Source: CrossBase/net/REST/CB_Net_REST.js, line 159 &lt;static&gt; headers_PERMANENT :CB_Net.REST.actionProcess_HEADERS Permanent function (must be a function returning a CB_Net.XHR.HEADERS object with the HTTP headers) to execute the same way as the &quot;headers&quot; parameter. The function assigned by default returns { &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; }. Used by the CB_Net.REST.actionProcess function. This is permanent for each REST action. Type: CB_Net.REST.actionProcess_HEADERS Source: CrossBase/net/REST/CB_Net_REST.js, line 143 &lt;static&gt; method_DEFAULT :string Default &quot;method&quot; for REST actions. Used by the CB_Net.REST.actionProcess function. Type: string Default Value: GET Source: CrossBase/net/REST/CB_Net_REST.js, line 45 &lt;static&gt; responseType_DEFAULT :string Default &quot;responseType&quot; for REST actions when it is not provided and it is not null. Used by the CB_Net.REST.actionProcess function. Type: string Default Value: text Source: CrossBase/net/REST/CB_Net_REST.js, line 54 &lt;static&gt; routeWildcardData_DEFAULT :CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA Default &quot;routeWildcardData&quot; for REST actions (must be a function returning a JSON object or null if we do not want to modify the route). The function assigned by default returns null. Used by the CB_Net.REST.actionProcess function. Type: CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA Source: CrossBase/net/REST/CB_Net_REST.js, line 85 &lt;static&gt; routeWildcardData_PERMANENT :CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA Permanent function (must return a JSON object or null if we do not want to modify it) to execute the same way as the &quot;routeWildcardData&quot; parameter (if other &quot;routeWildcardData&quot; are provided or set, they will be executed before this one). The function assigned by default returns null. Used by the CB_Net.REST.actionProcess function. This is permanent for each REST action. Type: CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA Source: CrossBase/net/REST/CB_Net_REST.js, line 72 &lt;static&gt; SERVER_URL_DEFAULT :string Defines the URL for the default REST server to use when the &quot;serverURL&quot; parameter is not available. Used by the CB_Net.XHR.callREST function as the default &quot;serverURL&quot; parameter. Type: string Default Value: http://localhost/CrossBrowdy/tests/net/fake_rest_server/index.php Source: CrossBase/net/REST/CB_Net_REST.js, line 24 &lt;static&gt; transparentHeaders_DEFAULT :boolean Tells whether get HTTP headers transparently from the server by default or not. Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;transparentHeaders&quot; option. Type: boolean Default Value: true Source: CrossBase/net/REST/CB_Net_REST.js, line 183 &lt;static&gt; transparentStatus_DEFAULT :boolean Tells whether get status transparently from the server by default or not. Used by the CB_Net.REST.actionProcess function when the REST action does not provided it and it is not null, as the &quot;transparentStatus&quot; option. Type: boolean Default Value: true Source: CrossBase/net/REST/CB_Net_REST.js, line 174 Methods &lt;static&gt; actionAbort(XHR) → {boolean} Cancels a REST action (by its AJAX/XHR request associated) by executing the &quot;abort&quot; method of the given XHR object (if available) and sets its &quot;aborted&quot; property to true if succeeds. When a REST action is aborted, the callbackOk functions associated (if any) will not be called (unless they have been called already). Parameters: Name Type Description XHR Object The XHR object that we want to abort. Source: CrossBase/net/REST/CB_Net_REST.js, line 601 Returns: Returns true if the &quot;abort&quot; method of the given XHR object could be called and the &quot;aborted&quot; property was set to true. Otherwise, returns false. Type boolean &lt;static&gt; actionAbortCancel(XHR) → {boolean} Tries to revert the abortion of a REST action (by its AJAX/XHR request associated) by setting the &quot;aborted&quot; property of the given XHR object to false. If this function is called before the &quot;callbackOk&quot; functions associated to the REST action (if any) are called, they could finally be called perhaps (depending on each case, could be different). Have in mind that, after calling CB_Net.REST.actionAbort, the &quot;abort&quot; method of the XHR object was probably called already (if available). Parameters: Name Type Description XHR Object The XHR object whose abortion we want to cancel. Source: CrossBase/net/REST/CB_Net_REST.js, line 614 Returns: Returns true if the &quot;aborted&quot; property was set to false. Otherwise, returns false. Type boolean &lt;static&gt; actionIsAborted(XHR) → {boolean} Returns whether a REST action is aborted or not (by its AJAX/XHR request associated). Parameters: Name Type Description XHR Object The XHR object that we want to check. Source: CrossBase/net/REST/CB_Net_REST.js, line 627 Returns: Returns true if the &quot;aborted&quot; property is set to true. Otherwise, returns false. Type boolean &lt;static&gt; actionProcess(actionName [, additionalData] [, XHR] [, serverURL] [, avoidProxy]) → {Object|null} Processes a desired REST action (which must be previously defined in the CB_Net.REST.actions object) by its name. NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. Parameters: Name Type Argument Description actionName string The name of the REST action that we want to perform. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * &lt;optional&gt; Any additional data desired. It will be passed as a parameter when different callbacks are called internally, as their &quot;additionalData&quot; parameter. XHR Object &lt;optional&gt; Used for the &quot;XHR&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. serverURL string &lt;optional&gt; Used for the &quot;serverURL&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. If provided, the value defined in the &quot;serverURL&quot; parameter of the REST action being performed (if any) will be ignored. avoidProxy boolean &lt;optional&gt; Used for the &quot;avoidProxy&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. If provided, the value defined in the &quot;avoidProxy&quot; parameter of the REST action being performed (if any) and the default one defined in CB_Net.REST.avoidProxy_DEFAULT (if any) will be both ignored. Source: CrossBase/net/REST/CB_Net_REST.js, line 444 Returns: Returns null if the CB_Net.XHR.callREST function is not called at all (because XHR is not supported or the REST action object cannot be found or the route is not well defined or the &quot;callbackBefore&quot; returns false, etc.). Otherwise, returns the same that the CB_Net.XHR.callREST function returns (called internally). Type Object | null Type Definitions actionProcess_ACTIONS Object that represents a REST action. Type: Object Properties: Name Type Argument Default Description route string The REST route (path). Belongs to the &quot;route&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. It is mandatory. callbackBefore CB_Net.REST.actionProcess_CALLBACK_BEFORE &lt;optional&gt; CB_Net.REST.callbackBefore_DEFAULT Callback run before performing the REST action which will decide whether to continue with it or not. avoidProxy boolean &lt;optional&gt; CB_Net.REST.avoidProxy_DEFAULT Belongs to the &quot;avoidProxy&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. routeWildcardData CB_Net.REST.actionProcess_ROUTE_WILDCARD_DATA &lt;optional&gt; CB_Net.REST.routeWildcardData_DEFAULT Callback returning an object that will be used for parsing the REST route. The object returned should follow the same rules as the &quot;JSONObject&quot; parameter of the CB_renderString function. dataURL CB_Net.REST.actionProcess_DATA_URL &lt;optional&gt; CB_Net.REST.dataURL_DEFAULT Belongs to the &quot;dataURL&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. data CB_Net.REST.actionProcess_DATA &lt;optional&gt; CB_Net.REST.data_DEFAULT Belongs to the &quot;data&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. headers CB_Net.REST.actionProcess_HEADERS &lt;optional&gt; CB_Net.REST.headers_DEFAULT Belongs to the &quot;headers&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. allowedSuccessStatuses array &lt;optional&gt; CB_Net.REST.allowedSuccessStatuses_DEFAULT Belongs to the &quot;allowedSuccessStatuses&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. callbackError CB_Net.REST.actionProcess_CALLBACK_ERROR &lt;optional&gt; CB_Net.REST.callbackError_DEFAULT Callback run when the REST action has not been performed successfully. callbackOk CB_Net.REST.actionProcess_CALLBACK_OK &lt;optional&gt; CB_Net.REST.callbackOk_DEFAULT Callback run when the REST action has been performed successfully. serverURL string &lt;optional&gt; CB_Net.REST.SERVER_URL_DEFAULT Belongs to the &quot;serverURL&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. method string &lt;optional&gt; CB_Net.REST.method_DEFAULT Belongs to the &quot;method&quot; parameter of the CB_Net.XHR.callREST function when it is called internally. responseType string &lt;optional&gt; CB_Net.REST.responseType_DEFAULT Belongs to the &quot;responseType&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.responseType_DEFAULT instead. forceJSON boolean &lt;optional&gt; CB_Net.REST.forceJSON_DEFAULT Belongs to the &quot;forceJSON&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.forceJSON_DEFAULT instead. getHeaders boolean &lt;optional&gt; CB_Net.REST.getHeaders_DEFAULT Belongs to the &quot;getHeaders&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.getHeaders_DEFAULT instead. getHeadersOneDimension boolean &lt;optional&gt; CB_Net.REST.getHeadersOneDimension_DEFAULT Belongs to the &quot;getHeadersOneDimension&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.getHeadersOneDimension_DEFAULT instead. getHeadersOneDimensionValues boolean &lt;optional&gt; CB_Net.REST.getHeadersOneDimensionValues_DEFAULT Belongs to the &quot;getHeadersOneDimensionValues&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.getHeadersOneDimensionValues_DEFAULT instead. transparentStatus boolean &lt;optional&gt; CB_Net.REST.transparentStatus_DEFAULT Belongs to the &quot;transparentStatus&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.transparentStatus_DEFAULT instead. transparentHeaders boolean &lt;optional&gt; CB_Net.REST.transparentHeaders_DEFAULT Belongs to the &quot;transparentHeaders&quot; parameter of the CB_Net.XHR.callREST function when it is called internally and will be sent even it is null. If it is undefined, it will use the value of CB_Net.REST.transparentHeaders_DEFAULT instead. Source: CrossBase/net/REST/CB_Net_REST.js, line 381 actionProcess_CALLBACK_BEFORE(actionName, additionalData) → {boolean} Callback that will be run before performing a REST action and must return a boolean defining whether we want to continue performing the action (returning true) or not (returning false). Parameters: Name Type Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 274 Returns: It should return true in the case that we want to continue performing the current REST action or false otherwise. Type boolean actionProcess_CALLBACK_ERROR(actionName [, XHR], additionalData) Callback that will be run when the REST action has been performed successfully. Parameters: Name Type Argument Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. XHR Object &lt;optional&gt; The XHR object that has been used to perform the REST action. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 346 actionProcess_CALLBACK_OK(actionName [, XHR], callbackError, additionalData) Callback that will be run when the REST action has been performed successfully. Parameters: Name Type Argument Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. XHR Object &lt;optional&gt; The XHR object that has been used to perform the REST action. callbackError CB_Net.REST.actionProcess_CALLBACK_ERROR The error callback function associated to the REST action being performed, just in case we want to call it. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 310 actionProcess_DATA(actionName, additionalData) → {string|Object} Callback returning the data (string or object) which will be used as the &quot;data&quot; parameter when the CB_Net.XHR.callREST function is called internally by CB_Net.REST.actionProcess. The values returned by all functions that are mean to return the data should always return the same type of data (all strinngs or all objects) since CB_Net.REST.actionProcess will use the CB_combineAutomatically function to combine them. Parameters: Name Type Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 221 Returns: It should return a string or object containing the data. Return null or an empty string (recommended) in the case that we do not want to add anything. The value returned (if any) will be used as the &quot;data&quot; parameter of the CB_Net.XHR.callREST function when it is called by CB_Net.REST.actionProcess internally. Type string | Object actionProcess_DATA_URL(actionName, additionalData) → {string} Callback returning a string containing the URL (GET) data which will be used as the &quot;dataURL&quot; parameter when the CB_Net.XHR.callREST function is called internally by CB_Net.REST.actionProcess. Parameters: Name Type Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 186 Returns: It should return a string containing the URL (GET) data. Return an empty string in the case that we do not want to add anything. The string returned (if any) will be used as the &quot;dataURL&quot; parameter of the CB_Net.XHR.callREST function when it is called by CB_Net.REST.actionProcess internally. Type string actionProcess_HEADERS(actionName, additionalData) → {CB_Net.XHR.HEADERS|null} Callback returning an object containing the HTTP headers which will be used as the &quot;headers&quot; parameter when the CB_Net.XHR.callREST function is called internally by CB_Net.REST.actionProcess. Parameters: Name Type Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 128 Returns: It should return an object containing the HTTP headers. Return null in the case that we do not want to add anything. The object returned (if any) will be used as the &quot;headers&quot; parameter of the CB_Net.XHR.callREST function when it is called by CB_Net.REST.actionProcess internally. Type CB_Net.XHR.HEADERS | null actionProcess_ROUTE_WILDCARD_DATA(actionName, additionalData) → {Object|null} Callback returning an object that will be used for parsing the REST route. The object returned should follow the same rules as the &quot;JSONObject&quot; parameter of the CB_renderString function. Parameters: Name Type Description actionName string The name of the REST action being performed. It should be the name of an index defined in the CB_Net.REST.actions object whose value should be a CB_Net.REST.actionProcess_ACTIONS object. additionalData * Any additional data associated to the REST action being performed (belongs to the &quot;additionalData&quot; parameter used when the CB_Net.REST.actionProcess function was called). Source: CrossBase/net/REST/CB_Net_REST.js, line 57 Returns: It should return an object containing the wildcards that will be used to parse the REST route of the action being performed. Return null in the case that we do not want to modify anything. The object returned (if any) will be used as the &quot;JSONObject&quot; parameter of the CB_renderString function (the first parameter will be the route which should be a string) when it is called by CB_Net.REST.actionProcess internally. Type Object | null × Search results Close "},"CB_Net.Sockets.html":{"id":"CB_Net.Sockets.html","title":"Namespace: Sockets","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: Sockets CB_Net. Sockets Static class to manage sockets and related. It will return itself if it is tried to be instantiated. It uses SockJS-client. Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 13 Namespaces SockJS × Search results Close "},"CB_Net.Sockets.SockJS.html":{"id":"CB_Net.Sockets.SockJS.html","title":"Namespace: SockJS","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: SockJS CB_Net.Sockets. SockJS Property that contains the functions and properties related with the SockJS client library. Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 17 Members &lt;static, readonly&gt; websocketLast :Object|null Keeps the last SockJS created. Type: Object | null Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 30 Methods &lt;static&gt; close( [websocket] [, onError]) → {undefined|false} Tries to close the websockets connection. Using the SockJS client library internally. Parameters: Name Type Argument Default Description websocket function &lt;optional&gt; CB_Net.Sockets.SockJS.websocketLast The SockJS object that we want to use. If not provided, it will try to use the last one created (if any) which is stored in CB_Net.Sockets.SockJS.websocketLast. onError function &lt;optional&gt; Function for the event &quot;onerror&quot; used by the SockJS object. If provided, it will replace the previous one (if any). Following the same rules as in the SockJS client library documentation. Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 134 Returns: Returns undefined (the same as the &quot;close&quot; function of the SockJS object) if the SockJS has been used or false otherwise. Type undefined | false &lt;static&gt; listen(serverURL [, onOpen] [, onClose] [, onMessage] [, onError] [, options] [, protocols]) → {Object|null} Creates the websockets object and sets the listeners. Using the SockJS client library internally. Parameters: Name Type Argument Description serverURL string The URL of the SockJS server. This will be used as the first parameter when it calls the constructor of SockJS internally. Following the same rules as in the SockJS client library documentation (the parameter is called &quot;url&quot;). onOpen function &lt;optional&gt; Function for the event &quot;onopen&quot; used by the SockJS object. Following the same rules as in the SockJS client library documentation. onClose function &lt;optional&gt; Function for the event &quot;onclose&quot; used by the SockJS object. Following the same rules as in the SockJS client library documentation. onMessage function &lt;optional&gt; Function for the event &quot;onmessage&quot; used by the SockJS object. Following the same rules as in the SockJS client library documentation. onError function &lt;optional&gt; Function for the event &quot;onerror&quot; used by the SockJS object. Following the same rules as in the SockJS client library documentation. options Object &lt;optional&gt; The desired options for the SockJS object. This will be used as the third parameter when it calls the constructor of SockJS internally. Following the same rules as in the SockJS client library documentation (the parameter is called &quot;options&quot;). protocols array &lt;optional&gt; This will be used as the second parameter when it calls the constructor of SockJS internally. Following the same rules as in the SockJS client library documentation (the parameter is called &quot;_reserved&quot;). Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 64 Returns: Returns a SockJS object. Read the SockJS client library documentation for more information. In the case of error, returns null. Type Object | null &lt;static&gt; open() Alias for CB_Net.Sockets.SockJS.listen. Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 47 See: CB_Net.Sockets.SockJS.listen &lt;static&gt; send(message [, websocket] [, onError]) → {undefined|false} Sends a websockets message. Using the SockJS client library internally. Parameters: Name Type Argument Default Description message string The message that we want to send. This will be used as the first and unique parameter when it calls the &quot;send&quot; function of the SockJS object internally. Following the same rules as in the SockJS client library documentation. websocket function &lt;optional&gt; CB_Net.Sockets.SockJS.websocketLast The SockJS object that we want to use. If not provided, it will try to use the last one created (if any) which is stored in CB_Net.Sockets.SockJS.websocketLast. onError function &lt;optional&gt; Function for the event &quot;onerror&quot; used by the SockJS object. If provided, it will replace the previous one (if any). Following the same rules as in the SockJS client library documentation. Source: CrossBase/net/sockets/CB_Net_Sockets.js, line 101 Returns: Returns undefined (the same as the &quot;send&quot; function of the SockJS object) if the SockJS has been used or false otherwise. Type undefined | false × Search results Close "},"CB_Net.XHR.html":{"id":"CB_Net.XHR.html","title":"Namespace: XHR","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: XHR CB_Net. XHR Static class to manage XMLHttpRequest (XHR, AJAX) and related. It will return itself if it is tried to be instantiated. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 14 To Do: Think about providing an easy way to abort XHR (AJAX) calls. Methods &lt;static&gt; call(URL [, method] [, data] [, headers] [, responseType] [, mimeType] [, callbackFunction] [, callbackFunctionOK] [, callbackFunctionError] [, allowedSuccessStatuses] [, asynchronous] [, XHR]) → {Object|null} Performs an AJAX (XHR) call. Parameters: Name Type Argument Default Description URL string The URL that we want to call. It can also contain URL (GET) parameters. method string &lt;optional&gt; 'POST' The HTTP method that will be used to perform the call (GET, POST, PUT, DELETE, etc.). data string | Object &lt;optional&gt; The data that we want to send. If a string is given and &quot;GET&quot; method is being used, it will assume they are GET (URL) parameters and will be attached at the end of the URL given. If something which is not a string is given, it will assume it is a JSON object and will try to convert it into a string (using the JSON.stringify function internally) before sending it. headers CB_Net.XHR.HEADERS &lt;optional&gt; Object containing the HTTP header names and their values that we want to send (used internally by the setRequestHeader method of the XHR object). responseType string &lt;optional&gt; If provided, it will be used for the responseType property of the XHR object (if available). mimeType string &lt;optional&gt; MIME type that will be used to override the default one returned by the server. Only used when the client supports the overrideMimeType method of the XHR object. callbackFunction function &lt;optional&gt; Function that will be used for the onreadystatechange property of the XHR object. The unique parameter that it will receive is the XHR object used by the request. If provided, the &quot;callbackFunctionOK&quot; and &quot;callbackFunctionError&quot; parameters will not be used even they were also provided. callbackFunctionOK function &lt;optional&gt; Function that will be called by an internally-created function used in the onreadystatechange property of the XHR object when the readyState property is 4 and the status property is included in the &quot;allowedSuccessStatuses&quot; desired. The first parameter it will receive is the XHR object used by the request and the second one will be the &quot;callbackFunctionError&quot; function provided (if any). It will not be used if the parameter &quot;callbackFunction&quot; is provided. callbackFunctionError function &lt;optional&gt; Function that will be called by an internally-created function used in the onreadystatechange property of the XHR object when the readyState property is 4 and the status property is not included in the &quot;allowedSuccessStatuses&quot; desired. The first parameter it will receive is the XHR object used by the request and the second one will be the &quot;callbackFunctionOk&quot; function provided (if any). It will not be used if the parameter &quot;callbackFunction&quot; is provided. allowedSuccessStatuses integer | array &lt;optional&gt; 200 An integer or a numeric array with a list of integers with the status or statuses that will be considered as a success call by the &quot;callbackFunctionOK&quot; function (only when it is used) when the response comes. asynchronous boolean &lt;optional&gt; true Defines whether to make a request asynchronously or not. It will be used for the third parameter of the method open of the XHR object. XHR Object &lt;optional&gt; The XHR object that we want to use for the call. If not provided, it will try to create a new one internally. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 119 To Do: Think about providing a way to choose whether we want the &quot;data&quot; provided to be added to the URL when the &quot;GET&quot; method is used or not. Describe better what kind of XHR object will the different callbacks receive, as in some cases (as when using REST) they can contain some special properties with HTTP headers, etc. Returns: Returns null if the URL provided was empty or the AJAX (XHR) object provided is not a valid object or it could not be created a new one internally. Otherwise, it returns the AJAX (XHR) object used to try to perform the call (even that maybe it failed or will fail later). Type Object | null &lt;static&gt; callBinary(URL [, data] [, headers] [, blobOrArrayBuffer] [, callbackFunction] [, callbackFunctionOK] [, callbackFunctionError] [, allowedSuccessStatuses] [, XHR]) → {Object|null} Performs a standard XHR request for a binary file. Uses the CB_Net.XHR.call function internally with &quot;GET&quot; method, using &quot;text/plain; charset=x-user-defined&quot; for the &quot;mimeType&quot; parameter and asynchronously. Parameters: Name Type Argument Default Description URL string Used for the &quot;URL&quot; parameter of the CB_Net.XHR.call function when it is called internally. data string | Object &lt;optional&gt; Used for the &quot;data&quot; parameter of the CB_Net.XHR.call function when it is called internally. headers CB_Net.XHR.HEADERS &lt;optional&gt; { &quot;Content-Type&quot; : &quot;text/plain; charset=x-user-defined&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } Object containing the HTTP header names and their values that we want to send. If not provided, it will use the default one. An empty object ({}) can be used if we do not want to send any HTTP headers at all. Used for the &quot;headers&quot; parameter of the CB_Net.XHR.call function when it is called internally. blobOrArrayBuffer 'arraybuffer' | 'blob' | '' &lt;optional&gt; 'arraybuffer' Used for the responseType parameter of the CB_Net.XHR.call function when it is called internally. If an empty string is provided, the responseType parameter will not be modified. callbackFunction function &lt;optional&gt; Used for the &quot;callbackFunction&quot; parameter of the CB_Net.XHR.call function when it is called internally. callbackFunctionOK function &lt;optional&gt; Used for the &quot;callbackFunctionOK&quot; parameter of the CB_Net.XHR.call function when it is called internally. callbackFunctionError function &lt;optional&gt; Used for the &quot;callbackFunctionError&quot; parameter of the CB_Net.XHR.call function when it is called internally. allowedSuccessStatuses integer | array &lt;optional&gt; 200 Used for the &quot;allowedSuccessStatuses&quot; parameter of the CB_Net.XHR.call function when it is called internally. XHR Object &lt;optional&gt; Used for the &quot;XHR&quot; parameter of the CB_Net.XHR.call function when it is called internally. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 340 Returns: Returns the same that the CB_Net.XHR.call function returns (called internally). Type Object | null &lt;static&gt; callForm(URL [, data] [, headers] [, responseType] [, charset] [, callbackFunction] [, callbackFunctionOK] [, callbackFunctionError] [, allowedSuccessStatuses] [, XHR]) → {Object|null} Performs a standard XHR request to send form data by POST (no files). Uses the CB_Net.XHR.call function internally with &quot;POST&quot; method, asynchronously and &quot;mimeType&quot; parameter not provided. Parameters: Name Type Argument Default Description URL string Used for the &quot;URL&quot; parameter of the CB_Net.XHR.call function when it is called internally. data string | Object &lt;optional&gt; Used for the &quot;data&quot; parameter of the CB_Net.XHR.call function when it is called internally. headers CB_Net.XHR.HEADERS &lt;optional&gt; { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=&quot; + charset, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } Object containing the HTTP header names and their values that we want to send. If not provided, it will use the default one that will include the charset defined by the &quot;charset&quot; parameter. An empty object ({}) can be used if we do not want to send any HTTP headers at all. Used for the &quot;headers&quot; parameter of the CB_Net.XHR.call function when it is called internally. responseType string &lt;optional&gt; Used for the responseType parameter of the CB_Net.XHR.call function when it is called internally. charset string &lt;optional&gt; 'UTF-8' The charset for the &quot;Content-Type&quot; HTTP header that will be sent by default only when no &quot;headers&quot; parameter is provided. callbackFunction function &lt;optional&gt; Used for the &quot;callbackFunction&quot; parameter of the CB_Net.XHR.call function when it is called internally. callbackFunctionOK function &lt;optional&gt; Used for the &quot;callbackFunctionOK&quot; parameter of the CB_Net.XHR.call function when it is called internally. callbackFunctionError function &lt;optional&gt; Used for the &quot;callbackFunctionError&quot; parameter of the CB_Net.XHR.call function when it is called internally. allowedSuccessStatuses integer | array &lt;optional&gt; 200 Used for the &quot;allowedSuccessStatuses&quot; parameter of the CB_Net.XHR.call function when it is called internally. XHR Object &lt;optional&gt; Used for the &quot;XHR&quot; parameter of the CB_Net.XHR.call function when it is called internally. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 292 Returns: Returns the same that the CB_Net.XHR.call function returns (called internally). Type Object | null &lt;static&gt; callProxy(URL [, method] [, data] [, headers] [, responseType] [, forceJSON] [, getHeaders] [, headersForceOneDimension] [, headersForceOneDimensionValues] [, transparentStatus] [, transparentHeaders] [, callbackFunction] [, callbackFunctionOK] [, callbackFunctionError] [, allowedSuccessStatuses] [, XHR]) → {Object|null} Performs an AJAX (XHR) call through the proxy (made with PHP language and using cURL, so it will need a server which supports that) to avoid cross-domain request limitations of AJAX. Uses the CB_Net.XHR.callForm function (with &quot;headers&quot; and &quot;charset&quot; parameters not provided) internally to call the proxy. NOTE: Edit the &quot;CB_proxy.config.php&quot; file to configure the default proxy (set by default in the value of the CB_Configuration.CrossBase.CB_Net_XHR_PROXY_URL property). Apart from configuring it, adding some security measures is highly recommended. Have in mind that, for safety reasons, the default proxy only allows to request the URLs defined in the &quot;$allowedURLs&quot; array in the &quot;CB_proxy.config.php&quot; file. Just edit it to allow other URLs. Parameters: Name Type Argument Default Description URL string The URL that we want the proxy to call for us. It can also contain URL (GET) parameters. method string &lt;optional&gt; 'POST' The HTTP method (GET, POST, PUT, DELETE, etc.) that we want the proxy to use for us when performing the call. data string | Object &lt;optional&gt; The data that we want to send through the proxy to the final server. If something which is not a string is given, it will assume it is a JSON object and will try to convert it into a string (using the JSON.stringify function internally) before sending it. headers CB_Net.XHR.HEADERS &lt;optional&gt; Object (JSON format) containing the HTTP header names and their values that we want the proxy to send to the final server. Even if not provided, the proxy could end sending some HTTP headers depending on the cURL configuration used. responseType string &lt;optional&gt; Used for the responseType parameter of the CB_Net.XHR.callForm function when it is called internally. forceJSON boolean &lt;optional&gt; false If it is set to true, the response from the proxy will be a JSON object with the status property containing the HTTP status of the reply, the response property with the response content itself and the &quot;headers&quot; property (only when &quot;getHeaders&quot; parameters is set to true) with the HTTP headers of the reply, all belonging to the response from the final server. getHeaders boolean &lt;optional&gt; false If it is set to true, the proxy will answer including the HTTP headers from the final server. The HTTP headers will be included in the final response string at the beginning (before the response content) if the &quot;forceJSON&quot; parameter is not set to true or in the &quot;headers&quot; property of the JSON object that belongs to the response otherwise. headersForceOneDimension boolean &lt;optional&gt; false If it is set to true, the proxy will consider that the HTTP headers of the response from the final server are not multidimensional which means that the final server would never reply the same HTTP header repeated multiple times (with different values, normally) in different chunks separated by double new lines (&quot;\\r\\n\\r\\n&quot;). Default value (false) is recommended. Needs &quot;getHeaders&quot; set to true. headersForceOneDimensionValues boolean &lt;optional&gt; false If it is set to true, the proxy will only consider one value per HTTP header from the response from the final server. Default value (false) is recommended. Needs &quot;getHeaders&quot; set to true. transparentStatus boolean &lt;optional&gt; false If it is set to true, the proxy will reply us with the same status as the final server in its HTTP response. transparentHeaders boolean &lt;optional&gt; false If it is set to true, the proxy will reply us with the same HTTP headers as the final server in its HTTP response. callbackFunction function &lt;optional&gt; Used for the &quot;callbackFunction&quot; parameter of the CB_Net.XHR.callForm function when it is called internally. callbackFunctionOK function &lt;optional&gt; Used for the &quot;callbackFunctionOK&quot; parameter of the CB_Net.XHR.callForm function when it is called internally. callbackFunctionError function &lt;optional&gt; Used for the &quot;callbackFunctionError&quot; parameter of the CB_Net.XHR.callForm function when it is called internally. allowedSuccessStatuses integer | array &lt;optional&gt; 200 Used for the &quot;allowedSuccessStatuses&quot; parameter of the CB_Net.XHR.callForm function when it is called internally. XHR Object &lt;optional&gt; Used for the &quot;XHR&quot; parameter of the CB_Net.XHR.callForm function when it is called internally. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 402 To Do: Document PHP proxy more. Returns: Returns the same that the CB_Net.XHR.callForm function returns (called internally). Type Object | null &lt;static&gt; callREST( [serverURL] [, route] [, dataURL] [, method] [, data] [, headers] [, responseType] [, avoidProxy] [, forceJSON] [, getHeaders] [, headersForceOneDimension] [, headersForceOneDimensionValues] [, transparentStatus] [, transparentHeaders] [, callbackFunctionOK] [, callbackFunctionError] [, allowedSuccessStatuses] [, XHR]) → {Object|null} Performs a REST call to a REST server. Uses the CB_Net.XHR.callProxy function (without &quot;callbackFunction&quot; parameter provided) internally if we do not want to avoid the proxy or uses the CB_Net.XHR.call function (asynchronously, with &quot;mimeType&quot; and &quot;callbackFunction&quot; parameters not provided) otherwise. Parameters: Name Type Argument Default Description serverURL string &lt;optional&gt; CB_Net.REST.SERVER_URL_DEFAULT The URL of the REST server that we want to call. It should not contain URL (GET) parameters. It can also contain the REST path (route), although it is recommended to set it in the &quot;route&quot; parameter. route string &lt;optional&gt; The REST path (route) we want to request. It can also contain URL (GET) parameters, although it is recommended to set them in the &quot;dataURL&quot; parameter. dataURL string &lt;optional&gt; The URL (GET) data that we want to send. method string &lt;optional&gt; 'POST' Used for the &quot;method&quot; parameter for the CB_Net.XHR.callProxy function or for the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. data string | Object &lt;optional&gt; Used for the &quot;data&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. headers CB_Net.XHR.HEADERS &lt;optional&gt; undefined|{ &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } Used for the &quot;headers&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. If not provided and the CB_Net.XHR.call function is used (if no proxy is allowed), the default value will be: { &quot;Content-Type&quot; : &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } responseType string &lt;optional&gt; Used for the responseType parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. avoidProxy boolean &lt;optional&gt; false If it is set to true, it will call the CB_Net.XHR.call internally. Otherwise, it will use the CB_Net.XHR.callProxy function internally. forceJSON boolean &lt;optional&gt; false Used for the &quot;forceJSON&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. getHeaders boolean &lt;optional&gt; false Used for the &quot;getHeaders&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. headersForceOneDimension boolean &lt;optional&gt; false Used for the &quot;headersForceOneDimension&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. headersForceOneDimensionValues boolean &lt;optional&gt; false Used for the &quot;headersForceOneDimensionValues&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. transparentStatus boolean &lt;optional&gt; false Used for the &quot;transparentStatus&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. transparentHeaders boolean &lt;optional&gt; false Used for the &quot;transparentHeaders&quot; parameter of the CB_Net.XHR.callProxy function (if the proxy is allowed) when it is called internally. callbackFunctionOK function &lt;optional&gt; Used for the &quot;callbackFunctionOK&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. callbackFunctionError function &lt;optional&gt; Used for the &quot;callbackFunctionError&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. allowedSuccessStatuses integer | array &lt;optional&gt; 200 Used for the &quot;allowedSuccessStatuses&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. XHR Object &lt;optional&gt; Used for the &quot;XHR&quot; parameter of the CB_Net.XHR.callProxy function or of the CB_Net.XHR.call function (if no proxy is allowed) when it is called internally. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 468 Returns: When using the proxy is allowed, returns the same that the CB_Net.XHR.callProxy function returns (called internally). Otherwise, it returns the same that the CB_Net.XHR.call function returns (called internally). Type Object | null &lt;static&gt; get() → {Object|null} Returns a new AJAX (XHR) object, if possible. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 59 Returns: Returns a new AJAX (XHR) object if it has been possible to create it or null otherwise. Type Object | null &lt;static&gt; getResponseContent(response [, sanitize]) → {string|null} Returns the response content from an XHR object (from its responseText property) or from the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy (response property). Useful to parse the response from the CB_Net.XHR.callProxy (or CB_Net.XHR.callREST and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. Parameters: Name Type Argument Default Description response Object | string The XHR object which contains the responseText property or the value of the responseText property (string) itself which should contain the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy. If a string is provided, tries to parse it as a JSON object. The responseText property (or the response property as a fallback) will be tried to be returned from it. sanitize boolean &lt;optional&gt; true If it is set to true and neither the responseText nor the response properties are found, it will return an empty string (&quot;&quot;) instead of returning null. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 580 Returns: Returns the content of the responseText (or response) property if possible. If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or an empty string (&quot;&quot;) otherwise. Type string | null &lt;static&gt; getResponseHeaders(response [, sanitize]) → {Object|null} Returns the HTTP headers (it should be an object) from the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy (&quot;headers&quot; property). Useful to parse the response from the CB_Net.XHR.callProxy (or CB_Net.XHR.callREST and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. Parameters: Name Type Argument Default Description response Object | string The XHR object which contains the responseText property or the value of the responseText property (string) itself which should contain the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy. If a string is provided, tries to parse it as a JSON object. The &quot;headers&quot; property will be tried to be returned from it. sanitize boolean &lt;optional&gt; true If it is set to true and the &quot;headers&quot; property is not found, it will return an empty object ({}) instead of returning null. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 545 To Do: Consider adding the parameter &quot;headerNameFirst&quot;. Returns: Returns the content of the &quot;headers&quot; property if possible (it should be a CB_Net.XHR.HEADERS object). If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or an empty object ({}) otherwise. Type Object | null &lt;static&gt; getStatusCode(response [, sanitize] [, statusDefault]) → {integer|*} Returns the HTTP status code from an XHR object (status property) or from the info array generated by the PHP's curl_getinfo function (&quot;http_code&quot; index) or from the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy (status property). Useful to parse the response from the CB_Net.XHR.callProxy (or CB_Net.XHR.callREST and related) function when it has been called with the &quot;forceJSON&quot; parameter set to true. Parameters: Name Type Argument Default Description response Object | string The XHR object which contains the status property or the value of the responseText property (string) itself which should contain the JSON response generated by the &quot;getSslPage&quot; function used by the PHP proxy. If a string is provided, tries to parse it as a JSON object. The status property will be tried to be returned from it (or the &quot;http_code&quot; property as a fallback). sanitize boolean &lt;optional&gt; true If it is set to true and neither the &quot;status&quot; nor the &quot;http_code&quot; property are found (or is not a number), it will return the value of &quot;statusDefault&quot; instead of returning null. statusDefault boolean &lt;optional&gt; -1 Default value to return when the status cannot be found (or is not a number). Only used when the &quot;sanitize&quot; parameter is set to true. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 562 Returns: Returns the content of the status (or &quot;http_code&quot;) property if possible (it should be an integer). If it is not possible, it will return null if the parameter &quot;sanitize&quot; is set to false or the value of &quot;statusDefault&quot; otherwise. Type integer | * &lt;static&gt; supported() → {boolean} Returns whether AJAX (XHR) is available or not. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 39 Returns: Returns true if XHR (AJAX) objects can be used. Type boolean Type Definitions HEADERS Object containing the HTTP headers and their values. Type: Object Properties: Name Type Description HTTPHeaderName Object Each property name is an HTTP header and its value is the desired one for this header. Source: CrossBase/net/XHR/CB_Net_XHR.js, line 91 Example { &quot;Content-Type&quot; : &quot;text/plain; charset=x-user-defined&quot;, &quot;Cache-Control&quot; : &quot;no-cache&quot;, &quot;Pragma&quot; : &quot;no-cache&quot; } × Search results Close "},"CB_Pointer.html":{"id":"CB_Pointer.html","title":"Namespace: CB_Pointer","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Pointer CB_Pointer Static class to manage the pointer, using the Pointer API if available and falling back to internal emulation otherwise. It will return itself if it is tried to be instantiated. Source: CrossBase/input/CB_Pointer.js, line 11 Methods &lt;static&gt; normalizeEvent(e) → {Event} Tries to return the given pointer event with some properties normalized (since different clients can use different values) and perhaps some new properties added (in the case they were missing), when possible. The new attached methods and properties may include polyfills, etc. It also calls the CB_Events.normalize function internally. Some properties added or affected could be &quot;POINTER_TYPE_TOUCH&quot;, &quot;POINTER_TYPE_MOUSE&quot;, &quot;POINTER_TYPE_PEN&quot;, &quot;pointerId&quot;, &quot;pointerType&quot;, &quot;pressure&quot;, &quot;tangentialPressure&quot;, &quot;tiltX&quot;, &quot;tiltY&quot;, &quot;width&quot;, &quot;height&quot;, &quot;currentTarget&quot;, &quot;isPrimary&quot;, &quot;twist&quot;, etc. Parameters: Name Type Description e Event Pointer event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). Source: CrossBase/input/CB_Pointer.js, line 79 To Do: Think about using Object.defineProperty with &quot;writable: true&quot; as option to prevent some web clients problems that have read only properties. Maybe e.width and e.height should be both 1 as default (?). Returns: Returns the pointer event object normalized. Type Event &lt;static&gt; onCancel(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerCancel&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 162 &lt;static&gt; onDown(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerDown&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 134 &lt;static&gt; onEnter(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerEnter&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 176 &lt;static&gt; onGotPointCapture(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onGotPointerCapture&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 246 &lt;static&gt; onLeave(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerLeave&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 190 &lt;static&gt; onLostPointCapture(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onLostPointerCapture&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 260 &lt;static&gt; onMove(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerMove&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 232 &lt;static&gt; onOut(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerOut&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 218 &lt;static&gt; onOver(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerOver&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 204 &lt;static&gt; onUp(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the &quot;onPointerUp&quot; event is fired or removes it. More information: Pointer events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Pointer.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Pointer.js, line 148 &lt;static&gt; setPointerEventsProperty(element, value [, important]) Sets the desired value for the CSS' style pointer-events property of a given element. Parameters: Name Type Argument Default Description element Element Element whose CSS' style &quot;pointer-events&quot; property we want to edit. value string CSS code for the CSS' style &quot;pointer-events&quot; property. important boolean &lt;optional&gt; false If set to true, it will add the &quot; !important&quot; text to the &quot;pointer-events&quot; property. Source: CrossBase/input/CB_Pointer.js, line 115 × Search results Close "},"CB_Screen.html":{"id":"CB_Screen.html","title":"Namespace: CB_Screen","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Screen CB_Screen Static class to manage the screen. It will return itself if it is tried to be instantiated. It can use detect-zoom and NoSleep.js. Source: CrossBase/audiovisual/image/CB_Screen.js, line 11 Methods &lt;static&gt; focus() Sets the focus to the main window (if possible). Source: CrossBase/audiovisual/image/CB_Screen.js, line 646 &lt;static&gt; getAvailableHeight() → {number} Gets the current available screen height (vertical resolution). Uses the window.screen.availHeight property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 243 Returns: Returns the current available screen height (vertical resolution) in pixels. Type number &lt;static&gt; getAvailableHeightPrevious() → {number} Gets the previous available screen height (vertical resolution). Useful when the resolution (screen size and/or orientation) changed. Uses the window.screen.availHeight property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 271 Returns: Returns the previous available screen height (vertical resolution) in pixels. Type number &lt;static&gt; getAvailableWidth() → {number} Gets the current available screen width (horizontal resolution). Uses the window.screen.availWidth property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 227 Returns: Returns the current available screen width (horizontal resolution) in pixels. Type number &lt;static&gt; getAvailableWidthPrevious() → {number} Gets the previous available screen width (horizontal resolution). Useful when the resolution (screen size and/or orientation) changed. Uses the window.screen.availWidth property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 259 Returns: Returns the previous available screen width (horizontal resolution) in pixels. Type number &lt;static&gt; getColorDepth() → {number} Gets the current color depth. Uses the window.screen.colorDepth property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 353 Returns: Returns the current color depth. Type number &lt;static&gt; getHeight() → {number} Gets the current screen height (vertical resolution). Uses the window.screen.height property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 187 Returns: Returns the current screen height (vertical resolution) in pixels. Type number &lt;static&gt; getHeightPrevious() → {number} Gets the previous screen height (vertical resolution). Calculated through the window.screen.height property internally, when possible. Useful when the resolution (screen size and/or orientation) changed. Source: CrossBase/audiovisual/image/CB_Screen.js, line 215 Returns: Returns the previous screen height (vertical resolution) in pixels. Type number &lt;static&gt; getOrientation() → {string} Gets the current orientation from the screen orientation object of the Screen Orientation API. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1675 Returns: Returns a string with the current orientation from the screen orientation object of the Screen Orientation API. If cannot be found, it will return &quot;landscape-primary&quot; as default. Type string &lt;static&gt; getOrientationObject() → {Object} Gets the screen orientation object of the Screen Orientation API. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1642 Returns: Returns the screen orientation object of the Screen Orientation API. Type Object &lt;static&gt; getPixelRatio() → {number} Gets the current pixel ratio of the screen (main window). Uses detect-zoom internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 466 To Do: Find a better and more-compatible way to detect pixel ratio which supports as many web clients as possible. Returns: Returns the current pixel ratio of the screen (main window). Default pixel ratio is 1 (one) even when it fails. Type number &lt;static&gt; getPixelRatioPrevious() → {number} Gets the previous pixel ratio of the screen (main window). Useful when the zoom/pixel-ratio changed. Uses detect-zoom internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 486 To Do: Find a better and more-compatible way to detect pixel ratio which supports as many web clients as possible. Returns: Returns the previous pixel ratio of the screen (main window). Default previous pixel ratio is 0 (zero) even when it fails. Type number &lt;static&gt; getScrollLeft() → {number|null} Gets the current scroll left position (horizontal scroll) of the screen (main window). Uses the CB_Elements.getScrollLeftById function internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 368 Returns: Returns the current scroll left position (horizontal scroll) of the screen (main window). It could return null if something fails. Type number | null &lt;static&gt; getScrollTop() → {number|null} Gets the current scroll top position (vertical scroll) of the screen (main window). Uses the CB_Elements.getScrollTopById function internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 401 Returns: Returns the current scroll top position (vertical scroll) of the screen (main window). It could return null if something fails. Type number | null &lt;static&gt; getWidth() → {number} Gets the current screen width (horizontal resolution). Uses the window.screen.width property internally, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 171 Returns: Returns the current screen width (horizontal resolution) in pixels. Type number &lt;static&gt; getWidthPrevious() → {number} Gets the previous screen width (horizontal resolution). Calculated through the window.screen.width property internally, when possible. Useful when the resolution (screen size and/or orientation) changed. Source: CrossBase/audiovisual/image/CB_Screen.js, line 203 Returns: Returns the previous screen width (horizontal resolution) in pixels. Type number &lt;static&gt; getWindowHeight() → {number} Gets the current window height (vertical resolution). Internally, uses the window.innerHeight if possible and fallbacks to document.documentElement.clientHeight or document.body.clientHeight property otherwise, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 306 Returns: Returns the current window height (vertical resolution) in pixels. Type number &lt;static&gt; getWindowHeightPrevious() → {number} Gets the previous window height (vertical resolution). Useful when the resolution (screen size and/or orientation) or window size changed. Internally, uses the window.innerHeight if possible and fallbacks to document.documentElement.clientHeight or document.body.clientHeight property otherwise, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 341 Returns: Returns the previous window height (vertical resolution) in pixels. Type number &lt;static&gt; getWindowWidth() → {number} Gets the current window width (horizontal resolution). Internally, uses the window.innerWidth if possible and fallbacks to document.documentElement.clientWidth or document.body.clientWidth property otherwise, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 283 Returns: Returns the current window width (horizontal resolution) in pixels. Type number &lt;static&gt; getWindowWidthPrevious() → {number} Gets the previous window width (horizontal resolution). Useful when the resolution (screen size and/or orientation) or window size changed. Internally, uses the window.innerWidth if possible and fallbacks to document.documentElement.clientWidth or document.body.clientWidth property otherwise, when possible. Source: CrossBase/audiovisual/image/CB_Screen.js, line 329 Returns: Returns the previous window width (horizontal resolution) in pixels. Type number &lt;static&gt; getZoom() → {number} Gets the current zoom level of the screen (main window). Uses detect-zoom internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 435 To Do: Find a better and more-compatible way to detect zoom which supports as many web clients as possible. Returns: Returns the current zoom level of the screen (main window). Default zoom level is 1 (one) even when it fails. Type number &lt;static&gt; getZoomPrevious() → {number} Gets the previous zoom level of the screen (main window). Useful when the zoom changed. Uses detect-zoom internally. Source: CrossBase/audiovisual/image/CB_Screen.js, line 454 Returns: Returns the previous zoom level of the screen (main window). Default previous zoom level is 0 (zero) even when it fails. Type number &lt;static&gt; isFocused() → {boolean} Tells whether the main window is focused or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 636 Returns: Returns whether the main window is focused or not. Type boolean &lt;static&gt; isFullScreen( [allowedWidthMarginPercentage] [, allowedHeightMarginPercentage]) → {boolean} Tells whether we are in full screen mode or not. Uses the Fullscreen API and fallbacks to other methods internally, including NW.js (formerly node-webkit) and Electron (Electron.js) ones, when not available. Parameters: Name Type Argument Default Description allowedWidthMarginPercentage number &lt;optional&gt; CB_Configuration.CrossBase.CB_Screen_isFullScreen_ALLOWED_WIDTH_MARGIN_PERCENTAGE Allowed width margin, in percentage, of the total screen available to detect whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. allowedHeightMarginPercentage number &lt;optional&gt; CB_Configuration.CrossBase.CB_Screen_isFullScreen_ALLOWED_HEIGHT_MARGIN_PERCENTAGE Allowed height margin, in percentage, of the total screen available to detect whether it is in full screen or not. Needed by old web clients without Fullscreen API support, mainly. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1196 Returns: Returns whether we are in full screen mode or not. Type boolean &lt;static&gt; isFullScreenAPICompatible() → {boolean} Tells whether the web client is compatible with the FullScreen API or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 872 Returns: Returns whether the web client is compatible with the FullScreen API or not. Type boolean &lt;static&gt; isLandscape() → {boolean} Tells whether the screen (main window) is in landscape position. Source: CrossBase/audiovisual/image/CB_Screen.js, line 497 Returns: Returns whether the screen is in landscape position. Type boolean &lt;static&gt; isVisible() → {boolean} Tells whether the main window is visible or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 584 Returns: Returns whether the main window is visible or not. Type boolean &lt;static&gt; keepAwake( [callbackOk] [, callbackError]) → {boolean} Keeps the screen awake and prevents it from turning off. Uses different methods internally: Apache Cordova's Insomnia plugin, Standby API, Mozilla's Wake Lock API, new W3C's Wake Lock API, old W3C's Wake Lock API, NoSleep.js library (it should be activated by an event fired by the user as onclick or ontouchstart, etc.)... Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; Function that will be called if the action has been performed successfully, without parameters. callbackError function &lt;optional&gt; Function that will be called if the action has not been performed successfully, without parameters. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1797 To Do: Pay attention since many internal functions as the new W3C's Wake Lock API are still experimental and not well-tested. Returns: If it uses the new W3C's Wake Lock API internally, it will return a Promise. Otherwise, it will return a boolean depending on whether the internal method has been called successfully or not. The fact that the internal method has been called successfully does not mean that the action will perform successfully so it is recommended to relay on the &quot;callbackOk&quot; and &quot;callbackError&quot; functions and ignore this returning value. Type boolean &lt;static&gt; keepAwakeDisable( [callbackOk] [, callbackError]) → {boolean} Lets the screen sleep again and stops preventing it from turning off. Uses different methods internally: Apache Cordova's Insomnia plugin, Standby API, Mozilla's Wake Lock API, new W3C's Wake Lock API, old W3C's Wake Lock API, NoSleep.js library (it should be activated by an event fired by the user as onclick or ontouchstart, etc.)... Parameters: Name Type Argument Description callbackOk function &lt;optional&gt; Function that will be called if the action has been performed successfully, without parameters. callbackError function &lt;optional&gt; Function that will be called if the action has not been performed successfully, without parameters. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1900 To Do: Pay attention since many internal functions as the new W3C's Wake Lock API are still experimental and not well-tested. Returns: If it uses the new W3C's Wake Lock API internally, it will return a Promise. Otherwise, it will return a boolean depending on whether the internal method has been called successfully or not. The fact that the internal method has been called successfully does not mean that the action will perform successfully so it is recommended to relay on the &quot;callbackOk&quot; and &quot;callbackError&quot; functions and ignore this returning value. Type boolean &lt;static&gt; lockOrientation(orientationMode [, onSuccess] [, onError]) → {boolean} Function that forces a desired screen orientation. Using the lock function and fallbacks to the lockOrientation function of the Screen Orientation API internally. Parameters: Name Type Argument Description orientationMode 'default' | 'any' | 'natural' | 'landscape' | 'portrait' | 'portrait-primary' | 'portrait-secondary' | 'landscape-primary' | 'landscape-secondary' Desired orientation. Internally, &quot;default&quot; and &quot;natural&quot; will be exchanged and &quot;any&quot; will be transformed to &quot;default&quot;, depending on the internal function used. Values &quot;default&quot;, &quot;any&quot; and &quot;natural&quot; are not recommended because they are not supported in all web clients. onSuccess function &lt;optional&gt; Callback function with no parameters that will be called if the orientation has been set successfully. onError function &lt;optional&gt; Callback function that will be called if the orientation has not been set successfully. Unique parameter received will be an error object (probably a DOMException, depending on the client) with the error. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1562 To Do: Transform values of &quot;default&quot;, &quot;any&quot; and &quot;natural&quot; to &quot;portrait&quot;, &quot;landscape&quot;, etc. when the web clients do not support it (calculating current orientation and trying to guess natural/default one, etc.). Returns: Returns the same Promise that the lock function returns, if available. Otherwise, returns the same boolean as the lockOrientation function (true if the locking action has been performed successfully), if available. Otherwise, returns false when the Screen Orientation API is not available. Type boolean &lt;static&gt; onFocusChange(callbackFunction [, keepOldFunction]) Sets a function to execute when the screen (main window) focus is changed or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 707 &lt;static&gt; onFullScreenChange(callbackFunction [, keepOldFunction]) Sets a function to execute when full screen mode is changed (enabled or disabled) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 828 &lt;static&gt; onOrientationChange(callbackFunction [, keepOldFunction]) Sets a function to execute when the screen (main window) orientation is changed (portrait or landscape) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 683 &lt;static&gt; onResize(callbackFunction [, keepOldFunction]) Sets a function to execute when the screen (main window) is resized (onResize event) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 719 &lt;static&gt; onResizeOrZoom(callbackFunction [, keepOldFunction]) Sets a function to execute when the screen (main window) is resized or the zoom is changed, or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 816 &lt;static&gt; onScrollLeft(callbackFunction [, keepOldFunction]) Sets a function to execute when the left scroll position (horizontal scroll) is changed in the screen (main window) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 659 &lt;static&gt; onScrollTop(callbackFunction [, keepOldFunction]) Sets a function to execute when the top scroll position (vertical scroll) is changed in the screen (main window) or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 671 &lt;static&gt; onVisibilityChange(callbackFunction [, keepOldFunction]) Sets a function to execute when the screen (main window) visibility is changed or removes it. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired, with no parameters. If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. Source: CrossBase/audiovisual/image/CB_Screen.js, line 695 &lt;static&gt; setFullScreen( [useFullScreen] [, element] [, allowReload]) Toggles between full screen and normal mode. Uses the Fullscreen API and fallbacks to other methods internally, including NW.js (formerly node-webkit) and Electron (Electron.js) ones, when not available. Recommended to be called through an event fired by the user as onclick or ontouchstart, etc. Parameters: Name Type Argument Default Description useFullScreen boolean &lt;optional&gt; true If set to true, it will try to enable full screen mode. Otherwise, it will try to enable normal mode. element Element &lt;optional&gt; document.documentElement|document.body Element which we want to use in full screen mode. By default uses the whole document body. Only used when the &quot;useFullScreen&quot; parameter is set to true. If an element is provided, it will use neither NW.js (formerly node-webkit) nor Electron (Electron.js) methods. allowReload boolean &lt;optional&gt; false If set to true and &quot;useFullScreen&quot; is set to true but it fails to enable full screen normally, it will try to reload the entire current document again in a new bigger window. Useful for very old web clients. Only used when the &quot;useFullScreen&quot; parameter is set to true. Source: CrossBase/audiovisual/image/CB_Screen.js, line 897 &lt;static&gt; setOrientation() Alias for CB_Screen.lockOrientation. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1548 See: CB_Screen.lockOrientation &lt;static&gt; setViewport( [width] [, height] [, userScalable] [, initialScale] [, minimumScale] [, maximumScale] [, targetDensityDPI] [, shrinkToFit]) → {Node|null} Sets the Viewport meta tag dynamically with the desired options. If the Viewport meta tag already exists, it will be updated. Otherwise, it will create a new one (and append it to the HEAD tag, if found). Parameters: Name Type Argument Default Description width string | integer &lt;optional&gt; Desired value for the &quot;width&quot; parameter. height string | integer &lt;optional&gt; Desired value for the &quot;height&quot; parameter. userScalable string | boolean &lt;optional&gt; 'no' Desired value for the &quot;user-scalable&quot; parameter. initialScale number &lt;optional&gt; Desired value for the &quot;initial-scale&quot; parameter. minimumScale number &lt;optional&gt; Desired value for the &quot;minimum-scale&quot; parameter. maximumScale number &lt;optional&gt; Desired value for the &quot;maximum-scale&quot; parameter. targetDensityDPI string | number &lt;optional&gt; Desired value for the &quot;target-densitydpi&quot; parameter. shrinkToFit string &lt;optional&gt; Desired value for the &quot;shrink-to-fit&quot; parameter. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1705 Returns: Returns the DOM element which belongs to the Viewport meta tag affected (it will have been just created if no one existed before). If a Viewport meta tag could not be created or modified, returns null. Type Node | null &lt;static&gt; unlockOrientation( [onError]) → {boolean} Function that unlocks the screen orientation. Using the unlock function and fallbacks to the unlockOrientation function of the Screen Orientation API internally. Parameters: Name Type Argument Description onError function &lt;optional&gt; Callback function that will be called if the orientation has not been unlocked successfully. Unique parameter received will be an error object (probably a DOMException, depending on the client) with the error. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1464 Returns: Returns the same that the unlock function returns (undefined, normally), if available. Otherwise, returns the same boolean as the unlockOrientation function (true if the unlocking action has been performed successfully), if available. Otherwise, returns false when the Screen Orientation API is not available. Type boolean &lt;static&gt; unsetOrientation() Alias for CB_Screen.unlockOrientation. Source: CrossBase/audiovisual/image/CB_Screen.js, line 1453 See: CB_Screen.unlockOrientation × Search results Close "},"CB_Speaker.html":{"id":"CB_Speaker.html","title":"Namespace: CB_Speaker","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Speaker CB_Speaker Static class to manage the speaker or speakers. It will return itself if it is tried to be instantiated. It can also use timbre.js, Band.js and jsfx. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 13 To Do: Check whether the path used to play silent sounds as a workaround (through the internal &quot;_playBlankFilesSilently&quot; method) is right or not (now it uses the CB_scriptPath variable). getCopy and filterProperties methods (similar to the ones from CB_GraphicSprites and CB_GraphicSpritesScene). Methods &lt;static&gt; getAudioFileSpritesPool() → {CB_AudioFileSpritesPool|null} Returns the current CB_AudioFileSpritesPool object (if any). Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 322 Returns: Returns the current CB_AudioFileSpritesPool object (if any) or null otherwise. Type CB_AudioFileSpritesPool | null &lt;static&gt; getBandJSObject() → {Object|null} Returns a new Band.js object (if possible). Useful for managing music composition. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 346 To Do: Band.js should have into account the CB_Speaker._volume Returns: Returns a new Band.js object (if possible) or null otherwise. Type Object | null &lt;static&gt; getJsfxObject() → {Object|null} Returns the jsfx object (if any). Useful for managing sound effects generation. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 358 To Do: jsfx should have into account the CB_Speaker._volume Returns: Returns the current jsfx object (if any) or null otherwise. Type Object | null &lt;static&gt; getTimbreJSObject() → {Object|null} Returns the timbre.js object (if any). Useful for functional processing and synthesizing audio. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 334 To Do: timbre.js should have into account the CB_Speaker._volume Returns: Returns the current timbre.js object (if any) or null otherwise. Type Object | null &lt;static&gt; getVolume( [avoidSanitize]) → {number} Tells the current volume. Parameters: Name Type Argument Default Description avoidSanitize boolean &lt;optional&gt; false If set to true, it will not call the CB_Speaker.sanitizeVolume function internally before returning the volume. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 293 Returns: Returns the current volume. Type number &lt;static&gt; mute( [avoidApplyingVolume] [, onMute] [, audioFiles]) → {number} Mutes the speaker. Calls the CB_Speaker.setVolume function internally, with 0 (zero) as the &quot;volume&quot; parmeter, null as the &quot;forceSetVolumeProperty&quot; parameter and true for both &quot;saveForUnmute&quot; and &quot;isMuteOrUnmute&quot; parameters. Parameters: Name Type Argument Default Description avoidApplyingVolume boolean &lt;optional&gt; false Used as a parameter to call the CB_Speaker.setVolume function internally. onMute function &lt;optional&gt; Used as as the &quot;functionToExecute&quot; parameter to call the CB_Speaker.setVolume function internally. audioFiles array &lt;optional&gt; Used as a parameter to call the CB_Speaker.setVolume function internally. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 261 To Do: Also affect BandJS, jsfx and timbre.js. Returns: Returns the result of the internal call to the CB_Speaker.setVolume function. Type number &lt;static&gt; sanitizeVolume( [volume] [, useSpeakerVolumeIfNaN]) → {number} Sanitizes the volume (it does not allow values greater than 100 or lower than 0). Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME|CB_Speaker._volume The desired volume to be sanitized. If not given, it will use the current volume if the &quot;useSpeakerVolumeIfNaN&quot; parameter is set to true or the default volume otherwise. useSpeakerVolumeIfNaN boolean &lt;optional&gt; false If it is set to true and no valid volume is received in the &quot;volume&quot; parameter, it will use the current volume (CB_Speaker._volume). Otherwise, if it is set to false and no valid volume is received in the &quot;volume&quot; parameter, it will use the default volume which is set in the CB_Configuration.CrossBase.CB_Speaker_DEFAULT_VOLUME constant. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 216 Returns: Returns the volume sanitized (it does not allow values greater than 100 or lower than 0). Type number &lt;static&gt; setAudioFileSpritesPool(audioFileSpritesPool) → {CB_AudioFileSpritesPool|null} Sets the desired CB_AudioFileSpritesPool object. Parameters: Name Type Description audioFileSpritesPool CB_AudioFileSpritesPool The desired CB_AudioFileSpritesPool object to manage all audio files. Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 306 Returns: Returns the current CB_AudioFileSpritesPool object after setting it (if any) or null otherwise. Type CB_AudioFileSpritesPool | null &lt;static&gt; setVolume( [volume] [, avoidApplyingVolume] [, forceSetVolumeProperty] [, functionToExecute] [, audioFiles] [, saveForUnmute] [, isMuteOrUnmute]) → {number} Sets the given volume. Parameters: Name Type Argument Default Description volume number &lt;optional&gt; CB_Speaker._volume The desired volume to be used (it will be sanitized internally by calling the CB_Speaker.sanitizeVolume function with the volume as the unique parameter). If not given, it will use the current volume. If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will also be used as a parameter to call the CB_AudioFileSpritesPool#setVolumeAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). avoidApplyingVolume boolean &lt;optional&gt; false If it is set to true, the volume will not be applied (by calling the CB_Speaker._applyVolume internal function, which will also use the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool, if any) and just the CB_Speaker._volume internal property will be set. forceSetVolumeProperty boolean &lt;optional&gt; false If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as a parameter to call the CB_AudioFileSpritesPool#setVolumeAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). functionToExecute function &lt;optional&gt; A callback function. If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as the &quot;onSetVolume&quot; parameter to call the CB_AudioFileSpritesPool#setVolumeAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is true, it will be used as the &quot;onMute&quot; parameter to call the CB_AudioFileSpritesPool#muteAll method or as the &quot;onUnmute&quot; parameter to call the CB_AudioFileSpritesPool#unmuteAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). audioFiles array &lt;optional&gt; An array containing the CB_AudioFile objects that we want to affect (if not set and the &quot;avoidApplyingVolume&quot; is set to false, it will affect all the CB_AudioFile objects of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool, if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is false, it will be used as the &quot;audioFiles&quot; parameter to call the CB_AudioFileSpritesPool#setVolumeAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). If the &quot;avoidApplyingVolume&quot; is set to false and the &quot;isMuteOrUnmute&quot; parameter is true, it will be used as the &quot;audioFiles&quot; parameter to call the CB_AudioFileSpritesPool#muteAll method or as the &quot;audioFiles&quot; parameter to call the CB_AudioFileSpritesPool#unmuteAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool (if any). saveForUnmute boolean &lt;optional&gt; false If it is set to true, the given volume will be saved to be restored later when the CB_Speaker.unmute method is called. isMuteOrUnmute boolean &lt;optional&gt; false If it is set to true and the volume given is zero, the action performed internally will be muting (by calling the CB_AudioFileSpritesPool#muteAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool, if any). Otherwise, if it is set to true and the volume given is not zero, the action performed internally will be unmuting (by calling the CB_AudioFileSpritesPool#unmuteAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool, if any). If it is set to false, the action performed will be set the volume given (by calling the CB_AudioFileSpritesPool#setVolumeAll method of the internal CB_AudioFileSpritesPool object defined in CB_Speaker._audioFileSpritesPool, if any). Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 242 To Do: Also affect BandJS, jsfx and timbre.js. Returns: Returns the current volume being used after setting it. Type number &lt;static&gt; unmute( [avoidApplyingVolume] [, onUnmute] [, audioFiles] [, ignoreVolume]) → {number} Restores the audio volume after muting it. If the current volume is 0 (zero, muted) or the &quot;ignoreVolume&quot; parameter is set to true, calls the CB_Speaker.setVolume function internally, with the previously-saved volume before muting it as the &quot;volume&quot; parmeter, null as the &quot;forceSetVolumeProperty&quot; parameter, false for the &quot;saveForUnmute&quot; parameter and true for the &quot;isMuteOrUnmute&quot; parameter. Parameters: Name Type Argument Default Description avoidApplyingVolume boolean &lt;optional&gt; false Used as a parameter to call the CB_Speaker.setVolume function internally, if the &quot;ignoreVolume&quot; parameter is set to true. onUnmute function &lt;optional&gt; Used as as the &quot;functionToExecute&quot; parameter to call the CB_Speaker.setVolume function internally, if the &quot;ignoreVolume&quot; parameter is set to true. audioFiles array &lt;optional&gt; Used as a parameter to call the CB_Speaker.setVolume function internally, if the &quot;ignoreVolume&quot; parameter is set to true. ignoreVolume boolean &lt;optional&gt; false If set to true, it will try to perform the muting action even when the current volume is not 0 (zero, muted). Source: CrossBase/audiovisual/audio/CB_Speaker.js, line 277 To Do: Also affect BandJS, jsfx and timbre.js. Returns: Returns the current volume. Type number × Search results Close "},"CB_Touch.html":{"id":"CB_Touch.html","title":"Namespace: CB_Touch","body":" CrossBrowdy API documentation [printable] Namespaces CB_ArraysCB_AudioDetectorCB_baseSymbolsCB_ClientCB_CollisionsCB_ConfigurationCB_Configuration.CrossBaseCB_Configuration.CrossBrowdyCB_ControllersCB_Controllers_ProprietaryCB_Controllers_Proprietary.WIICB_Controllers_Proprietary.WII_UCB_DeviceCB_Device.AmbientLightCB_Device.BatteryCB_Device.LocationCB_Device.MotionCB_Device.OrientationCB_Device.ProximityCB_Device.VibrationCB_ElementsCB_EventsCB_KeyboardCB_Keyboard.charsCB_Keyboard.extendedCB_Keyboard.keysCB_ModulesCB_MouseCB_Mouse.CursorImageCB_NetCB_Net.FetchCB_Net.RESTCB_Net.SocketsCB_Net.Sockets.SockJSCB_Net.XHRCB_PointerCB_ScreenCB_SpeakerCB_Touch Classes CB_AudioFileCB_AudioFile_API.AAPICB_AudioFile_API.ACMPCB_AudioFile_API.SM2CB_AudioFile_API.WAAPICB_AudioFileCacheCB_AudioFileSpritesCB_AudioFileSpritesPoolCB_CanvasCB_GraphicSpritesCB_GraphicSpritesScene Global CB_addCreditsCB_BASE_NAMECB_baseToBaseCB_baseToIntCB_br2nlCB_brToNlCB_combineArraysOrObjectsCB_combineAutomaticallyCB_combineJSONCB_combineURIParametersCB_combineURLParametersCB_consoleCB_copyObjectCB_countDecimalDigitsCB_countDecimalPartCB_countDecimalsCB_countIntegerDigitsCB_countIntegerPartCB_creditsCB_CREDITS_DEFAULTCB_forceStringCB_forEachCB_getBase64StringObjectCB_getCookieCB_getDatumCB_getJSONPropertyValueCB_getLZStringObjectCB_getValueIndexCB_getValuePathCB_includeJSFileCB_indexOfCB_initCB_intToBaseCB_isArrayCB_isEmailCB_isFileLocalCB_isStringCB_lastIndexOfCB_ltrimCB_NAMECB_nl2brCB_nlToBrCB_numberFormatCB_numberOfDecimalDigitsCB_numberOfDecimalsCB_numberOfIntegerDigitsCB_OPTIONSCB_parseJSONCB_parseStringCB_regularExpressionStringCB_renderStringCB_replaceAllCB_rtrimCB_scriptPathCB_scriptPathCalculateCB_setCookieCB_setDatumCB_sizeOfCB_sizeofCB_stringifyJSONCB_symmetricCallCB_symmetricCallClearCB_thisCB_trimCB_VERSION Namespace: CB_Touch CB_Touch Static class to manage the touch events. It will return itself if it is tried to be instantiated. It can also use Pressure.js and Hammer.js. Source: CrossBase/input/CB_Touch.js, line 11 Members &lt;static, readonly&gt; DEFAULT_FORCE :number Default value for the force attribute if no one is detected. Type: number Default Value: 1 Source: CrossBase/input/CB_Touch.js, line 23 Methods &lt;static&gt; delay( [delayMs] [, index]) → {boolean} First time, this function will return true. Next calls, with same index, returns false during the previously-defined time set in the previous call and true after that delay. After the first call, next calls of this function with same index will be ignored (returning always false) until the delay provided expires. If it is called after a previous call with the same index and the delay of the previous call already expired, it will act as it was the first call again. Useful, for example, to prevent the onTouchStart event to fire twice or more when a layer (container) is closed and behind there is another one with also the onTouchStart event. Parameters: Name Type Argument Default Description delayMs integer &lt;optional&gt; CB_Touch._delayMsDefault Delay desired in milliseconds. For same indexes, this parameter will be ignored if there was a previous call to this function whose delay did not expire yet. index integer | string &lt;optional&gt; 0 Desired index to identify the process. Source: CrossBase/input/CB_Touch.js, line 343 Returns: First time, this function will return true. Next calls with the same index, returns false during the given time and true after that delay. After the first call, next calls with same index of this function will be ignored (returning always false) until the delay provided expires. If it is called after a previous call with the same index and the delay of the previous call already expired, it will act as it was the first call again. Type boolean &lt;static&gt; getData() → {Event|null} Returns the last touch event object (if any), processed by CB_Touch.normalizeEvent internally, which was used in the last touch event fired, if that touch event was touchstart, touchenter or touchmove. The touchend and touchleave events set it to &quot;null&quot;. Source: CrossBase/input/CB_Touch.js, line 168 Returns: Returns the last touch event affected, if any. Type Event | null &lt;static&gt; getHammerJSObject() → {Object} Returns the Hammer.js object (if any). Useful for managing touch gestures. Source: CrossBase/input/CB_Touch.js, line 316 Returns: Returns the Hammer.js object (if any). Type Object &lt;static&gt; getMaxTouchPoints() → {integer|null} Returns the maximum of touch points supported by the device (if possible). Source: CrossBase/input/CB_Touch.js, line 179 Returns: Maximum touch points supported by the device (if possible). If it cannot be detected, returns null. Type integer | null &lt;static&gt; getPressureJSObject() → {Object} Returns the Pressure.js object (if any). Useful for managing Force Touch/3D Touch and Pointer Pressure features. Source: CrossBase/input/CB_Touch.js, line 327 Returns: Returns the Pressure.js object (if any). Type Object &lt;static&gt; normalizeEvent(e) → {Event} Tries to return the touch event object with some properties normalized (since different clients can use different values), when possible. It also calls the CB_Events.normalize and CB_Touch.normalizePoints functions internally. Some properties affected could be targetTouches, touches, changedTouches, etc. Parameters: Name Type Description e Event Touch event object. If not provided, it will use the value of &quot;event&quot;, &quot;window.event&quot;, &quot;Event&quot; or an empty object (&quot;{}&quot;). Source: CrossBase/input/CB_Touch.js, line 109 To Do: Add more properties and methods to normalize (if needed) Returns: Returns the touch event object normalized. Type Event &lt;static&gt; normalizeForce(force) → {Event} Normalizes the given &quot;force&quot; property value across different clients. The new attached methods and properties may include polyfills, etc. This function is called by CB_Touch.normalizePoint automatically. Parameters: Name Type Description force number Force value to be normalized. Source: CrossBase/input/CB_Touch.js, line 91 To Do: Not all web clients are the same, so not all should be normalized. Returns: Returns the force value normalized. Type Event &lt;static&gt; normalizePoint(point) → {Touch} Normalizes a given point. Calls CB_Touch.normalizeForce internally. This function is called by CB_Touch.normalizePoints automatically. Parameters: Name Type Description point Touch Touch object to be normalized. Source: CrossBase/input/CB_Touch.js, line 147 Returns: Returns the given point normalized. Type Touch &lt;static&gt; normalizePoints(points) → {TouchList|array} Normalizes a given list of points. Calls CB_Touch.normalizePoint internally. This function is called by CB_Touch.normalizeEvent automatically. Parameters: Name Type Description points TouchList | array TouchList or array with the points (Touch objects) to be normalized. Source: CrossBase/input/CB_Touch.js, line 130 Returns: Returns the given points normalized. Type TouchList | array &lt;static&gt; onCancel(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchCancel event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 226 &lt;static&gt; onEnd(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchEnd event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 212 &lt;static&gt; onEnter(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchEnter event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 240 &lt;static&gt; onLeave(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchLeave event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 254 &lt;static&gt; onMove(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchMove event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 268 &lt;static&gt; onStart(callbackFunction [, keepOldFunction] [, useCapture] [, target]) Sets a function to execute when the onTouchStart event is fired or removes it. More information: Touch events. Parameters: Name Type Argument Default Description callbackFunction function | null The function (event listener) that we want to execute when the event is fired. The first and unique parameter received for this function will be the event object (already normalized by the CB_Touch.normalizeEvent function). If a null value is used, the event will be removed. keepOldFunction boolean &lt;optional&gt; true Defines whether we want to keep any possible previous event listener for the same target and event name or not. useCapture boolean &lt;optional&gt; false Defines whether the event we want to add will use capture or not. This parameter will be effective only if the current client supports the addEventListener method and will be used as its third parameter. target Object &lt;optional&gt; document The target where we want to attach the event listener. Source: CrossBase/input/CB_Touch.js, line 198 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
