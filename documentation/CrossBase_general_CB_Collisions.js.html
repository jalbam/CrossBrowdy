<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>CrossBrowdy API documentation Source: CrossBase/general/CB_Collisions.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body style="min-width:800px; overflow-wrap:break-word; word-wrap:break-word; word-break:break-word; line-break:strict; hyphens:none; -webkit-hyphens:none; -moz-hyphens:none;">

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">CrossBrowdy API documentation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="CB_Arrays.html">CB_Arrays</a></li><li><a href="CB_AudioDetector.html">CB_AudioDetector</a></li><li><a href="CB_Client.html">CB_Client</a></li><li><a href="CB_Collisions.html">CB_Collisions</a></li><li><a href="CB_Configuration.html">CB_Configuration</a></li><li><a href="CB_Configuration.CrossBase.html">CB_Configuration.CrossBase</a></li><li><a href="CB_Configuration.CrossBrowdy.html">CB_Configuration.CrossBrowdy</a></li><li><a href="CB_Controllers.html">CB_Controllers</a></li><li><a href="CB_Controllers_Proprietary.html">CB_Controllers_Proprietary</a></li><li><a href="CB_Controllers_Proprietary.WII.html">CB_Controllers_Proprietary.WII</a></li><li><a href="CB_Controllers_Proprietary.WII_U.html">CB_Controllers_Proprietary.WII_U</a></li><li><a href="CB_Device.html">CB_Device</a></li><li><a href="CB_Device.AmbientLight.html">CB_Device.AmbientLight</a></li><li><a href="CB_Device.Battery.html">CB_Device.Battery</a></li><li><a href="CB_Device.Location.html">CB_Device.Location</a></li><li><a href="CB_Device.Motion.html">CB_Device.Motion</a></li><li><a href="CB_Device.Orientation.html">CB_Device.Orientation</a></li><li><a href="CB_Device.Proximity.html">CB_Device.Proximity</a></li><li><a href="CB_Device.Vibration.html">CB_Device.Vibration</a></li><li><a href="CB_Elements.html">CB_Elements</a></li><li><a href="CB_Events.html">CB_Events</a></li><li><a href="CB_Keyboard.html">CB_Keyboard</a></li><li><a href="CB_Keyboard.chars.html">CB_Keyboard.chars</a></li><li><a href="CB_Keyboard.extended.html">CB_Keyboard.extended</a></li><li><a href="CB_Keyboard.keys.html">CB_Keyboard.keys</a></li><li><a href="CB_Modules.html">CB_Modules</a></li><li><a href="CB_Mouse.html">CB_Mouse</a></li><li><a href="CB_Mouse.CursorImage.html">CB_Mouse.CursorImage</a></li><li><a href="CB_Net.html">CB_Net</a></li><li><a href="CB_Net.Fetch.html">CB_Net.Fetch</a></li><li><a href="CB_Net.REST.html">CB_Net.REST</a></li><li><a href="CB_Net.Sockets.html">CB_Net.Sockets</a></li><li><a href="CB_Net.Sockets.SockJS.html">CB_Net.Sockets.SockJS</a></li><li><a href="CB_Net.XHR.html">CB_Net.XHR</a></li><li><a href="CB_Pointer.html">CB_Pointer</a></li><li><a href="CB_Screen.html">CB_Screen</a></li><li><a href="CB_Speaker.html">CB_Speaker</a></li><li><a href="CB_Touch.html">CB_Touch</a></li><li><a href="CB_baseSymbols.html">CB_baseSymbols</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="CB_AudioFile.html">CB_AudioFile</a></li><li><a href="CB_AudioFileCache.html">CB_AudioFileCache</a></li><li><a href="CB_AudioFileSprites.html">CB_AudioFileSprites</a></li><li><a href="CB_AudioFileSpritesPool.html">CB_AudioFileSpritesPool</a></li><li><a href="CB_AudioFile_API.AAPI.html">CB_AudioFile_API.AAPI</a></li><li><a href="CB_AudioFile_API.ACMP.html">CB_AudioFile_API.ACMP</a></li><li><a href="CB_AudioFile_API.SM2.html">CB_AudioFile_API.SM2</a></li><li><a href="CB_AudioFile_API.WAAPI.html">CB_AudioFile_API.WAAPI</a></li><li><a href="CB_Canvas.html">CB_Canvas</a></li><li><a href="CB_GraphicSprites.html">CB_GraphicSprites</a></li><li><a href="CB_GraphicSpritesScene.html">CB_GraphicSpritesScene</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu inline">
					<li><a href="global.html#CB_BASE_NAME">CB_BASE_NAME</a></li><li><a href="global.html#CB_CREDITS_DEFAULT">CB_CREDITS_DEFAULT</a></li><li><a href="global.html#CB_NAME">CB_NAME</a></li><li><a href="global.html#CB_OPTIONS">CB_OPTIONS</a></li><li><a href="global.html#CB_VERSION">CB_VERSION</a></li><li><a href="global.html#CB_addCredits">CB_addCredits</a></li><li><a href="global.html#CB_baseToBase">CB_baseToBase</a></li><li><a href="global.html#CB_baseToInt">CB_baseToInt</a></li><li><a href="global.html#CB_br2nl">CB_br2nl</a></li><li><a href="global.html#CB_brToNl">CB_brToNl</a></li><li><a href="global.html#CB_combineArraysOrObjects">CB_combineArraysOrObjects</a></li><li><a href="global.html#CB_combineAutomatically">CB_combineAutomatically</a></li><li><a href="global.html#CB_combineJSON">CB_combineJSON</a></li><li><a href="global.html#CB_combineURIParameters">CB_combineURIParameters</a></li><li><a href="global.html#CB_combineURLParameters">CB_combineURLParameters</a></li><li><a href="global.html#CB_console">CB_console</a></li><li><a href="global.html#CB_copyObject">CB_copyObject</a></li><li><a href="global.html#CB_countDecimalDigits">CB_countDecimalDigits</a></li><li><a href="global.html#CB_countDecimalPart">CB_countDecimalPart</a></li><li><a href="global.html#CB_countDecimals">CB_countDecimals</a></li><li><a href="global.html#CB_countIntegerDigits">CB_countIntegerDigits</a></li><li><a href="global.html#CB_countIntegerPart">CB_countIntegerPart</a></li><li><a href="global.html#CB_credits">CB_credits</a></li><li><a href="global.html#CB_forEach">CB_forEach</a></li><li><a href="global.html#CB_forceString">CB_forceString</a></li><li><a href="global.html#CB_getBase64StringObject">CB_getBase64StringObject</a></li><li><a href="global.html#CB_getCookie">CB_getCookie</a></li><li><a href="global.html#CB_getDatum">CB_getDatum</a></li><li><a href="global.html#CB_getJSONPropertyValue">CB_getJSONPropertyValue</a></li><li><a href="global.html#CB_getLZStringObject">CB_getLZStringObject</a></li><li><a href="global.html#CB_getValueIndex">CB_getValueIndex</a></li><li><a href="global.html#CB_getValuePath">CB_getValuePath</a></li><li><a href="global.html#CB_includeJSFile">CB_includeJSFile</a></li><li><a href="global.html#CB_indexOf">CB_indexOf</a></li><li><a href="global.html#CB_init">CB_init</a></li><li><a href="global.html#CB_intToBase">CB_intToBase</a></li><li><a href="global.html#CB_isArray">CB_isArray</a></li><li><a href="global.html#CB_isEmail">CB_isEmail</a></li><li><a href="global.html#CB_isFileLocal">CB_isFileLocal</a></li><li><a href="global.html#CB_isString">CB_isString</a></li><li><a href="global.html#CB_lastIndexOf">CB_lastIndexOf</a></li><li><a href="global.html#CB_ltrim">CB_ltrim</a></li><li><a href="global.html#CB_nl2br">CB_nl2br</a></li><li><a href="global.html#CB_nlToBr">CB_nlToBr</a></li><li><a href="global.html#CB_numberFormat">CB_numberFormat</a></li><li><a href="global.html#CB_numberOfDecimalDigits">CB_numberOfDecimalDigits</a></li><li><a href="global.html#CB_numberOfDecimals">CB_numberOfDecimals</a></li><li><a href="global.html#CB_numberOfIntegerDigits">CB_numberOfIntegerDigits</a></li><li><a href="global.html#CB_parseJSON">CB_parseJSON</a></li><li><a href="global.html#CB_parseString">CB_parseString</a></li><li><a href="global.html#CB_regularExpressionString">CB_regularExpressionString</a></li><li><a href="global.html#CB_renderString">CB_renderString</a></li><li><a href="global.html#CB_replaceAll">CB_replaceAll</a></li><li><a href="global.html#CB_rtrim">CB_rtrim</a></li><li><a href="global.html#CB_scriptPath">CB_scriptPath</a></li><li><a href="global.html#CB_scriptPathCalculate">CB_scriptPathCalculate</a></li><li><a href="global.html#CB_setCookie">CB_setCookie</a></li><li><a href="global.html#CB_setDatum">CB_setDatum</a></li><li><a href="global.html#CB_sizeOf">CB_sizeOf</a></li><li><a href="global.html#CB_sizeof">CB_sizeof</a></li><li><a href="global.html#CB_stringifyJSON">CB_stringifyJSON</a></li><li><a href="global.html#CB_symmetricCall">CB_symmetricCall</a></li><li><a href="global.html#CB_symmetricCallClear">CB_symmetricCallClear</a></li><li><a href="global.html#CB_this">CB_this</a></li><li><a href="global.html#CB_trim">CB_trim</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content" style="width:100%;">
<div class="row" style="width:100%;">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: CrossBase/general/CB_Collisions.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">/**
 * @file Collisions management. Contains the {@link CB_Collisions} static class.
 *  @author Joan Alba Maldonado &lt;workindalian@gmail.com>
 *  @license Creative Commons Attribution 4.0 International. See more at {@link https://crossbrowdy.com/about#what_is_the_crossbrowdy_copyright_and_license}.
 */

 
/**
 * Static class to manage collisions. It will return itself if it is tried to be instantiated.
 * @namespace
 * @todo Finish many functions for many more kinds of collisions.
 * @todo Add triangles, polygons, arcs, etc.
 * @todo Add support to more dimensions (at least to 3D).
 * @todo Add lacking "touching" functions, equivalent to the "over" ones.
 * @todo Add a boolean parameter and a border parameter to detect collision just when it hits the border (not when it is inside of the object without touching the border), for "hollow" shapes.
 * @todo Think about adding function aliases with reversed names (for example, "isElementOverPoint" that points to "isPointOverElement", etc.). Think about whether the aliases should or not have some parameters in reversed order.
 */
var CB_Collisions = function() { return CB_Collisions; };
{
	CB_Collisions.initialized = false; //It will tells whether the object has been initialized or not.


	//Initializes all values:
	CB_Collisions.init = function()
	{
		if (CB_Collisions.initialized) { return CB_Collisions; }

		//The object has been initialized:
		CB_Collisions.initialized = true;
		
		//TODO.

		return CB_Collisions;
	}

	
	//TODO: add polygons, arcs, etc.
	

	/**
	 * Tells the distance between two points.
	 *  @function
	 *  @param {number} x - The "X" coordinate of the first point.
	 *  @param {number} y - The "Y" coordinate of the first point.
	 *  @param {number} x2 - The "X" coordinate of the second point.
	 *  @param {number} y2 - The "Y" coordinate of the second point.
	 *  @returns {number|null} Returns the distance between the two points. In the case that it could not be calculated, returns null.
	 */
	CB_Collisions.getDistancePoints = function(x, y, x2, y2)
	{
		var distance = parseFloat(Math.sqrt(Math.pow(x - x2, 2) + Math.pow(y - y2, 2)));
		return isNaN(distance) ? null : distance;
	}
	

	/**
	 * Tells whether a given point is over a given DOM element (it will be considered a rectangle).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {Element} element - The DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the point is over the given DOM element (it will be considered a rectangle).
	 */
	CB_Collisions.isPointOverElement = function(x, y, element)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isPointOverRectangle(x, y, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element));
	}


	/**
	 * Tells whether a given point is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {Element} element - The DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the point is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 */
	CB_Collisions.isPointTouchingElement = function(x, y, element)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isPointTouchingRectangle(x, y, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element));
	}


	/**
	 * Tells whether a point is over a line (infinite).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} lineX1 - The "X" coordinate of a first point of the line.
	 *  @param {number} lineY1 - The "Y" coordinate of a first point of the line.
	 *  @param {number} lineX2 - The "X" coordinate of a second point of the line.
	 *  @param {number} lineY2 - The "Y" coordinate of a second point of the line.
	 *  @param {number} [tolerance=0.001] - The amount of loss of precision we can tolerate to consider a collision.
	 *  @returns {boolean} Returns whether the point is over the line (infinite).
	 *  @todo Think about using a "width" parameter (apart from the "tolerance" parameter).
	 *  @todo Create a CB_Collisions.isPointTouchingLine function.
	 */
	CB_Collisions.isPointOverLine = function(x, y, lineX1, lineY1, lineX2, lineY2, tolerance)
	{
		if (typeof(tolerance) === "undefined" || tolerance === null) { tolerance = 0.001; }

		//If the line is vertical (infinite slope) or just a point:
		if (lineX1 === lineX2)
		{
			//If the point is in the same X axis:
			if (x === lineX1)
			{
				//If the line has the same Y at both ends, it's in fact just a point:
				if (lineY1 === lineY2)
				{
					//If the point is in the same Y axis:
					if (y === lineY1) { return true; } //The line is a point and the point given is the same one.
				}
				else if (lineY1 &lt; lineY2)
				{
					if (y >= lineY1 &amp;&amp; y &lt;= lineY2) { return true; }
				}
				else //lineY1 > lineY2
				{
					if (y >= lineY2 &amp;&amp; y &lt;= lineY1) { return true; }
				}
			}
		}
		else
		{
			var slope = (lineY2 - lineY1) / (lineX2 - lineX1);
			var yIntercept = lineY1 - slope * lineX1;
			if (Math.abs(y - (slope * x + yIntercept)) &lt;= tolerance)
			{
				return true;
			}
		}

		return false;
	}


	/**
	 * Tells whether a point is over a line segment.
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} segmentX1 - The "X" coordinate of the beginning point of the line.
	 *  @param {number} segmentY1 - The "Y" coordinate of the beginning point of the line.
	 *  @param {number} segmentX2 - The "X" coordinate of the end point of the line.
	 *  @param {number} segmentY2 - The "Y" coordinate of the end point of the line.
	 *  @param {number} [tolerance=0.001] - The amount of loss of precision we can tolerate to consider a collision.
	 *  @returns {boolean} Returns whether the point is over the line segment.
	 *  @todo Think about using a "width" parameter (apart from the "tolerance" parameter).
	 *  @todo Create a CB_Collisions.isPointTouchingSegment function.
	 */
	CB_Collisions.isPointOverSegment = function(x, y, segmentX1, segmentY1, segmentX2, segmentY2, tolerance)
	{
		var rectangleX1 = segmentX1;
		var rectangleY1 = segmentY1;
		var rectangleX2 = segmentX2;
		var rectangleY2 = segmentY2;

		if (segmentX2 &lt; segmentX1)
		{
			rectangleX1 = segmentX2;
			rectangleX2 = segmentX1;
		}
		if (segmentY2 &lt; segmentY1)
		{
			rectangleY1 = segmentY2;
			rectangleY2 = segmentY1;
		}

		if (CB_Collisions.isPointOverRectangle(x, y, rectangleX1, rectangleY1, rectangleX2 - rectangleX1 /*rectangleWidth*/, rectangleY2 - rectangleY1 /*rectangleHeight*/))
		{
			return CB_Collisions.isPointOverLine(x, y, segmentX1, segmentY1, segmentX2, segmentY2, tolerance);
		}

		return false;
	}


	/**
	 * Tells whether a point is over a rectangle.
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the rectangle.
	 *  @param {number} rectangleWidth - The width of the rectangle.
	 *  @param {number} rectangleHeight - The height of the rectangle.
	 *  @returns {boolean} Returns whether the point is over the rectangle.
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 */
	CB_Collisions.isPointOverRectangle = function(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight)
	{
		return (x > rectangleX &amp;&amp; x &lt; rectangleX + rectangleWidth &amp;&amp; y > rectangleY &amp;&amp; y &lt; rectangleY + rectangleHeight);
	}


	/**
	 * Tells whether a point is touching (maybe over) a rectangle. This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the rectangle.
	 *  @param {number} rectangleWidth - The width of the rectangle.
	 *  @param {number} rectangleHeight - The height of the rectangle.
	 *  @returns {boolean} Returns whether the point is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other).
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 */
	CB_Collisions.isPointTouchingRectangle = function(x, y, rectangleX, rectangleY, rectangleWidth, rectangleHeight)
	{
		/*
		if (x >= rectangleX &amp;&amp; x &lt;= rectangleX + rectangleWidth)
		{
			if (y >= rectangleY &amp;&amp; y &lt;= rectangleY + rectangleHeight)
			{
				return true;
			}
		}
		return false;
		*/
		return (x >= rectangleX &amp;&amp; x &lt;= rectangleX + rectangleWidth &amp;&amp; y >= rectangleY &amp;&amp; y &lt;= rectangleY + rectangleHeight);
	}


	/**
	 * Tells whether a point is over a circle.
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} centreX - The "X" coordinate of the center of the circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the circle.
	 *  @param {number} radius - The radius of the circle.
	 *  @returns {boolean} Returns whether the point is over the circle.
	 */
	CB_Collisions.isPointOverCircle = function(x, y, centreX, centreY, radius)
	{
		//If the distance is lower than the radius, there is a collision:
		//return (Math.sqrt(Math.pow(centreX - x, 2) + Math.pow(centreY - y, 2)) &lt; radius);
		return CB_Collisions.getDistancePoints(centreX, centreY, x, y) &lt; radius;
	}


	/**
	 * Tells whether a point is touching (maybe over) a circle. This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} centreX - The "X" coordinate of the center of the circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the circle.
	 *  @param {number} radius - The radius of the circle.
	 *  @returns {boolean} Returns whether the point is touching (maybe over) the circle. This will also return true if they are adjacent (next to each other).
	 */
	CB_Collisions.isPointTouchingCircle = function(x, y, centreX, centreY, radius)
	{
		//If the distance is lower than the radius, there is a collision:
		//return (Math.sqrt(Math.pow(centreX - x, 2) + Math.pow(centreY - y, 2)) &lt; radius);
		return CB_Collisions.getDistancePoints(centreX, centreY, x, y) &lt;= radius;
	}


	/**
	 * Tells whether a point is over an ellipse.
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} centreX - The "X" coordinate of the center of the ellipse.
	 *  @param {number} centreY - The "Y" coordinate of the center of the ellipse.
	 *  @param {number} radiusX - The X (horizontal) radius of the ellipse.
	 *  @param {number} radiusY - The Y (vertical) radius of the ellipse.
	 *  @param {number} [rotation=0] - The ellipse rotation. The value given will be considered either degrees or radians depending on the given "rotationUseDegrees" parameter (by default, it is considered radians). Not implemented yet!
	 *  @param {boolean} [rotationUseDegrees=false] - Defines whether the "rotation" given should be considered degrees or not (radians). Not implemented yet!
	 *  @returns {boolean} Returns whether the point is over the ellipse.
	 *  @todo Make the "rotation" parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate).
	 */
	CB_Collisions.isPointOverEllipse = function(x, y, centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees)
	{
		if (typeof(rotation) === "undefined" || rotation === null || isNaN(rotation)) { rotation = 0; }
		if (rotationUseDegrees &amp;&amp; rotation !== 0) { rotation *= Math.PI / 180 }
		
		var dx = x - centreX;
		var dy = y - centreY;
		return (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) &lt; 1;
	}


	/**
	 * Tells whether a point is touching (maybe over) a ellipse. This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} x - The "X" coordinate of the point.
	 *  @param {number} y - The "Y" coordinate of the point.
	 *  @param {number} centreX - The "X" coordinate of the center of the ellipse.
	 *  @param {number} centreY - The "Y" coordinate of the center of the ellipse.
	 *  @param {number} radiusX - The X (horizontal) radius of the ellipse.
	 *  @param {number} radiusY - The Y (vertical) radius of the ellipse.
	 *  @param {number} [rotation=0] - The ellipse rotation. The value given will be considered either degrees or radians depending on the given "rotationUseDegrees" parameter (by default, it is considered radians). Not implemented yet!
	 *  @param {boolean} [rotationUseDegrees=false] - Defines whether the "rotation" given should be considered degrees or not (radians). Not implemented yet!
	 *  @returns {boolean} Returns whether the point is touching (maybe over) the ellipse. This will also return true if they are adjacent (next to each other).
	 *  @todo Make the "rotation" parameter work (check https://math.stackexchange.com/questions/426150/what-is-the-general-equation-of-the-ellipse-that-is-not-in-the-origin-and-rotate).
	 */
	CB_Collisions.isPointTouchingEllipse = function(x, y, centreX, centreY, radiusX, radiusY, rotation, rotationUseDegrees)
	{
		if (typeof(rotation) === "undefined" || rotation === null || isNaN(rotation)) { rotation = 0; }
		if (rotationUseDegrees &amp;&amp; rotation !== 0) { rotation *= Math.PI / 180 }
		
		var dx = x - centreX;
		var dy = y - centreY;
		return (dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) &lt;= 1;
	}


	/**
	 * Tells whether a rectangle is over another rectangle.
	 *  @function
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
	 *  @param {number} rectangleX2 - The "X" coordinate of the upper left corner of the second rectangle.
	 *  @param {number} rectangleY2 - The "Y" coordinate of the upper left corner of the second rectangle.
	 *  @param {number} rectangleWidth2 - The width of the second rectangle.
	 *  @param {number} rectangleHeight2 - The height of the second rectangle.
	 *  @returns {boolean} Returns whether the rectangle is over the other rectangle.
	 *  @todo Think about using "rotation" and "rotation2" parameters to accept rotated rectangles.
	 */
	CB_Collisions.isRectangleOverRectangle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2)
	{
		return (
			Math.max(rectangleX, rectangleX2) &lt; Math.min(rectangleX + rectangleWidth, rectangleX2 + rectangleWidth2) &amp;&amp;
			Math.max(rectangleY, rectangleY2) &lt; Math.min(rectangleY + rectangleHeight, rectangleY2 + rectangleHeight2)
		);
	}


	/**
	 * Tells whether a rectangle is touching (maybe over) another rectangle. This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
	 *  @param {number} rectangleX2 - The "X" coordinate of the upper left corner of the second rectangle.
	 *  @param {number} rectangleY2 - The "Y" coordinate of the upper left corner of the second rectangle.
	 *  @param {number} rectangleWidth2 - The width of the second rectangle.
	 *  @param {number} rectangleHeight2 - The height of the second rectangle.
	 *  @returns {boolean} Returns whether the rectangle is touching (maybe over) the other rectangle. This will also return true if they are adjacent (next to each other).
	 *  @todo Think about using "rotation" and "rotation2" parameters to accept rotated rectangles.
	 */
	CB_Collisions.isRectangleTouchingRectangle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, rectangleX2, rectangleY2, rectangleWidth2, rectangleHeight2)
	{
		return (
			Math.max(rectangleX, rectangleX2) &lt;= Math.min(rectangleX + rectangleWidth, rectangleX2 + rectangleWidth2) &amp;&amp;
			Math.max(rectangleY, rectangleY2) &lt;= Math.min(rectangleY + rectangleHeight, rectangleY2 + rectangleHeight2)
		);
	}


	/**
	 * Tells whether a rectangle is over a given DOM element (it will be considered a rectangle).
	 *  @function
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
 	 *  @param {Element} element - The DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the rectangle is over the given DOM element (it will be considered a rectangle).
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 */
	CB_Collisions.isRectangleOverElement = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isRectangleOverRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element));
	}


	/**
	 * Tells whether a rectangle is touching (maybe over) a given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
 	 *  @param {Element} element - The DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the rectangle is touching (maybe over) the given DOM element (it will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 */
	CB_Collisions.isRectangleTouchingElement = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, element)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isRectangleTouchingRectangle(rectangleX, rectangleY, rectangleWidth, rectangleHeight, CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element));
	}


	/**
	 * Tells whether two given DOM elements are over each other (they will be considered a rectangle).
	 *  @function
 	 *  @param {Element} element - The first DOM element that we want to check (it will be considered a rectangle).
	 *  @param {Element} element2 - The second DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the two given DOM elements are over each other (they will be considered a rectangle).
	 */
	CB_Collisions.isElementOverElement = function(element, element2)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isRectangleOverElement(CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element), element2);
	}


	/**
	 * Tells whether two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 *  @function
 	 *  @param {Element} element - The first DOM element that we want to check (it will be considered a rectangle).
	 *  @param {Element} element2 - The second DOM element that we want to check (it will be considered a rectangle).
	 *  @returns {boolean} Returns whether the two given DOM elements are touching each other, maybe over each other (they will be considered a rectangle). This will also return true if they are adjacent (next to each other).
	 */
	CB_Collisions.isElementTouchingElement = function(element, element2)
	{
		if (typeof(element) === "undefined" || element === null) { return false; }
		return CB_Collisions.isRectangleTouchingElement(CB_Elements.getLeft(element), CB_Elements.getTop(element), CB_Elements.getWidth(element), CB_Elements.getHeight(element), element2);
	}


	/**
	 * Tells whether a circle is over another circle.
	 *  @function
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @param {number} centreX2 - The "X" coordinate of the center of the second circle.
	 *  @param {number} centreY2 - The "Y" coordinate of the center of the second circle.
	 *  @param {number} radius2 - The radius of the second circle.
	 *  @returns {boolean} Returns whether the circle is over the other circle.
	 */
	CB_Collisions.isCircleOverCircle = function(centreX, centreY, radius, centreX2, centreY2, radius2)
	{
		//return (Math.sqrt(Math.pow(centreX - centreX2, 2) + Math.pow(centreY - centreY2, 2)) &lt; radius + radius2); 
		return CB_Collisions.getDistancePoints(centreX, centreY, centreX2, centreY2) &lt; radius + radius2;
	}


	/**
	 * Tells whether a circle is touching (maybe over) another circle. This will also return true if they are adjacent (next to each other).
	 *  @function
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @param {number} centreX2 - The "X" coordinate of the center of the second circle.
	 *  @param {number} centreY2 - The "Y" coordinate of the center of the second circle.
	 *  @param {number} radius2 - The radius of the second circle.
	 *  @returns {boolean} Returns whether the circle is touching (maybe over) the other circle. This will also return true if they are adjacent (next to each other).
	 */
	CB_Collisions.isCircleTouchingCircle = function(centreX, centreY, radius, centreX2, centreY2, radius2)
	{
		//return (Math.sqrt(Math.pow(centreX - centreX2, 2) + Math.pow(centreY - centreY2, 2)) &lt;= radius + radius2); 
		return CB_Collisions.getDistancePoints(centreX, centreY, centreX2, centreY2) &lt;= radius + radius2;
	}


	/**
	 * Tells whether a circle is over a given rectangle.
	 *  @function
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
	 *  @returns {boolean} Returns whether the circle is over the rectangle.
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 */
	//* Source (modified): markE at https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle
	CB_Collisions.isRectangleOverCircle = function(centreX, centreY, radius, rectangleX, rectangleY, rectangleWidth, rectangleHeight)
	{
		var distanceX = Math.abs(centreX - rectangleX - rectangleWidth / 2);
		var distanceY = Math.abs(centreY - rectangleY - rectangleHeight / 2);

		if (distanceX > rectangleWidth / 2 + radius) { return false; }
		if (distanceY > rectangleHeight / 2 + radius) { return false; }

		if (distanceX &lt; rectangleWidth / 2) { return true; } 
		if (distanceY &lt; rectangleHeight / 2) { return true; }

		var dx = distanceX - rectangleWidth / 2;
		var dy = distanceY - rectangleHeight / 2;
		
		return (dx * dx + dy * dy &lt; radius * radius);
	}


	/**
	 * Tells whether a circle is touching (maybe over) a given rectangle.
	 *  @function
	 *  @param {number} rectangleX - The "X" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleY - The "Y" coordinate of the upper left corner of the first rectangle.
	 *  @param {number} rectangleWidth - The width of the first rectangle.
	 *  @param {number} rectangleHeight - The height of the first rectangle.
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @returns {boolean} Returns whether the circle is touching (maybe over) the rectangle. This will also return true if they are adjacent (next to each other).
	 *  @todo Think about using a "rotation" parameter to accept rotated rectangles.
	 //* Source (modified): markE at https://stackoverflow.com/questions/21089959/detecting-collision-of-rectangle-with-circle
	 */
	CB_Collisions.isRectangleTouchingCircle = function(rectangleX, rectangleY, rectangleWidth, rectangleHeight, centreX, centreY, radius)
	{
		var distanceX = Math.abs(centreX - rectangleX - rectangleWidth / 2);
		var distanceY = Math.abs(centreY - rectangleY - rectangleHeight / 2);

		if (distanceX > rectangleWidth / 2 + radius) { return false; }
		if (distanceY > rectangleHeight / 2 + radius) { return false; }

		if (distanceX &lt;= rectangleWidth / 2) { return true; } 
		if (distanceY &lt;= rectangleHeight / 2) { return true; }

		var dx = distanceX - rectangleWidth / 2;
		var dy = distanceY - rectangleHeight / 2;
		
		return (dx * dx + dy * dy &lt;= radius * radius);
	}


	/**
	 * Tells whether a line (infinite) is over a given circle.
	 *  @function
	 *  @param {number} lineX1 - The "X" coordinate of a first point of the line.
	 *  @param {number} lineY1 - The "Y" coordinate of a first point of the line.
	 *  @param {number} lineX2 - The "X" coordinate of a second point of the line.
	 *  @param {number} lineY2 - The "Y" coordinate of a second point of the line.
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @returns {boolean} Returns whether the line (infinite) is over the circle.
	 */
	//* Source (modified): https://github.com/mattdesl/line-circle-collision
	CB_Collisions.isLineOverCircle = function(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius)
	{
		if (CB_Collisions.isPointOverCircle(lineX1, lineY1, centreX, centreY, radius)) { return true; }
		else if (CB_Collisions.isPointOverCircle(lineX2, lineY2, centreX, centreY, radius)) { return true; }

		var dx = lineX2 - lineX1;
		var dy = lineY2 - lineY1;
		
		var lcx = centreX - lineX1;
		var lcy = centreY - lineY1;
		
		var dLen2 = dx * dx + dy * dy;
		var px = dx;
		var py = dy;
		
		if (dLen2 > 0)
		{
			var dp = (lcx * dx + lcy * dy) / dLen2;
			px *= dp;
			py *= dp;
		}
		
		var pLen2 = px * px + py * py;
		
		return CB_Collisions.isPointOverCircle(lineX1 + px, lineY1 + py, centreX, centreY, radius) &amp;&amp; pLen2 &lt; dLen2 &amp;&amp; (px * dx + py * dy) > 0; //TODO: test it well (some equal signs removed).
	}


	/**
	 * Tells whether a line (infinite) is touching (maybe over) a given circle.
	 *  @function
	 *  @param {number} lineX1 - The "X" coordinate of a first point of the line.
	 *  @param {number} lineY1 - The "Y" coordinate of a first point of the line.
	 *  @param {number} lineX2 - The "X" coordinate of a second point of the line.
	 *  @param {number} lineY2 - The "Y" coordinate of a second point of the line.
	 *  @param {number} centreX - The "X" coordinate of the center of the first circle.
	 *  @param {number} centreY - The "Y" coordinate of the center of the first circle.
	 *  @param {number} radius - The radius of the first circle.
	 *  @returns {boolean} Returns whether the line (infinite) is touching (maybe over) the circle.
	 */
	//* Source (modified): https://github.com/mattdesl/line-circle-collision
	CB_Collisions.isLineTouchingCircle = function(lineX1, lineY1, lineX2, lineY2, centreX, centreY, radius)
	{
		if (CB_Collisions.isPointTouchingCircle(lineX1, lineY1, centreX, centreY, radius)) { return true; }
		else if (CB_Collisions.isPointTouchingCircle(lineX2, lineY2, centreX, centreY, radius)) { return true; }

		var dx = lineX2 - lineX1;
		var dy = lineY2 - lineY1;
		
		var lcx = centreX - lineX1;
		var lcy = centreY - lineY1;
		
		var dLen2 = dx * dx + dy * dy;
		var px = dx;
		var py = dy;
		
		if (dLen2 > 0)
		{
			var dp = (lcx * dx + lcy * dy) / dLen2;
			px *= dp;
			py *= dp;
		}
		
		var pLen2 = px * px + py * py;
		
		return CB_Collisions.isPointTouchingCircle(lineX1 + px, lineY1 + py, centreX, centreY, radius) &amp;&amp; pLen2 &lt;= dLen2 &amp;&amp; (px * dx + py * dy) >= 0;
	}


	//Function that returns whether a line is over another line:
	CB_Collisions.isLineOverLine = function()
	{

	}

	//Function that returns whether a line segment is over another line segment:
	CB_Collisions.isSegmentOverSegment = function()
	{

	}


	//Function that returns whether a line is over a segment:
	CB_Collisions.isLineOverSegment = function()
	{

	}


	//Function that returns whether a line is over a rectangle:
	CB_Collisions.isLineOverRectangle = function()
	{

	}

	//Function that returns whether a line is over a circle:
	CB_Collisions.isLineOverCircle = function()
	{

	}


	//Function that returns whether a line segment is over a rectangle:
	CB_Collisions.isSegmentOverRectangle = function()
	{

	}

	//Function that returns whether a line segment is over a circle:
	CB_Collisions.isSegmentOverCircle = function()
	{

	}


	//Function that returns whether a line is touching (maybe over) another line:
	CB_Collisions.isLineTouchingLine = function()
	{

	}


	//Function that returns whether a line is touching (maybe over) a line segment:
	CB_Collisions.isLineTouchingSegment = function()
	{

	}


	//Function that returns whether a line is touching (maybe over) a rectangle:
	CB_Collisions.isLineTouchingRectangle = function()
	{

	}


	//Function that returns whether a line segment is touching (maybe over) a rectangle:
	CB_Collisions.isSegmentTouchingRectangle = function()
	{

	}


	//Function that returns whether a line segment is touching (maybe over) a circle:
	CB_Collisions.isSegmentTouchingCircle = function()
	{

	}

}</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	<a href="printable/" target="_blank">See a more printer-friendly version</a><hr /><span style="color:#000000">© <address style="display:inline; font-style:normal;"><a href="https://crossbrowdy.com/" target="_blank">CrossBrowdy</a> API documentation</address> by <a href="https://joanalbamaldonado.com/" target="_blank">Joan Alba Maldonado</a> - <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International</a><br />DocStrap Copyright © 2012-2015 The contributors to the JSDoc3 and DocStrap projects.</span>
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a>
	
		on Tue Mar 21st 2023
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->

<script>
	$( function () {
		$( '#main' ).localScroll( {
			offset : { top : 60 } //offset by the height of your header (give or take a few px, see what works for you)
		} );
		$( "dt.name" ).each( function () {
			var $this = $( this ).find("h4");
			var icon = $( "<i/>" ).addClass( "icon-plus-sign" ).addClass( "pull-right" ).addClass( "icon-white" );
			var dt = $(this);
			var children = dt.next( "dd" );

			dt.prepend( icon ).css( {cursor : "pointer"} );
			dt.addClass( "member-collapsed" ).addClass( "member" );


			children.hide();

			dt.children().on( "click", function () {
				children = dt.next( "dd" );
				children.slideToggle( "fast", function () {

					if ( children.is( ":visible" ) ) {
						icon.addClass( "icon-minus-sign" ).removeClass( "icon-plus-sign" ).removeClass( "icon-white" );
						dt.addClass( "member-open" ).animate( "member-collapsed" );
					} else {
						icon.addClass( "icon-plus-sign" ).removeClass( "icon-minus-sign" ).addClass( "icon-white" );
						dt.addClass( "member-collapsed" ).removeClass( "member-open" );
					}
				} );
			} );

		} );
	} );
</script>


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
